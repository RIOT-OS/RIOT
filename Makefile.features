# Process FEATURES variables
#
# The board/board common are responsible for defining the CPU and CPU_MODEL
# variables in their Makefile.features.
# This makes them available when setting features based on CPU_MODEL in the cpu
# Makefile.features and also during dependency resolution.

# Transition:
#   Moving 'CPU/CPU_MODEL' to Makefile.features is an ongoing work and may not
#   reflect the state of all boards for the moment.

include $(RIOTBOARD)/$(BOARD)/Makefile.features

# Transitional conditional include until all boards define 'CPU'
ifneq (,$(CPU))
  include $(RIOTCPU)/$(CPU)/Makefile.features
else
  $(warning CPU must be defined by board / board_common Makefile.features)
endif

include $(RIOTBASE)/drivers/Makefile.features

# Resolve FEATURES_ variables
# Their value will only be complete after resolving dependencies
#
# Features can now declare features that they provide to allow automatic
# handling of "parents" and "child", like a radio giving a "netif" feature
# FEATURES_COMPATIBLE_name_of_the_feature += features_also_provided

features_compatible = $1 $(foreach feature,$(FEATURES_COMPATIBLE_$1),$(call features_compatible,$(feature)))
features_providers_all = $(foreach feature,$(FEATURES_COMPATIBLES),$(if $(findstring $1,$(FEATURES_COMPATIBLE_$(feature))),$(feature) $(call features_providers_all,$(feature))))

# All features PROVIDED + compatible features
FEATURES_COMPATIBLES = $(sort $(foreach feature,$(FEATURES_PROVIDED),$(call features_compatible,$(feature))))
# Only features that are got from compatible features
FEATURES_COMPATIBLES_ONLY = $(filter-out $(FEATURES_PROVIDED),$(FEATURES_COMPATIBLES))

# Features that are required by the application but not provided by the BSP
# Having features missing may case the build to fail.
FEATURES_MISSING = $(sort $(filter-out $(FEATURES_COMPATIBLES),$(FEATURES_REQUIRED)))

# Features that are only optional and not required at the same time.
# The policy is to by default use by features if they are provided by the BSP.
FEATURES_OPTIONAL_ONLY = $(sort $(filter-out $(FEATURES_REQUIRED),$(FEATURES_OPTIONAL)))
FEATURES_OPTIONAL_USED = $(sort $(filter $(FEATURES_COMPATIBLES),$(FEATURES_OPTIONAL_ONLY)))
# Optional features that will not be used because they are not provided
FEATURES_OPTIONAL_MISSING = $(sort $(filter-out $(FEATURES_COMPATIBLES),$(FEATURES_OPTIONAL_ONLY)))

# Features that are used for an application
FEATURES_USED_EXPLICIT = $(sort $(FEATURES_REQUIRED) $(FEATURES_OPTIONAL_USED))
FEATURES_USED = $(sort $(FEATURES_USED_EXPLICIT) $(foreach feature,$(FEATURES_USED_EXPLICIT),$(call features_providers_all,$(feature))))

# Used features that conflict when used together
FEATURES_CONFLICTING = $(sort $(foreach conflict,$(FEATURES_CONFLICT),$(call _features_conflicting,$(conflict))))

# Return conflicting features from the conflict string feature1:feature2
#   $1: feature1:feature2
#   Return the list of conflicting features
_features_conflicting = $(if $(call _features_used_conflicting,$(subst :, ,$1)),$(subst :, ,$1))
# Check if all features from the list are used
#   $1: list of features that conflict together
#   Return non empty on error
_features_used_conflicting = $(filter $(words $1),$(words $(filter $(FEATURES_USED),$1)))


# Define FEATURES_PROVIDERS_ and FEATURES_PROVIDERS_ALL_
# Only define theme currently for debug, not sure if required or not
features_providers = $(sort $(foreach feature,$(FEATURES_COMPATIBLES),$(if $(findstring $1,$(FEATURES_COMPATIBLE_$(feature))),$(feature))))
define_providers = $(eval FEATURES_PROVIDERS_$1 = $$(call features_providers,$1))$(eval FEATURES_PROVIDERS_ALL_$1 = $$(call features_providers_all,$1))
$(foreach feature,$(FEATURES_COMPATIBLES_ONLY),$(eval $(call define_providers,$(feature))))
