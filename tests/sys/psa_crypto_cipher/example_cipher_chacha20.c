/*
 * Copyright (C) 2024 TU-Dresden
 *
 * This file is subject to the terms and conditions of the GNU Lesser
 * General Public License v2.1. See the file LICENSE in the top level
 * directory for more details.
 */

/**
 * @ingroup     tests
 * @{
 *
 * @brief       Tests the PSA cipher configurations
 *              Contents have been copied from `examples/advanced/psa_crypto`
 *
 * @author      Mikolai GÃ¼tschow <mikolai.guetschow@tu-dresden.de>
 * @author      Lena Boeckmann <lena.boeckmann@haw-hamburg.de>
 *
 * @}
 */

#include <stdio.h>
#include <stdint.h>

#include "psa/crypto.h"

static const uint8_t KEY_CHACHA20[] = {
    0x90, 0x6f, 0xdc, 0xf1, 0x72, 0xe6, 0x8a, 0xd1, 0xbb, 0xd0, 0xa3, 0x24,
    0x2a, 0xda, 0x91, 0xdb, 0x3a, 0x8d, 0xb8, 0xd4, 0x9a, 0x75, 0xc7, 0x14,
    0x00, 0x08, 0x9a, 0x8b, 0x86, 0x55, 0x2e, 0x9a
};

/* certain PSA backends require the data to be in RAM rather than ROM
 * so these values cannot be `const` */
static uint8_t PLAINTEXT[] = {
    0x48, 0x65, 0x6C, 0x6C, 0x6F, 0x20, 0x52, 0x49, 0x4F, 0x54, 0x21, 0x20,
    0x54, 0x68, 0x65, 0x20, 0x41, 0x6E, 0x73, 0x77, 0x65, 0x72, 0x20, 0x69,
    0x73, 0x20, 0x34, 0x32, 0x2E
};

static const uint8_t key_multipart[] = {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01
};

static const uint8_t iv_multipart[] = {
    0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x02
};

/* This cannot be const, as the Cryptocell hardware implementation does not have
   DMA access to flash storage, which contains the global const values */
static uint8_t plaintext_multipart[] = {
0x41, 0x6e, 0x79, 0x20, 0x73, 0x75, 0x62, 0x6d, 0x69, 0x73, 0x73, 0x69, 0x6f,
0x6e, 0x20, 0x74, 0x6f, 0x20, 0x74, 0x68, 0x65, 0x20, 0x49, 0x45, 0x54, 0x46,
0x20, 0x69, 0x6e, 0x74, 0x65, 0x6e, 0x64, 0x65, 0x64, 0x20, 0x62, 0x79, 0x20,
0x74, 0x68, 0x65, 0x20, 0x43, 0x6f, 0x6e, 0x74, 0x72, 0x69, 0x62, 0x75, 0x74,
0x6f, 0x72, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x70, 0x75, 0x62, 0x6c, 0x69, 0x63,
0x61, 0x74, 0x69, 0x6f, 0x6e, 0x20, 0x61, 0x73, 0x20, 0x61, 0x6c, 0x6c, 0x20,
0x6f, 0x72, 0x20, 0x70, 0x61, 0x72, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x61, 0x6e,
0x20, 0x49, 0x45, 0x54, 0x46, 0x20, 0x49, 0x6e, 0x74, 0x65, 0x72, 0x6e, 0x65,
0x74, 0x2d, 0x44, 0x72, 0x61, 0x66, 0x74, 0x20, 0x6f, 0x72, 0x20, 0x52, 0x46,
0x43, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x61, 0x6e, 0x79, 0x20, 0x73, 0x74, 0x61,
0x74, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x20, 0x6d, 0x61, 0x64, 0x65, 0x20, 0x77,
0x69, 0x74, 0x68, 0x69, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x63, 0x6f, 0x6e,
0x74, 0x65, 0x78, 0x74, 0x20, 0x6f, 0x66, 0x20, 0x61, 0x6e, 0x20, 0x49, 0x45,
0x54, 0x46, 0x20, 0x61, 0x63, 0x74, 0x69, 0x76, 0x69, 0x74, 0x79, 0x20, 0x69,
0x73, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x69, 0x64, 0x65, 0x72, 0x65, 0x64, 0x20,
0x61, 0x6e, 0x20, 0x22, 0x49, 0x45, 0x54, 0x46, 0x20, 0x43, 0x6f, 0x6e, 0x74,
0x72, 0x69, 0x62, 0x75, 0x74, 0x69, 0x6f, 0x6e, 0x22, 0x2e, 0x20, 0x53, 0x75,
0x63, 0x68, 0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73,
0x20, 0x69, 0x6e, 0x63, 0x6c, 0x75, 0x64, 0x65, 0x20, 0x6f, 0x72, 0x61, 0x6c,
0x20, 0x73, 0x74, 0x61, 0x74, 0x65, 0x6d, 0x65, 0x6e, 0x74, 0x73, 0x20, 0x69,
0x6e, 0x20, 0x49, 0x45, 0x54, 0x46, 0x20, 0x73, 0x65, 0x73, 0x73, 0x69, 0x6f,
0x6e, 0x73, 0x2c, 0x20, 0x61, 0x73, 0x20, 0x77, 0x65, 0x6c, 0x6c, 0x20, 0x61,
0x73, 0x20, 0x77, 0x72, 0x69, 0x74, 0x74, 0x65, 0x6e, 0x20, 0x61, 0x6e, 0x64,
0x20, 0x65, 0x6c, 0x65, 0x63, 0x74, 0x72, 0x6f, 0x6e, 0x69, 0x63, 0x20, 0x63,
0x6f, 0x6d, 0x6d, 0x75, 0x6e, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73,
0x20, 0x6d, 0x61, 0x64, 0x65, 0x20, 0x61, 0x74, 0x20, 0x61, 0x6e, 0x79, 0x20,
0x74, 0x69, 0x6d, 0x65, 0x20, 0x6f, 0x72, 0x20, 0x70, 0x6c, 0x61, 0x63, 0x65,
0x2c, 0x20, 0x77, 0x68, 0x69, 0x63, 0x68, 0x20, 0x61, 0x72, 0x65, 0x20, 0x61,
0x64, 0x64, 0x72, 0x65, 0x73, 0x73, 0x65, 0x64, 0x20, 0x74, 0x6f
};

/* This cannot be const, as the Cryptocell hardware implementation does not have
   DMA access to flash storage, which contains the global const values */
static uint8_t ciphertext_multipart[] = {
0xa3, 0xfb, 0xf0, 0x7d, 0xf3, 0xfa, 0x2f, 0xde, 0x4f, 0x37, 0x6c, 0xa2, 0x3e,
0x82, 0x73, 0x70, 0x41, 0x60, 0x5d, 0x9f, 0x4f, 0x4f, 0x57, 0xbd, 0x8c, 0xff,
0x2c, 0x1d, 0x4b, 0x79, 0x55, 0xec, 0x2a, 0x97, 0x94, 0x8b, 0xd3, 0x72, 0x29,
0x15, 0xc8, 0xf3, 0xd3, 0x37, 0xf7, 0xd3, 0x70, 0x05, 0x0e, 0x9e, 0x96, 0xd6,
0x47, 0xb7, 0xc3, 0x9f, 0x56, 0xe0, 0x31, 0xca, 0x5e, 0xb6, 0x25, 0x0d, 0x40,
0x42, 0xe0, 0x27, 0x85, 0xec, 0xec, 0xfa, 0x4b, 0x4b, 0xb5, 0xe8, 0xea, 0xd0,
0x44, 0x0e, 0x20, 0xb6, 0xe8, 0xdb, 0x09, 0xd8, 0x81, 0xa7, 0xc6, 0x13, 0x2f,
0x42, 0x0e, 0x52, 0x79, 0x50, 0x42, 0xbd, 0xfa, 0x77, 0x73, 0xd8, 0xa9, 0x05,
0x14, 0x47, 0xb3, 0x29, 0x1c, 0xe1, 0x41, 0x1c, 0x68, 0x04, 0x65, 0x55, 0x2a,
0xa6, 0xc4, 0x05, 0xb7, 0x76, 0x4d, 0x5e, 0x87, 0xbe, 0xa8, 0x5a, 0xd0, 0x0f,
0x84, 0x49, 0xed, 0x8f, 0x72, 0xd0, 0xd6, 0x62, 0xab, 0x05, 0x26, 0x91, 0xca,
0x66, 0x42, 0x4b, 0xc8, 0x6d, 0x2d, 0xf8, 0x0e, 0xa4, 0x1f, 0x43, 0xab, 0xf9,
0x37, 0xd3, 0x25, 0x9d, 0xc4, 0xb2, 0xd0, 0xdf, 0xb4, 0x8a, 0x6c, 0x91, 0x39,
0xdd, 0xd7, 0xf7, 0x69, 0x66, 0xe9, 0x28, 0xe6, 0x35, 0x55, 0x3b, 0xa7, 0x6c,
0x5c, 0x87, 0x9d, 0x7b, 0x35, 0xd4, 0x9e, 0xb2, 0xe6, 0x2b, 0x08, 0x71, 0xcd,
0xac, 0x63, 0x89, 0x39, 0xe2, 0x5e, 0x8a, 0x1e, 0x0e, 0xf9, 0xd5, 0x28, 0x0f,
0xa8, 0xca, 0x32, 0x8b, 0x35, 0x1c, 0x3c, 0x76, 0x59, 0x89, 0xcb, 0xcf, 0x3d,
0xaa, 0x8b, 0x6c, 0xcc, 0x3a, 0xaf, 0x9f, 0x39, 0x79, 0xc9, 0x2b, 0x37, 0x20,
0xfc, 0x88, 0xdc, 0x95, 0xed, 0x84, 0xa1, 0xbe, 0x05, 0x9c, 0x64, 0x99, 0xb9,
0xfd, 0xa2, 0x36, 0xe7, 0xe8, 0x18, 0xb0, 0x4b, 0x0b, 0xc3, 0x9c, 0x1e, 0x87,
0x6b, 0x19, 0x3b, 0xfe, 0x55, 0x69, 0x75, 0x3f, 0x88, 0x12, 0x8c, 0xc0, 0x8a,
0xaa, 0x9b, 0x63, 0xd1, 0xa1, 0x6f, 0x80, 0xef, 0x25, 0x54, 0xd7, 0x18, 0x9c,
0x41, 0x1f, 0x58, 0x69, 0xca, 0x52, 0xc5, 0xb8, 0x3f, 0xa3, 0x6f, 0xf2, 0x16,
0xb9, 0xc1, 0xd3, 0x00, 0x62, 0xbe, 0xbc, 0xfd, 0x2d, 0xc5, 0xbc, 0xe0, 0x91,
0x19, 0x34, 0xfd, 0xa7, 0x9a, 0x86, 0xf6, 0xe6, 0x98, 0xce, 0xd7, 0x59, 0xc3,
0xff, 0x9b, 0x64, 0x77, 0x33, 0x8f, 0x3d, 0xa4, 0xf9, 0xcd, 0x85, 0x14, 0xea,
0x99, 0x82, 0xcc, 0xaf, 0xb3, 0x41, 0xb2, 0x38, 0x4d, 0xd9, 0x02, 0xf3, 0xd1,
0xab, 0x7a, 0xc6, 0x1d, 0xd2, 0x9c, 0x6f, 0x21, 0xba, 0x5b, 0x86, 0x2f, 0x37,
0x30, 0xe3, 0x7c, 0xfd, 0xc4, 0xfd, 0x80, 0x6c, 0x22, 0xf2, 0x21
};

/**
 * @brief   Example function to perform an CHACHA20 encryption and decryption
 *          with the PSA Crypto API.
 *
 * @return  psa_status_t
 */
psa_status_t example_cipher_chacha20_oneshot(void)
{
    psa_status_t status = PSA_ERROR_DOES_NOT_EXIST;
    psa_key_id_t key_id = 0;
    psa_key_attributes_t attr = psa_key_attributes_init();
    psa_key_usage_t usage = PSA_KEY_USAGE_ENCRYPT | PSA_KEY_USAGE_DECRYPT;
    size_t cipher_output_size = PSA_CIPHER_ENCRYPT_OUTPUT_SIZE(PSA_KEY_TYPE_CHACHA20,
                                                             PSA_ALG_STREAM_CIPHER, sizeof(PLAINTEXT));

    uint8_t cipher_out[cipher_output_size];
    uint8_t plain_out[sizeof(PLAINTEXT)];
    size_t output_len = 0;

    psa_set_key_algorithm(&attr, PSA_ALG_STREAM_CIPHER);
    psa_set_key_usage_flags(&attr, usage);
    psa_set_key_bits(&attr, 256);
    psa_set_key_type(&attr, PSA_KEY_TYPE_CHACHA20);

    status = psa_import_key(&attr, KEY_CHACHA20, sizeof(KEY_CHACHA20), &key_id);
    if (status != PSA_SUCCESS) {
        psa_destroy_key(key_id);
        return status;
    }
    status = psa_cipher_encrypt(key_id, PSA_ALG_STREAM_CIPHER, PLAINTEXT,
                                sizeof(PLAINTEXT), cipher_out, cipher_output_size, &output_len);
    if (status != PSA_SUCCESS) {
        psa_destroy_key(key_id);
        return status;
    }
    status = psa_cipher_decrypt(key_id, PSA_ALG_STREAM_CIPHER, cipher_out,
                                sizeof(cipher_out), plain_out, sizeof(plain_out), &output_len);
    psa_destroy_key(key_id);
    if (status == PSA_SUCCESS) {
        return (memcmp(PLAINTEXT, plain_out, sizeof(plain_out)) ? -1 : 0);
    }
    return status;
}

/**
 * @brief   Example function to perform an CHACHA20 encryption and decryption
 *          with the PSA Crypto API.
 *
 * @return  psa_status_t
 */
psa_status_t example_cipher_chacha20_multipart(void)
{
    psa_cipher_operation_t operation;
    operation = psa_cipher_operation_init();
    psa_status_t status = PSA_ERROR_DOES_NOT_EXIST;
    psa_key_id_t key_id = 0;
    psa_key_attributes_t attr = psa_key_attributes_init();
    psa_key_usage_t usage = PSA_KEY_USAGE_ENCRYPT | PSA_KEY_USAGE_DECRYPT;

    size_t cipher_output_size = sizeof(ciphertext_multipart);
    size_t plain_output_size = sizeof(plaintext_multipart);

    printf("cipher output size: %zu\n", cipher_output_size);
    uint8_t cipher_out[cipher_output_size];
    uint8_t plain_out[plain_output_size];

    psa_set_key_algorithm(&attr, PSA_ALG_STREAM_CIPHER);
    psa_set_key_usage_flags(&attr, usage);
    psa_set_key_bits(&attr, 256);
    psa_set_key_type(&attr, PSA_KEY_TYPE_CHACHA20);

    status = psa_import_key(&attr, key_multipart, sizeof(key_multipart), &key_id);
    if (status != PSA_SUCCESS) {
        psa_destroy_key(key_id);
        return status;
    }

    /* test encrypt */
    status = psa_cipher_encrypt_setup(&operation, key_id, PSA_ALG_STREAM_CIPHER);
    if (status != PSA_SUCCESS) {
        psa_destroy_key(key_id);
        printf("Encrypt Setup Error: %s", psa_status_to_humanly_readable(status));
        return status;
    }
    status = psa_cipher_set_iv(&operation, iv_multipart, sizeof(iv_multipart));
    if (status != PSA_SUCCESS) {
        psa_destroy_key(key_id);
        printf("Encrypt Set IV Error: %s", psa_status_to_humanly_readable(status));
        return status;
    }
    size_t max_encrypt_size = sizeof(plaintext_multipart);
    uint16_t processed_bytes = 0;
    uint8_t input_length = 80;
    uint16_t calculated_output = 0;
    while ( processed_bytes < max_encrypt_size ) {
        if( (sizeof(plaintext_multipart) - processed_bytes) < 80 ) {
            input_length = sizeof(plaintext_multipart) - processed_bytes;
        }
        size_t new_output_length = 0;
        status = psa_cipher_update(
            &operation,
            &plaintext_multipart[processed_bytes],
            input_length,
            &cipher_out[calculated_output],
            (cipher_output_size-calculated_output),
            &new_output_length);
        if (status != PSA_SUCCESS) {
            psa_destroy_key(key_id);
            printf("Encrypt Update Error: %s", psa_status_to_humanly_readable(status));
            return status;
        }
        calculated_output += new_output_length;
        processed_bytes += input_length;
    }

    size_t finish_output_length = 0;
    status = psa_cipher_finish(&operation,
            &cipher_out[calculated_output],
            (cipher_output_size-calculated_output),
            &finish_output_length
        );
    if (status != PSA_SUCCESS) {
        psa_destroy_key(key_id);
        printf("Encrypt Finish Error: %s", psa_status_to_humanly_readable(status));
        return status;
    }
    calculated_output += finish_output_length;

    if( calculated_output != sizeof(ciphertext_multipart) ) {
        return PSA_ERROR_BUFFER_TOO_SMALL;
    }

    if( memcmp(cipher_out, ciphertext_multipart, sizeof(ciphertext_multipart)) != 0 ) {
        return PSA_ERROR_DATA_INVALID;
    }


    /* test decrypt */
    status = psa_cipher_decrypt_setup(&operation, key_id, PSA_ALG_STREAM_CIPHER);
    if (status != PSA_SUCCESS) {
        psa_destroy_key(key_id);
        printf("Decrypt Setup Error: %s", psa_status_to_humanly_readable(status));
        return status;
    }
    status = psa_cipher_set_iv(&operation, iv_multipart, sizeof(iv_multipart));
    if (status != PSA_SUCCESS) {
        psa_destroy_key(key_id);
        printf("Decrypt Set IV Error: %s", psa_status_to_humanly_readable(status));
        return status;
    }
    size_t max_decrypt_size = sizeof(ciphertext_multipart);
    processed_bytes = 0;
    input_length = 80;
    calculated_output = 0;
    while( processed_bytes < max_decrypt_size ) {
        if( (sizeof(plaintext_multipart) - processed_bytes) < 80 ) {
            input_length = sizeof(plaintext_multipart) - processed_bytes;
        }
        size_t new_output_length = 0;
        status = psa_cipher_update(
            &operation,
            &ciphertext_multipart[processed_bytes],
            input_length,
            &plain_out[calculated_output],
            (plain_output_size-calculated_output),
            &new_output_length);
        if (status != PSA_SUCCESS) {
            psa_destroy_key(key_id);
            printf("Decrypt Update Error: %s", psa_status_to_humanly_readable(status));
            return status;
        }
        calculated_output += new_output_length;
        processed_bytes += input_length;
    }

    finish_output_length = 0;
    status = psa_cipher_finish(&operation,
            &plain_out[calculated_output],
            (plain_output_size-calculated_output),
            &finish_output_length
        );
    if (status != PSA_SUCCESS) {
        psa_destroy_key(key_id);
        printf("Decrypt Finish Error: %s", psa_status_to_humanly_readable(status));
        return status;
    }
    calculated_output += finish_output_length;

    if( calculated_output != sizeof(plaintext_multipart) ) {
        return PSA_ERROR_BUFFER_TOO_SMALL;
    }

    if( memcmp(plain_out, plaintext_multipart, sizeof(plaintext_multipart)) != 0 ) {
        return PSA_ERROR_DATA_INVALID;
    }

    psa_destroy_key(key_id);
    return status;

}
