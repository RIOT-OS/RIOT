Dynamic Loader for RIOT
=======================

This is a port of the
[Contiki dynamic loader](https://github.com/contiki-os/contiki/wiki/The-dynamic-loader)
to RIOT. While usually a RIOT application is compiled together with
the OS into a single binary, this module allows to put code on a
running system and execute it. This allows to add new functions to a
running system.

The trickiest part about dynamic loading are the dynamic relocations,
which are different on every cpu, and hence must be implemented for
each cpu. As an example implementation the relocations for the msp-430
is provided.

Creating Dynamic Applications
-----------------------------

The dynamic loader is able to parse an
[elf](https://en.wikipedia.org/wiki/Executable_and_Linkable_Format)
file and figure out *where* new addresses need to be written to and
*which* new addresses need to be written. 

To execute dynamic code in RIOT, the user needs to provide an object
file (.o) (an elf file actually) with the code. It is the
responsibility of the developer of a dynamic application to provide an
object file with at least the **.text**, **.strtab** and **.symtab**
sections. When there are some relocation in the sections, there also
need to be the corresponding relocation sections (e.g. **.rela.text**)
in the object file.

An example of a dynamic application for the msp-430 can be found in
*test_dyn_app*.

Compiling RIOT with the Elfloader
---------------------------------

To load dynamic functions in RIOT, you need to use the *elfloader*
module in your project.

	USEMODULE += elfloader

Also if your future dynamic applications need to be able to use
functions from RIOT, or anything that has a name and is compiled into
RIOT, you need to include a special symbol table. This symbol table is
generated by a special script (also taken from the Contiki
project). To that end, a C source file is generated and is compiled
into RIOT. To stabilize the addresses in this table, RIOT needs to be
compiled several times. Please take a look at *test_loader* for an
example.

Please note, that while compiling RIOT for dynamic loading, you need
to ensure, that every function or global variable, that will be used
by your dynamic applications, is compiled into RIOT. So e.g. if you
want to use a certain module in your dynamic applications, then that
module needs to be included into RIOT, or your dynamic application
needs to bring it along.

Loading Dynamic Applications
----------------------------

Assuming your object files lies already at a known memory location
*dyn_app*. In such case all you need to do is to call

	process_t dyn_entry;
	int status = elfloader_load(dyn_app, "dyn_main", &dyn_entry);

where *"dyn_main"* is the name of the function you want the address
of. *elfloader_load(...)* will then do all the relocations and write
the address of the *"dyn_main"* symbol to *&dyn\_entry*. In the
example *process\_t* is the type of the *dyn\_main* symbol and the
programmer needs to ensure that it is correct. It can be e.g. a
function pointer and if it is, then the following is possible:

	int result = dyn_entry();

Which executes the function at *dyn\_entry*.

# Supporting Dynamic Loading on Other Systems

In this section we describe how to support dynamic loading on a new
system and by this explain the details of the process.

Creating a loadable object file
-------------------------------

The biggest challenge in running dynamic code, is that the final
memory locations of functions and other symbols are unknown at
compile/link time. Even when producing position independent code (gcc
switch *-fPIC*) there may (and most probably will) be some unresolved
references in your object file. Those unresolved references need to
correspond to symbols in the kernel.

The easiest way to create an object file that meets your requirements
is to compile a single *.c* file

	${MY_CPU_SPECIFIC_GCC} -c main.c -o main.o

An example is provided in *tests/test_dyn_app*, where the resulting
object file is hexdumped into C source file, which is useful for
debugging, since that's probably the easiest way to get your
application into memory at a known position.

In case you want to use more than just one source file, you need to
take care of linking the corresponding multiple object files into one
object file. For this you need to produce a relocatable object file,
which can usually be done with the --relocatable linker switch:

	${MY_CPU_SPECIFIC_LD} -r file1.o file2.o -o combined_files.o

Putting Objectfiles onto the device
-----------------------------------

To put and relocate an object file persistently, you need to put into
the flash memory. Then during relocation, the new values are flashed
persistently. You need to take care, that

- The object file does not share any segements with running code,
  because the flashing would interfere badly with it.
- The object file is aligned according to CPU requirements. Usually
  word size alignment.

Implementing CPU specific relocation functionality
--------------------------------------------------

Since the structure of an *Executable and Linkable Format* (elf) file
allows to implement most of the loading work for all platforms, which
support elf, in the same way, a new platform can be supported by just
implementing

	void elfloader_arch_relocate(void * fd,
	                             unsigned int sectionoffset,
	                             char *sectionaddr,
	                             elf32_rela_t* rela,
								 const char *addr);

An example implementation can be found for the msp-430:

	/*---------------------------------------------------------------------------*/
	void
	elfloader_arch_relocate(void * fd, unsigned int sectionoffset,
							char *sectionaddr,
							elf32_rela_t* rela, const char *addr)
	{
		addr += rela->addend;
		/* yes really copy the value of *addr*. hence the & in &addr. */
		memcpy(fd + sectionoffset + rela->offset, &addr, 2);
	}
	/*---------------------------------------------------------------------------*/

For the msp-430 it is quite simple, but for most other platforms you
will need to implement a long switch-case block, for doing different
things for different relocation types (the msp-430 has only one). For
further examples, look in the Contiki project.

In contrast to the Contiki loader, *elfloader_arch_relocate* is the
only function that is in need of implementation for each
platform. Still the elfloader relies on the ability of RIOT to write
to ROM for each particular platform.
