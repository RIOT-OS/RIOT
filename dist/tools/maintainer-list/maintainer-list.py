#! /usr/bin/env python3
#
# Copyright (C) 2024 TU Dresden
#
# This file is subject to the terms and conditions of the GNU Lesser
# General Public License v2.1. See the file LICENSE in the top level
# directory for more details.

__author__ = "Martine S. Lenders <martine.lenders@tu-dresden.de>"

import re
import os
import pathlib
import sys
import urllib.parse

import requests


SCRIPT_PATH = pathlib.Path(__file__).resolve().absolute().parent
RIOTBASE = (SCRIPT_PATH / ".." / ".." / "..").resolve()
TOKEN = os.environ.get("GITHUB_TOKEN")


NO_AREA_TEXT = "Has no chosen area of expertise."
MAINTAINER_FILE_BOILERPLATE = f"""# Maintainer List {{#maintainer-list}}

This file contains the current list of maintainers within the RIOT community.
The file is generated by combining the information from the Maintainers, Owners and
Admin teams from the RIOT-OS GitHub organization and the
[CODEOWNERS](https://github.com/RIOT-OS/RIOT/blob/master/CODEOWNERS) file.

If a maintainer is marked as "{NO_AREA_TEXT}", they did not have added any ownership
within CODEOWNERS. This does not mean that they do not feel responsible for any part of
the code base, they just did not declare it.

If a list entry only shows a pattern, it did not resolve to a specific Doxygen group
that may be referenced. This may be intentional, since the maintainer may feel
responsible for a large number of modules / groups within files that match that pattern.
If it is not intentional, please add an `@ingroup` command for an existing Doxygen
group to a file that matches the pattern; the corresponding group will then be linked
here.

If you are a maintainer and want to declare ownership for a part of a code base (and
receive notifications on pull requests against it), please add yourself and the path to
the part of the code base you want to be responsible for to CODEOWNERS.
"""


def get_team_members(team):
    members = requests.get(
        f"https://api.github.com/orgs/RIOT-OS/teams/{team}/members",
        headers={
            "Accept": "application/vnd.github+json",
            "Authorization": f"Bearer {TOKEN}",
            "X-GitHub-Api-Version": "2022-11-28",
        },
    )
    try:
        return set(m["login"] for m in members.json())
    except Exception as exc:
        print(f"Error fetching team {team}: {exc}", file=sys.stderr)
        raise


def get_github_user(username):
    user = requests.get(
        f"https://api.github.com/users/{username}",
        headers={
            "Accept": "application/vnd.github+json",
            "Authorization": f"Bearer {TOKEN}",
            "X-GitHub-Api-Version": "2022-11-28",
        },
    )
    return user.json()


def get_maintainer_codeowner_patterns(maintainers):
    maintainer_patterns = {m: [] for m in maintainers}

    with open(RIOTBASE / "CODEOWNERS") as codeowners_file:
        for line in codeowners_file:
            if re.search(r"^\s*#", line) or re.match(r"^\s*$", line):
                # skip comments and empty lines
                continue
            pattern, *owners = re.split(r"\s+", line.strip())
            for owner in owners:
                owner = owner.lstrip("@")
                if owner in maintainer_patterns:
                    maintainer_patterns[owner].append(pattern)
    return maintainer_patterns


def collect_maintainer_areas(maintainer_codeownership):
    maintainer_areas = {m: set() for m in maintainer_codeownership}
    for m in maintainer_areas:
        if not maintainer_areas[m] and maintainer_codeownership[m]:
            for rule in maintainer_codeownership[m]:
                maintainer_areas[m].add(rule)
    return maintainer_areas


def create_maintainer_markdown_file(maintainer_areas, owners, admins):
    with open(
        RIOTBASE / "doc" / "doxygen" / "src" / "maintainers.md", "w"
    ) as maintainers_file:
        print(MAINTAINER_FILE_BOILERPLATE, file=maintainers_file)
        for i, maintainer in enumerate(
            sorted(maintainer_areas, key=lambda x: x.lower())
        ):
            github_profile = get_github_user(maintainer)

            if (
                not github_profile["name"]
                or github_profile["name"] == github_profile["login"]
            ):
                title = f"\\@{github_profile['login']}"
            else:
                title = f"{github_profile['name']} (\\@{github_profile['login']})"
            anchor = urllib.parse.quote(github_profile["login"])
            print(f"## {title}  {{#{anchor}}}", file=maintainers_file)
            print(
                f"[GitHub profile]({github_profile['html_url']})",
                file=maintainers_file,
            )

            if maintainer in owners:
                print(
                    "- **Is one of the GitHub owners of RIOT.**", file=maintainers_file
                )

            if maintainer in admins:
                print(
                    "- **Is one of the GitHub admins of RIOT.**", file=maintainers_file
                )

            for area in sorted(
                maintainer_areas[maintainer],
            ):
                print(
                    f"- `{area.lstrip('/')}`",
                    file=maintainers_file
                )
            if not maintainer_areas[maintainer]:
                print("", file=maintainers_file)
                print(NO_AREA_TEXT, file=maintainers_file)
            if (i + 1) < len(maintainer_areas):
                print("", file=maintainers_file)


def main():
    if not TOKEN:
        print(
            "Please provide a sufficient GitHub token in `GITHUB_TOKEN` "
            "environment variable",
            file=sys.stderr,
        )
        sys.exit(1)
    maintainers = get_team_members("maintainers")
    admins = get_team_members("admin")
    owners = get_team_members("owners")
    maintainers = maintainers.union(admins)
    maintainers = maintainers.union(owners)
    maintainer_codeownership = get_maintainer_codeowner_patterns(maintainers)
    maintainer_areas = collect_maintainer_areas(maintainer_codeownership)
    create_maintainer_markdown_file(maintainer_areas, owners, admins)


if __name__ == "__main__":
    main()
