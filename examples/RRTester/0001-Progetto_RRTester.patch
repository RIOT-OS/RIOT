From f0e7cf9633f2797cb7ed0e3dfd489258b7b1bf2e Mon Sep 17 00:00:00 2001
From: Hafsa <101563334+hafsa-dreamyland@users.noreply.github.com>
Date: Sat, 30 Sep 2023 21:45:30 +0000
Subject: [PATCH] Progetto_RRTester

---
 examples/RRTester/Makefile            |   1 +
 examples/RRTester/Makefile.dep        |  13 ++++
 examples/RRTester/main.c              | 106 ++++++++++++++++++++++++++
 examples/RRTester/sched_round_robin.c |  94 +++++++++++++++++++++++
 4 files changed, 214 insertions(+)
 create mode 100644 examples/RRTester/Makefile
 create mode 100644 examples/RRTester/Makefile.dep
 create mode 100644 examples/RRTester/main.c
 create mode 100644 examples/RRTester/sched_round_robin.c

diff --git a/examples/RRTester/Makefile b/examples/RRTester/Makefile
new file mode 100644
index 0000000000..99a88ed402
--- /dev/null
+++ b/examples/RRTester/Makefile
@@ -0,0 +1 @@
+include Makefile.dep
diff --git a/examples/RRTester/Makefile.dep b/examples/RRTester/Makefile.dep
new file mode 100644
index 0000000000..8ac2f23c44
--- /dev/null
+++ b/examples/RRTester/Makefile.dep
@@ -0,0 +1,13 @@
+APPLICATION = RRTester
+BOARD ?= native
+USEMODULE += sched_round_robin
+
+
+RIOTBASE ?= $(CURDIR)/../../RIOT
+
+include $(RIOTBASE)/Makefile.base
+
+
+
+
+
diff --git a/examples/RRTester/main.c b/examples/RRTester/main.c
new file mode 100644
index 0000000000..b6ac07469f
--- /dev/null
+++ b/examples/RRTester/main.c
@@ -0,0 +1,106 @@
+#include "thread.h"
+#include <stdio.h>
+#include <stdlib.h>
+
+// Dimensione dello stack di default per i thread
+#define THREAD_STACKSIZE_DEFAULT (512)
+
+// Struttura per i parametri del thread
+typedef struct
+{
+    char name[2];     // Nome del thread
+    int service_time; // Tempo di servizio in secondi
+} thread_params_t;
+
+// Funzione eseguita dai thread
+void *thread_func(void *arg)
+{
+    thread_params_t *params = (thread_params_t *)arg;
+    int remaining_time = params->service_time;
+
+    // Loop fino a quando il tempo di servizio non è esaurito
+    while (remaining_time > 0)
+    {
+        printf("Thread %s: %d seconds remaining.\n", params->name, remaining_time);
+        remaining_time--;
+
+        // Sleep per 1 secondo
+        thread_sleep();
+    }
+
+    printf("Thread %s completed.\n", params->name);
+
+    // Termina il thread
+    return NULL;
+}
+
+// Funzione di inizializzazione del thread
+kernel_pid_t init_thread(thread_params_t *params)
+{
+    char *stack = malloc(THREAD_STACKSIZE_DEFAULT);
+    if (stack == NULL)
+    {
+        fprintf(stderr, "Error: Unable to allocate stack for Thread %s.\n", params->name);
+        return -1;
+    }
+
+    // Imposta la priorità del thread
+    uint8_t priority = 2; // Sostituisci con la priorità desiderata
+
+    // Crea e avvia il thread
+    kernel_pid_t pid = thread_create(stack,
+                                     THREAD_STACKSIZE_DEFAULT,
+                                     priority,
+                                     THREAD_CREATE_SLEEPING | THREAD_CREATE_STACKTEST,
+                                     thread_func,
+                                     params,
+                                     params->name);
+
+    // Verifica se la creazione del thread ha avuto successo
+    if (pid < 0)
+    {
+        fprintf(stderr, "Error: Unable to create Thread %s.\n", params->name);
+        free(stack);
+        return -1;
+    }
+
+    // Avvio del thread
+    thread_wakeup(pid);
+
+    printf("Created Thread %s with priority %d.\n", params->name, priority);
+
+    return pid;
+}
+
+int main(void)
+{
+    printf("RRTester Application\n");
+
+    // Definizione dei parametri per ciascun thread
+    thread_params_t thread_params[] = {
+        {"A", 3},
+        {"B", 6},
+        {"C", 4},
+        {"D", 5},
+        {"E", 2}};
+
+    // Creazione e avvio dei thread
+    for (int i = 0; i < sizeof(thread_params) / sizeof(thread_params[0]); i++)
+    {
+        kernel_pid_t pid = init_thread(&thread_params[i]);
+        if (pid < 0)
+        {
+            // Gestisci l'errore, ad esempio interrompendo la creazione di altri thread
+            break;
+        }
+    }
+
+    // Loop infinito per il thread principale
+    while (1)
+    {
+        printf("Main thread running.\n");
+        thread_sleep();
+    }
+
+    return 0;
+}
diff --git a/examples/RRTester/sched_round_robin.c b/examples/RRTester/sched_round_robin.c
new file mode 100644
index 0000000000..4861e159a5
--- /dev/null
+++ b/examples/RRTester/sched_round_robin.c
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2021 TUBA Freiberg
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+/**
+ * @ingroup     sys
+ * @{
+ *
+ * @file
+ * @brief       Round Robin Scheduler implementation
+ *
+ * @author      Karl Fessel <karl.fessel@ovgu.de>
+ *
+ * @}
+ */
+
+#include "thread.h"
+#include "ztimer.h"
+#include <stdio.h>
+
+/* Costanti per la politica di scheduling a feedback */
+#define NUM_FEEDBACK_QUEUES 3
+#define FEEDBACK_QUANTUM_S 500 /* che corrisponde a 0.5 secondi*/  
+
+// Dichiarazioni di variabili 
+static int feedback_quantum_count = 0;
+static int feedback_queue_levels[NUM_FEEDBACK_QUEUES] = {0};
+
+/* Callback per la politica di scheduling a feedback */
+static void _sched_feedback_cb(void *d);
+/* Timer per la politica di scheduling a feedback */
+static ztimer_t _feedback_timer = { .callback = _sched_feedback_cb };
+
+/* Variabile per tracciare la coda corrente */
+static uint8_t _current_feedback_queue = 0;
+
+void sched_runq_callback(uint8_t prio);
+/* Funzione di callback per il timer di scheduling a feedback */
+void _sched_feedback_cb(void *d)
+{
+    (void)d;
+    
+    /* Logica per la politica di scheduling a feedback */
+    thread_t *active_thread = thread_get_active();
+
+    if (active_thread && active_thread->status == STATUS_RUNNING) {
+        if (++feedback_quantum_count >= FEEDBACK_QUANTUM_S / NUM_FEEDBACK_QUEUES) {
+            feedback_quantum_count = 0;
+            feedback_queue_levels[active_thread->priority]++;
+            active_thread->priority = feedback_queue_levels[active_thread->priority] % NUM_FEEDBACK_QUEUES;
+
+            // Stampa delle informazioni sulla console 
+            printf("Thread %s switched to queue %d\n", thread_getpid_of(active_thread), active_thread->priority);
+        }
+    }
+
+    // Chiamata alla funzione sched_runq_callback per eventuali ulteriori azioni
+    if (active_thread) {
+        uint8_t active_priority = active_thread->priority;
+        sched_runq_callback(active_priority);
+    }
+}
+
+/* Implementazione della Callback. Gestisce lo scambio di 
+contesto e stampaerà le informazioni sulla console.
+E' basata su una rotazione semplice delle code di feedback.*/
+static inline void _sched_feedback_remove(void)
+{
+    _current_feedback_queue = 0;
+    ztimer_remove(FEEDBACK_QUANTUM_S, &_feedback_timer);
+}
+
+static inline void _sched_feedback_set(uint8_t queue)
+{
+    if (queue >= NUM_FEEDBACK_QUEUES) {
+        return;
+    }
+    _current_feedback_queue = queue;
+    ztimer_set(FEEDBACK_QUANTUM_S, &_feedback_timer, ztimer_ticks_from_s(FEEDBACK_QUANTUM_S));
+}
+
+/* Funzioni di Set e Remove per il Timer*/
+void sched_feedback_init(void)
+{
+    // Inizializza _current_feedback_queue e verifica se applicabile alla priorità attiva
+    _current_feedback_queue = 0;
+    thread_t *active_thread = thread_get_active();
+    if (active_thread) {
+        sched_runq_callback(active_thread->priority);
+    }
+}
-- 
2.42.0

