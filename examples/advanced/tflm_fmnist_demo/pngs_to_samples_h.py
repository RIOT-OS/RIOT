#!/usr/bin/env python3
# pngs_to_samples_h.py  (robust label inference)

import os, argparse, re
import numpy as np
from PIL import Image

# Fashion-MNIST class IDs
CLASSES = [
    "T-shirt/top","Trouser","Pullover","Dress","Coat",
    "Sandal","Shirt","Sneaker","Bag","Ankle boot"
]

# Ordered patterns (more specific first) -> class id
PATTERNS = [
    (re.compile(r"\bankle[ _-]?boot\b"), 9),
    (re.compile(r"\bt[- ]?shirt\b|\btshirt\b"), 0),  # require t-shirt/tshirt (not plain "shirt")
    (re.compile(r"\btrouser\b|\bpants\b"), 1),
    (re.compile(r"\bpullover\b|\bsweater\b|\bjumper\b"), 2),
    (re.compile(r"\bdress\b"), 3),
    (re.compile(r"\bcoat\b|\bjacket\b"), 4),
    (re.compile(r"\bsandal\b"), 5),
    (re.compile(r"\bshirt\b"), 6),                    # plain "shirt"
    (re.compile(r"\bsneaker\b|\btrainer\b|\bshoe\b"), 7),
    (re.compile(r"\bbag\b|\bhandbag\b|\bpurse\b"), 8),
]

def infer_label_from_name(path: str) -> int:
    base = os.path.splitext(os.path.basename(path))[0].lower()
    # Normalize: underscores/hyphens/anything non-alnum -> space
    s = re.sub(r"[^a-z0-9]+", " ", base).strip()
    # Try patterns in order
    for rx, cid in PATTERNS:
        if rx.search(s):
            return cid
    return 255  # unknown

def to_gray48_u8(path, size=48):
    im = Image.open(path).convert("L").resize((size, size), Image.BILINEAR)
    return np.asarray(im, dtype=np.uint8)

def write_header(images_u8, labels, out_path, size=48, src_files=None):
    n = images_u8.shape[0]
    with open(out_path, "w", encoding="utf-8") as f:
        f.write("// Auto-generated by pngs_to_samples_h.py (48x48 uint8)\n")
        f.write("#pragma once\n#include <stdint.h>\n\n")
        f.write(f"#define SAMPLE_COUNT {n}\n#define IMG_W {size}\n#define IMG_H {size}\n\n")
        f.write("static const uint8_t g_labels[SAMPLE_COUNT] = {")
        f.write(",".join(str(int(x)) for x in labels))
        f.write("};\n\n")
        f.write("static const uint8_t g_images[SAMPLE_COUNT][IMG_W*IMG_H] = {\n")
        for i in range(n):
            flat = images_u8[i].reshape(-1).tolist()
            f.write("  {")
            for j, v in enumerate(flat):
                f.write(str(int(v)))
                if j != len(flat)-1: f.write(",")
                if (j+1) % 24 == 0: f.write("\n   ")
            f.write("}")
            if i != n-1: f.write(",")
            f.write("\n")
        f.write("};\n")
    print(f"Wrote {out_path} with {n} samples.")
    if src_files:
        print("\nInferred labels:")
        for p, lbl in zip(src_files, labels):
            name = os.path.basename(p)
            cls = CLASSES[lbl] if 0 <= lbl < len(CLASSES) else "unknown"
            print(f" - {name:<20} -> {lbl} ({cls})")

def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--img-dir", required=True, help="Folder with PNG/JPGs")
    ap.add_argument("--out-header", default="samples.h")
    ap.add_argument("--limit", type=int, default=10)
    ap.add_argument("--size", type=int, default=48)
    args = ap.parse_args()

    exts = (".png",".jpg",".jpeg",".bmp",".tif",".tiff")
    files = [os.path.join(args.img_dir, p) for p in sorted(os.listdir(args.img_dir))
             if p.lower().endswith(exts)]
    if not files:
        raise SystemExit(f"No images found in {args.img_dir}")
    files = files[:args.limit]

    imgs, labels = [], []
    for p in files:
        imgs.append(to_gray48_u8(p, args.size))
        labels.append(infer_label_from_name(p))

    images_u8 = np.stack(imgs, axis=0)
    labels = np.array(labels, dtype=np.uint8)
    write_header(images_u8, labels, args.out_header, args.size, src_files=files)

if __name__ == "__main__":
    main()
