use core::time::Duration;
use log::{debug, info};
use riot_wrappers::random::Random;
use rand_core::RngCore as _;
use riot_wrappers::mutex::Mutex;
use rs_matter::utils::epoch::MATTER_EPOCH_SECS;

// RIOT_EPOCH(2020) in seconds since UNIX Epoch
const RIOT_EPOCH_SECS: u64 = 1577833200;

extern "C" {
    fn get_seconds_since_riot_epoch() -> u32;
    fn get_milliseconds() -> u16;
}

/// Generate random bytes using the RIOT random module
pub fn sys_rand(buf: &mut [u8]) {
    Random::new().fill_bytes(buf);
    debug!("RNG generated bytes: {:?}", buf);
}

// Current UNIX Epoch - must be in ms precision
static CURRENT_DURATION: Mutex<Duration> = Mutex::new(Duration::from_secs(RIOT_EPOCH_SECS));

/// Get the current time as UNIX Epoch with milliseconds precision
/// using periph_rtc (if supported) or ztimer module
pub fn sys_epoch() -> Duration {
    let mut duration = CURRENT_DURATION.lock();
    let riot_sec = unsafe { get_seconds_since_riot_epoch() } as u64;
    let riot_msec = unsafe { get_milliseconds() } as u32;
    let unix_seconds = RIOT_EPOCH_SECS + riot_sec;
    debug!("UNIX epoch (sec.ms): {}.{}", unix_seconds, riot_msec);
    let new_duration = Duration::new(unix_seconds, riot_msec*1000000);
    // make sure that we always get a new timestamp in rare cases if sec and msec didn't change
    if *duration == new_duration {
        *duration = Duration::new(unix_seconds, (riot_msec + 1)*1000000);
    } else {
        *duration = new_duration;
    }
    *duration
}
