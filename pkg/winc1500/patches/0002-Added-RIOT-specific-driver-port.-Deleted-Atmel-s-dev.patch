From ded918bd47e7a289465a43ac4c795dd53ac8035d Mon Sep 17 00:00:00 2001
From: Bumsik Kim <kbumsik@gmail.com>
Date: Mon, 2 Oct 2017 08:51:35 -0400
Subject: [PATCH 2/3] Added RIOT-specific driver port. Deleted Atmel's
 device-specific ports.

---
 winc1500/bsp/include/nm_bsp.h                      | 175 +++++------
 winc1500/bsp/include/nm_bsp_internal.h             |  71 +----
 .../bsp/include/{nm_bsp_samd21.h => nm_bsp_riot.h} |   9 +-
 .../bsp/source/{nm_bsp_samd21.c => nm_bsp_riot.c}  | 104 +++----
 winc1500/bus_wrapper/source/nm_bus_wrapper_riot.c  | 177 ++++++++++++
 .../bus_wrapper/source/nm_bus_wrapper_samd21.c     | 321 ---------------------
 winc1500/conf_winc.h                               |  72 +++++
 winc1500/driver/include/m2m_wifi.h                 |   2 +-
 winc1500/module_config/samd21/conf_winc.h          | 170 -----------
 9 files changed, 398 insertions(+), 703 deletions(-)
 rename winc1500/bsp/include/{nm_bsp_samd21.h => nm_bsp_riot.h} (91%)
 rename winc1500/bsp/source/{nm_bsp_samd21.c => nm_bsp_riot.c} (59%)
 create mode 100644 winc1500/bus_wrapper/source/nm_bus_wrapper_riot.c
 delete mode 100644 winc1500/bus_wrapper/source/nm_bus_wrapper_samd21.c
 create mode 100644 winc1500/conf_winc.h
 delete mode 100644 winc1500/module_config/samd21/conf_winc.h

diff --git a/winc1500/bsp/include/nm_bsp.h b/winc1500/bsp/include/nm_bsp.h
index a16ca07..5ffa8ad 100644
--- a/winc1500/bsp/include/nm_bsp.h
+++ b/winc1500/bsp/include/nm_bsp.h
@@ -52,7 +52,7 @@
 /*!< 
 *        Attribute used to define memory section to map Functions in host memory.
 */
-#define CONST const
+#define WINC1500_CONST const
 
 /*!< 
 *     Used for code portability.
@@ -84,40 +84,47 @@
  *                     Used as a data type of ISR function registered by \ref nm_bsp_register_isr
  * @return         None
  */
+#if	defined(MODULE_GNRC_NETDEV)
+typedef void (*tpfNmBspIsr)(void *arg);
+#else
 typedef void (*tpfNmBspIsr)(void);
+#endif
+
+#include <stdint.h>
+
   /*!
  * @ingroup DataTypes
  * @typedef      unsigned char	uint8;
  * @brief        Range of values between 0 to 255
  */
-typedef unsigned char	uint8;
+typedef uint8_t	uint8;
 
  /*!
  * @ingroup DataTypes
  * @typedef      unsigned short	uint16;
  * @brief        Range of values between 0 to 65535
  */
-typedef unsigned short	uint16;
+typedef uint16_t	uint16;
 
  /*!
  * @ingroup Data Types
  * @typedef      unsigned long	uint32;
  * @brief        Range of values between 0 to 4294967295
  */ 
-typedef unsigned long	uint32;
+typedef uint32_t	uint32;
   /*!
  * @ingroup Data Types
  * @typedef      signed char		sint8;
  * @brief        Range of values between -128 to 127
  */
-typedef signed char		sint8;
+typedef int8_t		sint8;
 
  /*!
  * @ingroup DataTypes
  * @typedef      signed short	sint16;
  * @brief        Range of values between -32768 to 32767
  */
-typedef signed short	sint16;
+typedef int16_t	sint16;
 
   /*!
  * @ingroup DataTypes
@@ -125,7 +132,7 @@ typedef signed short	sint16;
  * @brief        Range of values between -2147483648 to 2147483647
  */
 
-typedef signed long		sint32;
+typedef int32_t		sint32;
  //@}
 
 #ifndef CORTUS_APP
@@ -166,60 +173,60 @@ extern "C"{
 
  */
 sint8 nm_bsp_init(void);
- /**@}*/
+/**@}*/
 
- 
- /** @defgroup NmBspDeinitFn nm_bsp_deinit
- *    @ingroup BSPAPI
- *   	 De-initialization for BSP ((<strong>B</strong>oard <strong>S</strong>upport <strong>P</strong>ackage)). This function should be called only after
- *		 a successful call to nm_bsp_init. 
- */
- /**@{*/
+
+/** @defgroup NmBspDeinitFn nm_bsp_deinit
+*    @ingroup BSPAPI
+*   	 De-initialization for BSP ((<strong>B</strong>oard <strong>S</strong>upport <strong>P</strong>ackage)). This function should be called only after
+*		 a successful call to nm_bsp_init. 
+*/
+/**@{*/
 /*!
- * @fn           sint8 nm_bsp_deinit(void);
- * @pre          The BSP should be initialized through \ref nm_bsp_init first.
- * @brief		 This function is used to de-initialize the BSP and turn off the WINC board.
- *				 
- *				 The nm_bsp_deinit is the last function that should be called after the application has finished and before the WINC is switched 
- *				 off. The function call turns off the WINC board by setting CHIP_EN and RESET_N signals low.Every function call of "nm_bsp_init" should
- *				 be matched with a call to nm_bsp_deinit. Failure to do so may result in the WINC consuming higher power than expected. 
- * @note         Implementation of this function is host dependent.
- * @warning      misuse may lead to unknown behavior in case of soft reset.\n
- * @see          nm_bsp_init               
- * @return      The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
+* @fn           sint8 nm_bsp_deinit(void);
+* @pre          The BSP should be initialized through \ref nm_bsp_init first.
+* @brief		 This function is used to de-initialize the BSP and turn off the WINC board.
+*				 
+*				 The nm_bsp_deinit is the last function that should be called after the application has finished and before the WINC is switched 
+*				 off. The function call turns off the WINC board by setting CHIP_EN and RESET_N signals low.Every function call of "nm_bsp_init" should
+*				 be matched with a call to nm_bsp_deinit. Failure to do so may result in the WINC consuming higher power than expected. 
+* @note         Implementation of this function is host dependent.
+* @warning      misuse may lead to unknown behavior in case of soft reset.\n
+* @see          nm_bsp_init               
+* @return      The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
 
- */
+*/
 sint8 nm_bsp_deinit(void);
- /**@}*/
+/**@}*/
+
 
- 
 /** @defgroup NmBspResetFn  nm_bsp_reset
 *     @ingroup BSPAPI
 *      Resetting WINC1500 SoC by setting CHIP_EN and RESET_N signals low, then after specific delay the function will put CHIP_EN high then RESET_N high,
 *      for the timing between signals please review the WINC data-sheet
 */
 /**@{*/
- /*!
- * @fn           void nm_bsp_reset(void);    
- * @param [in]   None
- * @brief		 Applies a hardware reset to the WINC board.
- *				 The "nm_bsp_reset" is used to apply a hard reset to the WINC board by setting CHIP_EN and RESET_N signals low, then after specific delay
- *				 the function will put CHIP_EN high then RESET_N high, for the detailed timing between signals please review the WINC data-sheet. After a
- *				 successful call, the WINC board firmware will kick off to load and kick off the WINC firmware. This function should be called to reset the 
- *				 WINC firmware after the BSP is initialized and before the start of any communication with WINC board. Calling this function at any other time
- *				 will result in losing the state and connections saved in the WINC board and starting again from the initial state. The host driver will need 
- * 				 to be de-initialized before calling nm_bsp_reset and initialized again after it using the " m2m_wifi_(de)init". 
- * @pre          Initialize \ref nm_bsp_init first
- * @note         Implementation of this function is host dependent and called by HIF layer.
- * @warning		 Calling this function will drop any connection and internal state saved on the WINC firmware.
- * @see          nm_bsp_init, m2m_wifi_init,  m2m_wifi_deinit
- * @return       None
+/*!
+* @fn           void nm_bsp_reset(void);    
+* @param [in]   None
+* @brief		 Applies a hardware reset to the WINC board.
+*				 The "nm_bsp_reset" is used to apply a hard reset to the WINC board by setting CHIP_EN and RESET_N signals low, then after specific delay
+*				 the function will put CHIP_EN high then RESET_N high, for the detailed timing between signals please review the WINC data-sheet. After a
+*				 successful call, the WINC board firmware will kick off to load and kick off the WINC firmware. This function should be called to reset the 
+*				 WINC firmware after the BSP is initialized and before the start of any communication with WINC board. Calling this function at any other time
+*				 will result in losing the state and connections saved in the WINC board and starting again from the initial state. The host driver will need 
+* 				 to be de-initialized before calling nm_bsp_reset and initialized again after it using the " m2m_wifi_(de)init". 
+* @pre          Initialize \ref nm_bsp_init first
+* @note         Implementation of this function is host dependent and called by HIF layer.
+* @warning		 Calling this function will drop any connection and internal state saved on the WINC firmware.
+* @see          nm_bsp_init, m2m_wifi_init,  m2m_wifi_deinit
+* @return       None
 
- */
+*/
 void nm_bsp_reset(void);
- /**@}*/
+/**@}*/
+
 
- 
 /** @defgroup NmBspSleepFn nm_bsp_sleep
 *     @ingroup BSPAPI
 *     Sleep in units of milliseconds.\n
@@ -227,22 +234,22 @@ void nm_bsp_reset(void);
 */
 /**@{*/
 /*!
- * @fn           void nm_bsp_sleep(uint32);
- * @brief   	 Used to put the host to sleep for the specified duration.
- *				 Forcing the host to sleep for extended period may lead to host not being able to respond to WINC board events.It's important to
- *				 be considerate while choosing the sleep period. 
- * @param [in]   u32TimeMsec
- *               Time unit in milliseconds
- * @pre          Initialize \ref nm_bsp_init first
- * @warning      Maximum value must nor exceed 4294967295 milliseconds which is equal to 4294967.295 seconds.\n
- * @note         Implementation of this function is host dependent.
- * @see           nm_bsp_init               
- * @return       None
- */
+* @fn           void nm_bsp_sleep(uint32);
+* @brief   	 Used to put the host to sleep for the specified duration.
+*				 Forcing the host to sleep for extended period may lead to host not being able to respond to WINC board events.It's important to
+*				 be considerate while choosing the sleep period. 
+* @param [in]   u32TimeMsec
+*               Time unit in milliseconds
+* @pre          Initialize \ref nm_bsp_init first
+* @warning      Maximum value must nor exceed 4294967295 milliseconds which is equal to 4294967.295 seconds.\n
+* @note         Implementation of this function is host dependent.
+* @see           nm_bsp_init               
+* @return       None
+*/
 void nm_bsp_sleep(uint32 u32TimeMsec);
 /**@}*/
 
-  
+ 
 /** @defgroup NmBspRegisterFn nm_bsp_register_isr
 *     @ingroup BSPAPI
 *   Register ISR (Interrupt Service Routine) in the initialization of HIF (Host Interface) Layer. 
@@ -250,41 +257,41 @@ void nm_bsp_sleep(uint32 u32TimeMsec);
 */
 /**@{*/
 /*!
- * @fn           void nm_bsp_register_isr(tpfNmBspIsr);
- * @param [in]   tpfNmBspIsr  pfIsr
- *               Pointer to ISR handler in HIF
- * @brief		 Register the host interface interrupt service routine.
- *				 WINC board utilize SPI interface to communicate with the host. This function register the SPI interrupt the notify
- *				 the host whenever there is an outstanding message from the WINC board. The function should be called during the initialization
- *				 of the host interface. It an internal driver function and shouldn't be called by the application. 
- * @warning      Make sure that ISR for IRQ pin for WINC is disabled by default in your implementation.
- * @note         Implementation of this function is host dependent and called by HIF layer.
- * @see          tpfNmBspIsr
- * @return       None
+* @fn           void nm_bsp_register_isr(tpfNmBspIsr);
+* @param [in]   tpfNmBspIsr  pfIsr
+*               Pointer to ISR handler in HIF
+* @brief		 Register the host interface interrupt service routine.
+*				 WINC board utilize SPI interface to communicate with the host. This function register the SPI interrupt the notify
+*				 the host whenever there is an outstanding message from the WINC board. The function should be called during the initialization
+*				 of the host interface. It an internal driver function and shouldn't be called by the application. 
+* @warning      Make sure that ISR for IRQ pin for WINC is disabled by default in your implementation.
+* @note         Implementation of this function is host dependent and called by HIF layer.
+* @see          tpfNmBspIsr
+* @return       None
 
- */
+*/
 void nm_bsp_register_isr(tpfNmBspIsr pfIsr);
 /**@}*/
 
-  
+ 
 /** @defgroup NmBspInterruptCtrl nm_bsp_interrupt_ctrl
 *     @ingroup BSPAPI
 *    Synchronous enable/disable interrupts function
 */
 /**@{*/
 /*!
- * @fn           void nm_bsp_interrupt_ctrl(uint8);
- * @pre			 The interrupt must be registered using nm_bsp_register_isr first.
- * @brief        Enable/Disable interrupts
- *				 This function can be used to enable/disable the WINC to host interrupt as the depending on how the driver is implemented.
- *               It an internal driver function and shouldn't be called by the application.
- * @param [in]   u8Enable
- *               '0' disable interrupts. '1' enable interrupts 
- * @see          tpfNmBspIsr, nm_bsp_register_isr     
- * @note         Implementation of this function is host dependent and called by HIF layer.
- * @return       None
+* @fn           void nm_bsp_interrupt_ctrl(uint8);
+* @pre			 The interrupt must be registered using nm_bsp_register_isr first.
+* @brief        Enable/Disable interrupts
+*				 This function can be used to enable/disable the WINC to host interrupt as the depending on how the driver is implemented.
+*               It an internal driver function and shouldn't be called by the application.
+* @param [in]   u8Enable
+*               '0' disable interrupts. '1' enable interrupts 
+* @see          tpfNmBspIsr, nm_bsp_register_isr     
+* @note         Implementation of this function is host dependent and called by HIF layer.
+* @return       None
 
- */
+*/
 void nm_bsp_interrupt_ctrl(uint8 u8Enable);
   /**@}*/
 
diff --git a/winc1500/bsp/include/nm_bsp_internal.h b/winc1500/bsp/include/nm_bsp_internal.h
index 917ee91..76c1cc9 100644
--- a/winc1500/bsp/include/nm_bsp_internal.h
+++ b/winc1500/bsp/include/nm_bsp_internal.h
@@ -45,75 +45,6 @@
 #ifndef _NM_BSP_INTERNAL_H_
 #define _NM_BSP_INTERNAL_H_
 
-
-
-#ifdef WIN32
-#include "nm_bsp_win32.h"
-#endif
-
-#ifdef __K20D50M__
-#include "nm_bsp_k20d50m.h"
-#endif
-
-#ifdef __MSP430FR5739__
-#include "bsp_msp430fr5739.h"
-#endif
-
-#ifdef _FREESCALE_MCF51CN128_
-#include "bsp/include/nm_bsp_mcf51cn128.h"
-#endif
-
-#ifdef __MCF964548__
-#include "bsp/include/nm_bsp_mc96f4548.h"
-#endif
-
-#ifdef __APP_APS3_CORTUS__
-#include "nm_bsp_aps3_cortus.h"
-#endif
-
-#if (defined __SAMR21G18A__)
-#include "bsp/include/nm_bsp_samr21.h"
-#endif
-
-#if (defined __SAML21J18A__) || (defined __SAML21J18B__)
-#include "bsp/include/nm_bsp_saml21.h"
-#endif
-
-#if (defined __SAML22N18A__)
-#include "bsp/include/nm_bsp_saml22.h"
-#endif
-
-#if (defined __SAMD21J18A__) || (defined __SAMD21G18A__)
-#include "bsp/include/nm_bsp_samd21.h"
-#endif
-
-#if (defined __SAM4S16C__) || (defined __SAM4SD32C__)
-#include "bsp/include/nm_bsp_sam4s.h"
-#endif
-
-#ifdef __SAMG53N19__
-#include "bsp/include/nm_bsp_samg53.h"
-#endif
-
-#ifdef __SAMG55J19__
-#include "bsp/include/nm_bsp_samg55.h"
-#endif
-
-#if (defined __SAME70Q21__) || (defined __SAMV71Q21__)
-#include "bsp/include/nm_bsp_same70.h"
-#endif
-
-#ifdef CORTUS_APP
-#include "crt_iface.h"
-#endif
-
-#ifdef NRF51
-#include "nm_bsp_nrf51822.h"
-#endif
-
-#ifdef _ARDUINO_UNO_
-#include "bsp/include/nm_bsp_arduino_uno.h"
-#endif
-
+#include "nm_bsp_riot.h"
 
 #endif //_NM_BSP_INTERNAL_H_
\ No newline at end of file
diff --git a/winc1500/bsp/include/nm_bsp_samd21.h b/winc1500/bsp/include/nm_bsp_riot.h
similarity index 91%
rename from winc1500/bsp/include/nm_bsp_samd21.h
rename to winc1500/bsp/include/nm_bsp_riot.h
index 34a5d21..c575782 100644
--- a/winc1500/bsp/include/nm_bsp_samd21.h
+++ b/winc1500/bsp/include/nm_bsp_riot.h
@@ -2,7 +2,7 @@
  *
  * \file
  *
- * \brief This module contains SAMD21 BSP APIs declarations.
+ * \brief This module contains RIOT BSP APIs declarations.
  *
  * Copyright (c) 2016-2017 Atmel Corporation. All rights reserved.
  *
@@ -39,15 +39,14 @@
  *
  */
 
-#ifndef _NM_BSP_SAMD21_H_
-#define _NM_BSP_SAMD21_H_
+#ifndef _NM_BSP_RIOT_H_
+#define _NM_BSP_RIOT_H_
 
 #include "conf_winc.h"
-#include "math.h"
 
 #define NM_EDGE_INTERRUPT		(1)
 
 #define NM_DEBUG				CONF_WINC_DEBUG
 #define NM_BSP_PRINTF			CONF_WINC_PRINTF
 
-#endif /* _NM_BSP_SAMD21_H_ */
+#endif /* _NM_BSP_RIOT_H_ */
diff --git a/winc1500/bsp/source/nm_bsp_samd21.c b/winc1500/bsp/source/nm_bsp_riot.c
similarity index 59%
rename from winc1500/bsp/source/nm_bsp_samd21.c
rename to winc1500/bsp/source/nm_bsp_riot.c
index 37d17aa..deced12 100644
--- a/winc1500/bsp/source/nm_bsp_samd21.c
+++ b/winc1500/bsp/source/nm_bsp_riot.c
@@ -39,17 +39,27 @@
  *
  */
 
+#include "board.h"
+#include "periph/gpio.h"
+#include "xtimer.h"
+
 #include "bsp/include/nm_bsp.h"
 #include "common/include/nm_common.h"
-#include "asf.h"
+
+#include "winc1500.h"
+#include "winc1500_internal.h"
 #include "conf_winc.h"
 
 static tpfNmBspIsr gpfIsr;
 
-static void chip_isr(void)
+static void chip_isr(void *args)
 {
 	if (gpfIsr) {
+#if	defined(MODULE_WINC1500) && defined(MODULE_GNRC_NETDEV)
+		gpfIsr(args);
+#else
 		gpfIsr();
+#endif
 	}
 }
 
@@ -59,17 +69,21 @@ static void chip_isr(void)
  */
 static void init_chip_pins(void)
 {
-	struct port_config pin_conf;
+    winc1500_t *dev = &winc1500;
+	/* Configure INTN pins as input. */ // TODO: Delete?
+	gpio_init(dev->params.int_pin, GPIO_IN);
+
+	/* Configure RESETN pin as output. */
+	gpio_init(dev->params.reset_pin, GPIO_OUT);
+	gpio_clear(dev->params.reset_pin);
 
-	port_get_config_defaults(&pin_conf);
+	/* Configure CHIP_EN as output */
+	gpio_init(dev->params.wake_pin, GPIO_OUT);
 
-	/* Configure control pins as output. */
-	pin_conf.direction  = PORT_PIN_DIR_OUTPUT;
-	port_pin_set_config(CONF_WINC_PIN_RESET, &pin_conf);
-	port_pin_set_config(CONF_WINC_PIN_CHIP_ENABLE, &pin_conf);
-	port_pin_set_config(CONF_WINC_PIN_WAKE, &pin_conf);
-	port_pin_set_output_level(CONF_WINC_PIN_CHIP_ENABLE, false);
-	port_pin_set_output_level(CONF_WINC_PIN_RESET, false);
+	/* Configure CHIP_EN as output */
+	if (dev->params.en_pin != GPIO_UNDEF) {
+		gpio_init(dev->params.en_pin, GPIO_OUT); // TODO: pulled up input?
+	}
 }
 
 /*
@@ -77,23 +91,16 @@ static void init_chip_pins(void)
  *	@brief	Initialize BSP
  *	@return	0 in case of success and -1 in case of failure
  */
-sint8 nm_bsp_init(void)
+int8_t nm_bsp_init(void)
 {
 	gpfIsr = NULL;
 
 	/* Initialize chip IOs. */
 	init_chip_pins();
 
-    /* Make sure a 1ms Systick is configured. */
-    if (!(SysTick->CTRL & SysTick_CTRL_ENABLE_Msk && SysTick->CTRL & SysTick_CTRL_TICKINT_Msk)) {
-	    delay_init();
-    }
-
 	/* Perform chip reset. */
 	nm_bsp_reset();
 
-	system_interrupt_enable_global();
-
 	return M2M_SUCCESS;
 }
 
@@ -102,16 +109,17 @@ sint8 nm_bsp_init(void)
  *	@brief	De-iInitialize BSP
  *	@return	0 in case of success and -1 in case of failure
  */
-sint8 nm_bsp_deinit(void)
+int8_t nm_bsp_deinit(void)
 {
-	struct port_config pin_conf;
-	port_get_config_defaults(&pin_conf);
+    winc1500_t *dev = &winc1500;
 	/* Configure control pins as input no pull up. */
-	pin_conf.direction  = PORT_PIN_DIR_INPUT;
-	pin_conf.input_pull = PORT_PIN_PULL_NONE;
-	port_pin_set_output_level(CONF_WINC_PIN_CHIP_ENABLE, false);
-	port_pin_set_output_level(CONF_WINC_PIN_RESET, false);
-	port_pin_set_config(CONF_WINC_SPI_INT_PIN, &pin_conf);
+	gpio_clear(dev->params.reset_pin);
+	gpio_init(dev->params.reset_pin, GPIO_IN);
+	if (dev->params.en_pin != GPIO_UNDEF) {
+		gpio_clear(dev->params.en_pin);
+		gpio_init(dev->params.en_pin, GPIO_IN);
+	}
+
 	return M2M_SUCCESS;
 }
 
@@ -122,12 +130,17 @@ sint8 nm_bsp_deinit(void)
  */
 void nm_bsp_reset(void)
 {
-	port_pin_set_output_level(CONF_WINC_PIN_CHIP_ENABLE, false);
-	port_pin_set_output_level(CONF_WINC_PIN_RESET, false);
+    winc1500_t *dev = &winc1500;
+	if (dev->params.en_pin != GPIO_UNDEF) {
+		gpio_clear(dev->params.en_pin);
+	}
+	gpio_clear(dev->params.reset_pin);
 	nm_bsp_sleep(100);
-	port_pin_set_output_level(CONF_WINC_PIN_CHIP_ENABLE, true);
+	if (dev->params.en_pin != GPIO_UNDEF) {
+		gpio_set(dev->params.en_pin);
+	}
 	nm_bsp_sleep(100);
-	port_pin_set_output_level(CONF_WINC_PIN_RESET, true);
+	gpio_set(dev->params.reset_pin);
 	nm_bsp_sleep(100);
 }
 
@@ -137,10 +150,10 @@ void nm_bsp_reset(void)
  *	@param[IN]	u32TimeMsec
  *				Time in milliseconds
  */
-void nm_bsp_sleep(uint32 u32TimeMsec)
+void nm_bsp_sleep(uint32_t u32TimeMsec)
 {
 	while (u32TimeMsec--) {
-		delay_ms(1);
+		xtimer_usleep(1);
 	}
 }
 
@@ -152,21 +165,9 @@ void nm_bsp_sleep(uint32 u32TimeMsec)
  */
 void nm_bsp_register_isr(tpfNmBspIsr pfIsr)
 {
-	struct extint_chan_conf config_extint_chan;
-
+    winc1500_t *dev = &winc1500;
 	gpfIsr = pfIsr;
-
-	extint_chan_get_config_defaults(&config_extint_chan);
-	config_extint_chan.gpio_pin = CONF_WINC_SPI_INT_PIN;
-	config_extint_chan.gpio_pin_mux = CONF_WINC_SPI_INT_MUX;
-	config_extint_chan.gpio_pin_pull = EXTINT_PULL_UP;
-	config_extint_chan.detection_criteria = EXTINT_DETECT_FALLING;
-
-	extint_chan_set_config(CONF_WINC_SPI_INT_EIC, &config_extint_chan);
-	extint_register_callback(chip_isr, CONF_WINC_SPI_INT_EIC,
-			EXTINT_CALLBACK_TYPE_DETECT);
-	extint_chan_enable_callback(CONF_WINC_SPI_INT_EIC,
-			EXTINT_CALLBACK_TYPE_DETECT);
+	gpio_init_int(dev->params.int_pin, GPIO_IN, GPIO_FALLING, chip_isr, dev);
 }
 
 /*
@@ -175,13 +176,12 @@ void nm_bsp_register_isr(tpfNmBspIsr pfIsr)
  *	@param[IN]	u8Enable
  *				'0' disable interrupts. '1' enable interrupts
  */
-void nm_bsp_interrupt_ctrl(uint8 u8Enable)
+void nm_bsp_interrupt_ctrl(uint8_t u8Enable)
 {
+    winc1500_t *dev = &winc1500;
 	if (u8Enable) {
-		extint_chan_enable_callback(CONF_WINC_SPI_INT_EIC,
-				EXTINT_CALLBACK_TYPE_DETECT);
+		gpio_irq_enable(dev->params.int_pin);
 	} else {
-		extint_chan_disable_callback(CONF_WINC_SPI_INT_EIC,
-				EXTINT_CALLBACK_TYPE_DETECT);
+		gpio_irq_disable(dev->params.int_pin);
 	}
 }
diff --git a/winc1500/bus_wrapper/source/nm_bus_wrapper_riot.c b/winc1500/bus_wrapper/source/nm_bus_wrapper_riot.c
new file mode 100644
index 0000000..46eb82c
--- /dev/null
+++ b/winc1500/bus_wrapper/source/nm_bus_wrapper_riot.c
@@ -0,0 +1,177 @@
+/**
+ *
+ * \file
+ *
+ * \brief This module contains NMC1000 bus wrapper APIs implementation.
+ *
+ * Copyright (c) 2016-2017 Atmel Corporation. All rights reserved.
+ *
+ * \asf_license_start
+ *
+ * \page License
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. The name of Atmel may not be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * \asf_license_stop
+ *
+ */
+
+#include "board.h"
+#include "periph/gpio.h"
+#include "periph/spi.h"
+
+#include <stdio.h>
+#include "bsp/include/nm_bsp.h"
+#include "common/include/nm_common.h"
+#include "bus_wrapper/include/nm_bus_wrapper.h"
+
+#include "winc1500.h"
+#include "winc1500_internal.h"
+#include "conf_winc.h"
+
+#define NM_BUS_MAX_TRX_SZ	256
+
+tstrNmBusCapabilities egstrNmBusCapabilities =
+{
+	NM_BUS_MAX_TRX_SZ
+};
+
+static int8_t spi_rw(uint8_t* pu8Mosi, uint8_t* pu8Miso, uint16_t u16Sz)
+{
+    winc1500_t *dev = &winc1500;
+	uint8_t u8Dummy = 0;
+	uint8_t u8SkipMosi = 0, u8SkipMiso = 0;
+
+	/* Check parameters */
+	if (((pu8Miso == NULL) && (pu8Mosi == NULL)) ||(u16Sz == 0)) {
+		return M2M_ERR_INVALID_ARG;
+	}
+
+	/* Enable/Disable in/out operations */
+	if (pu8Mosi == NULL) {
+		pu8Mosi = &u8Dummy;
+		u8SkipMosi = 1;
+	}
+	if(pu8Miso == NULL) {
+		pu8Miso = &u8Dummy;
+		u8SkipMiso = 1;
+	}
+
+	gpio_clear(dev->params.cs_pin);
+
+	while (u16Sz) {
+		*pu8Miso = spi_transfer_byte(dev->params.spi, SPI_CS_UNDEF,
+										 true, *pu8Mosi);
+		u16Sz--;
+		if (!u8SkipMiso) {
+			pu8Miso++;
+		}
+		if (!u8SkipMosi) {
+			pu8Mosi++;
+		}
+	}
+
+	gpio_set(dev->params.cs_pin);
+
+	return M2M_SUCCESS;
+}
+
+/*
+*	@fn		nm_bus_init
+*	@brief	Initialize the bus wrapper
+*	@return	M2M_SUCCESS in case of success and M2M_ERR_BUS_FAIL in case of failure
+*/
+int8_t nm_bus_init(void *pvinit)
+{
+    winc1500_t *dev = &winc1500;
+	int8_t result = M2M_SUCCESS;
+
+	/* Configure SPI peripheral.
+	 *	This will initialized in the winc1500.c or winc1500_netdev.c */
+	/* spi_init(dev->params.spi); */
+
+	/* Configure CS PIN. */
+	/* This step will set the CS high */
+	gpio_init(dev->params.cs_pin, GPIO_OUT);
+	gpio_set(dev->params.cs_pin);
+
+	/* Reset WINC1500. */
+	nm_bsp_reset();
+	nm_bsp_sleep(1);
+	return result;
+}
+
+/*
+*	@fn		nm_bus_ioctl
+*	@brief	send/receive from the bus
+*	@param[IN]	u8Cmd
+*					IOCTL command for the operation
+*	@param[IN]	pvParameter
+*					Arbitrary parameter depenging on IOCTL
+*	@return	M2M_SUCCESS in case of success and M2M_ERR_BUS_FAIL in case of failure
+*	@note	For SPI only, it's important to be able to send/receive at the same time
+*/
+int8_t nm_bus_ioctl(uint8_t u8Cmd, void* pvParameter)
+{
+	int8_t s8Ret = 0;
+	switch(u8Cmd)
+	{
+		case NM_BUS_IOCTL_RW: {
+			tstrNmSpiRw *pstrParam = (tstrNmSpiRw *)pvParameter;
+			s8Ret = spi_rw(pstrParam->pu8InBuf, pstrParam->pu8OutBuf, pstrParam->u16Sz);
+		}
+		break;
+		default:
+			s8Ret = -1;
+			M2M_ERR("invalide ioclt cmd\n");
+			break;
+	}
+
+	return s8Ret;
+}
+
+/*
+*	@fn		nm_bus_deinit
+*	@brief	De-initialize the bus wrapper
+*/
+int8_t nm_bus_deinit(void)
+{
+	int8_t result = M2M_SUCCESS;
+	/* Code for Disabling SPI bus */
+	return result;
+}
+
+/*
+*	@fn			nm_bus_reinit
+*	@brief		re-initialize the bus wrapper
+*	@param [in]	void *config
+*					re-init configuration data
+*	@return		M2M_SUCCESS in case of success and M2M_ERR_BUS_FAIL in case of failure
+*/
+int8_t nm_bus_reinit(void* config)
+{
+	return M2M_SUCCESS;
+}
diff --git a/winc1500/bus_wrapper/source/nm_bus_wrapper_samd21.c b/winc1500/bus_wrapper/source/nm_bus_wrapper_samd21.c
deleted file mode 100644
index 2bfe376..0000000
--- a/winc1500/bus_wrapper/source/nm_bus_wrapper_samd21.c
+++ /dev/null
@@ -1,321 +0,0 @@
-/**
- *
- * \file
- *
- * \brief This module contains NMC1000 bus wrapper APIs implementation.
- *
- * Copyright (c) 2016-2017 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-
-#include <stdio.h>
-#include "bsp/include/nm_bsp.h"
-#include "common/include/nm_common.h"
-#include "bus_wrapper/include/nm_bus_wrapper.h"
-#include "asf.h"
-#include "conf_winc.h"
-
-#define NM_BUS_MAX_TRX_SZ	256
-
-tstrNmBusCapabilities egstrNmBusCapabilities =
-{
-	NM_BUS_MAX_TRX_SZ
-};
-
-#ifdef CONF_WINC_USE_I2C
-
-struct i2c_master_module i2c_master_instance;
-#define SLAVE_ADDRESS 0x60
-
-/** Number of times to try to send packet if failed. */
-#define I2C_TIMEOUT 100
-
-static sint8 nm_i2c_write(uint8 *b, uint16 sz)
-{
-	sint8 result = M2M_SUCCESS;
-	uint16_t timeout = 0;
-
-	struct i2c_master_packet packet = {
-		.address     = SLAVE_ADDRESS,
-		.data_length = sz,
-		.data        = b,
-	};
-
-	/* Write buffer to slave until success. */
-	while (i2c_master_write_packet_wait(&i2c_master_instance, &packet) != STATUS_OK) {
-		/* Increment timeout counter and check if timed out. */
-		if (timeout++ == I2C_TIMEOUT) {
-			break;
-		}
-	}
-
-	return result;
-}
-
-static sint8 nm_i2c_read(uint8 *rb, uint16 sz)
-{
-	uint16_t timeout = 0;
-	sint8 result = M2M_SUCCESS;
-	struct i2c_master_packet packet = {
-		.address     = SLAVE_ADDRESS,
-		.data_length = sz,
-		.data        = rb,
-	};
-
-	/* Write buffer to slave until success. */
-	while (i2c_master_read_packet_wait(&i2c_master_instance, &packet) != STATUS_OK) {
-		/* Increment timeout counter and check if timed out. */
-		if (timeout++ == I2C_TIMEOUT) {
-			break;
-		}
-	}
-
-	return result;
-}
-
-static sint8 nm_i2c_write_special(uint8 *wb1, uint16 sz1, uint8 *wb2, uint16 sz2)
-{
-	static uint8 tmp[NM_BUS_MAX_TRX_SZ];
-	m2m_memcpy(tmp, wb1, sz1);
-	m2m_memcpy(&tmp[sz1], wb2, sz2);
-	return nm_i2c_write(tmp, sz1+sz2);
-}
-#endif
-
-#ifdef CONF_WINC_USE_SPI
-
-struct spi_module master;
-struct spi_slave_inst slave_inst;
-
-static sint8 spi_rw(uint8* pu8Mosi, uint8* pu8Miso, uint16 u16Sz)
-{
-	uint8 u8Dummy = 0;
-	uint8 u8SkipMosi = 0, u8SkipMiso = 0;
-	uint16_t txd_data = 0;
-	uint16_t rxd_data = 0;
-
-	if(((pu8Miso == NULL) && (pu8Mosi == NULL)) ||(u16Sz == 0)) {
-		return M2M_ERR_INVALID_ARG;
-	}
-
-	if (pu8Mosi == NULL) {
-		pu8Mosi = &u8Dummy;
-		u8SkipMosi = 1;
-	}
-	if(pu8Miso == NULL) {
-		pu8Miso = &u8Dummy;
-		u8SkipMiso = 1;
-	}
-
-	spi_select_slave(&master, &slave_inst, true);
-
-	while (u16Sz) {
-		txd_data = *pu8Mosi;
-		while (!spi_is_ready_to_write(&master))
-			;
-		while(spi_write(&master, txd_data) != STATUS_OK)
-			;
-
-		/* Read SPI master data register. */
-		while (!spi_is_ready_to_read(&master))
-			;
-		while (spi_read(&master, &rxd_data) != STATUS_OK)
-			;
-		*pu8Miso = rxd_data;
-			
-		u16Sz--;
-		if (!u8SkipMiso)
-			pu8Miso++;
-		if (!u8SkipMosi)
-			pu8Mosi++;
-	}
-
-	while (!spi_is_write_complete(&master))
-		;
-
-	spi_select_slave(&master, &slave_inst, false);
-
-	return M2M_SUCCESS;
-}
-#endif
-
-/*
-*	@fn		nm_bus_init
-*	@brief	Initialize the bus wrapper
-*	@return	M2M_SUCCESS in case of success and M2M_ERR_BUS_FAIL in case of failure
-*/
-sint8 nm_bus_init(void *pvinit)
-{
-	sint8 result = M2M_SUCCESS;
-
-#ifdef CONF_WINC_USE_I2C
-	/* Initialize config structure and software module. */
-	struct i2c_master_config config_i2c_master;
-	i2c_master_get_config_defaults(&config_i2c_master);
-
-	/* Change buffer timeout to something longer. */
-	config_i2c_master.buffer_timeout = 1000;
-
-	/* Initialize and enable device with config. */
-	i2c_master_init(&i2c_master_instance, SERCOM2, &config_i2c_master);
-
-	i2c_master_enable(&i2c_master_instance);
-
-#elif defined CONF_WINC_USE_SPI
-	/* Structure for SPI configuration. */
-	struct spi_config config;
-	struct spi_slave_inst_config slave_config;
-
-	/* Select SPI slave CS pin. */
-	/* This step will set the CS high */
-	spi_slave_inst_get_config_defaults(&slave_config);
-	slave_config.ss_pin = CONF_WINC_SPI_CS_PIN;
-	spi_attach_slave(&slave_inst, &slave_config);
-
-	/* Configure the SPI master. */
-	spi_get_config_defaults(&config);
-	config.mux_setting = CONF_WINC_SPI_SERCOM_MUX;
-	config.pinmux_pad0 = CONF_WINC_SPI_PINMUX_PAD0;
-	config.pinmux_pad1 = CONF_WINC_SPI_PINMUX_PAD1;
-	config.pinmux_pad2 = CONF_WINC_SPI_PINMUX_PAD2;
-	config.pinmux_pad3 = CONF_WINC_SPI_PINMUX_PAD3;
-	config.master_slave_select_enable = false;
-	
-	config.mode_specific.master.baudrate = CONF_WINC_SPI_CLOCK;
-	if (spi_init(&master, CONF_WINC_SPI_MODULE, &config) != STATUS_OK) {
-		return M2M_ERR_BUS_FAIL;
-	}
-
-	/* Enable the SPI master. */
-	spi_enable(&master);
-
-	nm_bsp_reset();
-	nm_bsp_sleep(1);
-#endif
-	return result;
-}
-
-/*
-*	@fn		nm_bus_ioctl
-*	@brief	send/receive from the bus
-*	@param[IN]	u8Cmd
-*					IOCTL command for the operation
-*	@param[IN]	pvParameter
-*					Arbitrary parameter depenging on IOCTL
-*	@return	M2M_SUCCESS in case of success and M2M_ERR_BUS_FAIL in case of failure
-*	@note	For SPI only, it's important to be able to send/receive at the same time
-*/
-sint8 nm_bus_ioctl(uint8 u8Cmd, void* pvParameter)
-{
-	sint8 s8Ret = 0;
-	switch(u8Cmd)
-	{
-#ifdef CONF_WINC_USE_I2C
-		case NM_BUS_IOCTL_R: {
-			tstrNmI2cDefault *pstrParam = (tstrNmI2cDefault *)pvParameter;
-			s8Ret = nm_i2c_read(pstrParam->pu8Buf, pstrParam->u16Sz);
-		}
-		break;
-		case NM_BUS_IOCTL_W: {
-			tstrNmI2cDefault *pstrParam = (tstrNmI2cDefault *)pvParameter;
-			s8Ret = nm_i2c_write(pstrParam->pu8Buf, pstrParam->u16Sz);
-		}
-		break;
-		case NM_BUS_IOCTL_W_SPECIAL: {
-			tstrNmI2cSpecial *pstrParam = (tstrNmI2cSpecial *)pvParameter;
-			s8Ret = nm_i2c_write_special(pstrParam->pu8Buf1, pstrParam->u16Sz1, pstrParam->pu8Buf2, pstrParam->u16Sz2);
-		}
-		break;
-#elif defined CONF_WINC_USE_SPI
-		case NM_BUS_IOCTL_RW: {
-			tstrNmSpiRw *pstrParam = (tstrNmSpiRw *)pvParameter;
-			s8Ret = spi_rw(pstrParam->pu8InBuf, pstrParam->pu8OutBuf, pstrParam->u16Sz);
-		}
-		break;
-#endif
-		default:
-			s8Ret = -1;
-			M2M_ERR("invalide ioclt cmd\n");
-			break;
-	}
-
-	return s8Ret;
-}
-
-/*
-*	@fn		nm_bus_deinit
-*	@brief	De-initialize the bus wrapper
-*/
-sint8 nm_bus_deinit(void)
-{
-	sint8 result = M2M_SUCCESS;
-	struct port_config pin_conf;
-		
-	port_get_config_defaults(&pin_conf);
-	/* Configure control pins as input no pull up. */
-	pin_conf.direction  = PORT_PIN_DIR_INPUT;
-	pin_conf.input_pull = PORT_PIN_PULL_NONE;
-
-#ifdef CONF_WINC_USE_I2C
-	i2c_master_disable(&i2c_master_instance);
-	port_pin_set_config(CONF_WINC_I2C_SCL, &pin_conf);
-	port_pin_set_config(CONF_WINC_I2C_SDA, &pin_conf);
-#endif /* CONF_WINC_USE_I2C */
-#ifdef CONF_WINC_USE_SPI
-	spi_disable(&master);
-	port_pin_set_config(CONF_WINC_SPI_MOSI, &pin_conf);
-	port_pin_set_config(CONF_WINC_SPI_MISO, &pin_conf);
-	port_pin_set_config(CONF_WINC_SPI_SCK,  &pin_conf);
-	port_pin_set_config(CONF_WINC_SPI_SS,   &pin_conf);
-	
-	//port_pin_set_output_level(CONF_WINC_SPI_MOSI, false);
-	//port_pin_set_output_level(CONF_WINC_SPI_MISO, false);
-	//port_pin_set_output_level(CONF_WINC_SPI_SCK,  false);
-	//port_pin_set_output_level(CONF_WINC_SPI_SS,   false);
-#endif /* CONF_WINC_USE_SPI */
-	return result;
-}
-
-/*
-*	@fn			nm_bus_reinit
-*	@brief		re-initialize the bus wrapper
-*	@param [in]	void *config
-*					re-init configuration data
-*	@return		M2M_SUCCESS in case of success and M2M_ERR_BUS_FAIL in case of failure
-*/
-sint8 nm_bus_reinit(void* config)
-{
-	return M2M_SUCCESS;
-}
-
diff --git a/winc1500/conf_winc.h b/winc1500/conf_winc.h
new file mode 100644
index 0000000..9655267
--- /dev/null
+++ b/winc1500/conf_winc.h
@@ -0,0 +1,72 @@
+/**
+ *
+ * \file
+ *
+ * \brief WINC1500 configuration.
+ *
+ * Copyright (c) 2016-2017 Atmel Corporation. All rights reserved.
+ *
+ * \asf_license_start
+ *
+ * \page License
+ *
+ * Redistribution and use in source and binary forms, with or without
+ * modification, are permitted provided that the following conditions are met:
+ *
+ * 1. Redistributions of source code must retain the above copyright notice,
+ *    this list of conditions and the following disclaimer.
+ *
+ * 2. Redistributions in binary form must reproduce the above copyright notice,
+ *    this list of conditions and the following disclaimer in the documentation
+ *    and/or other materials provided with the distribution.
+ *
+ * 3. The name of Atmel may not be used to endorse or promote products derived
+ *    from this software without specific prior written permission.
+ *
+ * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
+ * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
+ * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
+ * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
+ * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
+ * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
+ * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
+ * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
+ * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
+ * POSSIBILITY OF SUCH DAMAGE.
+ *
+ * \asf_license_stop
+ *
+ */
+
+#ifndef CONF_WINC_H_INCLUDED
+#define CONF_WINC_H_INCLUDED
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#include "board.h"
+
+/*
+   ---------------------------------
+   ---------- SPI settings ---------
+   ---------------------------------
+*/
+#define CONF_WINC_USE_SPI				(1)
+
+/*
+   ---------------------------------
+   --------- Debug Options ---------
+   ---------------------------------
+*/
+#include "log.h"
+
+#define CONF_WINC_DEBUG					(1)
+#define CONF_WINC_PRINTF				LOG_DEBUG
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* CONF_WINC_H_INCLUDED */
diff --git a/winc1500/driver/include/m2m_wifi.h b/winc1500/driver/include/m2m_wifi.h
index 3477196..120a452 100644
--- a/winc1500/driver/include/m2m_wifi.h
+++ b/winc1500/driver/include/m2m_wifi.h
@@ -1485,7 +1485,7 @@ NMI_API sint8 m2m_wifi_p2p_disconnect(void);
 @endcode
 
 */
-NMI_API sint8 m2m_wifi_enable_ap(CONST tstrM2MAPConfig* pstrM2MAPConfig);
+NMI_API sint8 m2m_wifi_enable_ap(WINC1500_CONST tstrM2MAPConfig* pstrM2MAPConfig);
  /**@}*/
 /** @defgroup WifiDisableApFn m2m_wifi_disable_ap
  *   @ingroup WLANAPI
diff --git a/winc1500/module_config/samd21/conf_winc.h b/winc1500/module_config/samd21/conf_winc.h
deleted file mode 100644
index c269c43..0000000
--- a/winc1500/module_config/samd21/conf_winc.h
+++ /dev/null
@@ -1,170 +0,0 @@
-/**
- *
- * \file
- *
- * \brief WINC1500 configuration.
- *
- * Copyright (c) 2016-2017 Atmel Corporation. All rights reserved.
- *
- * \asf_license_start
- *
- * \page License
- *
- * Redistribution and use in source and binary forms, with or without
- * modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice,
- *    this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice,
- *    this list of conditions and the following disclaimer in the documentation
- *    and/or other materials provided with the distribution.
- *
- * 3. The name of Atmel may not be used to endorse or promote products derived
- *    from this software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY ATMEL "AS IS" AND ANY EXPRESS OR IMPLIED
- * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
- * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NON-INFRINGEMENT ARE
- * EXPRESSLY AND SPECIFICALLY DISCLAIMED. IN NO EVENT SHALL ATMEL BE LIABLE FOR
- * ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL
- * DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS
- * OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION)
- * HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
- * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN
- * ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
- * POSSIBILITY OF SUCH DAMAGE.
- *
- * \asf_license_stop
- *
- */
-
-#ifndef CONF_WINC_H_INCLUDED
-#define CONF_WINC_H_INCLUDED
-
-#ifdef __cplusplus
-extern "C" {
-#endif
-
-#include "board.h"
-
-#if BOARD == SAMW25_XPLAINED_PRO
-
-/* This configuration files comes with empty settings! */
-/* Default settings for SAMW25 Xplained Pro. */
-#warning Please modify conf_winc.h for WINC module settings!
-
-/*
-   ---------------------------------
-   ---------- PIN settings ---------
-   ---------------------------------
-*/
-
-#define CONF_WINC_PIN_RESET				0 /* PIN_PA27 */
-#define CONF_WINC_PIN_CHIP_ENABLE		0 /* PIN_PA28 */
-#define CONF_WINC_PIN_WAKE				0 /* PIN_PB08 */
-
-/*
-   ---------------------------------
-   ---------- SPI settings ---------
-   ---------------------------------
-*/
-
-#define CONF_WINC_USE_SPI				(1)
-
-/** SPI pin and instance settings. */
-#define CONF_WINC_SPI_MODULE			0 /* SERCOM2 */
-#define CONF_WINC_SPI_SERCOM_MUX		0 /* SPI_SIGNAL_MUX_SETTING_D */
-#define CONF_WINC_SPI_PINMUX_PAD0		0 /* PINMUX_PA12C_SERCOM2_PAD0 */ /* out */
-#define CONF_WINC_SPI_PINMUX_PAD1		0 /* PINMUX_PA13C_SERCOM2_PAD1 */ /* sck  */
-#define CONF_WINC_SPI_PINMUX_PAD2		0 /* PINMUX_UNUSED */ /* cs driven from software */
-#define CONF_WINC_SPI_PINMUX_PAD3		0 /* PINMUX_PA15C_SERCOM2_PAD3 */ /* in  */
-#define CONF_WINC_SPI_CS_PIN			0 /* PIN_PA14 */
-
-#define CONF_WINC_SPI_MOSI				0 /* PIN_PA12 */
-#define CONF_WINC_SPI_SCK				0 /* PIN_PA13 */
-#define CONF_WINC_SPI_SS				0 /* PIN_PA14 */
-#define CONF_WINC_SPI_MISO				0 /* PIN_PA15 */
-
-/** SPI interrupt pin. */
-#define CONF_WINC_SPI_INT_PIN			0 /* PIN_PB09A_EIC_EXTINT9 */
-#define CONF_WINC_SPI_INT_MUX			0 /* MUX_PB09A_EIC_EXTINT9 */
-#define CONF_WINC_SPI_INT_EIC			0 /* (9) */
-
-/** SPI clock. */
-#define CONF_WINC_SPI_CLOCK				(12000000)
-
-/*
-   ---------------------------------
-   --------- Debug Options ---------
-   ---------------------------------
-*/
-
-#define CONF_WINC_DEBUG					(1)
-#define CONF_WINC_PRINTF				printf
-
-
-
-#else /* BOARD == SAMD21_XPLAINED_PRO */
-
-/* This configuration files comes with empty settings! */
-/* Default settings for SAMD21 Xplained Pro with WINC on EXT1 are */
-/* available in comments for reference. */
-#warning Please modify conf_winc.h for WINC module settings!
-
-/*
-   ---------------------------------
-   ---------- PIN settings ---------
-   ---------------------------------
-*/
-
-#define CONF_WINC_PIN_RESET				0 /* PIN_PB06 */
-#define CONF_WINC_PIN_CHIP_ENABLE		0 /* PIN_PB05 */
-#define CONF_WINC_PIN_WAKE				0 /* PIN_PB07 */
-
-/*
-   ---------------------------------
-   ---------- SPI settings ---------
-   ---------------------------------
-*/
-
-#define CONF_WINC_USE_SPI				(1)
-
-/** SPI pin and instance settings. */
-#define CONF_WINC_SPI_MODULE			0 /* SERCOM1 */
-#define CONF_WINC_SPI_SERCOM_MUX		0 /* SPI_SIGNAL_MUX_SETTING_E */
-#define CONF_WINC_SPI_PINMUX_PAD0		0 /* PINMUX_PA16C_SERCOM1_PAD0 */ /* in */
-#define CONF_WINC_SPI_PINMUX_PAD1		0 /* PINMUX_PA16C_SERCOM1_PAD1 */ /* cs driven from software */
-#define CONF_WINC_SPI_PINMUX_PAD2		0 /* PINMUX_PA16C_SERCOM1_PAD2 */ /* out */
-#define CONF_WINC_SPI_PINMUX_PAD3		0 /* PINMUX_PA16C_SERCOM1_PAD3 */ /* sck */
-#define CONF_WINC_SPI_CS_PIN			0 /* PIN_PA17 */
-
-#define CONF_WINC_SPI_MISO				0 /* EXT1_PIN_SPI_MISO */
-#define CONF_WINC_SPI_MOSI				0 /* EXT1_PIN_SPI_MOSI */
-#define CONF_WINC_SPI_SCK				0 /* EXT1_PIN_SPI_SCK */
-#define CONF_WINC_SPI_SS				0 /* EXT1_PIN_SPI_SS_0 */
-
-/** SPI interrupt pin. */
-#define CONF_WINC_SPI_INT_PIN			0 /* PIN_PA20A_EIC_EXTINT4 */
-#define CONF_WINC_SPI_INT_MUX			0 /* PINMUX_PA20A_EIC_EXTINT4 */
-#define CONF_WINC_SPI_INT_EIC			0 /* (4) */
-
-/** SPI clock. */
-#define CONF_WINC_SPI_CLOCK				(12000000)
-
-/*
-   ---------------------------------
-   --------- Debug Options ---------
-   ---------------------------------
-*/
-
-#define CONF_WINC_DEBUG					(1)
-#define CONF_WINC_PRINTF				printf
-
-#endif
-
-#ifdef __cplusplus
-}
-#endif
-
-#endif /* CONF_WINC_H_INCLUDED */
-- 
2.13.4

