From 0b47abfbbe4e51093d3d632190d099999545a6b5 Mon Sep 17 00:00:00 2001
From: Bumsik Kim <kbumsik@gmail.com>
Date: Sun, 14 Oct 2018 00:15:33 -0400
Subject: [PATCH 4/4] Redesign: added winc1500_t * as first argument to
 (nearly) all function, and make them reentrant

---
 winc1500/bsp/include/nm_bsp.h                 |  41 +-
 winc1500/bsp/source/nm_bsp_riot.c             |  48 +-
 winc1500/bus_wrapper/include/nm_bus_wrapper.h |  10 +-
 .../bus_wrapper/source/nm_bus_wrapper_riot.c  |  29 +-
 winc1500/driver/include/m2m_ate_mode.h        |  38 +-
 winc1500/driver/include/m2m_crypto.h          |  14 +-
 winc1500/driver/include/m2m_ota.h             | 120 ++--
 winc1500/driver/include/m2m_periph.h          |  18 +-
 winc1500/driver/include/m2m_ssl.h             |  18 +-
 winc1500/driver/include/m2m_wifi.h            | 120 ++--
 winc1500/driver/source/m2m_crypto.c           | 198 +++---
 winc1500/driver/source/m2m_hif.c              | 236 ++++----
 winc1500/driver/source/m2m_hif.h              |  26 +-
 winc1500/driver/source/m2m_ota.c              |  76 +--
 winc1500/driver/source/m2m_periph.c           |  37 +-
 winc1500/driver/source/m2m_ssl.c              | 109 ++--
 winc1500/driver/source/m2m_wifi.c             | 567 +++++++++---------
 winc1500/driver/source/nmasic.c               | 214 +++----
 winc1500/driver/source/nmasic.h               |  48 +-
 winc1500/driver/source/nmbus.c                |  71 +--
 winc1500/driver/source/nmbus.h                |  18 +-
 winc1500/driver/source/nmdrv.c                |  94 +--
 winc1500/driver/source/nmdrv.h                |  12 +-
 winc1500/driver/source/nmspi.c                | 213 +++----
 winc1500/driver/source/nmspi.h                |  16 +-
 winc1500/socket/include/socket.h              |  44 +-
 winc1500/socket/source/socket.c               | 371 ++++++------
 winc1500/socket/source/socket_internal.h      |   2 +-
 winc1500/spi_flash/include/spi_flash.h        |  10 +-
 winc1500/spi_flash/source/spi_flash.c         | 238 ++++----
 30 files changed, 1532 insertions(+), 1524 deletions(-)

diff --git a/winc1500/bsp/include/nm_bsp.h b/winc1500/bsp/include/nm_bsp.h
index 9b89d8a..3cb1194 100644
--- a/winc1500/bsp/include/nm_bsp.h
+++ b/winc1500/bsp/include/nm_bsp.h
@@ -48,6 +48,8 @@
 #ifndef _NM_BSP_H_
 #define _NM_BSP_H_
 
+#include <stdint.h>
+
 #define NMI_API
 /*!< 
 *        Attribute used to define memory section to map Functions in host memory.
@@ -84,13 +86,7 @@
  *                     Used as a data type of ISR function registered by \ref nm_bsp_register_isr
  * @return         None
  */
-#if	defined(MODULE_NETDEV_ETH)
 typedef void (*tpfNmBspIsr)(void *arg);
-#else
-typedef void (*tpfNmBspIsr)(void);
-#endif
-
-#include <stdint.h>
 
   /*!
  * @ingroup DataTypes
@@ -137,6 +133,7 @@ typedef int32_t		sint32;
 
 #ifndef CORTUS_APP
 
+#include "winc1500.h"
 
 #ifdef __cplusplus
 extern "C"{
@@ -172,31 +169,31 @@ extern "C"{
  * @return       The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
 
  */
-sint8 nm_bsp_init(void);
+sint8 nm_bsp_init(winc1500_t *dev);
 /**@}*/
 
 
 /** @defgroup NmBspDeinitFn nm_bsp_deinit
 *    @ingroup BSPAPI
 *   	 De-initialization for BSP ((<strong>B</strong>oard <strong>S</strong>upport <strong>P</strong>ackage)). This function should be called only after
-*		 a successful call to nm_bsp_init. 
+*		 a successful call to nm_bsp_init.
 */
 /**@{*/
 /*!
 * @fn           sint8 nm_bsp_deinit(void);
 * @pre          The BSP should be initialized through \ref nm_bsp_init first.
 * @brief		 This function is used to de-initialize the BSP and turn off the WINC board.
-*				 
-*				 The nm_bsp_deinit is the last function that should be called after the application has finished and before the WINC is switched 
+*
+*				 The nm_bsp_deinit is the last function that should be called after the application has finished and before the WINC is switched
 *				 off. The function call turns off the WINC board by setting CHIP_EN and RESET_N signals low.Every function call of "nm_bsp_init" should
-*				 be matched with a call to nm_bsp_deinit. Failure to do so may result in the WINC consuming higher power than expected. 
+*				 be matched with a call to nm_bsp_deinit. Failure to do so may result in the WINC consuming higher power than expected.
 * @note         Implementation of this function is host dependent.
 * @warning      misuse may lead to unknown behavior in case of soft reset.\n
-* @see          nm_bsp_init               
+* @see          nm_bsp_init
 * @return      The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
 
 */
-sint8 nm_bsp_deinit(void);
+sint8 nm_bsp_deinit(winc1500_t *dev);
 /**@}*/
 
 
@@ -207,15 +204,15 @@ sint8 nm_bsp_deinit(void);
 */
 /**@{*/
 /*!
-* @fn           void nm_bsp_reset(void);    
+* @fn           void nm_bsp_reset(void);
 * @param [in]   None
 * @brief		 Applies a hardware reset to the WINC board.
 *				 The "nm_bsp_reset" is used to apply a hard reset to the WINC board by setting CHIP_EN and RESET_N signals low, then after specific delay
 *				 the function will put CHIP_EN high then RESET_N high, for the detailed timing between signals please review the WINC data-sheet. After a
-*				 successful call, the WINC board firmware will kick off to load and kick off the WINC firmware. This function should be called to reset the 
+*				 successful call, the WINC board firmware will kick off to load and kick off the WINC firmware. This function should be called to reset the
 *				 WINC firmware after the BSP is initialized and before the start of any communication with WINC board. Calling this function at any other time
-*				 will result in losing the state and connections saved in the WINC board and starting again from the initial state. The host driver will need 
-* 				 to be de-initialized before calling nm_bsp_reset and initialized again after it using the " m2m_wifi_(de)init". 
+*				 will result in losing the state and connections saved in the WINC board and starting again from the initial state. The host driver will need
+* 				 to be de-initialized before calling nm_bsp_reset and initialized again after it using the " m2m_wifi_(de)init".
 * @pre          Initialize \ref nm_bsp_init first
 * @note         Implementation of this function is host dependent and called by HIF layer.
 * @warning		 Calling this function will drop any connection and internal state saved on the WINC firmware.
@@ -223,14 +220,14 @@ sint8 nm_bsp_deinit(void);
 * @return       None
 
 */
-void nm_bsp_reset(void);
+void nm_bsp_reset(winc1500_t *dev);
 /**@}*/
 
 
 /** @defgroup NmBspSleepFn nm_bsp_sleep
 *     @ingroup BSPAPI
 *     Sleep in units of milliseconds.\n
-*    This function used by HIF Layer according to different situations. 
+*    This function used by HIF Layer according to different situations.
 */
 /**@{*/
 /*!
@@ -270,7 +267,7 @@ void nm_bsp_sleep(uint32 u32TimeMsec);
 * @return       None
 
 */
-void nm_bsp_register_isr(tpfNmBspIsr pfIsr);
+void nm_bsp_register_isr(winc1500_t *dev, tpfNmBspIsr pfIsr);
 /**@}*/
 
  
@@ -287,12 +284,12 @@ void nm_bsp_register_isr(tpfNmBspIsr pfIsr);
 *               It an internal driver function and shouldn't be called by the application.
 * @param [in]   u8Enable
 *               '0' disable interrupts. '1' enable interrupts 
-* @see          tpfNmBspIsr, nm_bsp_register_isr     
+* @see          tpfNmBspIsr, nm_bsp_register_isr
 * @note         Implementation of this function is host dependent and called by HIF layer.
 * @return       None
 
 */
-void nm_bsp_interrupt_ctrl(uint8 u8Enable);
+void nm_bsp_interrupt_ctrl(winc1500_t *dev, uint8 u8Enable);
   /**@}*/
 
 #ifdef __cplusplus
diff --git a/winc1500/bsp/source/nm_bsp_riot.c b/winc1500/bsp/source/nm_bsp_riot.c
index a20c367..241774b 100644
--- a/winc1500/bsp/source/nm_bsp_riot.c
+++ b/winc1500/bsp/source/nm_bsp_riot.c
@@ -43,24 +43,23 @@
 #include "periph/gpio.h"
 #include "xtimer.h"
 
-#include "bsp/include/nm_bsp.h"
-#include "common/include/nm_common.h"
-
 #include "winc1500.h"
 #include "winc1500_internal.h"
 #include "conf_winc.h"
 
-static tpfNmBspIsr gpfIsr;
+#include "bsp/include/nm_bsp.h"
+#include "common/include/nm_common.h"
 
-static void chip_isr(void *args)
+static void chip_isr(void *arg)
 {
-	if (gpfIsr) {
+	winc1500_t *dev = (winc1500_t *)arg;
+	winc1500_internal_t *internal = &dev->internal;
+
+	if (internal->gpfIsr) {
 #if	defined(MODULE_WINC1500) && defined(MODULE_NETDEV_ETH)
-		gpfIsr(args);
+		internal->gpfIsr(arg);
 #else
-		(void)args;
-
-		gpfIsr();
+		internal->gpfIsr(arg);
 #endif
 	}
 }
@@ -69,9 +68,8 @@ static void chip_isr(void *args)
  *	@fn		init_chip_pins
  *	@brief	Initialize reset, chip enable and wake pin
  */
-static void init_chip_pins(void)
+static void init_chip_pins(winc1500_t *dev)
 {
-    winc1500_t *dev = &winc1500;
 	/* Configure INTN pins as input. */ // TODO: Delete?
 	gpio_init(dev->params.int_pin, GPIO_IN);
 
@@ -93,15 +91,17 @@ static void init_chip_pins(void)
  *	@brief	Initialize BSP
  *	@return	0 in case of success and -1 in case of failure
  */
-int8_t nm_bsp_init(void)
+int8_t nm_bsp_init(winc1500_t *dev)
 {
-	gpfIsr = NULL;
+	winc1500_internal_t *internal = &dev->internal;
+
+	internal->gpfIsr = NULL;
 
 	/* Initialize chip IOs. */
-	init_chip_pins();
+	init_chip_pins(dev);
 
 	/* Perform chip reset. */
-	nm_bsp_reset();
+	nm_bsp_reset(dev);
 
 	return M2M_SUCCESS;
 }
@@ -111,9 +111,8 @@ int8_t nm_bsp_init(void)
  *	@brief	De-iInitialize BSP
  *	@return	0 in case of success and -1 in case of failure
  */
-int8_t nm_bsp_deinit(void)
+int8_t nm_bsp_deinit(winc1500_t *dev)
 {
-    winc1500_t *dev = &winc1500;
 	/* Configure control pins as input no pull up. */
 	gpio_clear(dev->params.reset_pin);
 	gpio_init(dev->params.reset_pin, GPIO_IN);
@@ -130,9 +129,8 @@ int8_t nm_bsp_deinit(void)
  *	@brief	Reset NMC1500 SoC by setting CHIP_EN and RESET_N signals low,
  *           CHIP_EN high then RESET_N high
  */
-void nm_bsp_reset(void)
+void nm_bsp_reset(winc1500_t *dev)
 {
-    winc1500_t *dev = &winc1500;
 	if (dev->params.en_pin != GPIO_UNDEF) {
 		gpio_clear(dev->params.en_pin);
 	}
@@ -165,10 +163,11 @@ void nm_bsp_sleep(uint32_t u32TimeMsec)
  *	@param[IN]	pfIsr
  *				Pointer to ISR handler
  */
-void nm_bsp_register_isr(tpfNmBspIsr pfIsr)
+void nm_bsp_register_isr(winc1500_t *dev, tpfNmBspIsr pfIsr)
 {
-    winc1500_t *dev = &winc1500;
-	gpfIsr = pfIsr;
+	winc1500_internal_t *internal = &dev->internal;
+
+	internal->gpfIsr = pfIsr;
 	gpio_init_int(dev->params.int_pin, GPIO_IN, GPIO_FALLING, chip_isr, dev);
 }
 
@@ -178,9 +177,8 @@ void nm_bsp_register_isr(tpfNmBspIsr pfIsr)
  *	@param[IN]	u8Enable
  *				'0' disable interrupts. '1' enable interrupts
  */
-void nm_bsp_interrupt_ctrl(uint8_t u8Enable)
+void nm_bsp_interrupt_ctrl(winc1500_t *dev, uint8_t u8Enable)
 {
-    winc1500_t *dev = &winc1500;
 	if (u8Enable) {
 		gpio_irq_enable(dev->params.int_pin);
 	} else {
diff --git a/winc1500/bus_wrapper/include/nm_bus_wrapper.h b/winc1500/bus_wrapper/include/nm_bus_wrapper.h
index 98a1a12..53e5f83 100644
--- a/winc1500/bus_wrapper/include/nm_bus_wrapper.h
+++ b/winc1500/bus_wrapper/include/nm_bus_wrapper.h
@@ -122,7 +122,7 @@ typedef struct
 	uint16	u16Sz;		/*!< Operation size */
 } tstrNmUartDefault;
 /*!< Bus capabilities. This structure must be declared at platform specific bus wrapper */
-extern tstrNmBusCapabilities egstrNmBusCapabilities;
+extern const tstrNmBusCapabilities egstrNmBusCapabilities;
 
 
 #ifdef __cplusplus
@@ -133,7 +133,7 @@ extern tstrNmBusCapabilities egstrNmBusCapabilities;
 *	@brief	Initialize the bus wrapper
 *	@return	ZERO in case of success and M2M_ERR_BUS_FAIL in case of failure
 */
-sint8 nm_bus_init(void *);
+sint8 nm_bus_init(winc1500_t *dev, void *pvinit);
 
 /**
 *	@fn		nm_bus_ioctl
@@ -145,14 +145,14 @@ sint8 nm_bus_init(void *);
 *	@return	ZERO in case of success and M2M_ERR_BUS_FAIL in case of failure
 *	@note	For SPI only, it's important to be able to send/receive at the same time
 */
-sint8 nm_bus_ioctl(uint8 u8Cmd, void* pvParameter);
+sint8 nm_bus_ioctl(winc1500_t *dev, uint8 u8Cmd, void* pvParameter);
 
 /**
 *	@fn		nm_bus_deinit
 *	@brief	De-initialize the bus wrapper
 *	@return	ZERO in case of success and M2M_ERR_BUS_FAIL in case of failure
 */
-sint8 nm_bus_deinit(void);
+sint8 nm_bus_deinit(winc1500_t *dev);
 
 /*
 *	@fn			nm_bus_reinit
@@ -161,7 +161,7 @@ sint8 nm_bus_deinit(void);
 *					re-init configuration data
 *	@return		ZERO in case of success and M2M_ERR_BUS_FAIL in case of failure
 */
-sint8 nm_bus_reinit(void *);
+sint8 nm_bus_reinit(winc1500_t *dev, void* config);
 /*
 *	@fn			nm_bus_get_chip_type
 *	@brief		get chip type
diff --git a/winc1500/bus_wrapper/source/nm_bus_wrapper_riot.c b/winc1500/bus_wrapper/source/nm_bus_wrapper_riot.c
index 144703c..b4e9071 100644
--- a/winc1500/bus_wrapper/source/nm_bus_wrapper_riot.c
+++ b/winc1500/bus_wrapper/source/nm_bus_wrapper_riot.c
@@ -43,25 +43,24 @@
 #include "periph/gpio.h"
 #include "periph/spi.h"
 
+#include "winc1500.h"
+#include "winc1500_internal.h"
+#include "conf_winc.h"
+
 #include <stdio.h>
 #include "bsp/include/nm_bsp.h"
 #include "common/include/nm_common.h"
 #include "bus_wrapper/include/nm_bus_wrapper.h"
 
-#include "winc1500.h"
-#include "winc1500_internal.h"
-#include "conf_winc.h"
-
 #define NM_BUS_MAX_TRX_SZ	256
 
-tstrNmBusCapabilities egstrNmBusCapabilities =
+const tstrNmBusCapabilities egstrNmBusCapabilities =
 {
 	NM_BUS_MAX_TRX_SZ
 };
 
-static int8_t spi_rw(uint8_t* pu8Mosi, uint8_t* pu8Miso, uint16_t u16Sz)
+static int8_t spi_rw(winc1500_t *dev, uint8_t* pu8Mosi, uint8_t* pu8Miso, uint16_t u16Sz)
 {
-    winc1500_t *dev = &winc1500;
 	uint8_t u8Dummy = 0;
 	uint8_t u8SkipMosi = 0, u8SkipMiso = 0;
 
@@ -104,11 +103,10 @@ static int8_t spi_rw(uint8_t* pu8Mosi, uint8_t* pu8Miso, uint16_t u16Sz)
 *	@brief	Initialize the bus wrapper
 *	@return	M2M_SUCCESS in case of success and M2M_ERR_BUS_FAIL in case of failure
 */
-int8_t nm_bus_init(void *pvinit)
+int8_t nm_bus_init(winc1500_t *dev, void *pvinit)
 {
 	(void)pvinit;
 
-    winc1500_t *dev = &winc1500;
 	int8_t result = M2M_SUCCESS;
 
 	/* Configure SPI peripheral.
@@ -121,7 +119,7 @@ int8_t nm_bus_init(void *pvinit)
 	gpio_set(dev->params.cs_pin);
 
 	/* Reset WINC1500. */
-	nm_bsp_reset();
+	nm_bsp_reset(dev);
 	nm_bsp_sleep(1);
 	return result;
 }
@@ -136,14 +134,14 @@ int8_t nm_bus_init(void *pvinit)
 *	@return	M2M_SUCCESS in case of success and M2M_ERR_BUS_FAIL in case of failure
 *	@note	For SPI only, it's important to be able to send/receive at the same time
 */
-int8_t nm_bus_ioctl(uint8_t u8Cmd, void* pvParameter)
+int8_t nm_bus_ioctl(winc1500_t *dev, uint8_t u8Cmd, void* pvParameter)
 {
 	int8_t s8Ret = 0;
 	switch(u8Cmd)
 	{
 		case NM_BUS_IOCTL_RW: {
 			tstrNmSpiRw *pstrParam = (tstrNmSpiRw *)pvParameter;
-			s8Ret = spi_rw(pstrParam->pu8InBuf, pstrParam->pu8OutBuf, pstrParam->u16Sz);
+			s8Ret = spi_rw(dev, pstrParam->pu8InBuf, pstrParam->pu8OutBuf, pstrParam->u16Sz);
 		}
 		break;
 		default:
@@ -159,8 +157,10 @@ int8_t nm_bus_ioctl(uint8_t u8Cmd, void* pvParameter)
 *	@fn		nm_bus_deinit
 *	@brief	De-initialize the bus wrapper
 */
-int8_t nm_bus_deinit(void)
+int8_t nm_bus_deinit(winc1500_t *dev)
 {
+	(void) dev;
+
 	int8_t result = M2M_SUCCESS;
 	/* Code for Disabling SPI bus */
 	return result;
@@ -173,8 +173,9 @@ int8_t nm_bus_deinit(void)
 *					re-init configuration data
 *	@return		M2M_SUCCESS in case of success and M2M_ERR_BUS_FAIL in case of failure
 */
-int8_t nm_bus_reinit(void* config)
+int8_t nm_bus_reinit(winc1500_t *dev, void* config)
 {
+	(void)dev;
 	(void)config;
 	
 	return M2M_SUCCESS;
diff --git a/winc1500/driver/include/m2m_ate_mode.h b/winc1500/driver/include/m2m_ate_mode.h
index a17d298..5ff15d4 100644
--- a/winc1500/driver/include/m2m_ate_mode.h
+++ b/winc1500/driver/include/m2m_ate_mode.h
@@ -448,7 +448,7 @@ FUNCTION PROTOTYPES
 @see
 	m2m_ate_init_param	
 */
-sint8 m2m_ate_init(void);
+sint8 m2m_ate_init(winc1500_t *dev);
 
 
 /*!
@@ -465,7 +465,7 @@ sint8 m2m_ate_init(void);
 @see
 	m2m_ate_init
 */
-sint8 m2m_ate_init_param(tstrM2mAteInit *pstrInit);
+sint8 m2m_ate_init_param(winc1500_t *dev, tstrM2mAteInit *pstrInit);
 
 /*!
 @fn	\
@@ -477,7 +477,7 @@ sint8 m2m_ate_init_param(tstrM2mAteInit *pstrInit);
 @return
 	The function SHALL return @ref M2M_SUCCESS for success and a negative value otherwise.
 */
-sint8 m2m_ate_deinit(void);
+sint8 m2m_ate_deinit(winc1500_t *dev);
 
 /*!
 @fn	\
@@ -493,7 +493,7 @@ sint8 m2m_ate_deinit(void);
 @see
 	m2m_ate_init
 */
-sint8 m2m_ate_set_fw_state(uint8);
+sint8 m2m_ate_set_fw_state(winc1500_t *dev, uint8);
 
 /*!
 @fn	\
@@ -507,7 +507,7 @@ sint8 m2m_ate_set_fw_state(uint8);
 @see
 	m2m_ate_init, m2m_ate_set_fw_state
 */
-sint8 m2m_ate_get_fw_state(void);
+sint8 m2m_ate_get_fw_state(winc1500_t *dev);
 
 /*!
 @fn	\
@@ -523,7 +523,7 @@ sint8 m2m_ate_get_fw_state(void);
 @see
 	tenuM2mAteTxIndexOfRates
 */
-uint32 m2m_ate_get_tx_rate(uint8);
+uint32 m2m_ate_get_tx_rate(winc1500_t *dev, uint8);
 
 /*!
 @fn	\
@@ -537,7 +537,7 @@ uint32 m2m_ate_get_tx_rate(uint8);
 @see
 	m2m_ate_start_tx, m2m_ate_stop_tx
 */
-sint8 m2m_ate_get_tx_status(void);
+sint8 m2m_ate_get_tx_status(winc1500_t *dev);
 
 /*!
 @fn	\
@@ -553,7 +553,7 @@ sint8 m2m_ate_get_tx_status(void);
 @see
 	m2m_ate_init, m2m_ate_stop_tx, m2m_ate_get_tx_status
 */
-sint8 m2m_ate_start_tx(tstrM2mAteTx *);
+sint8 m2m_ate_start_tx(winc1500_t *dev, tstrM2mAteTx *);
 
 /*!
 @fn	\
@@ -567,7 +567,7 @@ sint8 m2m_ate_start_tx(tstrM2mAteTx *);
 @see
 	m2m_ate_init, m2m_ate_start_tx, m2m_ate_get_tx_status
 */
-sint8 m2m_ate_stop_tx(void);
+sint8 m2m_ate_stop_tx(winc1500_t *dev);
 
 /*!
 @fn	\
@@ -581,7 +581,7 @@ sint8 m2m_ate_stop_tx(void);
 @see
 	m2m_ate_start_rx, m2m_ate_stop_rx
 */
-sint8 m2m_ate_get_rx_status(void);
+sint8 m2m_ate_get_rx_status(winc1500_t *dev);
 
 /*!
 @fn	\
@@ -597,7 +597,7 @@ sint8 m2m_ate_get_rx_status(void);
 @see
 	m2m_ate_init, m2m_ate_stop_rx, m2m_ate_get_rx_status
 */
-sint8 m2m_ate_start_rx(tstrM2mAteRx *);
+sint8 m2m_ate_start_rx(winc1500_t *dev, tstrM2mAteRx *);
 
 /*!
 @fn	\
@@ -611,7 +611,7 @@ sint8 m2m_ate_start_rx(tstrM2mAteRx *);
 @see
 	m2m_ate_init, m2m_ate_start_rx, m2m_ate_get_rx_status
 */
-sint8 m2m_ate_stop_rx(void);
+sint8 m2m_ate_stop_rx(winc1500_t *dev);
 
 /*!
 @fn	\
@@ -627,7 +627,7 @@ sint8 m2m_ate_stop_rx(void);
 @see
 	m2m_ate_init, m2m_ate_start_rx
 */
-sint8 m2m_ate_read_rx_status(tstrM2mAteRxStatus *);
+sint8 m2m_ate_read_rx_status(winc1500_t *dev, tstrM2mAteRxStatus *);
 
 /*!
 @fn	\
@@ -643,7 +643,7 @@ sint8 m2m_ate_read_rx_status(tstrM2mAteRxStatus *);
 @see
 m2m_ate_get_dig_gain, m2m_ate_get_pa_gain,m2m_ate_get_ppa_gain,m2m_ate_get_tot_gain
 */
-sint8 m2m_ate_set_dig_gain(double dGaindB);
+sint8 m2m_ate_set_dig_gain(winc1500_t *dev, double dGaindB);
 
 /*!
 @fn	\
@@ -660,7 +660,7 @@ sint8 m2m_ate_set_dig_gain(double dGaindB);
 @see
 m2m_ate_set_dig_gain, m2m_ate_get_pa_gain,m2m_ate_get_ppa_gain,m2m_ate_get_tot_gain
 */
-sint8 m2m_ate_get_dig_gain(double * dGaindB);
+sint8 m2m_ate_get_dig_gain(winc1500_t *dev, double * dGaindB);
 
 /*!
 @fn	\
@@ -673,7 +673,7 @@ sint8 m2m_ate_get_dig_gain(double * dGaindB);
 		PA gain level allowed (18/15/12/9/6/3/0 only)
 
 */
-void m2m_ate_set_pa_gain(uint8 gain_db);
+void m2m_ate_set_pa_gain(winc1500_t *dev, uint8 gain_db);
 /*!
 @fn	\
 	sint8 m2m_ate_get_pa_gain(double *paGaindB)
@@ -688,7 +688,7 @@ void m2m_ate_set_pa_gain(uint8 gain_db);
 @see
 m2m_ate_set_dig_gain, m2m_ate_get_dig_gain,m2m_ate_get_ppa_gain,m2m_ate_get_tot_gain
 */
-sint8 m2m_ate_get_pa_gain(double *paGaindB);
+sint8 m2m_ate_get_pa_gain(winc1500_t *dev, double *paGaindB);
 
 /*!
 @fn	\
@@ -704,7 +704,7 @@ sint8 m2m_ate_get_pa_gain(double *paGaindB);
 @see
 m2m_ate_set_dig_gain, m2m_ate_get_dig_gain,m2m_ate_get_pa_gain,m2m_ate_get_tot_gain
 */
-sint8 m2m_ate_get_ppa_gain(double * ppaGaindB);
+sint8 m2m_ate_get_ppa_gain(winc1500_t *dev, double * ppaGaindB);
 
 /*!
 @fn	\
@@ -720,7 +720,7 @@ sint8 m2m_ate_get_ppa_gain(double * ppaGaindB);
 @see
 m2m_ate_set_dig_gain, m2m_ate_get_dig_gain,m2m_ate_get_pa_gain,m2m_ate_get_ppa_gain
 */
-sint8 m2m_ate_get_tot_gain(double * totGaindB);
+sint8 m2m_ate_get_tot_gain(winc1500_t *dev, double * totGaindB);
    //@}
 	
 #ifdef __cplusplus
diff --git a/winc1500/driver/include/m2m_crypto.h b/winc1500/driver/include/m2m_crypto.h
index e7cb213..f9bdb20 100644
--- a/winc1500/driver/include/m2m_crypto.h
+++ b/winc1500/driver/include/m2m_crypto.h
@@ -106,7 +106,7 @@ typedef enum{
 	m2m_crypto_init
 	tenuM2mCryptoCmd
 */
-typedef void (*tpfAppCryproCb) (uint8 u8MsgType,void * pvResp, void * pvMsg);
+typedef void (*tpfAppCryproCb) (winc1500_t *dev, uint8 u8MsgType,void * pvResp, void * pvMsg);
 
 /*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
 FUNCTION PROTOTYPES
@@ -130,7 +130,7 @@ FUNCTION PROTOTYPES
 @return		
 	The function returns @ref M2M_SUCCESS for successful operation and a negative value otherwise.
 */
-sint8 m2m_crypto_init(tpfAppCryproCb pfAppCryproCb);
+sint8 m2m_crypto_init(winc1500_t *dev, tpfAppCryproCb pfAppCryproCb);
 /*!
 @fn	\
 	sint8 m2m_sha256_hash_init(tstrM2mSha256Ctxt *psha256Ctxt);
@@ -142,7 +142,7 @@ sint8 m2m_crypto_init(tpfAppCryproCb pfAppCryproCb);
 @return		
 	The function returns @ref M2M_SUCCESS for successful operation and a negative value otherwise.
 */
-sint8 m2m_crypto_sha256_hash_init(tstrM2mSha256Ctxt *psha256Ctxt);
+sint8 m2m_crypto_sha256_hash_init(winc1500_t *dev, tstrM2mSha256Ctxt *psha256Ctxt);
 
 
 /*!
@@ -167,7 +167,7 @@ sint8 m2m_crypto_sha256_hash_init(tstrM2mSha256Ctxt *psha256Ctxt);
 	The function returns @ref M2M_SUCCESS for successful operation and a negative value otherwise.
 
 */
-sint8 m2m_crypto_sha256_hash_update(tstrM2mSha256Ctxt *psha256Ctxt, uint8 *pu8Data, uint16 u16DataLength);
+sint8 m2m_crypto_sha256_hash_update(winc1500_t *dev, tstrM2mSha256Ctxt *psha256Ctxt, uint8 *pu8Data, uint16 u16DataLength);
 
 
 /*!
@@ -185,7 +185,7 @@ sint8 m2m_crypto_sha256_hash_update(tstrM2mSha256Ctxt *psha256Ctxt, uint8 *pu8Da
 @return		
 	The function returns @ref M2M_SUCCESS for successful operation and a negative value otherwise.
 */
-sint8 m2m_crypto_sha256_hash_finish(tstrM2mSha256Ctxt *psha256Ctxt, uint8 *pu8Sha256Digest);
+sint8 m2m_crypto_sha256_hash_finish(winc1500_t *dev, tstrM2mSha256Ctxt *psha256Ctxt, uint8 *pu8Sha256Digest);
 
 
 /*!
@@ -223,7 +223,7 @@ sint8 m2m_crypto_sha256_hash_finish(tstrM2mSha256Ctxt *psha256Ctxt, uint8 *pu8Sh
 @return		
 	The function returns @ref M2M_SUCCESS for successful operation and a negative value otherwise.
 */
-sint8 m2m_crypto_rsa_sign_verify(uint8 *pu8N, uint16 u16NSize, uint8 *pu8E, uint16 u16ESize, uint8 *pu8SignedMsgHash, 
+sint8 m2m_crypto_rsa_sign_verify(winc1500_t *dev, uint8 *pu8N, uint16 u16NSize, uint8 *pu8E, uint16 u16ESize, uint8 *pu8SignedMsgHash,
 						  uint16 u16HashLength, uint8 *pu8RsaSignature);
 
 
@@ -262,7 +262,7 @@ sint8 m2m_crypto_rsa_sign_verify(uint8 *pu8N, uint16 u16NSize, uint8 *pu8E, uint
 @return		
 	The function returns @ref M2M_SUCCESS for successful operation and a negative value otherwise.
 */
-sint8 m2m_crypto_rsa_sign_gen(uint8 *pu8N, uint16 u16NSize, uint8 *pu8d, uint16 u16dSize, uint8 *pu8SignedMsgHash, 
+sint8 m2m_crypto_rsa_sign_gen(winc1500_t *dev, uint8 *pu8N, uint16 u16NSize, uint8 *pu8d, uint16 u16dSize, uint8 *pu8SignedMsgHash, 
 					   uint16 u16HashLength, uint8 *pu8RsaSignature);
 #ifdef __cplusplus
 }
diff --git a/winc1500/driver/include/m2m_ota.h b/winc1500/driver/include/m2m_ota.h
index 4f3dd5a..461e6d6 100644
--- a/winc1500/driver/include/m2m_ota.h
+++ b/winc1500/driver/include/m2m_ota.h
@@ -69,25 +69,25 @@ INCLUDES
 		The notification is not supported (Not implemented yet)
 
 */
-typedef void (*tpfOtaNotifCb) (tstrOtaUpdateInfo * pstrOtaUpdateInfo);
+typedef void (*tpfOtaNotifCb) (winc1500_t *dev, tstrOtaUpdateInfo * pstrOtaUpdateInfo);
 
 
 /*!
 @typedef void (*tpfOtaUpdateCb) (uint8 u8OtaUpdateStatusType ,uint8 u8OtaUpdateStatus);
 
-@brief 
+@brief
    A callback to get OTA status update, the callback provide the status type and its status.
-   The OTA callback provides the download status, the switch to the downloaded firmware status and roll-back status. 
- 
+   The OTA callback provides the download status, the switch to the downloaded firmware status and roll-back status.
+
 @param[in] u8OtaUpdateStatusType Possible values are listed in tenuOtaUpdateStatusType.
 
-@param[in] u8OtaUpdateStatus Possible values are listed as enumerated by @ref tenuOtaUpdateStatus. 
+@param[in] u8OtaUpdateStatus Possible values are listed as enumerated by @ref tenuOtaUpdateStatus.
 
 @see
 	tenuOtaUpdateStatusType
 	tenuOtaUpdateStatus
  */
-typedef void (*tpfOtaUpdateCb) (uint8 u8OtaUpdateStatusType ,uint8 u8OtaUpdateStatus);
+typedef void (*tpfOtaUpdateCb) (winc1500_t *dev, uint8 u8OtaUpdateStatusType ,uint8 u8OtaUpdateStatus);
  /**@}*/
 /*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
 FUNCTION PROTOTYPES
@@ -118,9 +118,9 @@ FUNCTION PROTOTYPES
 @return		
 	The function returns @ref M2M_SUCCESS for successful operations  and a negative value otherwise.
 */
-NMI_API sint8  m2m_ota_init(tpfOtaUpdateCb  pfOtaUpdateCb,tpfOtaNotifCb  pfOtaNotifCb);
+NMI_API sint8  m2m_ota_init(winc1500_t *dev, tpfOtaUpdateCb  pfOtaUpdateCb,tpfOtaNotifCb  pfOtaNotifCb);
  /**@}*/
- 
+
  /** @defgroup OtaNotifStFn m2m_ota_notif_set_url
  *  @ingroup WLANAPI
  * Set the OTA notification server URL, the functions need to be called before any check for update
@@ -132,15 +132,15 @@ NMI_API sint8  m2m_ota_init(tpfOtaUpdateCb  pfOtaUpdateCb,tpfOtaNotifCb  pfOtaNo
 
 @param [in]	u8Url
 			 Set the OTA notification server URL, the functions need to be called before any check for update.
-@warning 
+@warning
 			Calling m2m_ota_init is required
 			Notification Server is not supported in the current version (function is not implemented)
-@see    
-			m2m_ota_init			
-@return		
+@see
+			m2m_ota_init
+@return
 	The function returns @ref M2M_SUCCESS for successful operations  and a negative value otherwise.
 */
-NMI_API sint8  m2m_ota_notif_set_url(uint8 * u8Url);
+NMI_API sint8  m2m_ota_notif_set_url(winc1500_t *dev, uint8 * u8Url);
  /**@}*/
  /** @defgroup OtaNotifCheckFn m2m_ota_notif_check_for_update
  *  @ingroup WLANAPI
@@ -153,16 +153,16 @@ NMI_API sint8  m2m_ota_notif_set_url(uint8 * u8Url);
 @fn	\
 	NMI_API sint8  m2m_ota_notif_check_for_update(void);
 
-@warning 
+@warning
 		Function is not implemented (not supported at the current version)
-		
-@sa   
+
+@sa
 			m2m_ota_init
 			m2m_ota_notif_set_url
-@return		
+@return
 	The function returns @ref M2M_SUCCESS for successful operations  and a negative value otherwise.
 */
-NMI_API sint8  m2m_ota_notif_check_for_update(void);
+NMI_API sint8  m2m_ota_notif_check_for_update(winc1500_t *dev);
  /**@}*/
  /** @defgroup OtaSched m2m_ota_notif_sched
 *  @ingroup WLANAPI
@@ -177,19 +177,19 @@ NMI_API sint8  m2m_ota_notif_check_for_update(void);
 @param [in]	u32Period
 			Period in days
 
-@sa 
+@sa
 		m2m_ota_init
 		m2m_ota_notif_check_for_update
 		m2m_ota_notif_set_url
-@return		
+@return
 	The function returns @ref M2M_SUCCESS for successful operations  and a negative value otherwise.
 */
-NMI_API sint8 m2m_ota_notif_sched(uint32 u32Period);
+NMI_API sint8 m2m_ota_notif_sched(winc1500_t *dev, uint32 u32Period);
   /**@}*/
 /** @defgroup OtaStartUpdatefn m2m_ota_start_update
 *  @ingroup WLANAPI
-*	Request OTA start update using the downloaded URL, the OTA module will download the OTA image and ensure integrity of the image, 
-*   and update the validity of the image in control structure. Switching to that image requires calling @ref m2m_ota_switch_firmware API. 
+*	Request OTA start update using the downloaded URL, the OTA module will download the OTA image and ensure integrity of the image,
+*   and update the validity of the image in control structure. Switching to that image requires calling @ref m2m_ota_switch_firmware API.
 *   As a prerequisite @ref m2m_ota_init should be called before using @ref m2m_ota_start().
 */
   /**@{*/
@@ -202,14 +202,14 @@ NMI_API sint8 m2m_ota_notif_sched(uint32 u32Period);
 
 @warning
 	Calling this API does not guarantee OTA WINC image update, It depends on the connection with the download server and the validity of the image.
-	If the API response is failure this may invalidate the roll-back image if it was previously valid, since the WINC does not have any internal memory 
+	If the API response is failure this may invalidate the roll-back image if it was previously valid, since the WINC does not have any internal memory
 	except the flash roll-back image location to validate the downloaded image from
-				
+
 @see		
 		m2m_ota_init
 		tpfOtaUpdateCb
-		
-@return		
+
+@return
 	The function returns @ref M2M_SUCCESS for successful operations  and a negative value otherwise.
 \section Example
    The example shows an example of how the OTA image update is carried out.
@@ -245,10 +245,10 @@ int main (void)
 	tstrWifiInitParam param;
 	tstr1xAuthCredentials gstrCred1x    = AUTH_CREDENTIALS;
 	nm_bsp_init();
-	
+
 	m2m_memset((uint8*)&param, 0, sizeof(param));
 	param.pfAppWifiCb = wifi_event_cb;
-	
+
 	//Initialize the WINC Driver
 	ret = m2m_wifi_init(&param);
 	if (M2M_SUCCESS != ret)
@@ -263,23 +263,23 @@ int main (void)
 
 	while(1)
 	{
-		
-		//Handle the app state machine plus the WINC event handler                                                                     
+
+		//Handle the app state machine plus the WINC event handler
 		while(m2m_wifi_handle_events(NULL) != M2M_SUCCESS) {
 			
 		}
-		
+
 	}
 }
-@endcode		
+@endcode
 
 */
-NMI_API sint8 m2m_ota_start_update(uint8 * u8DownloadUrl);
+NMI_API sint8 m2m_ota_start_update(winc1500_t *dev, uint8 * u8DownloadUrl);
     /**@}*/
 /** @defgroup OtaStartUpdatefn m2m_ota_start_update_crt
 *  @ingroup WLANAPI
-*	Request OTA start for cortus application image using the downloaded URL, the OTA module will download the OTA image and ensure integrity of the image, 
-*   and update the validity of the image in control structure. Switching to that image requires calling @ref m2m_ota_switch_crt API. 
+*	Request OTA start for cortus application image using the downloaded URL, the OTA module will download the OTA image and ensure integrity of the image,
+*   and update the validity of the image in control structure. Switching to that image requires calling @ref m2m_ota_switch_crt API.
 *   As a prerequisite @ref m2m_ota_init should be called before using @ref m2m_ota_start_update_crt().
 */
   /**@{*/
@@ -291,17 +291,17 @@ NMI_API sint8 m2m_ota_start_update(uint8 * u8DownloadUrl);
 		The cortus application image url.
 @warning
 	Calling this API does not guarantee cortus application image update, It depends on the connection with the download server and the validity of the image.
-	If the API response is failure this may invalidate the roll-back image if it was previously valid, since the WINC does not have any internal memory 
+	If the API response is failure this may invalidate the roll-back image if it was previously valid, since the WINC does not have any internal memory
 	except the flash roll-back image location to validate the downloaded image from
-				
+
 @see		
 		m2m_ota_init
 		tpfOtaUpdateCb
-		
-@return		
+
+@return
 	The function returns @ref M2M_SUCCESS for successful operations  and a negative value otherwise.
 */
-NMI_API sint8 m2m_ota_start_update_crt(uint8 * u8DownloadUrl);
+NMI_API sint8 m2m_ota_start_update_crt(winc1500_t *dev, uint8 * u8DownloadUrl);
   /**@}*/
 /** @defgroup OtaRollbackfn m2m_ota_rollback
 *  @ingroup WLANAPI
@@ -316,14 +316,14 @@ NMI_API sint8 m2m_ota_start_update_crt(uint8 * u8DownloadUrl);
 @fn	\
 	NMI_API sint8 m2m_ota_rollback(void);
 
-@sa 
+@sa
 	m2m_ota_init
-	m2m_ota_start_update	
+	m2m_ota_start_update
 
-@return		
+@return
 	The function returns @ref M2M_SUCCESS for successful operations  and a negative value otherwise.
 */
-NMI_API sint8 m2m_ota_rollback(void);
+NMI_API sint8 m2m_ota_rollback(winc1500_t *dev);
     /**@}*/
 /** @defgroup OtaRollbackfn m2m_ota_rollback_crt
 *  @ingroup WLANAPI
@@ -338,14 +338,14 @@ NMI_API sint8 m2m_ota_rollback(void);
 @fn	\
 	NMI_API sint8 m2m_ota_rollback_crt(void);
 
-@sa 
+@sa
 	m2m_ota_init
-	m2m_ota_start_update_crt	
+	m2m_ota_start_update_crt
 
-@return		
+@return
 	The function returns @ref M2M_SUCCESS for successful operations  and a negative value otherwise.
 */
-NMI_API sint8 m2m_ota_rollback_crt(void);
+NMI_API sint8 m2m_ota_rollback_crt(winc1500_t *dev);
   /**@}*/
 /** @defgroup OtaAbortfn m2m_ota_abort
 *  @ingroup WLANAPI
@@ -361,7 +361,7 @@ NMI_API sint8 m2m_ota_rollback_crt(void);
 @return
 	The function returns @ref M2M_SUCCESS for successful operation and a negative value otherwise.
 */
-NMI_API sint8 m2m_ota_abort(void);
+NMI_API sint8 m2m_ota_abort(winc1500_t *dev);
   /**@}*/
   /**@}*/
 /** @defgroup OtaSwitchFirmware m2m_ota_switch_firmware
@@ -375,16 +375,16 @@ NMI_API sint8 m2m_ota_abort(void);
 	NMI_API sint8 m2m_ota_switch_firmware(void);
 
 @warning
-   It is important to note that if the API succeeds, system restart is required (re-initializing the driver with hardware reset) updating the host driver version may be required 
+   It is important to note that if the API succeeds, system restart is required (re-initializing the driver with hardware reset) updating the host driver version may be required
    if it does not match the minimum driver version supported by the WINC's firmware.
-@sa 
+@sa
 	m2m_ota_init
 	m2m_ota_start_update
 
-@return		
+@return
 	The function returns @ref M2M_SUCCESS for successful operations  and a negative value otherwise.
 */
-NMI_API sint8 m2m_ota_switch_firmware(void);
+NMI_API sint8 m2m_ota_switch_firmware(winc1500_t *dev);
   /**@}*/
   /**@}*/
 /** @defgroup OtaSwitchFirmware m2m_ota_switch_crt
@@ -398,16 +398,16 @@ NMI_API sint8 m2m_ota_switch_firmware(void);
 	NMI_API sint8 m2m_ota_switch_firmware(void);
 
 @warning
-   It is important to note that if the API succeeds, system restart is required (re-initializing the driver with hardware reset) updating the host driver version may be required 
+   It is important to note that if the API succeeds, system restart is required (re-initializing the driver with hardware reset) updating the host driver version may be required
    if it does not match the minimum driver version supported by the WINC's firmware.
-@sa 
+@sa
 	m2m_ota_init
 	m2m_ota_start_update_crt
 
-@return		
+@return
 	The function returns @ref M2M_SUCCESS for successful operations  and a negative value otherwise.
 */
-NMI_API sint8 m2m_ota_switch_crt(void);
+NMI_API sint8 m2m_ota_switch_crt(winc1500_t *dev);
 /*!
 @fn	\
 	NMI_API sint8 m2m_ota_get_firmware_version(void);
@@ -418,9 +418,9 @@ NMI_API sint8 m2m_ota_switch_crt(void);
 @return
 	The function SHALL return 0 for success and a negative value otherwise.
 */
-NMI_API sint8 m2m_ota_get_firmware_version(tstrM2mRev *pstrRev);
+NMI_API sint8 m2m_ota_get_firmware_version(winc1500_t *dev, tstrM2mRev *pstrRev);
   /**@}*/
-NMI_API sint8 m2m_ota_test(void);
+NMI_API sint8 m2m_ota_test(winc1500_t *dev);
 
 #ifdef __cplusplus
 }
diff --git a/winc1500/driver/include/m2m_periph.h b/winc1500/driver/include/m2m_periph.h
index 1012882..fe56a5a 100644
--- a/winc1500/driver/include/m2m_periph.h
+++ b/winc1500/driver/include/m2m_periph.h
@@ -225,7 +225,7 @@ FUNCTION PROTOTYPES
 @sa
 	tstrPerphInitParam
 */
-NMI_API sint8 m2m_periph_init(tstrPerphInitParam * param);
+NMI_API sint8 m2m_periph_init(winc1500_t *dev, tstrPerphInitParam * param);
 
 /*!
 @fn	\
@@ -246,7 +246,7 @@ NMI_API sint8 m2m_periph_init(tstrPerphInitParam * param);
 @sa
 	tenuGpioNum
 */
-NMI_API sint8 m2m_periph_gpio_set_dir(uint8 u8GpioNum, uint8 u8GpioDir);
+NMI_API sint8 m2m_periph_gpio_set_dir(winc1500_t *dev, uint8 u8GpioNum, uint8 u8GpioDir);
 
 /*!
 @fn	\
@@ -267,7 +267,7 @@ NMI_API sint8 m2m_periph_gpio_set_dir(uint8 u8GpioNum, uint8 u8GpioDir);
 @sa
 	tenuGpioNum
 */
-NMI_API sint8 m2m_periph_gpio_set_val(uint8 u8GpioNum, uint8 u8GpioVal);
+NMI_API sint8 m2m_periph_gpio_set_val(winc1500_t *dev, uint8 u8GpioNum, uint8 u8GpioVal);
 
 /*!
 @fn	\
@@ -288,7 +288,7 @@ NMI_API sint8 m2m_periph_gpio_set_val(uint8 u8GpioNum, uint8 u8GpioVal);
 @sa
 	tenuGpioNum
 */
-NMI_API sint8 m2m_periph_gpio_get_val(uint8 u8GpioNum, uint8 * pu8GpioVal);
+NMI_API sint8 m2m_periph_gpio_get_val(winc1500_t *dev, uint8 u8GpioNum, uint8 * pu8GpioVal);
 
 /*!
 @fn	\
@@ -309,7 +309,7 @@ NMI_API sint8 m2m_periph_gpio_get_val(uint8 u8GpioNum, uint8 * pu8GpioVal);
 @sa
 	tenuGpioNum
 */
-NMI_API sint8 m2m_periph_gpio_pullup_ctrl(uint8 u8GpioNum, uint8 u8PullupEn);
+NMI_API sint8 m2m_periph_gpio_pullup_ctrl(winc1500_t *dev, uint8 u8GpioNum, uint8 u8PullupEn);
 
 /*!
 @fn	\
@@ -327,7 +327,7 @@ NMI_API sint8 m2m_periph_gpio_pullup_ctrl(uint8 u8GpioNum, uint8 u8PullupEn);
 @sa
 	tstrI2cMasterInitParam
 */
-NMI_API sint8 m2m_periph_i2c_master_init(tstrI2cMasterInitParam * param);
+NMI_API sint8 m2m_periph_i2c_master_init(winc1500_t *dev, tstrI2cMasterInitParam * param);
 
 /*!
 @fn	\
@@ -351,7 +351,7 @@ NMI_API sint8 m2m_periph_i2c_master_init(tstrI2cMasterInitParam * param);
 @sa
 	tenuI2cMasterFlags
 */
-NMI_API sint8 m2m_periph_i2c_master_write(uint8 u8SlaveAddr, uint8 * pu8Buf, uint16 u16BufLen, uint8 flags);
+NMI_API sint8 m2m_periph_i2c_master_write(winc1500_t *dev, uint8 u8SlaveAddr, uint8 * pu8Buf, uint16 u16BufLen, uint8 flags);
 
 
 /*!
@@ -378,7 +378,7 @@ NMI_API sint8 m2m_periph_i2c_master_write(uint8 u8SlaveAddr, uint8 * pu8Buf, uin
 @sa
 	tenuI2cMasterFlags
 */
-NMI_API sint8 m2m_periph_i2c_master_read(uint8 u8SlaveAddr, uint8 * pu8Buf, uint16 u16BufLen, uint16 * pu16ReadLen, uint8 flags);
+NMI_API sint8 m2m_periph_i2c_master_read(winc1500_t *dev, uint8 u8SlaveAddr, uint8 * pu8Buf, uint16 u16BufLen, uint16 * pu16ReadLen, uint8 flags);
 
 
 /*!
@@ -401,7 +401,7 @@ NMI_API sint8 m2m_periph_i2c_master_read(uint8 u8SlaveAddr, uint8 * pu8Buf, uint
 @sa
 	tenuPullupMask
 */
-NMI_API sint8 m2m_periph_pullup_ctrl(uint32 pinmask, uint8 enable);
+NMI_API sint8 m2m_periph_pullup_ctrl(winc1500_t *dev, uint32 pinmask, uint8 enable);
 
 #ifdef __cplusplus
 }
diff --git a/winc1500/driver/include/m2m_ssl.h b/winc1500/driver/include/m2m_ssl.h
index f5271f0..38ef947 100644
--- a/winc1500/driver/include/m2m_ssl.h
+++ b/winc1500/driver/include/m2m_ssl.h
@@ -68,7 +68,7 @@ INCLUDES
 @param[in] u8MsgType
 @param[in] pvMsg A structure to provide notification payload.
 */
-typedef void (*tpfAppSSLCb) (uint8 u8MsgType, void * pvMsg);
+typedef void (*tpfAppSSLCb) (winc1500_t *dev, uint8 u8MsgType, void * pvMsg);
 
 /**@}
 */
@@ -88,7 +88,7 @@ FUNCTION PROTOTYPES
 				Application SSL callback function.
 	@return		The function SHALL return 0 for success and a negative value otherwise.
 */
-NMI_API sint8 m2m_ssl_init(tpfAppSSLCb pfAppSSLCb);
+NMI_API sint8 m2m_ssl_init(winc1500_t *dev, tpfAppSSLCb pfAppSSLCb);
 
 /*!
 	@fn	\	 NMI_API sint8 m2m_ssl_handshake_rsp(tstrEccReqInfo* strECCResp, uint8* pu8RspDataBuff, uint16 u16RspDataSz)
@@ -101,7 +101,7 @@ NMI_API sint8 m2m_ssl_init(tpfAppSSLCb pfAppSSLCb);
 				Response data size.
 	@return		The function SHALL return 0 for success and a negative value otherwise.
 */
-NMI_API sint8 m2m_ssl_handshake_rsp(tstrEccReqInfo* strECCResp, uint8* pu8RspDataBuff, uint16 u16RspDataSz);
+NMI_API sint8 m2m_ssl_handshake_rsp(winc1500_t *dev, tstrEccReqInfo* strECCResp, uint8* pu8RspDataBuff, uint16 u16RspDataSz);
 
 /*!
 	@fn	\	NMI_API sint8 m2m_ssl_send_certs_to_winc(uint8* pu8Buffer, uint32 u32BufferSz)
@@ -112,7 +112,7 @@ NMI_API sint8 m2m_ssl_handshake_rsp(tstrEccReqInfo* strECCResp, uint8* pu8RspDat
 				Size of the certificates.
 	@return		The function SHALL return 0 for success and a negative value otherwise.
 */
-NMI_API sint8 m2m_ssl_send_certs_to_winc(uint8* pu8Buffer, uint32 u32BufferSz);
+NMI_API sint8 m2m_ssl_send_certs_to_winc(winc1500_t *dev, uint8* pu8Buffer, uint32 u32BufferSz);
 
 /*!
 	@fn	\	NMI_API sint8 m2m_ssl_retrieve_cert(uint16* pu16CurveType, uint8* pu8Hash, uint8* pu8Sig, tstrECPoint* pu8Key)
@@ -127,7 +127,7 @@ NMI_API sint8 m2m_ssl_send_certs_to_winc(uint8* pu8Buffer, uint32 u32BufferSz);
 				Pointer to the certificate Key.
 	@return		The function SHALL return 0 for success and a negative value otherwise.
 */
-NMI_API sint8 m2m_ssl_retrieve_cert(uint16* pu16CurveType, uint8* pu8Hash, uint8* pu8Sig, tstrECPoint* pu8Key);
+NMI_API sint8 m2m_ssl_retrieve_cert(winc1500_t *dev, uint16* pu16CurveType, uint8* pu8Hash, uint8* pu8Sig, tstrECPoint* pu8Key);
 
 /*!
 	@fn	\	NMI_API sint8 m2m_ssl_retrieve_hash(uint8* pu8Hash, uint16 u16HashSz)
@@ -138,7 +138,7 @@ NMI_API sint8 m2m_ssl_retrieve_cert(uint16* pu16CurveType, uint8* pu8Hash, uint8
 				Hash size.
 	@return		The function SHALL return 0 for success and a negative value otherwise.
 */
-NMI_API sint8 m2m_ssl_retrieve_hash(uint8* pu8Hash, uint16 u16HashSz);
+NMI_API sint8 m2m_ssl_retrieve_hash(winc1500_t *dev, uint8* pu8Hash, uint16 u16HashSz);
 
 /*!
 	@fn	\	NMI_API void m2m_ssl_stop_processing_certs(void)
@@ -146,7 +146,7 @@ NMI_API sint8 m2m_ssl_retrieve_hash(uint8* pu8Hash, uint16 u16HashSz);
 	@warning	This API must only be called if some certificates are left unread.
 	@return		None.
 */
-NMI_API void m2m_ssl_stop_processing_certs(void);
+NMI_API void m2m_ssl_stop_processing_certs(winc1500_t *dev);
 
 /*!
 	@fn	\	NMI_API void m2m_ssl_ecc_process_done(void)
@@ -154,7 +154,7 @@ NMI_API void m2m_ssl_stop_processing_certs(void);
 	@warning	This API must be called after receiving a SSL callback with type @ref M2M_SSL_REQ_ECC
 	@return		None.
 */
-NMI_API void m2m_ssl_ecc_process_done(void);
+NMI_API void m2m_ssl_ecc_process_done(winc1500_t *dev);
 
 /*!
 @fn	\
@@ -176,7 +176,7 @@ NMI_API void m2m_ssl_ecc_process_done(void);
 	- [SOCK_ERR_NO_ERROR](@ref SOCK_ERR_NO_ERROR)
 	- [SOCK_ERR_INVALID_ARG](@ref SOCK_ERR_INVALID_ARG)
 */
-sint8 m2m_ssl_set_active_ciphersuites(uint32 u32SslCsBMP);
+sint8 m2m_ssl_set_active_ciphersuites(winc1500_t *dev, uint32 u32SslCsBMP);
 
  /**@}*/
 #endif /* __M2M_SSL_H__ */
\ No newline at end of file
diff --git a/winc1500/driver/include/m2m_wifi.h b/winc1500/driver/include/m2m_wifi.h
index 120a452..b565343 100644
--- a/winc1500/driver/include/m2m_wifi.h
+++ b/winc1500/driver/include/m2m_wifi.h
@@ -393,7 +393,7 @@ typedef enum{
 	tstrM2mScanDone
 	tstrM2mWifiscanResult
 */
-typedef void (*tpfAppWifiCb) (uint8 u8MsgType, void * pvMsg);
+typedef void (*tpfAppWifiCb) (winc1500_t *dev, uint8 u8MsgType, void * pvMsg);
 
 /*!
 @typedef \
@@ -424,7 +424,7 @@ typedef void (*tpfAppWifiCb) (uint8 u8MsgType, void * pvMsg);
 	m2m_wifi_init
 
 */
-typedef void (*tpfAppEthCb) (uint8 u8MsgType, void * pvMsg,void * pvCtrlBuf);
+typedef void (*tpfAppEthCb) (winc1500_t *dev, uint8 u8MsgType, void * pvMsg,void * pvCtrlBuf);
 
 /*!
 @typedef	\
@@ -453,7 +453,7 @@ typedef void (*tpfAppEthCb) (uint8 u8MsgType, void * pvMsg,void * pvCtrlBuf);
 	u16PayloadSize should not exceed the buffer size given through m2m_wifi_enable_monitoring_mode.
 	
 */
-typedef void (*tpfAppMonCb) (tstrM2MWifiRxPacketInfo *pstrWifiRxPacket, uint8 * pu8Payload, uint16 u16PayloadSize);
+typedef void (*tpfAppMonCb) (winc1500_t *dev, tstrM2MWifiRxPacketInfo *pstrWifiRxPacket, uint8 * pu8Payload, uint16 u16PayloadSize);
 
 /**
 @struct 	\
@@ -594,7 +594,7 @@ FUNCTION PROTOTYPES
 @return		
 	The function returns @ref M2M_SUCCESS for successful operations  and a negative value otherwise.
 */
-NMI_API sint8  m2m_wifi_download_mode(void);
+NMI_API sint8  m2m_wifi_download_mode(winc1500_t *dev);
 
  /**@}*/
  /** @defgroup WifiInitFn m2m_wifi_init
@@ -653,7 +653,7 @@ Following are the possible Wi-Fi events that are expected to be received through
 @return		
 	The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
 */
-NMI_API sint8  m2m_wifi_init(tstrWifiInitParam * pWifiInitParam);
+NMI_API sint8  m2m_wifi_init(winc1500_t *dev, tstrWifiInitParam * pWifiInitParam);
  /**@}*/
  /** @defgroup WifiDeinitFn m2m_wifi_deinit
  *  @ingroup WLANAPI
@@ -677,7 +677,7 @@ NMI_API sint8  m2m_wifi_init(tstrWifiInitParam * pWifiInitParam);
 @return		
 	The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
 */
-NMI_API sint8  m2m_wifi_deinit(void * arg);
+NMI_API sint8  m2m_wifi_deinit(winc1500_t *dev, void * arg);
 
  /**@}*/
 /** @defgroup WifiHandleEventsFn m2m_wifi_handle_events
@@ -707,7 +707,7 @@ NMI_API sint8  m2m_wifi_deinit(void * arg);
 	The function returns @ref M2M_SUCCESS for successful interrupt handling and a negative value otherwise.
 */
 
-NMI_API sint8 m2m_wifi_handle_events(void * arg);
+NMI_API sint8 m2m_wifi_handle_events(winc1500_t *dev, void * arg);
 
  /**@}*/
 /** @defgroup WifiSendCRLFn m2m_wifi_send_crl
@@ -731,7 +731,7 @@ NMI_API sint8 m2m_wifi_handle_events(void * arg);
 	and a negative value otherwise.
 */
 
-sint8 m2m_wifi_send_crl(tstrTlsCrlInfo* pCRL);
+sint8 m2m_wifi_send_crl(winc1500_t *dev, tstrTlsCrlInfo* pCRL);
 
  /**@}*/
 /** @defgroup WifiDefaultConnectFn m2m_wifi_default_connect
@@ -766,7 +766,7 @@ sint8 m2m_wifi_send_crl(tstrTlsCrlInfo* pCRL);
 	The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
 
 */
-NMI_API sint8 m2m_wifi_default_connect(void);
+NMI_API sint8 m2m_wifi_default_connect(winc1500_t *dev);
  /**@}*/
 /** @defgroup WifiConnectFn m2m_wifi_connect
  *   @ingroup WLANAPI
@@ -824,7 +824,7 @@ NMI_API sint8 m2m_wifi_default_connect(void);
 @return	The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
 	
 */
-NMI_API sint8 m2m_wifi_connect(char *pcSsid, uint8 u8SsidLen, uint8 u8SecType, void *pvAuthInfo, uint16 u16Ch);
+NMI_API sint8 m2m_wifi_connect(winc1500_t *dev, char *pcSsid, uint8 u8SsidLen, uint8 u8SecType, void *pvAuthInfo, uint16 u16Ch);
  /**@}*/
 /** @defgroup WifiConnectFn m2m_wifi_connect_sc
  *   @ingroup WLANAPI
@@ -886,7 +886,7 @@ NMI_API sint8 m2m_wifi_connect(char *pcSsid, uint8 u8SsidLen, uint8 u8SecType, v
 @return	The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
 	
 */
- NMI_API sint8 m2m_wifi_connect_sc(char *pcSsid, uint8 u8SsidLen, uint8 u8SecType, void *pvAuthInfo, uint16 u16Ch, uint8 u8SaveCred);
+ NMI_API sint8 m2m_wifi_connect_sc(winc1500_t *dev, char *pcSsid, uint8 u8SsidLen, uint8 u8SecType, void *pvAuthInfo, uint16 u16Ch, uint8 u8SaveCred);
  /**@}*/
 /** @defgroup WifiDisconnectFn m2m_wifi_disconnect
  *   @ingroup WLANAPI
@@ -913,7 +913,7 @@ NMI_API sint8 m2m_wifi_connect(char *pcSsid, uint8 u8SsidLen, uint8 u8SecType, v
 @return		
 	The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
 */
-NMI_API sint8 m2m_wifi_disconnect(void);
+NMI_API sint8 m2m_wifi_disconnect(winc1500_t *dev);
  
  /**@}*/
 /** @defgroup StartProvisionModeFn m2m_wifi_start_provision_mode
@@ -1034,7 +1034,7 @@ NMI_API sint8 m2m_wifi_disconnect(void);
 	
 @endcode
 */
-NMI_API sint8 m2m_wifi_start_provision_mode(tstrM2MAPConfig *pstrAPConfig, char *pcHttpServerDomainName, uint8 bEnableHttpRedirect);
+NMI_API sint8 m2m_wifi_start_provision_mode(winc1500_t *dev, tstrM2MAPConfig *pstrAPConfig, char *pcHttpServerDomainName, uint8 bEnableHttpRedirect);
  /**@}*/
 /** @defgroup StopProvisioningModeFn m2m_wifi_stop_provision_mode
  *   @ingroup WLANAPI
@@ -1053,7 +1053,7 @@ NMI_API sint8 m2m_wifi_start_provision_mode(tstrM2MAPConfig *pstrAPConfig, char
 @return
 	The function returns ZERO for success and a negative value otherwise.
 */
-NMI_API sint8 m2m_wifi_stop_provision_mode(void);
+NMI_API sint8 m2m_wifi_stop_provision_mode(winc1500_t *dev);
  /**@}*/
 /** @defgroup GetConnectionInfoFn m2m_wifi_get_connection_info
  *   @ingroup WLANAPI
@@ -1144,7 +1144,7 @@ NMI_API sint8 m2m_wifi_stop_provision_mode(void);
 	
 @endcode
 */
-NMI_API sint8 m2m_wifi_get_connection_info(void);
+NMI_API sint8 m2m_wifi_get_connection_info(winc1500_t *dev);
  /**@}*/
 /** @defgroup WifiSetMacAddFn m2m_wifi_set_mac_address
  *   @ingroup WLANAPI
@@ -1165,7 +1165,7 @@ NMI_API sint8 m2m_wifi_get_connection_info(void);
 @return		
 	The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
 */
-NMI_API sint8 m2m_wifi_set_mac_address(uint8 au8MacAddress[6]);
+NMI_API sint8 m2m_wifi_set_mac_address(winc1500_t *dev, uint8 au8MacAddress[6]);
  
  /**@}*/
 /** @defgroup WifiWpsFn m2m_wifi_wps
@@ -1262,7 +1262,7 @@ NMI_API sint8 m2m_wifi_set_mac_address(uint8 au8MacAddress[6]);
 	
 @endcode
 */
-NMI_API sint8 m2m_wifi_wps(uint8 u8TriggerType,const char  *pcPinNumber);
+NMI_API sint8 m2m_wifi_wps(winc1500_t *dev, uint8 u8TriggerType,const char  *pcPinNumber);
  /**@}*/
 /** @defgroup WifiWpsDisableFn m2m_wifi_wps_disable
  *   @ingroup WLANAPI
@@ -1283,7 +1283,7 @@ NMI_API sint8 m2m_wifi_wps(uint8 u8TriggerType,const char  *pcPinNumber);
 @return
 	The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
 */
-NMI_API sint8 m2m_wifi_wps_disable(void);
+NMI_API sint8 m2m_wifi_wps_disable(winc1500_t *dev);
  
  /**@}*/
 /** @defgroup WifiP2PFn m2m_wifi_p2p
@@ -1374,7 +1374,7 @@ NMI_API sint8 m2m_wifi_wps_disable(void);
 @endcode
 
 */
-NMI_API sint8 m2m_wifi_p2p(uint8 u8Channel);
+NMI_API sint8 m2m_wifi_p2p(winc1500_t *dev, uint8 u8Channel);
  /**@}*/
 /** @defgroup WifiP2PDisconnectFn m2m_wifi_p2p_disconnect
  *   @ingroup WLANAPI
@@ -1392,7 +1392,7 @@ NMI_API sint8 m2m_wifi_p2p(uint8 u8Channel);
 @return
 	The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
 */
-NMI_API sint8 m2m_wifi_p2p_disconnect(void);
+NMI_API sint8 m2m_wifi_p2p_disconnect(winc1500_t *dev);
  /**@}*/
 /** @defgroup WifiEnableApFn m2m_wifi_enable_ap
  *   @ingroup WLANAPI
@@ -1485,7 +1485,7 @@ NMI_API sint8 m2m_wifi_p2p_disconnect(void);
 @endcode
 
 */
-NMI_API sint8 m2m_wifi_enable_ap(WINC1500_CONST tstrM2MAPConfig* pstrM2MAPConfig);
+NMI_API sint8 m2m_wifi_enable_ap(winc1500_t *dev, WINC1500_CONST tstrM2MAPConfig* pstrM2MAPConfig);
  /**@}*/
 /** @defgroup WifiDisableApFn m2m_wifi_disable_ap
  *   @ingroup WLANAPI
@@ -1501,7 +1501,7 @@ NMI_API sint8 m2m_wifi_enable_ap(WINC1500_CONST tstrM2MAPConfig* pstrM2MAPConfig
 @return
 	The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
 */
-NMI_API sint8 m2m_wifi_disable_ap(void);
+NMI_API sint8 m2m_wifi_disable_ap(winc1500_t *dev);
  /**@}*/
 /** @defgroup SetStaticIPFn m2m_wifi_set_static_ip
  *   @ingroup WLANAPI
@@ -1533,7 +1533,7 @@ NMI_API sint8 m2m_wifi_disable_ap(void);
 @return
 	The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
 */
-NMI_API sint8 m2m_wifi_set_static_ip(tstrM2MIPConfig * pstrStaticIPConf);
+NMI_API sint8 m2m_wifi_set_static_ip(winc1500_t *dev, tstrM2MIPConfig * pstrStaticIPConf);
  
  /**@}*/
 /** @defgroup RequestDHCPClientFn m2m_wifi_request_dhcp_client
@@ -1552,7 +1552,7 @@ NMI_API sint8 m2m_wifi_set_static_ip(tstrM2MIPConfig * pstrStaticIPConf);
 @return
 	The function returns @ref M2M_SUCCESS always.
 */
-NMI_API sint8 m2m_wifi_request_dhcp_client(void);
+NMI_API sint8 m2m_wifi_request_dhcp_client(winc1500_t *dev);
  /**@}*/
 /** @defgroup RequestDHCPServerFn m2m_wifi_request_dhcp_server
  *   @ingroup WLANAPI
@@ -1570,7 +1570,7 @@ NMI_API sint8 m2m_wifi_request_dhcp_client(void);
 @return
 	The function returns @ref M2M_SUCCESS always.
 */
-NMI_API sint8 m2m_wifi_request_dhcp_server(uint8* addr);
+NMI_API sint8 m2m_wifi_request_dhcp_server(winc1500_t *dev, uint8* addr);
  /**@}*/
 /** @defgroup WifiDHCPEnableFn m2m_wifi_enable_dhcp
  *   @ingroup WLANAPI
@@ -1599,7 +1599,7 @@ NMI_API sint8 m2m_wifi_request_dhcp_server(uint8* addr);
 @return
 	The function SHALL return @ref M2M_SUCCESS  for successful operation and a negative value otherwise.
 */
-NMI_API sint8 m2m_wifi_enable_dhcp(uint8  u8DhcpEn );
+NMI_API sint8 m2m_wifi_enable_dhcp(winc1500_t *dev, uint8  u8DhcpEn );
  /**@}*/
 /** @defgroup WifiSetScanOptionFn m2m_wifi_set_scan_options
  *   @ingroup WLANAPI
@@ -1621,7 +1621,7 @@ NMI_API sint8 m2m_wifi_enable_dhcp(uint8  u8DhcpEn );
 @return
 	The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
 */
-NMI_API sint8 m2m_wifi_set_scan_options(tstrM2MScanOption* ptstrM2MScanOption);
+NMI_API sint8 m2m_wifi_set_scan_options(winc1500_t *dev, tstrM2MScanOption* ptstrM2MScanOption);
  /**@}*/
 /** @defgroup WifiSetScanRegionFn m2m_wifi_set_scan_region
  *   @ingroup WLANAPI
@@ -1644,7 +1644,7 @@ NMI_API sint8 m2m_wifi_set_scan_options(tstrM2MScanOption* ptstrM2MScanOption);
 	The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
 
 */
-NMI_API sint8 m2m_wifi_set_scan_region(uint16  ScanRegion);
+NMI_API sint8 m2m_wifi_set_scan_region(winc1500_t *dev, uint16  ScanRegion);
  /**@}*/
 /** @defgroup WifiRequestScanFn m2m_wifi_request_scan
 *   @ingroup WLANAPI
@@ -1770,7 +1770,7 @@ NMI_API sint8 m2m_wifi_set_scan_region(uint16  ScanRegion);
 	
 @endcode
 */
-NMI_API sint8 m2m_wifi_request_scan(uint8 ch);
+NMI_API sint8 m2m_wifi_request_scan(winc1500_t *dev, uint8 ch);
 
   /**@}*/
 /** @defgroup WifiRequestScanFn m2m_wifi_request_scan_passive
@@ -1815,7 +1815,7 @@ NMI_API sint8 m2m_wifi_request_scan(uint8 ch);
 	The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
 
 */
-NMI_API sint8 m2m_wifi_request_scan_passive(uint8 ch, uint16 scan_time);
+NMI_API sint8 m2m_wifi_request_scan_passive(winc1500_t *dev, uint8 ch, uint16 scan_time);
 
   
  /**@}*/
@@ -1976,7 +1976,7 @@ NMI_API sint8 m2m_wifi_request_scan_passive(uint8 ch, uint16 scan_time);
 	
 @endcode
 */
-NMI_API sint8 m2m_wifi_request_scan_ssid_list(uint8 ch,uint8 * u8Ssidlist);
+NMI_API sint8 m2m_wifi_request_scan_ssid_list(winc1500_t *dev, uint8 ch,uint8 * u8Ssidlist);
 
 /**@}*/
 /** @defgroup WifiGetNumAPFoundFn m2m_wifi_get_num_ap_found
@@ -2085,7 +2085,7 @@ NMI_API sint8 m2m_wifi_request_scan_ssid_list(uint8 ch,uint8 * u8Ssidlist);
 	
 @endcode			 
 */
-NMI_API uint8 m2m_wifi_get_num_ap_found(void);
+NMI_API uint8 m2m_wifi_get_num_ap_found(winc1500_t *dev);
 /**@}*/
 /** @defgroup WifiReqScanResult m2m_wifi_req_scan_result
 *   @ingroup WLANAPI
@@ -2199,7 +2199,7 @@ NMI_API uint8 m2m_wifi_get_num_ap_found(void);
 	
 @endcode 
 */
-NMI_API sint8 m2m_wifi_req_scan_result(uint8 index);
+NMI_API sint8 m2m_wifi_req_scan_result(winc1500_t *dev, uint8 index);
 /**@}*/
 /** @defgroup WifiReqCurrentRssiFn m2m_wifi_req_curr_rssi
  *   @ingroup WLANAPI
@@ -2257,7 +2257,7 @@ NMI_API sint8 m2m_wifi_req_scan_result(uint8 index);
 @endcode	
 
 */
-NMI_API sint8 m2m_wifi_req_curr_rssi(void);
+NMI_API sint8 m2m_wifi_req_curr_rssi(winc1500_t *dev);
 /**@}*/
 /** @defgroup WifiGetOtpMacAddFn m2m_wifi_get_otp_mac_address
 *   @ingroup WLANAPI
@@ -2279,7 +2279,7 @@ NMI_API sint8 m2m_wifi_req_curr_rssi(void);
 @return      The function returns @ref M2M_SUCCESS for success and a negative value otherwise.
 
 */
-NMI_API sint8 m2m_wifi_get_otp_mac_address(uint8 *pu8MacAddr, uint8 * pu8IsValid);
+NMI_API sint8 m2m_wifi_get_otp_mac_address(winc1500_t *dev, uint8 *pu8MacAddr, uint8 * pu8IsValid);
 /**@}*/
 /** @defgroup WifiGetMacAddFn m2m_wifi_get_mac_address
 *   @ingroup WLANAPI
@@ -2295,7 +2295,7 @@ NMI_API sint8 m2m_wifi_get_otp_mac_address(uint8 *pu8MacAddr, uint8 * pu8IsValid
 @return      The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
 
 */
-NMI_API sint8 m2m_wifi_get_mac_address(uint8 *pu8MacAddr);
+NMI_API sint8 m2m_wifi_get_mac_address(winc1500_t *dev, uint8 *pu8MacAddr);
 /**@}*/
 /** @defgroup SetSleepModeFn m2m_wifi_set_sleep_mode
  *   @ingroup WLANAPI
@@ -2324,7 +2324,7 @@ NMI_API sint8 m2m_wifi_get_mac_address(uint8 *pu8MacAddr);
 
 @return    The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
 */
-NMI_API sint8 m2m_wifi_set_sleep_mode(uint8 PsTyp, uint8 BcastEn);
+NMI_API sint8 m2m_wifi_set_sleep_mode(winc1500_t *dev, uint8 PsTyp, uint8 BcastEn);
 /**@}*/
 /** @defgroup WifiRequestSleepFn m2m_wifi_request_sleep
  *   @ingroup WLANAPI
@@ -2349,7 +2349,7 @@ NMI_API sint8 m2m_wifi_set_sleep_mode(uint8 PsTyp, uint8 BcastEn);
 
 @return    	The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
 */
-NMI_API sint8 m2m_wifi_request_sleep(uint32 u32SlpReqTime);
+NMI_API sint8 m2m_wifi_request_sleep(winc1500_t *dev, uint32 u32SlpReqTime);
 /**@}*/
 /** @defgroup GetSleepModeFn m2m_wifi_get_sleep_mode
  *   @ingroup WLANAPI
@@ -2362,7 +2362,7 @@ NMI_API sint8 m2m_wifi_request_sleep(uint32 u32SlpReqTime);
 		    m2m_wifi_set_sleep_mode
 @return	    The current operating power saving mode based on the enumerated sleep modes @ref tenuPowerSaveModes.
 */
-NMI_API uint8 m2m_wifi_get_sleep_mode(void);
+NMI_API uint8 m2m_wifi_get_sleep_mode(winc1500_t *dev);
 /**@}*/
 /** @defgroup WifiReqClientCtrlFn m2m_wifi_req_client_ctrl
  *   @ingroup WLANAPI
@@ -2381,7 +2381,7 @@ NMI_API uint8 m2m_wifi_get_sleep_mode(void);
 			M2M_WIFI_RESP_CLIENT_INFO
 @return		The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
 */
-NMI_API sint8 m2m_wifi_req_client_ctrl(uint8 cmd);
+NMI_API sint8 m2m_wifi_req_client_ctrl(winc1500_t *dev, uint8 cmd);
 /**@}*/
 /** @defgroup WifiReqServerInit m2m_wifi_req_server_init
  *   @ingroup WLANAPI
@@ -2399,7 +2399,7 @@ NMI_API sint8 m2m_wifi_req_client_ctrl(uint8 cmd);
 @warning	       This mode is not supported in the current release.
 @return		The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
 */
-NMI_API sint8 m2m_wifi_req_server_init(uint8 ch);
+NMI_API sint8 m2m_wifi_req_server_init(winc1500_t *dev, uint8 ch);
 /**@}*/
 /** @defgroup WifiSetDeviceNameFn m2m_wifi_set_device_name
  *   @ingroup WLANAPI
@@ -2420,7 +2420,7 @@ NMI_API sint8 m2m_wifi_req_server_init(uint8 ch);
 @warning    Device name shall contain only characters allowed in valid internet host name as defined in RFC 952 and 1123.
 @return		The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
 */
-NMI_API sint8 m2m_wifi_set_device_name(uint8 *pu8DeviceName, uint8 u8DeviceNameLength);
+NMI_API sint8 m2m_wifi_set_device_name(winc1500_t *dev, uint8 *pu8DeviceName, uint8 u8DeviceNameLength);
 /**@}*/
 /** @defgroup WifiSetLsnIntFn m2m_wifi_set_lsn_int
  *   @ingroup WLANAPI
@@ -2442,7 +2442,7 @@ NMI_API sint8 m2m_wifi_set_device_name(uint8 *pu8DeviceName, uint8 u8DeviceNameL
 @return		The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
 
 */
-NMI_API sint8 m2m_wifi_set_lsn_int(tstrM2mLsnInt *pstrM2mLsnInt);
+NMI_API sint8 m2m_wifi_set_lsn_int(winc1500_t *dev, tstrM2mLsnInt *pstrM2mLsnInt);
 /**@}*/
 /** @defgroup WifiEnableMonitorModeFn m2m_wifi_enable_monitoring_mode
  *   @ingroup WLANAPI
@@ -2536,7 +2536,7 @@ NMI_API sint8 m2m_wifi_set_lsn_int(tstrM2mLsnInt *pstrM2mLsnInt);
 			}
  * @endcode
  */
-NMI_API sint8 m2m_wifi_enable_monitoring_mode(tstrM2MWifiMonitorModeCtrl *pstrMtrCtrl, uint8 *pu8PayloadBuffer, 
+NMI_API sint8 m2m_wifi_enable_monitoring_mode(winc1500_t *dev, tstrM2MWifiMonitorModeCtrl *pstrMtrCtrl, uint8 *pu8PayloadBuffer,
 										   uint16 u16BufferSize, uint16 u16DataOffset);
 /**@}*/
 /** @defgroup WifiDisableMonitorModeFn m2m_wifi_disable_monitoring_mode
@@ -2550,7 +2550,7 @@ NMI_API sint8 m2m_wifi_enable_monitoring_mode(tstrM2MWifiMonitorModeCtrl *pstrMt
  * @see           m2m_wifi_enable_monitoring_mode               
  * @return      The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
  */
-NMI_API sint8 m2m_wifi_disable_monitoring_mode(void);
+NMI_API sint8 m2m_wifi_disable_monitoring_mode(winc1500_t *dev);
  /**@}*/
  /** @defgroup SendWlanPktFn m2m_wifi_send_wlan_pkt
  *   @ingroup WLANAPI
@@ -2573,7 +2573,7 @@ NMI_API sint8 m2m_wifi_disable_monitoring_mode(void);
  * @note             Packets are user's responsibility.
  * @return     	    The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
  */
-NMI_API sint8 m2m_wifi_send_wlan_pkt(uint8 *pu8WlanPacket, uint16 u16WlanHeaderLength, uint16 u16WlanPktSize);
+NMI_API sint8 m2m_wifi_send_wlan_pkt(winc1500_t *dev, uint8 *pu8WlanPacket, uint16 u16WlanHeaderLength, uint16 u16WlanPktSize);
 /**@}*/
 /** @defgroup WifiSendEthernetPktFn m2m_wifi_send_ethernet_pkt
  *   @ingroup WLANAPI
@@ -2593,7 +2593,7 @@ NMI_API sint8 m2m_wifi_send_wlan_pkt(uint8 *pu8WlanPacket, uint16 u16WlanHeaderL
  * @return         The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
 
  */
-NMI_API sint8 m2m_wifi_send_ethernet_pkt(uint8* pu8Packet,uint16 u16PacketSize);
+NMI_API sint8 m2m_wifi_send_ethernet_pkt(winc1500_t *dev, uint8* pu8Packet,uint16 u16PacketSize);
 /**@}*/
 /** @defgroup WifiEnableSntpFn m2m_wifi_enable_sntp
  *   @ingroup WLANAPI
@@ -2616,7 +2616,7 @@ NMI_API sint8 m2m_wifi_send_ethernet_pkt(uint8* pu8Packet,uint16 u16PacketSize);
  * @see             m2m_wifi_set_sytem_time       
  * @return        The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
  */
-NMI_API sint8 m2m_wifi_enable_sntp(uint8 bEnable);
+NMI_API sint8 m2m_wifi_enable_sntp(winc1500_t *dev, uint8 bEnable);
 /**@}*/
 /** @defgroup WifiSetSystemTime m2m_wifi_set_sytem_time
  *   @ingroup WLANAPI
@@ -2634,7 +2634,7 @@ NMI_API sint8 m2m_wifi_enable_sntp(uint8 bEnable);
  *		         using the API @ref m2m_wifi_set_sytem_time.
  * @return        The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
  */
-NMI_API sint8 m2m_wifi_set_sytem_time(uint32 u32UTCSeconds);
+NMI_API sint8 m2m_wifi_set_sytem_time(winc1500_t *dev, uint32 u32UTCSeconds);
 /**@}*/
 /** @defgroup WifiGetSystemTime m2m_wifi_get_sytem_time
  *   @ingroup WLANAPI
@@ -2650,7 +2650,7 @@ NMI_API sint8 m2m_wifi_set_sytem_time(uint32 u32UTCSeconds);
  *		        using the API @ref m2m_wifi_get_sytem_time.
  * @return        The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
  */
-NMI_API sint8 m2m_wifi_get_sytem_time(void);
+NMI_API sint8 m2m_wifi_get_sytem_time(winc1500_t *dev);
 /**@}*/
 /** @defgroup WifiSetCustInfoElementFn m2m_wifi_set_cust_InfoElement
  *   @ingroup WLANAPI
@@ -2710,7 +2710,7 @@ NMI_API sint8 m2m_wifi_get_sytem_time(void);
             m2m_wifi_set_cust_InfoElement(elementData);	
  * @endcode
  */
-NMI_API sint8 m2m_wifi_set_cust_InfoElement(uint8* pau8M2mCustInfoElement);
+NMI_API sint8 m2m_wifi_set_cust_InfoElement(winc1500_t *dev, uint8* pau8M2mCustInfoElement);
  /**@}*/
 /** @defgroup WifiSetPowerProfile m2m_wifi_set_power_profile
  *   @ingroup WLANAPI
@@ -2728,7 +2728,7 @@ NMI_API sint8 m2m_wifi_set_cust_InfoElement(uint8* pau8M2mCustInfoElement);
 			m2m_wifi_init
 @return		The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.    
 */
-sint8 m2m_wifi_set_power_profile(uint8 u8PwrMode);
+sint8 m2m_wifi_set_power_profile(winc1500_t *dev, uint8 u8PwrMode);
   /**@}*/
   /** @defgroup WifiSetTxPower m2m_wifi_set_tx_power
  *   @ingroup WLANAPI
@@ -2744,7 +2744,7 @@ sint8 m2m_wifi_set_power_profile(uint8 u8PwrMode);
 			m2m_wifi_init
 @return		The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.    
 */
-sint8 m2m_wifi_set_tx_power(uint8 u8TxPwrLevel);
+sint8 m2m_wifi_set_tx_power(winc1500_t *dev, uint8 u8TxPwrLevel);
  /**@}*/
 /** @defgroup WifiEnableFirmware m2m_wifi_enable_firmware_logs
 *   @ingroup WLANAPI
@@ -2761,7 +2761,7 @@ sint8 m2m_wifi_set_tx_power(uint8 u8TxPwrLevel);
 			m2m_wifi_init
 @return		The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.     
 */
-sint8 m2m_wifi_enable_firmware_logs(uint8 u8Enable);
+sint8 m2m_wifi_enable_firmware_logs(winc1500_t *dev, uint8 u8Enable);
   /**@}*/
  /** @defgroup WifiSetBatteryVoltage m2m_wifi_set_battery_voltage
 *   @ingroup WLANAPI
@@ -2777,7 +2777,7 @@ sint8 m2m_wifi_enable_firmware_logs(uint8 u8Enable);
 @sa       		m2m_wifi_init
 @return		The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
 */
-sint8 m2m_wifi_set_battery_voltage(uint16 u16BattVoltx100);
+sint8 m2m_wifi_set_battery_voltage(winc1500_t *dev, uint16 u16BattVoltx100);
   /**@}*/
  /** @defgroup WifiSetGains m2m_wifi_set_gains
 *   @ingroup WLANAPI
@@ -2793,7 +2793,7 @@ sint8 m2m_wifi_set_battery_voltage(uint16 u16BattVoltx100);
 @sa       		m2m_wifi_init
 @return		The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
 */
-sint8 m2m_wifi_set_gains(tstrM2mWifiGainsParams* pstrM2mGain);
+sint8 m2m_wifi_set_gains(winc1500_t *dev, tstrM2mWifiGainsParams* pstrM2mGain);
  /**@}*/
 /** @defgroup WifiGetFirmwareVersion m2m_wifi_get_firmware_version
 *   @ingroup WLANAPI
@@ -2808,7 +2808,7 @@ sint8 m2m_wifi_set_gains(tstrM2mWifiGainsParams* pstrM2mGain);
 @sa       		m2m_wifi_init
 @return		The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
 */
-sint8 m2m_wifi_get_firmware_version(tstrM2mRev *pstrRev);
+sint8 m2m_wifi_get_firmware_version(winc1500_t *dev, tstrM2mRev *pstrRev);
 /**@}*/
 #ifdef ETH_MODE
 /** @defgroup WifiEnableMacMcastFn m2m_wifi_enable_mac_mcast
@@ -2831,7 +2831,7 @@ sint8 m2m_wifi_get_firmware_version(tstrM2mRev *pstrRev);
  * @sa		m2m_wifi_set_receive_buffer, m2m_wifi_send_ethernet_pkt
  * @return       The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
  */
-NMI_API sint8 m2m_wifi_enable_mac_mcast(uint8* pu8MulticastMacAddress, uint8 u8AddRemove);
+NMI_API sint8 m2m_wifi_enable_mac_mcast(winc1500_t *dev, uint8* pu8MulticastMacAddress, uint8 u8AddRemove);
 /**@}*/
 /** @defgroup SetReceiveBufferFn m2m_wifi_set_receive_buffer
  *   @ingroup WLANAPI
@@ -2854,7 +2854,7 @@ NMI_API sint8 m2m_wifi_enable_mac_mcast(uint8* pu8MulticastMacAddress, uint8 u8A
  * @sa		m2m_wifi_enable_mac_mcast,m2m_wifi_send_ethernet_pkt	
  * @return       The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
  */
-NMI_API sint8 m2m_wifi_set_receive_buffer(void* pvBuffer,uint16 u16BufferLen);
+NMI_API sint8 m2m_wifi_set_receive_buffer(winc1500_t *dev, void* pvBuffer,uint16 u16BufferLen);
 /**@}*/
 #endif /* ETH_MODE */
 /** @defgroup GetPrngBytes m2m_wifi_prng_get_random_bytes
@@ -2873,7 +2873,7 @@ NMI_API sint8 m2m_wifi_set_receive_buffer(void* pvBuffer,uint16 u16BufferLen);
  *@see  			tstrPrng	
  * @return       	The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
  */
-sint8 m2m_wifi_prng_get_random_bytes(uint8 * pu8PrngBuff,uint16 u16PrngSize);
+sint8 m2m_wifi_prng_get_random_bytes(winc1500_t *dev, uint8 * pu8PrngBuff,uint16 u16PrngSize);
 /**@}*/
 #ifdef __cplusplus
 }
diff --git a/winc1500/driver/source/m2m_crypto.c b/winc1500/driver/source/m2m_crypto.c
index 9ac7711..bc756cf 100644
--- a/winc1500/driver/source/m2m_crypto.c
+++ b/winc1500/driver/source/m2m_crypto.c
@@ -201,7 +201,7 @@ typedef struct{
 *           SHA256 IMPLEMENTATION           *
 *======*======*======*======*======*========*/
 
-sint8 m2m_crypto_sha256_hash_init(tstrM2mSha256Ctxt *pstrSha256Ctxt)
+sint8 m2m_crypto_sha256_hash_init(winc1500_t *dev, tstrM2mSha256Ctxt *pstrSha256Ctxt)
 {
 	tstrSHA256HashCtxt	*pstrSHA256 = (tstrSHA256HashCtxt*)pstrSha256Ctxt;
 	if(pstrSHA256 != NULL)
@@ -212,7 +212,7 @@ sint8 m2m_crypto_sha256_hash_init(tstrM2mSha256Ctxt *pstrSha256Ctxt)
 	return 0;
 }
 
-sint8 m2m_crypto_sha256_hash_update(tstrM2mSha256Ctxt *pstrSha256Ctxt, uint8 *pu8Data, uint16 u16DataLength)
+sint8 m2m_crypto_sha256_hash_update(winc1500_t *dev, tstrM2mSha256Ctxt *pstrSha256Ctxt, uint8 *pu8Data, uint16 u16DataLength)
 {
 	sint8	s8Ret = M2M_ERR_FAIL;
 	tstrSHA256HashCtxt	*pstrSHA256 = (tstrSHA256HashCtxt*)pstrSha256Ctxt;
@@ -242,7 +242,7 @@ sint8 m2m_crypto_sha256_hash_update(tstrM2mSha256Ctxt *pstrSha256Ctxt, uint8 *pu
 				pu8Data			+= u32Offset;
 				u16DataLength	-= u32Offset;
 
-				nm_write_block(u32Addr, pstrSHA256->au8CurrentBlock, SHA_BLOCK_SIZE);
+				nm_write_block(dev, u32Addr, pstrSHA256->au8CurrentBlock, SHA_BLOCK_SIZE);
 				u32Addr += SHA_BLOCK_SIZE;
 				u32CurrentBlock	 = 1;
 			}
@@ -259,7 +259,7 @@ sint8 m2m_crypto_sha256_hash_update(tstrM2mSha256Ctxt *pstrSha256Ctxt, uint8 *pu
 
 		if(u32NBlocks != 0)
 		{
-			nm_write_block(u32Addr, pu8Data, (uint16)(u32NBlocks * SHA_BLOCK_SIZE));
+			nm_write_block(dev, u32Addr, pu8Data, (uint16)(u32NBlocks * SHA_BLOCK_SIZE));
 			pu8Data += (u32NBlocks * SHA_BLOCK_SIZE);
 		}
 
@@ -268,9 +268,9 @@ sint8 m2m_crypto_sha256_hash_update(tstrM2mSha256Ctxt *pstrSha256Ctxt, uint8 *pu
 		{
 			uint32	u32RegVal = 0;
 
-			nm_write_reg(SHA256_CTRL, u32RegVal);
+			nm_write_reg(dev, SHA256_CTRL, u32RegVal);
 			u32RegVal |= SHA256_CTRL_FORCE_SHA256_QUIT_MASK;
-			nm_write_reg(SHA256_CTRL, u32RegVal);
+			nm_write_reg(dev, SHA256_CTRL, u32RegVal);
 
 			if(pstrSHA256->u8InitHashFlag)
 			{
@@ -279,21 +279,21 @@ sint8 m2m_crypto_sha256_hash_update(tstrM2mSha256Ctxt *pstrSha256Ctxt, uint8 *pu
 			}
 
 			u32ReadAddr = u32WriteAddr + (u32NBlocks * SHA_BLOCK_SIZE);
-			nm_write_reg(SHA256_DATA_LENGTH, (u32NBlocks * SHA_BLOCK_SIZE));
-			nm_write_reg(SHA256_START_RD_ADDR, u32WriteAddr);
-			nm_write_reg(SHA256_START_WR_ADDR, u32ReadAddr);
+			nm_write_reg(dev, SHA256_DATA_LENGTH, (u32NBlocks * SHA_BLOCK_SIZE));
+			nm_write_reg(dev, SHA256_START_RD_ADDR, u32WriteAddr);
+			nm_write_reg(dev, SHA256_START_WR_ADDR, u32ReadAddr);
 
 			u32RegVal |= SHA256_CTRL_START_CALC_MASK;
 
 			u32RegVal &= ~(0x7 << 8);
 			u32RegVal |= (2 << 8);
 
-			nm_write_reg(SHA256_CTRL, u32RegVal);
+			nm_write_reg(dev, SHA256_CTRL, u32RegVal);
 
 			/* 5.	Wait for done_intr */
 			while(!u8IsDone)
 			{
-				u32RegVal = nm_read_reg(SHA256_DONE_INTR_STS);
+				u32RegVal = nm_read_reg(dev, SHA256_DONE_INTR_STS);
 				u8IsDone = u32RegVal & NBIT0;
 			}
 		}
@@ -307,7 +307,7 @@ sint8 m2m_crypto_sha256_hash_update(tstrM2mSha256Ctxt *pstrSha256Ctxt, uint8 *pu
 }
 
 
-sint8 m2m_crypto_sha256_hash_finish(tstrM2mSha256Ctxt *pstrSha256Ctxt, uint8 *pu8Sha256Digest)
+sint8 m2m_crypto_sha256_hash_finish(winc1500_t *dev, tstrM2mSha256Ctxt *pstrSha256Ctxt, uint8 *pu8Sha256Digest)
 {
 	sint8	s8Ret = M2M_ERR_FAIL;
 	tstrSHA256HashCtxt	*pstrSHA256 = (tstrSHA256HashCtxt*)pstrSha256Ctxt;
@@ -324,9 +324,9 @@ sint8 m2m_crypto_sha256_hash_finish(tstrM2mSha256Ctxt *pstrSha256Ctxt, uint8 *pu
 		uint32	au32Digest[M2M_SHA256_DIGEST_LEN / 4];
 		uint8	u8IsDone		= 0;
 
-		nm_write_reg(SHA256_CTRL,u32RegVal);
+		nm_write_reg(dev, SHA256_CTRL,u32RegVal);
 		u32RegVal |= SHA256_CTRL_FORCE_SHA256_QUIT_MASK;
-		nm_write_reg(SHA256_CTRL,u32RegVal);
+		nm_write_reg(dev, SHA256_CTRL,u32RegVal);
 
 		if(pstrSHA256->u8InitHashFlag)
 		{
@@ -351,7 +351,7 @@ sint8 m2m_crypto_sha256_hash_finish(tstrM2mSha256Ctxt *pstrSha256Ctxt, uint8 *pu
 		*/
 		if(u16PaddingLength < 8)
 		{
-			nm_write_block(u32Addr, pstrSHA256->au8CurrentBlock, SHA_BLOCK_SIZE);
+			nm_write_block(dev, u32Addr, pstrSHA256->au8CurrentBlock, SHA_BLOCK_SIZE);
 			u32Addr += SHA_BLOCK_SIZE;
 			m2m_memset(pstrSHA256->au8CurrentBlock, 0, SHA_BLOCK_SIZE);
 			u16NBlocks ++;
@@ -361,26 +361,26 @@ sint8 m2m_crypto_sha256_hash_finish(tstrM2mSha256Ctxt *pstrSha256Ctxt, uint8 *pu
 		PUTU32(pstrSHA256->u32TotalLength << 3, pstrSHA256->au8CurrentBlock, (SHA_BLOCK_SIZE - 4));
 
 		u32ReadAddr = u32WriteAddr + (u16NBlocks * SHA_BLOCK_SIZE);
-		nm_write_block(u32Addr, pstrSHA256->au8CurrentBlock, SHA_BLOCK_SIZE);
-		nm_write_reg(SHA256_DATA_LENGTH, (u16NBlocks * SHA_BLOCK_SIZE));
-		nm_write_reg(SHA256_START_RD_ADDR, u32WriteAddr);
-		nm_write_reg(SHA256_START_WR_ADDR, u32ReadAddr);
+		nm_write_block(dev, u32Addr, pstrSHA256->au8CurrentBlock, SHA_BLOCK_SIZE);
+		nm_write_reg(dev, SHA256_DATA_LENGTH, (u16NBlocks * SHA_BLOCK_SIZE));
+		nm_write_reg(dev, SHA256_START_RD_ADDR, u32WriteAddr);
+		nm_write_reg(dev, SHA256_START_WR_ADDR, u32ReadAddr);
 
 		u32RegVal |= SHA256_CTRL_START_CALC_MASK;
 		u32RegVal |= SHA256_CTRL_WR_BACK_HASH_VALUE_MASK;
 		u32RegVal &= ~(0x7UL << 8);
 		u32RegVal |= (0x2UL << 8);
 
-		nm_write_reg(SHA256_CTRL,u32RegVal);
+		nm_write_reg(dev, SHA256_CTRL,u32RegVal);
 
 
 		/* 5.	Wait for done_intr */
 		while(!u8IsDone)
 		{
-			u32RegVal = nm_read_reg(SHA256_DONE_INTR_STS);
+			u32RegVal = nm_read_reg(dev, SHA256_DONE_INTR_STS);
 			u8IsDone = u32RegVal & NBIT0;
 		}
-		nm_read_block(u32ReadAddr, (uint8*)au32Digest, 32);
+		nm_read_block(dev, u32ReadAddr, (uint8*)au32Digest, 32);
 		
 		/* Convert the output words to an array of bytes.
 		*/
@@ -402,7 +402,7 @@ sint8 m2m_crypto_sha256_hash_finish(tstrM2mSha256Ctxt *pstrSha256Ctxt, uint8 *pu
 *             RSA IMPLEMENTATION            *
 *======*======*======*======*======*========*/
 
-static void FlipBuffer(uint8 *pu8InBuffer, uint8 *pu8OutBuffer, uint16 u16BufferSize)
+static void FlipBuffer(winc1500_t *dev, uint8 *pu8InBuffer, uint8 *pu8OutBuffer, uint16 u16BufferSize)
 {
 	uint16	u16Idx;
 	for(u16Idx = 0; u16Idx < u16BufferSize; u16Idx ++)
@@ -416,7 +416,8 @@ static void FlipBuffer(uint8 *pu8InBuffer, uint8 *pu8OutBuffer, uint16 u16Buffer
 }
 
 void BigInt_ModExp
-(	
+(
+ winc1500_t *dev,
  uint8	*pu8X,	uint16	u16XSize,
  uint8	*pu8E,	uint16	u16ESize,
  uint8	*pu8M,	uint16	u16MSize,
@@ -445,22 +446,22 @@ void BigInt_ModExp
 	*/
 	u32Reg	= 0;
 	u32Reg	|= BIGINT_MISC_CTRL_CTL_RESET;
-	u32Reg	= nm_read_reg(BIGINT_MISC_CTRL);
+	u32Reg	= nm_read_reg(dev, BIGINT_MISC_CTRL);
 	u32Reg	&= ~BIGINT_MISC_CTRL_CTL_RESET;
-	u32Reg = nm_read_reg(BIGINT_MISC_CTRL);
+	u32Reg = nm_read_reg(dev, BIGINT_MISC_CTRL);
 
-	nm_write_block(u32RAddr,au8Tmp, u16RSize);
+	nm_write_block(dev, u32RAddr,au8Tmp, u16RSize);
 
 	/* Write Input Operands to Chip Memory. 
 	*/
 	/*------- X -------*/
-	FlipBuffer(pu8X,au8Tmp,u16XSize);
-	nm_write_block(u32XAddr,au8Tmp,u16XSizeWords * 4);
+	FlipBuffer(dev, pu8X,au8Tmp,u16XSize);
+	nm_write_block(dev, u32XAddr,au8Tmp,u16XSizeWords * 4);
 
 	/*------- E -------*/
 	m2m_memset(au8Tmp, 0, sizeof(au8Tmp));
-	FlipBuffer(pu8E, au8Tmp, u16ESize);
-	nm_write_block(u32EAddr, au8Tmp, u16ESizeWords * 4);
+	FlipBuffer(dev, pu8E, au8Tmp, u16ESize);
+	nm_write_block(dev, u32EAddr, au8Tmp, u16ESizeWords * 4);
 	u32Exponent = GET_UINT32(au8Tmp, (u16ESizeWords * 4) - 4);
 	while((u32Exponent & NBIT31)== 0)
 	{
@@ -470,51 +471,51 @@ void BigInt_ModExp
 
 	/*------- M -------*/
 	m2m_memset(au8Tmp, 0, sizeof(au8Tmp));
-	FlipBuffer(pu8M, au8Tmp, u16XSize);
-	nm_write_block(u32MAddr, au8Tmp, u16XSizeWords * 4);
+	FlipBuffer(dev, pu8M, au8Tmp, u16XSize);
+	nm_write_block(dev, u32MAddr, au8Tmp, u16XSizeWords * 4);
 
 	/* Program the addresses of the input operands. 
 	*/
-	nm_write_reg(BIGINT_ADDR_X, u32XAddr);
-	nm_write_reg(BIGINT_ADDR_E, u32EAddr);
-	nm_write_reg(BIGINT_ADDR_M, u32MAddr);
-	nm_write_reg(BIGINT_ADDR_R, u32RAddr);
+	nm_write_reg(dev, BIGINT_ADDR_X, u32XAddr);
+	nm_write_reg(dev, BIGINT_ADDR_E, u32EAddr);
+	nm_write_reg(dev, BIGINT_ADDR_M, u32MAddr);
+	nm_write_reg(dev, BIGINT_ADDR_R, u32RAddr);
 
 	/* Mprime. 
 	*/
-	nm_write_reg(BIGINT_M_PRIME,u32Mprime);
+	nm_write_reg(dev, BIGINT_M_PRIME,u32Mprime);
 
 	/* Length. 
 	*/
 	u32Reg	= (u16XSizeWords & 0xFF);
 	u32Reg += ((u16ESizeWords & 0xFF) << 8);
 	u32Reg += (u8EMswBits << 16);
-	nm_write_reg(BIGINT_LENGTH,u32Reg);
+	nm_write_reg(dev, BIGINT_LENGTH,u32Reg);
 
 	/* CTRL Register. 
 	*/
-	u32Reg = nm_read_reg(BIGINT_MISC_CTRL);
+	u32Reg = nm_read_reg(dev, BIGINT_MISC_CTRL);
 	u32Reg ^= BIGINT_MISC_CTRL_CTL_START;
 	u32Reg |= BIGINT_MISC_CTRL_CTL_FORCE_BARRETT;
 	//u32Reg |= BIGINT_MISC_CTRL_CTL_M_PRIME_VALID;
 #if ENABLE_FLIPPING == 0
 	u32Reg |= BIGINT_MISC_CTRL_CTL_MSW_FIRST;
 #endif
-	nm_write_reg(BIGINT_MISC_CTRL,u32Reg);
+	nm_write_reg(dev, BIGINT_MISC_CTRL,u32Reg);
 
 	/* Wait for computation to complete. */
 	while(1)
 	{
-		u32Reg = nm_read_reg(BIGINT_IRQ_STS);
+		u32Reg = nm_read_reg(dev, BIGINT_IRQ_STS);
 		if(u32Reg & BIGINT_IRQ_STS_DONE)
 		{
 			break;
 		}
 	}
-	nm_write_reg(BIGINT_IRQ_STS,0);
+	nm_write_reg(dev, BIGINT_IRQ_STS,0);
 	m2m_memset(au8Tmp, 0, sizeof(au8Tmp));
-	nm_read_block(u32RAddr, au8Tmp, u16RSize);
-	FlipBuffer(au8Tmp, pu8R, u16RSize);
+	nm_read_block(dev, u32RAddr, au8Tmp, u16RSize);
+	FlipBuffer(dev, au8Tmp, pu8R, u16RSize);
 }
 
 
@@ -551,7 +552,7 @@ static const uint8 au8TEncodingSHA2[] =
 */
 
 
-sint8 m2m_crypto_rsa_sign_verify(uint8 *pu8N, uint16 u16NSize, uint8 *pu8E, uint16 u16ESize, uint8 *pu8SignedMsgHash, 
+sint8 m2m_crypto_rsa_sign_verify(winc1500_t *dev, uint8 *pu8N, uint16 u16NSize, uint8 *pu8E, uint16 u16ESize, uint8 *pu8SignedMsgHash,
 						  uint16 u16HashLength, uint8 *pu8RsaSignature)
 {
 	sint8		s8Ret = M2M_RSA_SIGN_FAIL;
@@ -590,7 +591,7 @@ sint8 m2m_crypto_rsa_sign_verify(uint8 *pu8N, uint16 u16NSize, uint8 *pu8E, uint
 			/*
 			RSA verification
 			*/
-			BigInt_ModExp(pu8RsaSignature, u16NSize, pu8E, u16ESize, pu8N, u16NSize, au8EM, u16NSize);
+			BigInt_ModExp(dev, pu8RsaSignature, u16NSize, pu8E, u16ESize, pu8N, u16NSize, au8EM, u16NSize);
 
 			u32PSLength = u16NSize - u16TLength - 3;
 
@@ -624,7 +625,7 @@ sint8 m2m_crypto_rsa_sign_verify(uint8 *pu8N, uint16 u16NSize, uint8 *pu8E, uint
 }
 
 
-sint8 m2m_crypto_rsa_sign_gen(uint8 *pu8N, uint16 u16NSize, uint8 *pu8d, uint16 u16dSize, uint8 *pu8SignedMsgHash, 
+sint8 m2m_crypto_rsa_sign_gen(winc1500_t *dev, uint8 *pu8N, uint16 u16NSize, uint8 *pu8d, uint16 u16dSize, uint8 *pu8SignedMsgHash,
 					   uint16 u16HashLength, uint8 *pu8RsaSignature)
 {
 	sint8		s8Ret = M2M_RSA_SIGN_FAIL;
@@ -683,7 +684,7 @@ sint8 m2m_crypto_rsa_sign_gen(uint8 *pu8N, uint16 u16NSize, uint8 *pu8d, uint16
 			/*
 			RSA Signature Generation
 			*/
-			BigInt_ModExp(au8EM, u16NSize, pu8d, u16dSize, pu8N, u16NSize, pu8RsaSignature, u16NSize);
+			BigInt_ModExp(dev, au8EM, u16NSize, pu8d, u16dSize, pu8N, u16NSize, pu8RsaSignature, u16NSize);
 			s8Ret = M2M_RSA_SIGN_OK;
 		}
 	}
@@ -694,12 +695,6 @@ sint8 m2m_crypto_rsa_sign_gen(uint8 *pu8N, uint16 u16NSize, uint8 *pu8d, uint16
 
 #ifdef CONF_CRYPTO_SOFT
 
-typedef struct {
-	tpfAppCryproCb pfAppCryptoCb;
-	uint8 * pu8Digest;
-	uint8 * pu8Rsa;
-	uint8 u8CryptoBusy;
-}tstrCryptoCtxt;
 
 typedef struct {
 	uint8 au8N[M2M_MAX_RSA_LEN];
@@ -711,8 +706,6 @@ typedef struct {
 	uint8 _pad16_[2];
 }tstrRsaPayload;
 
-static tstrCryptoCtxt gstrCryptoCtxt;
-
 
 /**
 *	@fn			m2m_crypto_cb(uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
@@ -727,33 +720,34 @@ static tstrCryptoCtxt gstrCryptoCtxt;
 *	@date
 *	@version	1.0
 */
-static void m2m_crypto_cb(uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
+static void m2m_crypto_cb(winc1500_t *dev, uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	sint8 ret = M2M_SUCCESS;
-	gstrCryptoCtxt.u8CryptoBusy = 0;
+	internal->gstrCryptoCtxt.u8CryptoBusy = 0;
 	if(u8OpCode == M2M_CRYPTO_RESP_SHA256_INIT)
 	{
 		tstrM2mSha256Ctxt strCtxt;	
-		if (hif_receive(u32Addr, (uint8*) &strCtxt,sizeof(tstrM2mSha256Ctxt), 0) == M2M_SUCCESS)
+		if (hif_receive(dev, u32Addr, (uint8*) &strCtxt,sizeof(tstrM2mSha256Ctxt), 0) == M2M_SUCCESS)
 		{	
 			tstrCyptoResp strResp;	
-			if(hif_receive(u32Addr + sizeof(tstrM2mSha256Ctxt), (uint8*) &strResp,sizeof(tstrCyptoResp), 1) == M2M_SUCCESS)
+			if(hif_receive(dev, u32Addr + sizeof(tstrM2mSha256Ctxt), (uint8*) &strResp,sizeof(tstrCyptoResp), 1) == M2M_SUCCESS)
 			{
-				if (gstrCryptoCtxt.pfAppCryptoCb)
-					gstrCryptoCtxt.pfAppCryptoCb(u8OpCode,&strResp,&strCtxt);
+				if (internal->gstrCryptoCtxt.pfAppCryptoCb)
+					internal->gstrCryptoCtxt.pfAppCryptoCb(dev, u8OpCode,&strResp,&strCtxt);
 			}
 		}
 	}
 	else if(u8OpCode == M2M_CRYPTO_RESP_SHA256_UPDATE)
 	{
 		tstrM2mSha256Ctxt strCtxt;
-		if (hif_receive(u32Addr, (uint8*) &strCtxt,sizeof(tstrM2mSha256Ctxt), 0) == M2M_SUCCESS)
+		if (hif_receive(dev, u32Addr, (uint8*) &strCtxt,sizeof(tstrM2mSha256Ctxt), 0) == M2M_SUCCESS)
 		{
 			tstrCyptoResp strResp;
-			if (hif_receive(u32Addr + sizeof(tstrM2mSha256Ctxt), (uint8*) &strResp,sizeof(tstrCyptoResp), 1) == M2M_SUCCESS)
+			if (hif_receive(dev, u32Addr + sizeof(tstrM2mSha256Ctxt), (uint8*) &strResp,sizeof(tstrCyptoResp), 1) == M2M_SUCCESS)
 			{
-				if (gstrCryptoCtxt.pfAppCryptoCb)
-					gstrCryptoCtxt.pfAppCryptoCb(u8OpCode,&strResp,&strCtxt);
+				if (internal->gstrCryptoCtxt.pfAppCryptoCb)
+					internal->gstrCryptoCtxt.pfAppCryptoCb(dev, u8OpCode,&strResp,&strCtxt);
 			}
 		}
 
@@ -761,12 +755,12 @@ static void m2m_crypto_cb(uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
 	else if(u8OpCode == M2M_CRYPTO_RESP_SHA256_FINSIH)
 	{
 		tstrCyptoResp strResp;
-		if (hif_receive(u32Addr + sizeof(tstrM2mSha256Ctxt), (uint8*) &strResp,sizeof(tstrCyptoResp), 0) == M2M_SUCCESS)
+		if (hif_receive(dev, u32Addr + sizeof(tstrM2mSha256Ctxt), (uint8*) &strResp,sizeof(tstrCyptoResp), 0) == M2M_SUCCESS)
 		{
-			if (hif_receive(u32Addr + sizeof(tstrM2mSha256Ctxt) + sizeof(tstrCyptoResp), (uint8*)gstrCryptoCtxt.pu8Digest,M2M_SHA256_DIGEST_LEN, 1) == M2M_SUCCESS)
+			if (hif_receive(dev, u32Addr + sizeof(tstrM2mSha256Ctxt) + sizeof(tstrCyptoResp), (uint8*)internal->gstrCryptoCtxt.pu8Digest,M2M_SHA256_DIGEST_LEN, 1) == M2M_SUCCESS)
 			{
-				if (gstrCryptoCtxt.pfAppCryptoCb)
-					gstrCryptoCtxt.pfAppCryptoCb(u8OpCode,&strResp,gstrCryptoCtxt.pu8Digest);
+				if (internal->gstrCryptoCtxt.pfAppCryptoCb)
+					internal->gstrCryptoCtxt.pfAppCryptoCb(dev, u8OpCode,&strResp,internal->gstrCryptoCtxt.pu8Digest);
 				
 			}
 		}
@@ -774,22 +768,22 @@ static void m2m_crypto_cb(uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
 	else if(u8OpCode == M2M_CRYPTO_RESP_RSA_SIGN_GEN)
 	{
 		tstrCyptoResp strResp;
-		if (hif_receive(u32Addr + sizeof(tstrRsaPayload), (uint8*)&strResp,sizeof(tstrCyptoResp), 0) == M2M_SUCCESS)
+		if (hif_receive(dev, u32Addr + sizeof(tstrRsaPayload), (uint8*)&strResp,sizeof(tstrCyptoResp), 0) == M2M_SUCCESS)
 		{
-			if (hif_receive(u32Addr + sizeof(tstrRsaPayload) + sizeof(tstrCyptoResp), (uint8*)gstrCryptoCtxt.pu8Rsa,M2M_MAX_RSA_LEN, 0) == M2M_SUCCESS)
+			if (hif_receive(dev, u32Addr + sizeof(tstrRsaPayload) + sizeof(tstrCyptoResp), (uint8*)internal->gstrCryptoCtxt.pu8Rsa,M2M_MAX_RSA_LEN, 0) == M2M_SUCCESS)
 			{
-				if (gstrCryptoCtxt.pfAppCryptoCb)
-					gstrCryptoCtxt.pfAppCryptoCb(u8OpCode,&strResp,gstrCryptoCtxt.pu8Rsa);
+				if (internal->gstrCryptoCtxt.pfAppCryptoCb)
+					internal->gstrCryptoCtxt.pfAppCryptoCb(dev, u8OpCode,&strResp,internal->gstrCryptoCtxt.pu8Rsa);
 			}
 		}
 	}
 	else if(u8OpCode == M2M_CRYPTO_RESP_RSA_SIGN_VERIFY)
 	{
 		tstrCyptoResp strResp;
-		if (hif_receive(u32Addr + sizeof(tstrRsaPayload), (uint8*)&strResp,sizeof(tstrCyptoResp), 1) == M2M_SUCCESS)
+		if (hif_receive(dev, u32Addr + sizeof(tstrRsaPayload), (uint8*)&strResp,sizeof(tstrCyptoResp), 1) == M2M_SUCCESS)
 		{
-			if (gstrCryptoCtxt.pfAppCryptoCb)
-				gstrCryptoCtxt.pfAppCryptoCb(u8OpCode,&strResp,NULL);
+			if (internal->gstrCryptoCtxt.pfAppCryptoCb)
+				internal->gstrCryptoCtxt.pfAppCryptoCb(dev, u8OpCode,&strResp,NULL);
 		}
 	}
 	else 
@@ -807,14 +801,15 @@ static void m2m_crypto_cb(uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
 @param[in]	pfAppCryproCb
 
 */
-sint8 m2m_crypto_init(tpfAppCryproCb pfAppCryproCb)
+sint8 m2m_crypto_init(winc1500_t *dev, tpfAppCryproCb pfAppCryproCb)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	sint8 ret = M2M_ERR_FAIL;
-	m2m_memset((uint8*)&gstrCryptoCtxt,0,sizeof(tstrCryptoCtxt));
+	m2m_memset((uint8*)&internal->gstrCryptoCtxt,0,sizeof(tstrCryptoCtxt));
 	if(pfAppCryproCb != NULL)
 	{
-		gstrCryptoCtxt.pfAppCryptoCb = pfAppCryproCb;
-		ret = hif_register_cb(M2M_REQ_GROUP_CRYPTO,m2m_crypto_cb);
+		internal->gstrCryptoCtxt.pfAppCryptoCb = pfAppCryproCb;
+		ret = hif_register_cb(dev, M2M_REQ_GROUP_CRYPTO,m2m_crypto_cb);
 	}
 	return ret;
 }
@@ -827,12 +822,13 @@ sint8 m2m_crypto_init(tpfAppCryproCb pfAppCryproCb)
 @param[in]	psha256Ctxt
 				Pointer to a sha256 context allocated by the caller.
 */
-sint8 m2m_crypto_sha256_hash_init(tstrM2mSha256Ctxt *psha256Ctxt)
+sint8 m2m_crypto_sha256_hash_init(winc1500_t *dev, tstrM2mSha256Ctxt *psha256Ctxt)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	sint8  ret = M2M_ERR_FAIL;
-	if((psha256Ctxt != NULL)&&(!gstrCryptoCtxt.u8CryptoBusy))
+	if((psha256Ctxt != NULL)&&(!internal->gstrCryptoCtxt.u8CryptoBusy))
 	{
-		ret = hif_send(M2M_REQ_GROUP_CRYPTO,M2M_CRYPTO_REQ_SHA256_INIT|M2M_REQ_DATA_PKT,(uint8*)psha256Ctxt,sizeof(tstrM2mSha256Ctxt),NULL,0,0);
+		ret = hif_send(dev, M2M_REQ_GROUP_CRYPTO,M2M_CRYPTO_REQ_SHA256_INIT|M2M_REQ_DATA_PKT,(uint8*)psha256Ctxt,sizeof(tstrM2mSha256Ctxt),NULL,0,0);
 	}
 	return ret;
 }
@@ -853,12 +849,13 @@ sint8 m2m_crypto_sha256_hash_init(tstrM2mSha256Ctxt *psha256Ctxt)
 @param [in]	u16DataLength
 				Size of the data bufefr in bytes.
 */
-sint8 m2m_crypto_sha256_hash_update(tstrM2mSha256Ctxt *psha256Ctxt, uint8 *pu8Data, uint16 u16DataLength)
+sint8 m2m_crypto_sha256_hash_update(winc1500_t *dev, tstrM2mSha256Ctxt *psha256Ctxt, uint8 *pu8Data, uint16 u16DataLength)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	sint8  ret = M2M_ERR_FAIL;
-	if((!gstrCryptoCtxt.u8CryptoBusy) && (psha256Ctxt != NULL) && (pu8Data != NULL) && (u16DataLength < M2M_SHA256_MAX_DATA))
+	if((!internal->gstrCryptoCtxt.u8CryptoBusy) && (psha256Ctxt != NULL) && (pu8Data != NULL) && (u16DataLength < M2M_SHA256_MAX_DATA))
 	{
-		ret = hif_send(M2M_REQ_GROUP_CRYPTO,M2M_CRYPTO_REQ_SHA256_UPDATE|M2M_REQ_DATA_PKT,(uint8*)psha256Ctxt,sizeof(tstrM2mSha256Ctxt),pu8Data,u16DataLength,sizeof(tstrM2mSha256Ctxt) + sizeof(tstrCyptoResp));
+		ret = hif_send(dev, M2M_REQ_GROUP_CRYPTO,M2M_CRYPTO_REQ_SHA256_UPDATE|M2M_REQ_DATA_PKT,(uint8*)psha256Ctxt,sizeof(tstrM2mSha256Ctxt),pu8Data,u16DataLength,sizeof(tstrM2mSha256Ctxt) + sizeof(tstrCyptoResp));
 	}
 	return ret;
 	
@@ -877,13 +874,14 @@ sint8 m2m_crypto_sha256_hash_update(tstrM2mSha256Ctxt *psha256Ctxt, uint8 *pu8Da
 @param [in] pu8Sha256Digest
 				Buffer allocated by the caller which will hold the resultant SHA256 Digest. It must be allocated no less than M2M_SHA256_DIGEST_LEN.
 */
-sint8 m2m_crypto_sha256_hash_finish(tstrM2mSha256Ctxt *psha256Ctxt, uint8 *pu8Sha256Digest)
+sint8 m2m_crypto_sha256_hash_finish(winc1500_t *dev, tstrM2mSha256Ctxt *psha256Ctxt, uint8 *pu8Sha256Digest)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	sint8  ret = M2M_ERR_FAIL;
-	if((!gstrCryptoCtxt.u8CryptoBusy) && (psha256Ctxt != NULL) && (pu8Sha256Digest != NULL))
+	if((!internal->gstrCryptoCtxt.u8CryptoBusy) && (psha256Ctxt != NULL) && (pu8Sha256Digest != NULL))
 	{
-		gstrCryptoCtxt.pu8Digest = pu8Sha256Digest;
-		ret = hif_send(M2M_REQ_GROUP_CRYPTO,M2M_CRYPTO_REQ_SHA256_FINSIH|M2M_REQ_DATA_PKT,(uint8*)psha256Ctxt,sizeof(tstrM2mSha256Ctxt),NULL,0,0);
+		internal->gstrCryptoCtxt.pu8Digest = pu8Sha256Digest;
+		ret = hif_send(dev, M2M_REQ_GROUP_CRYPTO,M2M_CRYPTO_REQ_SHA256_FINSIH|M2M_REQ_DATA_PKT,(uint8*)psha256Ctxt,sizeof(tstrM2mSha256Ctxt),NULL,0,0);
 	}
 	return ret;
 }
@@ -925,11 +923,12 @@ sint8 m2m_crypto_sha256_hash_finish(tstrM2mSha256Ctxt *psha256Ctxt, uint8 *pu8Sh
 */
 
 
-sint8 m2m_crypto_rsa_sign_verify(uint8 *pu8N, uint16 u16NSize, uint8 *pu8E, uint16 u16ESize, uint8 *pu8SignedMsgHash, 
+sint8 m2m_crypto_rsa_sign_verify(winc1500_t *dev, uint8 *pu8N, uint16 u16NSize, uint8 *pu8E, uint16 u16ESize, uint8 *pu8SignedMsgHash,
 						  uint16 u16HashLength, uint8 *pu8RsaSignature)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	sint8 ret = M2M_ERR_FAIL;
-	if((!gstrCryptoCtxt.u8CryptoBusy) && (pu8N != NULL) && (pu8E != NULL) && (pu8RsaSignature != NULL) && (pu8SignedMsgHash != NULL) 
+	if((!internal->gstrCryptoCtxt.u8CryptoBusy) && (pu8N != NULL) && (pu8E != NULL) && (pu8RsaSignature != NULL) && (pu8SignedMsgHash != NULL)
 	&& (u16NSize != 0) && (u16ESize != 0) && (u16HashLength != 0) && (pu8RsaSignature != NULL) )
 	
 	{
@@ -943,7 +942,7 @@ sint8 m2m_crypto_rsa_sign_verify(uint8 *pu8N, uint16 u16NSize, uint8 *pu8E, uint
 		strRsa.u16Hsz = u16HashLength;
 		strRsa.u16Nsz = u16NSize;
 		
-		ret = hif_send(M2M_REQ_GROUP_CRYPTO,M2M_CRYPTO_REQ_RSA_SIGN_VERIFY|M2M_REQ_DATA_PKT,(uint8*)&strRsa,sizeof(tstrRsaPayload),NULL,0,0);
+		ret = hif_send(dev, M2M_REQ_GROUP_CRYPTO,M2M_CRYPTO_REQ_RSA_SIGN_VERIFY|M2M_REQ_DATA_PKT,(uint8*)&strRsa,sizeof(tstrRsaPayload),NULL,0,0);
 		
 	}
 	return ret;
@@ -982,11 +981,12 @@ sint8 m2m_crypto_rsa_sign_verify(uint8 *pu8N, uint16 u16NSize, uint8 *pu8E, uint
 @param[out] pu8RsaSignature
 				Pointer to a user buffer allocated by teh caller shall hold the generated signature.
 */
-sint8 m2m_crypto_rsa_sign_gen(uint8 *pu8N, uint16 u16NSize, uint8 *pu8d, uint16 u16dSize, uint8 *pu8SignedMsgHash, 
+sint8 m2m_crypto_rsa_sign_gen(winc1500_t *dev, uint8 *pu8N, uint16 u16NSize, uint8 *pu8d, uint16 u16dSize, uint8 *pu8SignedMsgHash, 
 					   uint16 u16HashLength, uint8 *pu8RsaSignature)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	sint8 ret = M2M_ERR_FAIL;
-	if((!gstrCryptoCtxt.u8CryptoBusy) && (pu8N != NULL) && (pu8d != NULL) && (pu8RsaSignature != NULL) && (pu8SignedMsgHash != NULL)
+	if((!internal->gstrCryptoCtxt.u8CryptoBusy) && (pu8N != NULL) && (pu8d != NULL) && (pu8RsaSignature != NULL) && (pu8SignedMsgHash != NULL)
 	&& (u16NSize != 0) && (u16dSize != 0) && (u16HashLength != 0) && (pu8RsaSignature != NULL))
 	
 	{
@@ -1000,8 +1000,8 @@ sint8 m2m_crypto_rsa_sign_gen(uint8 *pu8N, uint16 u16NSize, uint8 *pu8d, uint16
 		strRsa.u16Hsz = u16HashLength;
 		strRsa.u16Nsz = u16NSize;
 		
-		gstrCryptoCtxt.pu8Rsa = pu8RsaSignature;
-		ret = hif_send(M2M_REQ_GROUP_CRYPTO,M2M_CRYPTO_REQ_RSA_SIGN_GEN|M2M_REQ_DATA_PKT,(uint8*)&strRsa,sizeof(tstrRsaPayload),NULL,0,0);
+		internal->gstrCryptoCtxt.pu8Rsa = pu8RsaSignature;
+		ret = hif_send(dev, M2M_REQ_GROUP_CRYPTO,M2M_CRYPTO_REQ_RSA_SIGN_GEN|M2M_REQ_DATA_PKT,(uint8*)&strRsa,sizeof(tstrRsaPayload),NULL,0,0);
 		
 	}
 	return ret;			   
diff --git a/winc1500/driver/source/m2m_hif.c b/winc1500/driver/source/m2m_hif.c
index af0e4a3..255c3de 100644
--- a/winc1500/driver/source/m2m_hif.c
+++ b/winc1500/driver/source/m2m_hif.c
@@ -66,49 +66,35 @@
 #define WIFI_HOST_RCV_CTRL_4	(0x150400)
 #define WIFI_HOST_RCV_CTRL_5	(0x1088)
 
-typedef struct {
-	uint8 u8ChipMode;
-	uint8 u8ChipSleep;
-	uint8 u8HifRXDone;
-	uint8 u8Interrupt;
-	uint32 u32RxAddr;
-	uint32 u32RxSize;
-	tpfHifCallBack pfWifiCb;
-	tpfHifCallBack pfIpCb;
-	tpfHifCallBack pfOtaCb;
-	tpfHifCallBack pfSigmaCb;
-	tpfHifCallBack pfHifCb;
-	tpfHifCallBack pfCryptoCb;
-	tpfHifCallBack pfSslCb;
-}tstrHifContext;
-
-volatile tstrHifContext gstrHifCxt;
-
-void m2m_hif_isr(void)
+void m2m_hif_isr(void *arg)
 {
-	gstrHifCxt.u8Interrupt++;
-	M2M_DBG("Interrupt triggered: %d",gstrHifCxt.u8Interrupt);
+	winc1500_t *dev = (winc1500_t *)arg;
+	winc1500_internal_t *internal = &dev->internal;
+
+	internal->gstrHifCxt.u8Interrupt++;
+	M2M_DBG("Interrupt triggered: %d", internal->gstrHifCxt.u8Interrupt);
 #ifdef NM_LEVEL_INTERRUPT
-	nm_bsp_interrupt_ctrl(0);
+	nm_bsp_interrupt_ctrl(dev, 0);
 #endif
 }
-static sint8 hif_set_rx_done(void)
+static sint8 hif_set_rx_done(winc1500_t *dev)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	uint32 reg;
 	sint8 ret = M2M_SUCCESS;
 
-	gstrHifCxt.u8HifRXDone = 0;
+	internal->gstrHifCxt.u8HifRXDone = 0;
 #ifdef NM_EDGE_INTERRUPT
-	nm_bsp_interrupt_ctrl(1);
+	nm_bsp_interrupt_ctrl(dev, 1);
 #endif
-	ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_0,&reg);
+	ret = nm_read_reg_with_ret(dev, WIFI_HOST_RCV_CTRL_0, &reg);
 	if(ret != M2M_SUCCESS)goto ERR1;
 	/* Set RX Done */
 	reg |= NBIT1;
-	ret = nm_write_reg(WIFI_HOST_RCV_CTRL_0,reg);
+	ret = nm_write_reg(dev, WIFI_HOST_RCV_CTRL_0, reg);
 	if(ret != M2M_SUCCESS)goto ERR1;
 #ifdef NM_LEVEL_INTERRUPT
-	nm_bsp_interrupt_ctrl(1);
+	nm_bsp_interrupt_ctrl(dev, 1);
 #endif
 ERR1:
 	return ret;
@@ -129,8 +115,9 @@ ERR1:
 *	@date
 *	@version	1.0
 */
-static void m2m_hif_cb(uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
+static void m2m_hif_cb(winc1500_t *dev, uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
 {
+	(void)dev;
 	(void)u8OpCode;
 	(void)u16DataSize;
 	(void)u32Addr;
@@ -143,26 +130,27 @@ static void m2m_hif_cb(uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
 *    @return		The function shall return ZERO for successful operation and a negative value otherwise.
 */
 
-sint8 hif_chip_wake(void)
+sint8 hif_chip_wake(winc1500_t *dev)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	sint8 ret = M2M_SUCCESS;
-	if(gstrHifCxt.u8HifRXDone)
+	if(internal->gstrHifCxt.u8HifRXDone)
 	{
 		/*chip already wake for the rx not done no need to send wake request*/
 		return ret;
 	}
-	if(gstrHifCxt.u8ChipSleep == 0)
+	if(internal->gstrHifCxt.u8ChipSleep == 0)
 	{
-		if(gstrHifCxt.u8ChipMode != M2M_NO_PS)
+		if(internal->gstrHifCxt.u8ChipMode != M2M_NO_PS)
 		{
-			ret = chip_wake();
+			ret = chip_wake(dev);
 			if(ret != M2M_SUCCESS)goto ERR1;
 		}
 		else
 		{
 		}
 	}
-	gstrHifCxt.u8ChipSleep++;
+	internal->gstrHifCxt.u8ChipSleep++;
 ERR1:
 	return ret;
 }
@@ -180,9 +168,10 @@ ERR1:
 	The function SHALL return 0 for success and a negative value otherwise.
 */
 
-void hif_set_sleep_mode(uint8 u8Pstype)
+void hif_set_sleep_mode(winc1500_t *dev, uint8 u8Pstype)
 {
-	gstrHifCxt.u8ChipMode = u8Pstype;
+	winc1500_internal_t *internal = &dev->internal;
+	internal->gstrHifCxt.u8ChipMode = u8Pstype;
 }
 /*!
 @fn	\
@@ -195,9 +184,10 @@ void hif_set_sleep_mode(uint8 u8Pstype)
 	The function SHALL return the sleep mode of the HIF layer.
 */
 
-uint8 hif_get_sleep_mode(void)
+uint8 hif_get_sleep_mode(winc1500_t *dev)
 {
-	return gstrHifCxt.u8ChipMode;
+	winc1500_internal_t *internal = &dev->internal;
+	return internal->gstrHifCxt.u8ChipMode;
 }
 
 /**
@@ -206,11 +196,12 @@ uint8 hif_get_sleep_mode(void)
 *    @return		The function shall return ZERO for successful operation and a negative value otherwise.
 */
 
-sint8 hif_chip_sleep_sc(void)
+sint8 hif_chip_sleep_sc(winc1500_t *dev)
 {
-	if(gstrHifCxt.u8ChipSleep >= 1)
+	winc1500_internal_t *internal = &dev->internal;
+	if(internal->gstrHifCxt.u8ChipSleep >= 1)
 	{
-		gstrHifCxt.u8ChipSleep--;
+		internal->gstrHifCxt.u8ChipSleep--;
 	}
 	return M2M_SUCCESS;
 }
@@ -220,20 +211,21 @@ sint8 hif_chip_sleep_sc(void)
 *    @return		The function shall return ZERO for successful operation and a negative value otherwise.
 */
 
-sint8 hif_chip_sleep(void)
+sint8 hif_chip_sleep(winc1500_t *dev)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	sint8 ret = M2M_SUCCESS;
 
-	if(gstrHifCxt.u8ChipSleep >= 1)
+	if(internal->gstrHifCxt.u8ChipSleep >= 1)
 	{
-		gstrHifCxt.u8ChipSleep--;
+		internal->gstrHifCxt.u8ChipSleep--;
 	}
-	
-	if(gstrHifCxt.u8ChipSleep == 0)
+
+	if(internal->gstrHifCxt.u8ChipSleep == 0)
 	{
-		if(gstrHifCxt.u8ChipMode != M2M_NO_PS)
+		if(internal->gstrHifCxt.u8ChipMode != M2M_NO_PS)
 		{
-			ret = chip_sleep();
+			ret = chip_sleep(dev);
 			if(ret != M2M_SUCCESS)goto ERR1;
 
 		}
@@ -252,19 +244,20 @@ ERR1:
 *   @return		The function shall return ZERO for successful operation and a negative value otherwise.
 */
 
-sint8 hif_init(void * arg)
+sint8 hif_init(winc1500_t *dev, void * arg)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	(void)arg;
 
-	m2m_memset((uint8*)&gstrHifCxt,0,sizeof(tstrHifContext));
+	m2m_memset((uint8*)&internal->gstrHifCxt,0,sizeof(struct tstrHifContext));
 #if defined(MODULE_NETDEV_ETH)
 	/** The isr will be registered in _init() in winc1500_netdev.c
 	 * 	when you use GNRC.
 	 */
 #else
-	nm_bsp_register_isr(m2m_hif_isr);
+	nm_bsp_register_isr(dev, m2m_hif_isr);
 #endif
-	hif_register_cb(M2M_REQ_GROUP_HIF,m2m_hif_cb);
+	hif_register_cb(dev, M2M_REQ_GROUP_HIF,m2m_hif_cb);
 	return M2M_SUCCESS;
 }
 /**
@@ -274,13 +267,14 @@ sint8 hif_init(void * arg)
 *				Pointer to the arguments.
 *    @return		The function shall return ZERO for successful operation and a negative value otherwise.
 */
-sint8 hif_deinit(void * arg)
+sint8 hif_deinit(winc1500_t *dev, void * arg)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	(void)arg;
 
 	sint8 ret = M2M_SUCCESS;
-	ret = hif_chip_wake();
-	m2m_memset((uint8*)&gstrHifCxt,0,sizeof(tstrHifContext));
+	ret = hif_chip_wake(dev);
+	m2m_memset((uint8*)&internal->gstrHifCxt,0,sizeof(struct tstrHifContext));
 	return ret;
 }
 /**
@@ -305,7 +299,7 @@ sint8 hif_deinit(void * arg)
 *    @return		The function shall return ZERO for successful operation and a negative value otherwise.
 */
 
-sint8 hif_send(uint8 u8Gid,uint8 u8Opcode,uint8 *pu8CtrlBuf,uint16 u16CtrlBufSize,
+sint8 hif_send(winc1500_t *dev, uint8 u8Gid,uint8 u8Opcode,uint8 *pu8CtrlBuf,uint16 u16CtrlBufSize,
 			   uint8 *pu8DataBuf,uint16 u16DataSize, uint16 u16DataOffset)
 {
 	sint8		ret = M2M_ERR_SEND;
@@ -322,7 +316,7 @@ sint8 hif_send(uint8 u8Gid,uint8 u8Opcode,uint8 *pu8CtrlBuf,uint16 u16CtrlBufSiz
 	{
 		strHif.u16Length += u16CtrlBufSize;
 	}
-	ret = hif_chip_wake();
+	ret = hif_chip_wake(dev);
 	if(ret == M2M_SUCCESS)
 	{
 		volatile uint32 reg, dma_addr = 0;
@@ -334,12 +328,12 @@ sint8 hif_send(uint8 u8Gid,uint8 u8Opcode,uint8 *pu8CtrlBuf,uint16 u16CtrlBufSiz
 		reg |= (uint32)u8Gid;
 		reg |= ((uint32)u8Opcode<<8);
 		reg |= ((uint32)strHif.u16Length<<16);
-		ret = nm_write_reg(NMI_STATE_REG,reg);
+		ret = nm_write_reg(dev, NMI_STATE_REG,reg);
 		if(M2M_SUCCESS != ret) goto ERR1;
 
 		reg = 0UL;
 		reg |= NBIT1;
-		ret = nm_write_reg(WIFI_HOST_RCV_CTRL_2, reg);
+		ret = nm_write_reg(dev, WIFI_HOST_RCV_CTRL_2, reg);
 		if(M2M_SUCCESS != ret) goto ERR1;
 #else
 		reg = 0UL;
@@ -347,14 +341,14 @@ sint8 hif_send(uint8 u8Gid,uint8 u8Opcode,uint8 *pu8CtrlBuf,uint16 u16CtrlBufSiz
 		reg |= ((u8Opcode & NBIT7) ? (NBIT2):(0)); /*Data = 1 or config*/
 		reg |= (u8Gid == M2M_REQ_GROUP_IP) ? (NBIT3):(0); /*IP = 1 or non IP*/
 		reg |= ((uint32)strHif.u16Length << 4); /*length of pkt max = 4096*/
-		ret = nm_write_reg(WIFI_HOST_RCV_CTRL_2, reg);
+		ret = nm_write_reg(dev, WIFI_HOST_RCV_CTRL_2, reg);
 		if(M2M_SUCCESS != ret) goto ERR1;
 #endif
 		dma_addr = 0;
 		
 		for(cnt = 0; cnt < 1000; cnt ++)
 		{
-			ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_2,(uint32 *)&reg);
+			ret = nm_read_reg_with_ret(dev, WIFI_HOST_RCV_CTRL_2,(uint32 *)&reg);
 			if(ret != M2M_SUCCESS) break;
 			/*
 			 * If it takes too long to get a response, the slow down to 
@@ -368,7 +362,7 @@ sint8 hif_send(uint8 u8Gid,uint8 u8Opcode,uint8 *pu8CtrlBuf,uint16 u16CtrlBufSiz
 			}
 			if (!(reg & NBIT1))
 			{
-				ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_4,(uint32 *)&dma_addr);
+				ret = nm_read_reg_with_ret(dev, WIFI_HOST_RCV_CTRL_4,(uint32 *)&dma_addr);
 				if(ret != M2M_SUCCESS) {
 					/*in case of read error clear the DMA address and return error*/
 					dma_addr = 0;
@@ -384,31 +378,31 @@ sint8 hif_send(uint8 u8Gid,uint8 u8Opcode,uint8 *pu8CtrlBuf,uint16 u16CtrlBufSiz
 			volatile uint32	u32CurrAddr;
 			u32CurrAddr = dma_addr;
 			strHif.u16Length=NM_BSP_B_L_16(strHif.u16Length);
-			ret = nm_write_block(u32CurrAddr, (uint8*)&strHif, M2M_HIF_HDR_OFFSET);
+			ret = nm_write_block(dev, u32CurrAddr, (uint8*)&strHif, M2M_HIF_HDR_OFFSET);
 			if(M2M_SUCCESS != ret) goto ERR1;
 			u32CurrAddr += M2M_HIF_HDR_OFFSET;
 			if(pu8CtrlBuf != NULL)
 			{
-				ret = nm_write_block(u32CurrAddr, pu8CtrlBuf, u16CtrlBufSize);
+				ret = nm_write_block(dev, u32CurrAddr, pu8CtrlBuf, u16CtrlBufSize);
 				if(M2M_SUCCESS != ret) goto ERR1;
 				u32CurrAddr += u16CtrlBufSize;
 			}
 			if(pu8DataBuf != NULL)
 			{
 				u32CurrAddr += (u16DataOffset - u16CtrlBufSize);
-				ret = nm_write_block(u32CurrAddr, pu8DataBuf, u16DataSize);
+				ret = nm_write_block(dev, u32CurrAddr, pu8DataBuf, u16DataSize);
 				if(M2M_SUCCESS != ret) goto ERR1;
 				u32CurrAddr += u16DataSize;
 			}
 
 			reg = dma_addr << 2;
 			reg |= NBIT1;
-			ret = nm_write_reg(WIFI_HOST_RCV_CTRL_3, reg);
+			ret = nm_write_reg(dev, WIFI_HOST_RCV_CTRL_3, reg);
 			if(M2M_SUCCESS != ret) goto ERR1;
 		}
 		else
 		{
-			ret = hif_chip_sleep();
+			ret = hif_chip_sleep(dev);
 			M2M_DBG("Failed to alloc rx size %d",ret);
 			ret = M2M_ERR_MEM_ALLOC;
 			goto ERR2;
@@ -421,63 +415,64 @@ sint8 hif_send(uint8 u8Gid,uint8 u8Opcode,uint8 *pu8CtrlBuf,uint16 u16CtrlBufSiz
 		goto ERR2;
 	}
 	/*actual sleep ret = M2M_SUCCESS*/
- 	ret = hif_chip_sleep();
+ 	ret = hif_chip_sleep(dev);
 	return ret;
 ERR1:
 	/*reset the count but no actual sleep as it already bus error*/
-	hif_chip_sleep_sc();
+	hif_chip_sleep_sc(dev);
 ERR2:
 	/*logical error*/
 	return ret;
 }
 /**
 *	@fn		hif_isr
-*	@brief	Host interface interrupt service routine
+winc1500_t *dev	@brief	Host interface interrupt service routine
 *	@author	M. Abdelmawla
 *	@date	15 July 2012
 *	@return	1 in case of interrupt received else 0 will be returned
 *	@version	1.0
 */
-static sint8 hif_isr(void)
+static sint8 hif_isr(winc1500_t *dev)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	sint8 ret = M2M_SUCCESS;
 	uint32 reg;
 	volatile tstrHifHdr strHif;
 
-	ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_0, &reg);
+	ret = nm_read_reg_with_ret(dev, WIFI_HOST_RCV_CTRL_0, &reg);
 	if(M2M_SUCCESS == ret)
 	{
 		if(reg & 0x1)	/* New interrupt has been received */
 		{
 			uint16 size;
 
-			nm_bsp_interrupt_ctrl(0);
+			nm_bsp_interrupt_ctrl(dev, 0);
 			/*Clearing RX interrupt*/
 			reg &= ~NBIT0;
-			ret = nm_write_reg(WIFI_HOST_RCV_CTRL_0,reg);
+			ret = nm_write_reg(dev, WIFI_HOST_RCV_CTRL_0,reg);
 			if(ret != M2M_SUCCESS)goto ERR1;
-			gstrHifCxt.u8HifRXDone = 1;
+			internal->gstrHifCxt.u8HifRXDone = 1;
 			size = (uint16)((reg >> 2) & 0xfff);
 			if (size > 0) {
 				uint32 address = 0;
 				/**
 				start bus transfer
 				**/
-				ret = nm_read_reg_with_ret(WIFI_HOST_RCV_CTRL_1, &address);
+				ret = nm_read_reg_with_ret(dev, WIFI_HOST_RCV_CTRL_1, &address);
 				if(M2M_SUCCESS != ret)
 				{
 					M2M_ERR("(hif) WIFI_HOST_RCV_CTRL_1 bus fail\n");
-					nm_bsp_interrupt_ctrl(1);
+					nm_bsp_interrupt_ctrl(dev, 1);
 					goto ERR1;
 				}
-				gstrHifCxt.u32RxAddr = address;
-				gstrHifCxt.u32RxSize = size;
-				ret = nm_read_block(address, (uint8*)&strHif, sizeof(tstrHifHdr));
+				internal->gstrHifCxt.u32RxAddr = address;
+				internal->gstrHifCxt.u32RxSize = size;
+				ret = nm_read_block(dev, address, (uint8*)&strHif, sizeof(tstrHifHdr));
 				strHif.u16Length = NM_BSP_B_L_16(strHif.u16Length);
 				if(M2M_SUCCESS != ret)
 				{
 					M2M_ERR("(hif) address bus fail\n");
-					nm_bsp_interrupt_ctrl(1);
+					nm_bsp_interrupt_ctrl(dev, 1);
 					goto ERR1;
 				}
 				if(strHif.u16Length != size)
@@ -486,7 +481,7 @@ static sint8 hif_isr(void)
 					{
 						M2M_ERR("(hif) Corrupted packet Size = %u <L = %u, G = %u, OP = %02X>\n",
 							size, strHif.u16Length, strHif.u8Gid, strHif.u8Opcode);
-						nm_bsp_interrupt_ctrl(1);
+						nm_bsp_interrupt_ctrl(dev, 1);
 						ret = M2M_ERR_BUS_FAIL;
 						goto ERR1;
 					}
@@ -495,47 +490,47 @@ static sint8 hif_isr(void)
 				M2M_DBG("Message request group: %u, Opcode: %u", strHif.u8Gid, strHif.u8Opcode);
 				if(M2M_REQ_GROUP_WIFI == strHif.u8Gid)
 				{
-					if(gstrHifCxt.pfWifiCb)
-						gstrHifCxt.pfWifiCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
+					if(internal->gstrHifCxt.pfWifiCb)
+						internal->gstrHifCxt.pfWifiCb(dev, strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
 					else
 						M2M_ERR("WIFI callback is not registered\n");
 
 				}
 				else if(M2M_REQ_GROUP_IP == strHif.u8Gid)
 				{
-					if(gstrHifCxt.pfIpCb)
-						gstrHifCxt.pfIpCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
+					if(internal->gstrHifCxt.pfIpCb)
+						internal->gstrHifCxt.pfIpCb(dev, strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
 					else
 						M2M_ERR("Scoket callback is not registered\n");
 
 				}
 				else if(M2M_REQ_GROUP_OTA == strHif.u8Gid)
 				{
-					if(gstrHifCxt.pfOtaCb)
-						gstrHifCxt.pfOtaCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
+					if(internal->gstrHifCxt.pfOtaCb)
+						internal->gstrHifCxt.pfOtaCb(dev, strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
 					else
 						M2M_ERR("Ota callback is not registered\n");
 
 				}
 				else if(M2M_REQ_GROUP_CRYPTO == strHif.u8Gid)
 				{
-					if(gstrHifCxt.pfCryptoCb)
-						gstrHifCxt.pfCryptoCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
+					if(internal->gstrHifCxt.pfCryptoCb)
+						internal->gstrHifCxt.pfCryptoCb(dev, strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
 
 					else
 						M2M_ERR("Crypto callback is not registered\n");
 				}
 				else if(M2M_REQ_GROUP_SIGMA == strHif.u8Gid)
 				{
-					if(gstrHifCxt.pfSigmaCb)
-						gstrHifCxt.pfSigmaCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
+					if(internal->gstrHifCxt.pfSigmaCb)
+						internal->gstrHifCxt.pfSigmaCb(dev, strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
 					else
 						M2M_ERR("Sigma callback is not registered\n");
 				}
 				else if(M2M_REQ_GROUP_SSL == strHif.u8Gid)
 				{
-				    if(gstrHifCxt.pfSslCb)
-						gstrHifCxt.pfSslCb(strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
+				    if(internal->gstrHifCxt.pfSslCb)
+						internal->gstrHifCxt.pfSslCb(dev, strHif.u8Opcode,strHif.u16Length - M2M_HIF_HDR_OFFSET, address + M2M_HIF_HDR_OFFSET);
 				}
 				else
 				{
@@ -543,10 +538,10 @@ static sint8 hif_isr(void)
 					ret = M2M_ERR_BUS_FAIL;
 					goto ERR1;
 				}
-				if(gstrHifCxt.u8HifRXDone)
+				if(internal->gstrHifCxt.u8HifRXDone)
 				{
 					M2M_ERR("(hif) host app didn't set RX Done <%u><%X>\n", strHif.u8Gid, strHif.u8Opcode);
-					ret = hif_set_rx_done();
+					ret = hif_set_rx_done(dev);
 					if(ret != M2M_SUCCESS) goto ERR1;
 				}
 			}
@@ -583,16 +578,17 @@ ERR1:
 *   @return     The function SHALL return 0 for success and a negative value otherwise.
 */
 
-sint8 hif_handle_isr(void)
+sint8 hif_handle_isr(winc1500_t *dev)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	sint8 ret = M2M_SUCCESS;	
-	while (gstrHifCxt.u8Interrupt) {
+	while (internal->gstrHifCxt.u8Interrupt) {
 		/*must be at that place because of the race of interrupt increment and that decrement*/
 		/*when the interrupt enabled*/
-		gstrHifCxt.u8Interrupt--;
+		internal->gstrHifCxt.u8Interrupt--;
 		while(1)
 		{
-			ret = hif_isr();
+			ret = hif_isr(dev);
 			if(ret == M2M_SUCCESS) {
 				/*we will try forever untill we get that interrupt*/
 				/*Fail return errors here due to bus errors (reading expected values)*/
@@ -618,15 +614,16 @@ sint8 hif_handle_isr(void)
 *				If you don't need any more packets send True otherwise send false
 *    @return		The function shall return ZERO for successful operation and a negative value otherwise.
 */
-sint8 hif_receive(uint32 u32Addr, uint8 *pu8Buf, uint16 u16Sz, uint8 isDone)
+sint8 hif_receive(winc1500_t *dev, uint32 u32Addr, uint8 *pu8Buf, uint16 u16Sz, uint8 isDone)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	sint8 ret = M2M_SUCCESS;
 	if((u32Addr == 0)||(pu8Buf == NULL) || (u16Sz == 0))
 	{
 		if(isDone)
-		{			
+		{
 			/* set RX done */
-			ret = hif_set_rx_done();
+			ret = hif_set_rx_done(dev);
 		}
 		else
 		{
@@ -636,28 +633,28 @@ sint8 hif_receive(uint32 u32Addr, uint8 *pu8Buf, uint16 u16Sz, uint8 isDone)
 		goto ERR1;
 	}
 
-	if(u16Sz > gstrHifCxt.u32RxSize)
+	if(u16Sz > internal->gstrHifCxt.u32RxSize)
 	{
 		ret = M2M_ERR_FAIL;
-		M2M_ERR("APP Requested Size is larger than the recived buffer size <%u><%lu>\n",u16Sz, gstrHifCxt.u32RxSize);
+		M2M_ERR("APP Requested Size is larger than the recived buffer size <%u><%lu>\n",u16Sz, internal->gstrHifCxt.u32RxSize);
 		goto ERR1;
 	}
-	if((u32Addr < gstrHifCxt.u32RxAddr)||((u32Addr + u16Sz)>(gstrHifCxt.u32RxAddr + gstrHifCxt.u32RxSize)))
+	if((u32Addr < internal->gstrHifCxt.u32RxAddr)||((u32Addr + u16Sz)>(internal->gstrHifCxt.u32RxAddr + internal->gstrHifCxt.u32RxSize)))
 	{
 		/* ret = M2M_ERR_FAIL; */
 		M2M_ERR("APP Requested Address beyond the recived buffer address and length\n");
 		/* goto ERR1; */
 	}
-	
+
 	/* Receive the payload */
-	ret = nm_read_block(u32Addr, pu8Buf, u16Sz);
+	ret = nm_read_block(dev, u32Addr, pu8Buf, u16Sz);
 	if(ret != M2M_SUCCESS)goto ERR1;
 
 	/* check if this is the last packet */
-	if((((gstrHifCxt.u32RxAddr + gstrHifCxt.u32RxSize) - (u32Addr + u16Sz)) <= 0) || isDone)
+	if((((internal->gstrHifCxt.u32RxAddr + internal->gstrHifCxt.u32RxSize) - (u32Addr + u16Sz)) <= 0) || isDone)
 	{
 		/* set RX done */
-		ret = hif_set_rx_done();
+		ret = hif_set_rx_done(dev);
 	}
 
 ERR1:
@@ -674,31 +671,32 @@ ERR1:
 *    @return		The function shall return ZERO for successful operation and a negative value otherwise.
 */
 
-sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn)
+sint8 hif_register_cb(winc1500_t *dev, uint8 u8Grp,tpfHifCallBack fn)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	sint8 ret = M2M_SUCCESS;
 	switch(u8Grp)
 	{
 		case M2M_REQ_GROUP_IP:
-			gstrHifCxt.pfIpCb = fn;
+			internal->gstrHifCxt.pfIpCb = fn;
 			break;
 		case M2M_REQ_GROUP_WIFI:
-			gstrHifCxt.pfWifiCb = fn;
+			internal->gstrHifCxt.pfWifiCb = fn;
 			break;
 		case M2M_REQ_GROUP_OTA:
-			gstrHifCxt.pfOtaCb = fn;
+			internal->gstrHifCxt.pfOtaCb = fn;
 			break;
 		case M2M_REQ_GROUP_HIF:
-			gstrHifCxt.pfHifCb = fn;
+			internal->gstrHifCxt.pfHifCb = fn;
 			break;
 		case M2M_REQ_GROUP_CRYPTO:
-			gstrHifCxt.pfCryptoCb = fn;
+			internal->gstrHifCxt.pfCryptoCb = fn;
 			break;
 		case M2M_REQ_GROUP_SIGMA:
-			gstrHifCxt.pfSigmaCb = fn;
+			internal->gstrHifCxt.pfSigmaCb = fn;
 			break;
 		case M2M_REQ_GROUP_SSL:
-			gstrHifCxt.pfSslCb = fn;
+			internal->gstrHifCxt.pfSslCb = fn;
 			break;
 		default:
 			M2M_ERR("GRp ? %d\n",u8Grp);
diff --git a/winc1500/driver/source/m2m_hif.h b/winc1500/driver/source/m2m_hif.h
index 1df0481..894e9a5 100644
--- a/winc1500/driver/source/m2m_hif.h
+++ b/winc1500/driver/source/m2m_hif.h
@@ -89,11 +89,11 @@ typedef struct
 @param [in]	grp
 				HIF group type.
 */
-typedef void (*tpfHifCallBack)(uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr);
+typedef void (*tpfHifCallBack)(winc1500_t *dev, uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr);
 /**
  * @brief	Wi-Fi module interrupt service routine.
  */
-void m2m_hif_isr(void);
+void m2m_hif_isr(void *arg);
 /**
 *   @fn			NMI_API sint8 hif_init(void * arg);
 *   @brief
@@ -103,7 +103,7 @@ void m2m_hif_isr(void);
 *   @return
 				The function shall return ZERO for successful operation and a negative value otherwise.
 */
-NMI_API sint8 hif_init(void * arg);
+NMI_API sint8 hif_init(winc1500_t *dev, void * arg);
 /**
 *	@fn			NMI_API sint8 hif_deinit(void * arg);
 *	@brief
@@ -113,7 +113,7 @@ NMI_API sint8 hif_init(void * arg);
 *    @return
 				The function shall return ZERO for successful operation and a negative value otherwise.
 */
-NMI_API sint8 hif_deinit(void * arg);
+NMI_API sint8 hif_deinit(winc1500_t *dev, void * arg);
 /**
 *	@fn		NMI_API sint8 hif_send(uint8 u8Gid,uint8 u8Opcode,uint8 *pu8CtrlBuf,uint16 u16CtrlBufSize,
 					   uint8 *pu8DataBuf,uint16 u16DataSize, uint16 u16DataOffset)
@@ -135,7 +135,7 @@ NMI_API sint8 hif_deinit(void * arg);
 				Packet buffer size (including the HIF header).
 *    @return	The function shall return ZERO for successful operation and a negative value otherwise.
 */
-NMI_API sint8 hif_send(uint8 u8Gid,uint8 u8Opcode,uint8 *pu8CtrlBuf,uint16 u16CtrlBufSize,
+NMI_API sint8 hif_send(winc1500_t *dev, uint8 u8Gid,uint8 u8Opcode,uint8 *pu8CtrlBuf,uint16 u16CtrlBufSize,
 					   uint8 *pu8DataBuf,uint16 u16DataSize, uint16 u16DataOffset);
 /*
 *	@fn		hif_receive
@@ -152,7 +152,7 @@ NMI_API sint8 hif_send(uint8 u8Gid,uint8 u8Opcode,uint8 *pu8CtrlBuf,uint16 u16Ct
 				The function shall return ZERO for successful operation and a negative value otherwise.
 */
 
-NMI_API sint8 hif_receive(uint32 u32Addr, uint8 *pu8Buf, uint16 u16Sz, uint8 isDone);
+NMI_API sint8 hif_receive(winc1500_t *dev, uint32 u32Addr, uint8 *pu8Buf, uint16 u16Sz, uint8 isDone);
 /**
 *	@fn			hif_register_cb
 *	@brief
@@ -166,7 +166,7 @@ NMI_API sint8 hif_receive(uint32 u32Addr, uint8 *pu8Buf, uint16 u16Sz, uint8 isD
 *   @return
 				The function shall return ZERO for successful operation and a negative value otherwise.
 */
-NMI_API sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn);
+NMI_API sint8 hif_register_cb(winc1500_t *dev, uint8 u8Grp,tpfHifCallBack fn);
 /**
 *	@fn		NMI_API sint8 hif_chip_sleep(void);
 *	@brief
@@ -174,7 +174,7 @@ NMI_API sint8 hif_register_cb(uint8 u8Grp,tpfHifCallBack fn);
 *   @return
 				The function shall return ZERO for successful operation and a negative value otherwise.
 */
-NMI_API sint8 hif_chip_sleep(void);
+NMI_API sint8 hif_chip_sleep(winc1500_t *dev);
 /**
 *	@fn		NMI_API sint8 hif_chip_sleep_sc(void);
 *	@brief
@@ -182,7 +182,7 @@ NMI_API sint8 hif_chip_sleep(void);
 *   @return
 				The function shall return ZERO for successful operation and a negative value otherwise.
 */
-NMI_API sint8 hif_chip_sleep_sc(void);
+NMI_API sint8 hif_chip_sleep_sc(winc1500_t *dev);
 /**
 *	@fn		NMI_API sint8 hif_chip_wake(void);
 *	@brief
@@ -191,7 +191,7 @@ NMI_API sint8 hif_chip_sleep_sc(void);
 			The function shall return ZERO for successful operation and a negative value otherwise.
 */
 
-NMI_API sint8 hif_chip_wake(void);
+NMI_API sint8 hif_chip_wake(winc1500_t *dev);
 /*!
 @fn	\
 			NMI_API void hif_set_sleep_mode(uint8 u8Pstype);
@@ -206,7 +206,7 @@ NMI_API sint8 hif_chip_wake(void);
 			The function SHALL return 0 for success and a negative value otherwise.
 */
 
-NMI_API void hif_set_sleep_mode(uint8 u8Pstype);
+NMI_API void hif_set_sleep_mode(winc1500_t *dev, uint8 u8Pstype);
 /*!
 @fn	\
 	NMI_API uint8 hif_get_sleep_mode(void);
@@ -218,7 +218,7 @@ NMI_API void hif_set_sleep_mode(uint8 u8Pstype);
 	The function SHALL return the sleep mode of the HIF layer.
 */
 
-NMI_API uint8 hif_get_sleep_mode(void);
+NMI_API uint8 hif_get_sleep_mode(winc1500_t *dev);
 
 #ifdef CORTUS_APP
 /**
@@ -245,7 +245,7 @@ NMI_API sint8 hif_Resp_handler(uint8 *pu8Buffer, uint16 u16BufferSize);
 *   @return
 			The function SHALL return 0 for success and a negative value otherwise.
 */
-NMI_API sint8 hif_handle_isr(void);
+NMI_API sint8 hif_handle_isr(winc1500_t *dev);
 
 #ifdef __cplusplus
 }
diff --git a/winc1500/driver/source/m2m_ota.c b/winc1500/driver/source/m2m_ota.c
index efe167a..31ba0a1 100644
--- a/winc1500/driver/source/m2m_ota.c
+++ b/winc1500/driver/source/m2m_ota.c
@@ -55,8 +55,6 @@ MACROS
 /*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
 DATA TYPES
 *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
-static tpfOtaUpdateCb gpfOtaUpdateCb = NULL;
-static tpfOtaNotifCb  gpfOtaNotifCb = NULL;
 
 
 /*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
@@ -77,8 +75,9 @@ FUNCTION PROTOTYPES
 *	@date
 *	@version	1.0
 */
-static void m2m_ota_cb(uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
+static void m2m_ota_cb(winc1500_t *dev, uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	(void)u16DataSize;
 
 	sint8 ret = M2M_SUCCESS;
@@ -86,22 +85,22 @@ static void m2m_ota_cb(uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
 	{
 		tstrOtaUpdateInfo strOtaUpdateInfo;
 		m2m_memset((uint8*)&strOtaUpdateInfo,0,sizeof(tstrOtaUpdateInfo));
-		ret = hif_receive(u32Addr,(uint8*)&strOtaUpdateInfo,sizeof(tstrOtaUpdateInfo),0);
+		ret = hif_receive(dev, u32Addr,(uint8*)&strOtaUpdateInfo,sizeof(tstrOtaUpdateInfo),0);
 		if(ret == M2M_SUCCESS)
 		{
-			if(gpfOtaNotifCb)
-				gpfOtaNotifCb(&strOtaUpdateInfo);
+			if(internal->gpfOtaNotifCb)
+				internal->gpfOtaNotifCb(dev, &strOtaUpdateInfo);
 		}
 	}
 	else if (u8OpCode == M2M_OTA_RESP_UPDATE_STATUS)
 	{
 		tstrOtaUpdateStatusResp strOtaUpdateStatusResp;
 		m2m_memset((uint8*)&strOtaUpdateStatusResp,0,sizeof(tstrOtaUpdateStatusResp));
-		ret = hif_receive(u32Addr, (uint8*) &strOtaUpdateStatusResp,sizeof(tstrOtaUpdateStatusResp), 0);
+		ret = hif_receive(dev, u32Addr, (uint8*) &strOtaUpdateStatusResp,sizeof(tstrOtaUpdateStatusResp), 0);
 		if(ret == M2M_SUCCESS)
 		{
-			if(gpfOtaUpdateCb)
-				gpfOtaUpdateCb(strOtaUpdateStatusResp.u8OtaUpdateStatusType,strOtaUpdateStatusResp.u8OtaUpdateStatus);
+			if(internal->gpfOtaUpdateCb)
+				internal->gpfOtaUpdateCb(dev, strOtaUpdateStatusResp.u8OtaUpdateStatusType,strOtaUpdateStatusResp.u8OtaUpdateStatus);
 		}
 	}
 	else
@@ -126,22 +125,23 @@ static void m2m_ota_cb(uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
 @return
 	The function SHALL return 0 for success and a negative value otherwise.
 */
-NMI_API sint8  m2m_ota_init(tpfOtaUpdateCb pfOtaUpdateCb, tpfOtaNotifCb pfOtaNotifCb)
+NMI_API sint8  m2m_ota_init(winc1500_t *dev, tpfOtaUpdateCb pfOtaUpdateCb, tpfOtaNotifCb pfOtaNotifCb)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	sint8 ret = M2M_SUCCESS;
 
 	if(pfOtaUpdateCb){
-		gpfOtaUpdateCb = pfOtaUpdateCb;
+		internal->gpfOtaUpdateCb = pfOtaUpdateCb;
 	}else{
 		M2M_ERR("Invaild Ota update cb\n");
 	}
 	if(pfOtaNotifCb){
-		gpfOtaNotifCb = pfOtaNotifCb;
+		internal->gpfOtaNotifCb = pfOtaNotifCb;
 	}else{
 		M2M_ERR("Invaild Ota notify cb\n");
 	}
 
-	hif_register_cb(M2M_REQ_GROUP_OTA,m2m_ota_cb);
+	hif_register_cb(dev, M2M_REQ_GROUP_OTA,m2m_ota_cb);
 
 	return ret;
 }
@@ -158,14 +158,14 @@ NMI_API sint8  m2m_ota_init(tpfOtaUpdateCb pfOtaUpdateCb, tpfOtaNotifCb pfOtaNot
 @return
 	The function SHALL return 0 for success and a negative value otherwise.
 */
-NMI_API sint8  m2m_ota_notif_set_url(uint8 * u8Url)
+NMI_API sint8  m2m_ota_notif_set_url(winc1500_t *dev, uint8 * u8Url)
 {
 	sint8 ret = M2M_SUCCESS;
 	uint16 u16UrlSize = m2m_strlen(u8Url) + 1;
 	/*Todo: we may change it to data pkt but we need to give it higer priority
 			but the priorty is not implemnted yet in data pkt
 	*/
-	ret = hif_send(M2M_REQ_GROUP_OTA,M2M_OTA_REQ_NOTIF_SET_URL,u8Url,u16UrlSize,NULL,0,0);
+	ret = hif_send(dev, M2M_REQ_GROUP_OTA,M2M_OTA_REQ_NOTIF_SET_URL,u8Url,u16UrlSize,NULL,0,0);
 	return ret;
 
 }
@@ -180,10 +180,10 @@ NMI_API sint8  m2m_ota_notif_set_url(uint8 * u8Url)
 @return
 	The function SHALL return 0 for success and a negative value otherwise.
 */
-NMI_API sint8  m2m_ota_notif_check_for_update(void)
+NMI_API sint8  m2m_ota_notif_check_for_update(winc1500_t *dev)
 {
 	sint8 ret = M2M_SUCCESS;
-	ret = hif_send(M2M_REQ_GROUP_OTA,M2M_OTA_REQ_NOTIF_CHECK_FOR_UPDATE,NULL,0,NULL,0,0);
+	ret = hif_send(dev, M2M_REQ_GROUP_OTA,M2M_OTA_REQ_NOTIF_CHECK_FOR_UPDATE,NULL,0,NULL,0,0);
 	return ret;
 }
 
@@ -200,12 +200,12 @@ NMI_API sint8  m2m_ota_notif_check_for_update(void)
 @return
 	The function SHALL return 0 for success and a negative value otherwise.
 */
-NMI_API sint8 m2m_ota_notif_sched(uint32 u32Period)
+NMI_API sint8 m2m_ota_notif_sched(winc1500_t *dev, uint32 u32Period)
 {
 	(void)u32Period;
-	
+
 	sint8 ret = M2M_SUCCESS;
-	ret = hif_send(M2M_REQ_GROUP_OTA,M2M_OTA_REQ_NOTIF_CHECK_FOR_UPDATE,NULL,0,NULL,0,0);
+	ret = hif_send(dev, M2M_REQ_GROUP_OTA,M2M_OTA_REQ_NOTIF_CHECK_FOR_UPDATE,NULL,0,NULL,0,0);
 	return ret;
 }
 
@@ -223,14 +223,14 @@ NMI_API sint8 m2m_ota_notif_sched(uint32 u32Period)
 	The function SHALL return 0 for success and a negative value otherwise.
 
 */
-NMI_API sint8 m2m_ota_start_update(uint8 * u8DownloadUrl)
+NMI_API sint8 m2m_ota_start_update(winc1500_t *dev, uint8 * u8DownloadUrl)
 {
 	sint8 ret = M2M_SUCCESS;
 	uint16 u16DurlSize = m2m_strlen(u8DownloadUrl) + 1;
 	/*Todo: we may change it to data pkt but we need to give it higer priority
 			but the priorty is not implemnted yet in data pkt
 	*/
-	ret = hif_send(M2M_REQ_GROUP_OTA,M2M_OTA_REQ_START_FW_UPDATE,u8DownloadUrl,u16DurlSize,NULL,0,0);
+	ret = hif_send(dev, M2M_REQ_GROUP_OTA,M2M_OTA_REQ_START_FW_UPDATE,u8DownloadUrl,u16DurlSize,NULL,0,0);
 	return ret;
 }
 /*!
@@ -247,11 +247,11 @@ NMI_API sint8 m2m_ota_start_update(uint8 * u8DownloadUrl)
 	The function SHALL return 0 for success and a negative value otherwise.
 
 */
-NMI_API sint8 m2m_ota_start_update_crt(uint8 * u8DownloadUrl)
+NMI_API sint8 m2m_ota_start_update_crt(winc1500_t *dev, uint8 * u8DownloadUrl)
 {
 	sint8 ret = M2M_SUCCESS;
 	uint16 u16DurlSize = m2m_strlen(u8DownloadUrl) + 1;
-	ret = hif_send(M2M_REQ_GROUP_OTA,M2M_OTA_REQ_START_CRT_UPDATE,u8DownloadUrl,u16DurlSize,NULL,0,0);
+	ret = hif_send(dev, M2M_REQ_GROUP_OTA,M2M_OTA_REQ_START_CRT_UPDATE,u8DownloadUrl,u16DurlSize,NULL,0,0);
 	return ret;
 }
 
@@ -266,10 +266,10 @@ NMI_API sint8 m2m_ota_start_update_crt(uint8 * u8DownloadUrl)
 @return
 	The function SHALL return 0 for success and a negative value otherwise.
 */
-NMI_API sint8 m2m_ota_rollback(void)
+NMI_API sint8 m2m_ota_rollback(winc1500_t *dev)
 {
 	sint8 ret = M2M_SUCCESS;
-	ret = hif_send(M2M_REQ_GROUP_OTA,M2M_OTA_REQ_ROLLBACK_FW,NULL,0,NULL,0,0);
+	ret = hif_send(dev, M2M_REQ_GROUP_OTA,M2M_OTA_REQ_ROLLBACK_FW,NULL,0,NULL,0,0);
 	return ret;
 }
 /*!
@@ -282,10 +282,10 @@ NMI_API sint8 m2m_ota_rollback(void)
 @return
 	The function SHALL return 0 for success and a negative value otherwise.
 */
-NMI_API sint8 m2m_ota_rollback_crt(void)
+NMI_API sint8 m2m_ota_rollback_crt(winc1500_t *dev)
 {
 	sint8 ret = M2M_SUCCESS;
-	ret = hif_send(M2M_REQ_GROUP_OTA,M2M_OTA_REQ_ROLLBACK_CRT,NULL,0,NULL,0,0);
+	ret = hif_send(dev, M2M_REQ_GROUP_OTA,M2M_OTA_REQ_ROLLBACK_CRT,NULL,0,NULL,0,0);
 	return ret;
 }
 
@@ -299,10 +299,10 @@ NMI_API sint8 m2m_ota_rollback_crt(void)
 @return
 	The function SHALL return 0 for success and a negative value otherwise.
 */
-NMI_API sint8 m2m_ota_abort(void)
+NMI_API sint8 m2m_ota_abort(winc1500_t *dev)
 {
 	sint8 ret = M2M_SUCCESS;
-	ret = hif_send(M2M_REQ_GROUP_OTA,M2M_OTA_REQ_ABORT,NULL,0,NULL,0,0);
+	ret = hif_send(dev, M2M_REQ_GROUP_OTA,M2M_OTA_REQ_ABORT,NULL,0,NULL,0,0);
 	return ret;
 }
 
@@ -317,10 +317,10 @@ NMI_API sint8 m2m_ota_abort(void)
 @return
 	The function SHALL return 0 for success and a negative value otherwise.
 */
-NMI_API sint8 m2m_ota_switch_firmware(void)
+NMI_API sint8 m2m_ota_switch_firmware(winc1500_t *dev)
 {
 	sint8 ret = M2M_SUCCESS;
-	ret = hif_send(M2M_REQ_GROUP_OTA,M2M_OTA_REQ_SWITCH_FIRMWARE,NULL,0,NULL,0,0);
+	ret = hif_send(dev, M2M_REQ_GROUP_OTA,M2M_OTA_REQ_SWITCH_FIRMWARE,NULL,0,NULL,0,0);
 	return ret;
 }
 /*!
@@ -333,10 +333,10 @@ NMI_API sint8 m2m_ota_switch_firmware(void)
 @return
 	The function SHALL return 0 for success and a negative value otherwise.
 */
-NMI_API sint8 m2m_ota_switch_crt(void)
+NMI_API sint8 m2m_ota_switch_crt(winc1500_t *dev)
 {
 	sint8 ret = M2M_SUCCESS;
-	ret = hif_send(M2M_REQ_GROUP_OTA,M2M_OTA_REQ_SWITCH_CRT_IMG,NULL,0,NULL,0,0);
+	ret = hif_send(dev, M2M_REQ_GROUP_OTA,M2M_OTA_REQ_SWITCH_CRT_IMG,NULL,0,NULL,0,0);
 	return ret;
 }
 
@@ -350,14 +350,14 @@ NMI_API sint8 m2m_ota_switch_crt(void)
 @return
 	The function SHALL return 0 for success and a negative value otherwise.
 */
-NMI_API sint8 m2m_ota_get_firmware_version(tstrM2mRev * pstrRev)
+NMI_API sint8 m2m_ota_get_firmware_version(winc1500_t *dev, tstrM2mRev * pstrRev)
 {
 	sint8 ret = M2M_SUCCESS;
-	ret = hif_chip_wake();
+	ret = hif_chip_wake(dev);
 	if(ret == M2M_SUCCESS)
 	{
-    	ret = nm_get_ota_firmware_info(pstrRev);
-		hif_chip_sleep();
+    	ret = nm_get_ota_firmware_info(dev, pstrRev);
+		hif_chip_sleep(dev);
 	}
 	return ret;
 }
diff --git a/winc1500/driver/source/m2m_periph.c b/winc1500/driver/source/m2m_periph.c
index ce51f69..3baa0a2 100644
--- a/winc1500/driver/source/m2m_periph.c
+++ b/winc1500/driver/source/m2m_periph.c
@@ -80,11 +80,11 @@ static sint8 get_gpio_idx(uint8 u8GpioNum)
 /*
  * GPIO read/write skeleton with wakeup/sleep capability.
  */
-static sint8 gpio_ioctl(uint8 op, uint8 u8GpioNum, uint8 u8InVal, uint8 * pu8OutVal)
+static sint8 gpio_ioctl(winc1500_t *dev, uint8 op, uint8 u8GpioNum, uint8 u8InVal, uint8 * pu8OutVal)
 {
 	sint8 ret, gpio;
 
-	ret = hif_chip_wake();
+	ret = hif_chip_wake(dev);
 	if(ret != M2M_SUCCESS) goto _EXIT;
 
 	gpio = get_gpio_idx(u8GpioNum);
@@ -100,7 +100,7 @@ static sint8 gpio_ioctl(uint8 op, uint8 u8GpioNum, uint8 u8InVal, uint8 * pu8Out
 	if(ret != M2M_SUCCESS) goto _EXIT1;
 
 _EXIT1:
-	ret = hif_chip_sleep();
+	ret = hif_chip_sleep(dev);
 _EXIT:
 	return ret;
 }
@@ -109,53 +109,58 @@ FUNCTION IMPLEMENTATION
 *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
 
 
-sint8 m2m_periph_init(tstrPerphInitParam * param)
+sint8 m2m_periph_init(winc1500_t *dev, tstrPerphInitParam * param)
 {
+	(void)dev;
 	return M2M_SUCCESS;
 }
 
-sint8 m2m_periph_gpio_set_dir(uint8 u8GpioNum, uint8 u8GpioDir)
+sint8 m2m_periph_gpio_set_dir(winc1500_t *dev, uint8 u8GpioNum, uint8 u8GpioDir)
 {
-	return gpio_ioctl(GPIO_OP_DIR, u8GpioNum, u8GpioDir, NULL);
+	return gpio_ioctl(dev, GPIO_OP_DIR, u8GpioNum, u8GpioDir, NULL);
 }
 
-sint8 m2m_periph_gpio_set_val(uint8 u8GpioNum, uint8 u8GpioVal)
+sint8 m2m_periph_gpio_set_val(winc1500_t *dev, uint8 u8GpioNum, uint8 u8GpioVal)
 {
-	return gpio_ioctl(GPIO_OP_SET, u8GpioNum, u8GpioVal, NULL);
+	return gpio_ioctl(dev, GPIO_OP_SET, u8GpioNum, u8GpioVal, NULL);
 }
 
-sint8 m2m_periph_gpio_get_val(uint8 u8GpioNum, uint8 * pu8GpioVal)
+sint8 m2m_periph_gpio_get_val(winc1500_t *dev, uint8 u8GpioNum, uint8 * pu8GpioVal)
 {
-	return gpio_ioctl(GPIO_OP_GET, u8GpioNum, 0, pu8GpioVal);
+	return gpio_ioctl(dev, GPIO_OP_GET, u8GpioNum, 0, pu8GpioVal);
 }
 
-sint8 m2m_periph_gpio_pullup_ctrl(uint8 u8GpioNum, uint8 u8PullupEn)
+sint8 m2m_periph_gpio_pullup_ctrl(winc1500_t *dev, uint8 u8GpioNum, uint8 u8PullupEn)
 {
+	(void)dev;
 	/* TBD */
 	return M2M_SUCCESS;
 }
 
-sint8 m2m_periph_i2c_master_init(tstrI2cMasterInitParam * param)
+sint8 m2m_periph_i2c_master_init(winc1500_t *dev, tstrI2cMasterInitParam * param)
 {
+	(void)dev;
 	/* TBD */
 	return M2M_SUCCESS;
 }
 
-sint8 m2m_periph_i2c_master_write(uint8 u8SlaveAddr, uint8 * pu8Buf, uint16 u16BufLen, uint8 flags)
+sint8 m2m_periph_i2c_master_write(winc1500_t *dev, uint8 u8SlaveAddr, uint8 * pu8Buf, uint16 u16BufLen, uint8 flags)
 {
+	(void)dev;
 	/* TBD */
 	return M2M_SUCCESS;
 }
 
-sint8 m2m_periph_i2c_master_read(uint8 u8SlaveAddr, uint8 * pu8Buf, uint16 u16BufLen, uint16 * pu16ReadLen, uint8 flags)
+sint8 m2m_periph_i2c_master_read(winc1500_t *dev, uint8 u8SlaveAddr, uint8 * pu8Buf, uint16 u16BufLen, uint16 * pu16ReadLen, uint8 flags)
 {
+	(void)dev;
 	/* TBD */
 	return M2M_SUCCESS;
 }
 
 
-sint8 m2m_periph_pullup_ctrl(uint32 pinmask, uint8 enable)
+sint8 m2m_periph_pullup_ctrl(winc1500_t *dev, uint32 pinmask, uint8 enable)
 {
-	return pullup_ctrl(pinmask, enable);
+	return pullup_ctrl(dev, pinmask, enable);
 }
 #endif /* CONF_PERIPH */
\ No newline at end of file
diff --git a/winc1500/driver/source/m2m_ssl.c b/winc1500/driver/source/m2m_ssl.c
index 98bd7f7..96609da 100644
--- a/winc1500/driver/source/m2m_ssl.c
+++ b/winc1500/driver/source/m2m_ssl.c
@@ -39,10 +39,14 @@
  *
  */
 
+// Disabled when RIOT's network stack is used.
+#if	!defined(MODULE_NETDEV_ETH)
+
 /*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
 INCLUDES
 *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
 
+#include "bsp/include/nm_bsp.h"
 #include "driver/include/m2m_ssl.h"
 #include "driver/source/m2m_hif.h"
 #include "driver/source/nmasic.h"
@@ -54,8 +58,6 @@ MACROS
 /*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
 DATA TYPES
 *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
-static tpfAppSSLCb gpfAppSSLCb = NULL;
-static uint32 gu32HIFAddr = 0;
 
 /*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
 FUNCTION PROTOTYPES
@@ -71,23 +73,24 @@ FUNCTION PROTOTYPES
 	@param [in]	u32Addr
 				HIF address.
 */
-static void m2m_ssl_cb(uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
+static void m2m_ssl_cb(winc1500_t *dev, uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	(void)u16DataSize;
-	
+
 	sint8 s8tmp = M2M_SUCCESS;
 	switch(u8OpCode)
 	{
 		case M2M_SSL_REQ_ECC:
 		{
 			tstrEccReqInfo strEccREQ;
-			s8tmp = hif_receive(u32Addr, (uint8*)&strEccREQ, sizeof(tstrEccReqInfo), 0);
+			s8tmp = hif_receive(dev, u32Addr, (uint8*)&strEccREQ, sizeof(tstrEccReqInfo), 0);
 			if(s8tmp == M2M_SUCCESS)
 			{
-				if (gpfAppSSLCb)
+				if (internal->gpfAppSSLCb)
 				{
-					gu32HIFAddr = u32Addr + sizeof(tstrEccReqInfo);
-					gpfAppSSLCb(M2M_SSL_REQ_ECC, &strEccREQ);
+					internal->gu32HIFAddr = u32Addr + sizeof(tstrEccReqInfo);
+					internal->gpfAppSSLCb(dev, M2M_SSL_REQ_ECC, &strEccREQ);
 				}
 			}
 		}
@@ -95,11 +98,11 @@ static void m2m_ssl_cb(uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
 		case M2M_SSL_RESP_SET_CS_LIST:
 		{
 			tstrSslSetActiveCsList strCsList;
-			s8tmp = hif_receive(u32Addr, (uint8*)&strCsList, sizeof(tstrSslSetActiveCsList), 0);
+			s8tmp = hif_receive(dev, u32Addr, (uint8*)&strCsList, sizeof(tstrSslSetActiveCsList), 0);
 			if(s8tmp == M2M_SUCCESS)
 			{
-				if (gpfAppSSLCb)
-					gpfAppSSLCb(M2M_SSL_RESP_SET_CS_LIST, &strCsList);
+				if (internal->gpfAppSSLCb)
+					internal->gpfAppSSLCb(dev, M2M_SSL_RESP_SET_CS_LIST, &strCsList);
 			}
 		}
 		break;
@@ -122,11 +125,11 @@ static void m2m_ssl_cb(uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
 				Response data size.
 	@return		The function SHALL return 0 for success and a negative value otherwise.
 */
-NMI_API sint8 m2m_ssl_handshake_rsp(tstrEccReqInfo* strECCResp, uint8* pu8RspDataBuff, uint16 u16RspDataSz)
+NMI_API sint8 m2m_ssl_handshake_rsp(winc1500_t *dev, tstrEccReqInfo* strECCResp, uint8* pu8RspDataBuff, uint16 u16RspDataSz)
 {
 	sint8 s8Ret = M2M_SUCCESS;
-	
-	s8Ret = hif_send(M2M_REQ_GROUP_SSL, (M2M_SSL_RESP_ECC | M2M_REQ_DATA_PKT), (uint8*)strECCResp, sizeof(tstrEccReqInfo), pu8RspDataBuff, u16RspDataSz, sizeof(tstrEccReqInfo));
+
+	s8Ret = hif_send(dev, M2M_REQ_GROUP_SSL, (M2M_SSL_RESP_ECC | M2M_REQ_DATA_PKT), (uint8*)strECCResp, sizeof(tstrEccReqInfo), pu8RspDataBuff, u16RspDataSz, sizeof(tstrEccReqInfo));
 
 	return s8Ret;
 }
@@ -140,11 +143,11 @@ NMI_API sint8 m2m_ssl_handshake_rsp(tstrEccReqInfo* strECCResp, uint8* pu8RspDat
 				Size of the certificates.
 	@return		The function SHALL return 0 for success and a negative value otherwise.
 */
-NMI_API sint8 m2m_ssl_send_certs_to_winc(uint8* pu8Buffer, uint32 u32BufferSz)
+NMI_API sint8 m2m_ssl_send_certs_to_winc(winc1500_t *dev, uint8* pu8Buffer, uint32 u32BufferSz)
 {
 	sint8 s8Ret = M2M_SUCCESS;
 
-	s8Ret = hif_send(M2M_REQ_GROUP_SSL, (M2M_SSL_IND_CERTS_ECC | M2M_REQ_DATA_PKT), NULL, 0, pu8Buffer, u32BufferSz, 0);
+	s8Ret = hif_send(dev, M2M_REQ_GROUP_SSL, (M2M_SSL_IND_CERTS_ECC | M2M_REQ_DATA_PKT), NULL, 0, pu8Buffer, u32BufferSz, 0);
 
 	return s8Ret;
 }
@@ -162,39 +165,40 @@ NMI_API sint8 m2m_ssl_send_certs_to_winc(uint8* pu8Buffer, uint32 u32BufferSz)
 				Pointer to the certificate Key.
 	@return		The function SHALL return 0 for success and a negative value otherwise.
 */
-NMI_API sint8 m2m_ssl_retrieve_cert(uint16* pu16CurveType, uint8* pu8Hash, uint8* pu8Sig, tstrECPoint* pu8Key)
+NMI_API sint8 m2m_ssl_retrieve_cert(winc1500_t *dev, uint16* pu16CurveType, uint8* pu8Hash, uint8* pu8Sig, tstrECPoint* pu8Key)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	uint8	bSetRxDone	= 1;
 	uint16	u16HashSz, u16SigSz, u16KeySz;
 	sint8	s8Ret = M2M_SUCCESS;
 
-	if(gu32HIFAddr == 0) return M2M_ERR_FAIL;
-	
-	if(hif_receive(gu32HIFAddr, (uint8*)pu16CurveType, 2, 0) != M2M_SUCCESS) goto __ERR;
-	gu32HIFAddr += 2;
+	if(internal->gu32HIFAddr == 0) return M2M_ERR_FAIL;
 
-	if(hif_receive(gu32HIFAddr, (uint8*)&u16KeySz, 2, 0) != M2M_SUCCESS) goto __ERR;
-	gu32HIFAddr += 2;
+	if(hif_receive(dev, internal->gu32HIFAddr, (uint8*)pu16CurveType, 2, 0) != M2M_SUCCESS) goto __ERR;
+	internal->gu32HIFAddr += 2;
 
-	if(hif_receive(gu32HIFAddr, (uint8*)&u16HashSz, 2, 0) != M2M_SUCCESS) goto __ERR;
-	gu32HIFAddr += 2;
+	if(hif_receive(dev, internal->gu32HIFAddr, (uint8*)&u16KeySz, 2, 0) != M2M_SUCCESS) goto __ERR;
+	internal->gu32HIFAddr += 2;
 
-	if(hif_receive(gu32HIFAddr, (uint8*)&u16SigSz, 2, 0) != M2M_SUCCESS) goto __ERR;
-	gu32HIFAddr += 2;
+	if(hif_receive(dev, internal->gu32HIFAddr, (uint8*)&u16HashSz, 2, 0) != M2M_SUCCESS) goto __ERR;
+	internal->gu32HIFAddr += 2;
+
+	if(hif_receive(dev, internal->gu32HIFAddr, (uint8*)&u16SigSz, 2, 0) != M2M_SUCCESS) goto __ERR;
+	internal->gu32HIFAddr += 2;
 
 	(*pu16CurveType)= _htons((*pu16CurveType));
 	pu8Key->u16Size	= _htons(u16KeySz);
 	u16HashSz		= _htons(u16HashSz);
 	u16SigSz		= _htons(u16SigSz);
 	
-	if(hif_receive(gu32HIFAddr, pu8Key->X, pu8Key->u16Size * 2, 0) != M2M_SUCCESS) goto __ERR;
-	gu32HIFAddr += (pu8Key->u16Size * 2);
+	if(hif_receive(dev, internal->gu32HIFAddr, pu8Key->X, pu8Key->u16Size * 2, 0) != M2M_SUCCESS) goto __ERR;
+	internal->gu32HIFAddr += (pu8Key->u16Size * 2);
 
-	if(hif_receive(gu32HIFAddr, pu8Hash, u16HashSz, 0) != M2M_SUCCESS) goto __ERR;
-	gu32HIFAddr += u16HashSz;
+	if(hif_receive(dev, internal->gu32HIFAddr, pu8Hash, u16HashSz, 0) != M2M_SUCCESS) goto __ERR;
+	internal->gu32HIFAddr += u16HashSz;
 
-	if(hif_receive(gu32HIFAddr, pu8Sig, u16SigSz, 0) != M2M_SUCCESS) goto __ERR;
-	gu32HIFAddr += u16SigSz;
+	if(hif_receive(dev, internal->gu32HIFAddr, pu8Sig, u16SigSz, 0) != M2M_SUCCESS) goto __ERR;
+	internal->gu32HIFAddr += u16SigSz;
 	
 	bSetRxDone = 0;
 
@@ -202,7 +206,7 @@ __ERR:
 	if(bSetRxDone)
 	{
 		s8Ret = M2M_ERR_FAIL;
-		hif_receive(0, NULL, 0, 1);
+		hif_receive(dev, 0, NULL, 0, 1);
 	}
 	return s8Ret;
 }
@@ -216,14 +220,15 @@ __ERR:
 				Hash size.
 	@return		The function SHALL return 0 for success and a negative value otherwise.
 */
-NMI_API sint8 m2m_ssl_retrieve_hash(uint8* pu8Hash, uint16 u16HashSz)
+NMI_API sint8 m2m_ssl_retrieve_hash(winc1500_t *dev, uint8* pu8Hash, uint16 u16HashSz)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	uint8	bSetRxDone	= 1;
 	sint8	s8Ret = M2M_SUCCESS;
 
-	if(gu32HIFAddr == 0) return M2M_ERR_FAIL;
+	if(internal->gu32HIFAddr == 0) return M2M_ERR_FAIL;
 
-	if(hif_receive(gu32HIFAddr, pu8Hash, u16HashSz, 0) != M2M_SUCCESS) goto __ERR;
+	if(hif_receive(dev, internal->gu32HIFAddr, pu8Hash, u16HashSz, 0) != M2M_SUCCESS) goto __ERR;
 	
 	bSetRxDone = 0;
 
@@ -231,7 +236,7 @@ __ERR:
 	if(bSetRxDone)
 	{
 		s8Ret = M2M_ERR_FAIL;
-		hif_receive(0, NULL, 0, 1);
+		hif_receive(dev, 0, NULL, 0, 1);
 	}
 	return s8Ret;
 }
@@ -240,18 +245,19 @@ __ERR:
 	@fn	\	m2m_ssl_stop_processing_certs(void)
 	@brief	Stops receiving from the HIF
 */
-NMI_API void m2m_ssl_stop_processing_certs(void)
+NMI_API void m2m_ssl_stop_processing_certs(winc1500_t *dev)
 {
-	hif_receive(0, NULL, 0, 1);
+	hif_receive(dev, 0, NULL, 0, 1);
 }
 
 /*!
 	@fn	\	m2m_ssl_ecc_process_done(void)
 	@brief	Stops receiving from the HIF
 */
-NMI_API void m2m_ssl_ecc_process_done(void)
+NMI_API void m2m_ssl_ecc_process_done(winc1500_t *dev)
 {
-	gu32HIFAddr = 0;
+	winc1500_internal_t *internal = &dev->internal;
+	internal->gu32HIFAddr = 0;
 }
 
 /*!
@@ -274,13 +280,13 @@ NMI_API void m2m_ssl_ecc_process_done(void)
 	- [SOCK_ERR_NO_ERROR](@ref SOCK_ERR_NO_ERROR)
 	- [SOCK_ERR_INVALID_ARG](@ref SOCK_ERR_INVALID_ARG)
 */
-sint8 m2m_ssl_set_active_ciphersuites(uint32 u32SslCsBMP)
+sint8 m2m_ssl_set_active_ciphersuites(winc1500_t *dev, uint32 u32SslCsBMP)
 {
 	sint8 s8Ret = M2M_SUCCESS;
 	tstrSslSetActiveCsList	strCsList;
-	
+
 	strCsList.u32CsBMP = u32SslCsBMP;
-	s8Ret = hif_send(M2M_REQ_GROUP_SSL, M2M_SSL_REQ_SET_CS_LIST, (uint8*)&strCsList, sizeof(tstrSslSetActiveCsList), NULL, 0, 0);
+	s8Ret = hif_send(dev, M2M_REQ_GROUP_SSL, M2M_SSL_REQ_SET_CS_LIST, (uint8*)&strCsList, sizeof(tstrSslSetActiveCsList), NULL, 0, 0);
 
 	return s8Ret;
 }
@@ -292,17 +298,20 @@ sint8 m2m_ssl_set_active_ciphersuites(uint32 u32SslCsBMP)
 	Application SSL callback function.
 	@return		The function SHALL return 0 for success and a negative value otherwise.
 */
-NMI_API sint8 m2m_ssl_init(tpfAppSSLCb pfAppSSLCb)
+NMI_API sint8 m2m_ssl_init(winc1500_t *dev, tpfAppSSLCb pfAppSSLCb)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	sint8 s8Ret = M2M_SUCCESS;
 
-	gpfAppSSLCb = pfAppSSLCb;
-	gu32HIFAddr = 0;
+	internal->gpfAppSSLCb = pfAppSSLCb;
+	internal->gu32HIFAddr = 0;
 
-	s8Ret = hif_register_cb(M2M_REQ_GROUP_SSL,m2m_ssl_cb);
+	s8Ret = hif_register_cb(dev, M2M_REQ_GROUP_SSL,m2m_ssl_cb);
 	if (s8Ret != M2M_SUCCESS)
 	{
 		M2M_ERR("hif_register_cb() failed with ret=%d", s8Ret);
 	}
 	return s8Ret;
-}
\ No newline at end of file
+}
+
+#endif	// !defined(MODULE_NETDEV_ETH)
\ No newline at end of file
diff --git a/winc1500/driver/source/m2m_wifi.c b/winc1500/driver/source/m2m_wifi.c
index 9311764..2168f00 100644
--- a/winc1500/driver/source/m2m_wifi.c
+++ b/winc1500/driver/source/m2m_wifi.c
@@ -39,34 +39,12 @@
  *
  */
 
+#include "bsp/include/nm_bsp.h"
 #include "driver/include/m2m_wifi.h"
 #include "driver/source/m2m_hif.h"
 #include "driver/source/nmasic.h"
 
-static volatile uint8 gu8ChNum;
-/* This will be used globally in winc1500_callback.c */
-volatile uint8_t gu8scanInProgress = 0;
-static tpfAppWifiCb gpfAppWifiCb = NULL;
 
-
-#ifdef ETH_MODE
-static tpfAppEthCb  gpfAppEthCb  = NULL;
-static uint8* 	        gau8ethRcvBuf=NULL;
-static uint16 	        gu16ethRcvBufSize ;
-#endif
-
-
-//#define CONF_MGMT
-#ifdef CONF_MGMT
-static tpfAppMonCb  gpfAppMonCb  = NULL;
-static struct _tstrMgmtCtrl
-{
-	uint8* pu8Buf;
-	uint16 u16Offset;
-	uint16 u16Sz;
-}
-gstrMgmtCtrl = {NULL, 0 , 0};
-#endif
 /**
 *	@fn			m2m_wifi_cb(uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr, uint8 grp)
 *	@brief		WiFi call back function
@@ -84,34 +62,35 @@ gstrMgmtCtrl = {NULL, 0 , 0};
 */
 /* RIOT implements its own wifi callback */
 #ifndef MODULE_WINC1500
-static void m2m_wifi_cb(uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
+static void m2m_wifi_cb(winc1500_t *dev, uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	uint8 rx_buf[8];
 	if (u8OpCode == M2M_WIFI_RESP_CON_STATE_CHANGED)
 	{
 		tstrM2mWifiStateChanged strState;
-		if (hif_receive(u32Addr, (uint8*) &strState,sizeof(tstrM2mWifiStateChanged), 0) == M2M_SUCCESS)
+		if (hif_receive(dev, u32Addr, (uint8*) &strState,sizeof(tstrM2mWifiStateChanged), 0) == M2M_SUCCESS)
 		{
-			if (gpfAppWifiCb)
-				gpfAppWifiCb(M2M_WIFI_RESP_CON_STATE_CHANGED, &strState);
+			if (internal->gpfAppWifiCb)
+				internal->gpfAppWifiCb(dev, M2M_WIFI_RESP_CON_STATE_CHANGED, &strState);
 		}
 	}
 	else if (u8OpCode == M2M_WIFI_RESP_GET_SYS_TIME)
 	{
 		tstrSystemTime strSysTime;
-		if (hif_receive(u32Addr, (uint8*) &strSysTime,sizeof(tstrSystemTime), 0) == M2M_SUCCESS)
+		if (hif_receive(dev, u32Addr, (uint8*) &strSysTime,sizeof(tstrSystemTime), 0) == M2M_SUCCESS)
 		{
-			if (gpfAppWifiCb)
-				gpfAppWifiCb(M2M_WIFI_RESP_GET_SYS_TIME, &strSysTime);
+			if (internal->gpfAppWifiCb)
+				internal->gpfAppWifiCb(dev, M2M_WIFI_RESP_GET_SYS_TIME, &strSysTime);
 		}
 	}
 	else if(u8OpCode == M2M_WIFI_RESP_CONN_INFO)
 	{
 		tstrM2MConnInfo		strConnInfo;
-		if(hif_receive(u32Addr, (uint8*)&strConnInfo, sizeof(tstrM2MConnInfo), 1) == M2M_SUCCESS)
+		if(hif_receive(dev, u32Addr, (uint8*)&strConnInfo, sizeof(tstrM2MConnInfo), 1) == M2M_SUCCESS)
 		{
-			if(gpfAppWifiCb)
-				gpfAppWifiCb(M2M_WIFI_RESP_CONN_INFO, &strConnInfo);
+			if(internal->gpfAppWifiCb)
+				internal->gpfAppWifiCb(dev, M2M_WIFI_RESP_CONN_INFO, &strConnInfo);
 		}
 	}
 	else if (u8OpCode == M2M_WIFI_RESP_MEMORY_RECOVER)
@@ -129,31 +108,31 @@ static void m2m_wifi_cb(uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
 	else if (u8OpCode == M2M_WIFI_REQ_DHCP_CONF)
 	{
 		tstrM2MIPConfig strIpConfig;
-		if (hif_receive(u32Addr, (uint8 *)&strIpConfig, sizeof(tstrM2MIPConfig), 0) == M2M_SUCCESS)
+		if (hif_receive(dev, u32Addr, (uint8 *)&strIpConfig, sizeof(tstrM2MIPConfig), 0) == M2M_SUCCESS)
 		{
-			if (gpfAppWifiCb)
-				gpfAppWifiCb(M2M_WIFI_REQ_DHCP_CONF, (uint8 *)&strIpConfig);
+			if (internal->gpfAppWifiCb)
+				internal->gpfAppWifiCb(dev, M2M_WIFI_REQ_DHCP_CONF, (uint8 *)&strIpConfig);
 		}
 	}
 	else if (u8OpCode == M2M_WIFI_REQ_WPS)
 	{
 		tstrM2MWPSInfo strWps;
 		m2m_memset((uint8*)&strWps,0,sizeof(tstrM2MWPSInfo));
-		if(hif_receive(u32Addr, (uint8*)&strWps, sizeof(tstrM2MWPSInfo), 0) == M2M_SUCCESS)
+		if(hif_receive(dev, u32Addr, (uint8*)&strWps, sizeof(tstrM2MWPSInfo), 0) == M2M_SUCCESS)
 		{
-			if (gpfAppWifiCb)
-				gpfAppWifiCb(M2M_WIFI_REQ_WPS, &strWps);
+			if (internal->gpfAppWifiCb)
+				internal->gpfAppWifiCb(dev, M2M_WIFI_REQ_WPS, &strWps);
 		}
 	}
 	else if (u8OpCode == M2M_WIFI_RESP_IP_CONFLICT)
 	{
 		uint32  u32ConflictedIP;
-		if(hif_receive(u32Addr, (uint8 *)&u32ConflictedIP, sizeof(u32ConflictedIP), 0) == M2M_SUCCESS)
+		if(hif_receive(dev, u32Addr, (uint8 *)&u32ConflictedIP, sizeof(u32ConflictedIP), 0) == M2M_SUCCESS)
 		{
-			M2M_INFO("Conflicted IP \" %u.%u.%u.%u \" \n", 
+			M2M_INFO("Conflicted IP \" %u.%u.%u.%u \" \n",
 				BYTE_0(u32ConflictedIP),BYTE_1(u32ConflictedIP),BYTE_2(u32ConflictedIP),BYTE_3(u32ConflictedIP));
-			if (gpfAppWifiCb)
-				gpfAppWifiCb(M2M_WIFI_RESP_IP_CONFLICT, NULL);
+			if (internal->gpfAppWifiCb)
+				internal->gpfAppWifiCb(dev, M2M_WIFI_RESP_IP_CONFLICT, NULL);
 
 		}
 	}
@@ -161,66 +140,66 @@ static void m2m_wifi_cb(uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
 	{
 		tstrM2mScanDone strState;
 		gu8scanInProgress = 0;
-		if(hif_receive(u32Addr, (uint8*)&strState, sizeof(tstrM2mScanDone), 0) == M2M_SUCCESS)
+		if(hif_receive(dev, u32Addr, (uint8*)&strState, sizeof(tstrM2mScanDone), 0) == M2M_SUCCESS)
 		{
 			gu8ChNum = strState.u8NumofCh;
-			if (gpfAppWifiCb)
-				gpfAppWifiCb(M2M_WIFI_RESP_SCAN_DONE, &strState);
+			if (internal->gpfAppWifiCb)
+				internal->gpfAppWifiCb(dev, M2M_WIFI_RESP_SCAN_DONE, &strState);
 		}
 	}
 	else if (u8OpCode == M2M_WIFI_RESP_SCAN_RESULT)
 	{
 		tstrM2mWifiscanResult strScanResult;
-		if(hif_receive(u32Addr, (uint8*)&strScanResult, sizeof(tstrM2mWifiscanResult), 0) == M2M_SUCCESS)
+		if(hif_receive(dev, u32Addr, (uint8*)&strScanResult, sizeof(tstrM2mWifiscanResult), 0) == M2M_SUCCESS)
 		{
-			if (gpfAppWifiCb)
-				gpfAppWifiCb(M2M_WIFI_RESP_SCAN_RESULT, &strScanResult);
+			if (internal->gpfAppWifiCb)
+				internal->gpfAppWifiCb(dev, M2M_WIFI_RESP_SCAN_RESULT, &strScanResult);
 		}
 	}
 	else if (u8OpCode == M2M_WIFI_RESP_CURRENT_RSSI)
 	{
-		if (hif_receive(u32Addr, rx_buf, 4, 0) == M2M_SUCCESS)
+		if (hif_receive(dev, u32Addr, rx_buf, 4, 0) == M2M_SUCCESS)
 		{
-			if (gpfAppWifiCb)
-				gpfAppWifiCb(M2M_WIFI_RESP_CURRENT_RSSI, rx_buf);
+			if (internal->gpfAppWifiCb)
+				internal->gpfAppWifiCb(dev, M2M_WIFI_RESP_CURRENT_RSSI, rx_buf);
 		}
 	}
 	else if (u8OpCode == M2M_WIFI_RESP_CLIENT_INFO)
 	{
-		if (hif_receive(u32Addr, rx_buf, 4, 0) == M2M_SUCCESS)
+		if (hif_receive(dev, u32Addr, rx_buf, 4, 0) == M2M_SUCCESS)
 		{
-			if (gpfAppWifiCb)
-				gpfAppWifiCb(M2M_WIFI_RESP_CLIENT_INFO, rx_buf);
+			if (internal->gpfAppWifiCb)
+				internal->gpfAppWifiCb(dev, M2M_WIFI_RESP_CLIENT_INFO, rx_buf);
 		}
 	}
 	else if(u8OpCode == M2M_WIFI_RESP_PROVISION_INFO)
 	{
 		tstrM2MProvisionInfo	strProvInfo;
-		if(hif_receive(u32Addr, (uint8*)&strProvInfo, sizeof(tstrM2MProvisionInfo), 1) == M2M_SUCCESS)
+		if(hif_receive(dev, u32Addr, (uint8*)&strProvInfo, sizeof(tstrM2MProvisionInfo), 1) == M2M_SUCCESS)
 		{
-			if(gpfAppWifiCb)
-				gpfAppWifiCb(M2M_WIFI_RESP_PROVISION_INFO, &strProvInfo);
+			if(internal->gpfAppWifiCb)
+				internal->gpfAppWifiCb(dev, M2M_WIFI_RESP_PROVISION_INFO, &strProvInfo);
 		}
 	}
 	else if(u8OpCode == M2M_WIFI_RESP_DEFAULT_CONNECT)
 	{
 		tstrM2MDefaultConnResp	strResp;
-		if(hif_receive(u32Addr, (uint8*)&strResp, sizeof(tstrM2MDefaultConnResp), 1) == M2M_SUCCESS)
+		if(hif_receive(dev, u32Addr, (uint8*)&strResp, sizeof(tstrM2MDefaultConnResp), 1) == M2M_SUCCESS)
 		{
-			if(gpfAppWifiCb)
-				gpfAppWifiCb(M2M_WIFI_RESP_DEFAULT_CONNECT, &strResp);
+			if(internal->gpfAppWifiCb)
+				internal->gpfAppWifiCb(dev, M2M_WIFI_RESP_DEFAULT_CONNECT, &strResp);
 		}
 	}
-	
+
 	else if(u8OpCode == M2M_WIFI_RESP_GET_PRNG)
 	{
 		tstrPrng strPrng;
-		if(hif_receive(u32Addr, (uint8*)&strPrng,sizeof(tstrPrng), 0) == M2M_SUCCESS)
+		if(hif_receive(dev, u32Addr, (uint8*)&strPrng,sizeof(tstrPrng), 0) == M2M_SUCCESS)
 		{
-			if(hif_receive(u32Addr + sizeof(tstrPrng),strPrng.pu8RngBuff,strPrng.u16PrngSize, 1) == M2M_SUCCESS)
+			if(hif_receive(dev, u32Addr + sizeof(tstrPrng),strPrng.pu8RngBuff,strPrng.u16PrngSize, 1) == M2M_SUCCESS)
 			{
-				if(gpfAppWifiCb)
-					gpfAppWifiCb(M2M_WIFI_RESP_GET_PRNG,&strPrng);
+				if(internal->gpfAppWifiCb)
+					internal->gpfAppWifiCb(dev, M2M_WIFI_RESP_GET_PRNG,&strPrng);
 			}
 		}
 	}
@@ -229,31 +208,31 @@ static void m2m_wifi_cb(uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
 		{
 			uint8 u8SetRxDone;
 			tstrM2mIpRsvdPkt strM2mRsvd;
-			if(hif_receive(u32Addr, &strM2mRsvd ,sizeof(tstrM2mIpRsvdPkt), 0) == M2M_SUCCESS)
+			if(hif_receive(dev, u32Addr, &strM2mRsvd ,sizeof(tstrM2mIpRsvdPkt), 0) == M2M_SUCCESS)
 			{
 				tstrM2mIpCtrlBuf  strM2mIpCtrlBuf;
 				uint16 u16Offset = strM2mRsvd.u16PktOffset;
 				strM2mIpCtrlBuf.u16RemainigDataSize = strM2mRsvd.u16PktSz;
-				if((gpfAppEthCb) && (gau8ethRcvBuf) && (gu16ethRcvBufSize > 0))
+				if((internal->gpfAppEthCb) && (internal->gau8ethRcvBuf) && (internal->gu16ethRcvBufSize > 0))
 				{
 					do
 					{
 						u8SetRxDone = 1;
-						if(strM2mIpCtrlBuf.u16RemainigDataSize > gu16ethRcvBufSize)
+						if(strM2mIpCtrlBuf.u16RemainigDataSize > internal->gu16ethRcvBufSize)
 						{
 							u8SetRxDone = 0;
-							strM2mIpCtrlBuf.u16DataSize = gu16ethRcvBufSize;
+							strM2mIpCtrlBuf.u16DataSize = internal->gu16ethRcvBufSize;
 						}
 						else
 						{
 							strM2mIpCtrlBuf.u16DataSize = strM2mIpCtrlBuf.u16RemainigDataSize;
 						}
 
-						if(hif_receive(u32Addr + u16Offset, gau8ethRcvBuf, strM2mIpCtrlBuf.u16DataSize, u8SetRxDone) == M2M_SUCCESS)
+						if(hif_receive(dev, u32Addr + u16Offset, internal->gau8ethRcvBuf, strM2mIpCtrlBuf.u16DataSize, u8SetRxDone) == M2M_SUCCESS)
 						{
-							strM2mIpCtrlBuf.u16RemainigDataSize -= strM2mIpCtrlBuf.u16DataSize;							
+							strM2mIpCtrlBuf.u16RemainigDataSize -= strM2mIpCtrlBuf.u16DataSize;
 							u16Offset += strM2mIpCtrlBuf.u16DataSize;
-							gpfAppEthCb(M2M_WIFI_RESP_ETHERNET_RX_PACKET, gau8ethRcvBuf, &(strM2mIpCtrlBuf));
+							internal->gpfAppEthCb(dev, M2M_WIFI_RESP_ETHERNET_RX_PACKET, internal->gau8ethRcvBuf, &(strM2mIpCtrlBuf));
 						}
 						else
 						{
@@ -267,23 +246,23 @@ static void m2m_wifi_cb(uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
 #ifdef CONF_MGMT
 	else if(u8OpCode == M2M_WIFI_RESP_WIFI_RX_PACKET)
 	{
-		
+
 		tstrM2MWifiRxPacketInfo		strRxPacketInfo;
 		if(u16DataSize >= sizeof(tstrM2MWifiRxPacketInfo)) {
-			if(hif_receive(u32Addr, (uint8*)&strRxPacketInfo, sizeof(tstrM2MWifiRxPacketInfo), 0) == M2M_SUCCESS)
+			if(hif_receive(dev, u32Addr, (uint8*)&strRxPacketInfo, sizeof(tstrM2MWifiRxPacketInfo), 0) == M2M_SUCCESS)
 			{
 				u16DataSize -= sizeof(tstrM2MWifiRxPacketInfo);
-				if(u16DataSize > 0 && gstrMgmtCtrl.pu8Buf != NULL)
+				if(u16DataSize > 0 && internal->gstrMgmtCtrl.pu8Buf != NULL)
 				{
-					if(u16DataSize > (gstrMgmtCtrl.u16Sz + gstrMgmtCtrl.u16Offset))
+					if(u16DataSize > (internal->gstrMgmtCtrl.u16Sz + internal->gstrMgmtCtrl.u16Offset))
 					{
-						u16DataSize = gstrMgmtCtrl.u16Sz;
+						u16DataSize = internal->gstrMgmtCtrl.u16Sz;
 					}
-					u32Addr += sizeof(tstrM2MWifiRxPacketInfo) + gstrMgmtCtrl.u16Offset;
-					if(hif_receive(u32Addr , gstrMgmtCtrl.pu8Buf, u16DataSize, 1) != M2M_SUCCESS) return;
+					u32Addr += sizeof(tstrM2MWifiRxPacketInfo) + internal->gstrMgmtCtrl.u16Offset;
+					if(hif_receive(dev, u32Addr , internal->gstrMgmtCtrl.pu8Buf, u16DataSize, 1) != M2M_SUCCESS) return;
 				}
-				if(gpfAppMonCb)
-					gpfAppMonCb(&strRxPacketInfo, gstrMgmtCtrl.pu8Buf,u16DataSize);
+				if(internal->gpfAppMonCb)
+					gpfAppMonCb(dev, &strRxPacketInfo, internal->gstrMgmtCtrl.pu8Buf,u16DataSize);
 			}
 		} else {
 			M2M_ERR("Incorrect mon data size %u\n", u16DataSize);
@@ -297,23 +276,24 @@ static void m2m_wifi_cb(uint8 u8OpCode, uint16 u16DataSize, uint32 u32Addr)
 }
 #endif
 
-sint8 m2m_wifi_download_mode(void)
+sint8 m2m_wifi_download_mode(winc1500_t *dev)
 {
 	sint8 ret = M2M_SUCCESS;
 	/* Apply device specific initialization. */
-	ret = nm_drv_init_download_mode();
+	ret = nm_drv_init_download_mode(dev);
 	if(ret != M2M_SUCCESS) 	goto _EXIT0;
 
 
 
-	enable_interrupts();
+	enable_interrupts(dev);
 
 _EXIT0:
 	return ret;
 }
 
-static sint8 m2m_validate_ap_parameters(WINC1500_CONST tstrM2MAPConfig* pstrM2MAPConfig)
+static sint8 m2m_validate_ap_parameters(winc1500_t *dev, WINC1500_CONST tstrM2MAPConfig* pstrM2MAPConfig)
 {
+	(void)dev;
 	sint8 s8Ret = M2M_SUCCESS;
 	/* Check for incoming pointer */
 	if(pstrM2MAPConfig == NULL)
@@ -393,12 +373,13 @@ static sint8 m2m_validate_ap_parameters(WINC1500_CONST tstrM2MAPConfig* pstrM2MA
 		s8Ret = M2M_ERR_FAIL;
 		goto ERR1;
 	}
-	
+
 ERR1:
 	return s8Ret;
 }
-static sint8 m2m_validate_scan_options(tstrM2MScanOption* ptstrM2MScanOption)
+static sint8 m2m_validate_scan_options(winc1500_t *dev, tstrM2MScanOption* ptstrM2MScanOption)
 {
+	(void) dev;
 	sint8 s8Ret = M2M_SUCCESS;
 	/* Check for incoming pointer */
 	if(ptstrM2MScanOption == NULL)
@@ -439,47 +420,48 @@ ERR:
 	return s8Ret;
 }
 
-sint8 m2m_wifi_send_crl(tstrTlsCrlInfo* pCRL)
+sint8 m2m_wifi_send_crl(winc1500_t *dev, tstrTlsCrlInfo* pCRL)
 {
 	sint8 s8Ret = M2M_ERR_FAIL;
-	s8Ret = hif_send(M2M_REQ_GROUP_SSL, M2M_SSL_IND_CRL|M2M_REQ_DATA_PKT, NULL, 0, (uint8*)pCRL, sizeof(tstrTlsCrlInfo), 0);
+	s8Ret = hif_send(dev, M2M_REQ_GROUP_SSL, M2M_SSL_IND_CRL|M2M_REQ_DATA_PKT, NULL, 0, (uint8*)pCRL, sizeof(tstrTlsCrlInfo), 0);
 	return s8Ret;
 }
 
-sint8 m2m_wifi_init(tstrWifiInitParam * param)
+sint8 m2m_wifi_init(winc1500_t *dev, tstrWifiInitParam * param)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	tstrM2mRev strtmp;
 	sint8 ret = M2M_SUCCESS;
 	uint8 u8WifiMode = M2M_WIFI_MODE_NORMAL;
-	
+
 	if(param == NULL) {
 		ret = M2M_ERR_FAIL;
 		goto _EXIT0;
 	}
-	
-	gpfAppWifiCb = param->pfAppWifiCb;
+
+	internal->gpfAppWifiCb = param->pfAppWifiCb;
 
 #ifdef ETH_MODE
-	gpfAppEthCb  	    = param->strEthInitParam.pfAppEthCb;
-	gau8ethRcvBuf       = param->strEthInitParam.au8ethRcvBuf;
-	gu16ethRcvBufSize	= param->strEthInitParam.u16ethRcvBufSize;
+	internal->gpfAppEthCb  	    = param->strEthInitParam.pfAppEthCb;
+	internal->gau8ethRcvBuf       = param->strEthInitParam.au8ethRcvBuf;
+	internal->gu16ethRcvBufSize	= param->strEthInitParam.u16ethRcvBufSize;
 	u8WifiMode = param->strEthInitParam.u8EthernetEnable;
 #endif /* ETH_MODE */
 
 #ifdef CONF_MGMT
-	gpfAppMonCb  = param->pfAppMonCb;
+	internal->gpfAppMonCb  = param->pfAppMonCb;
 #endif
-	gu8scanInProgress = 0;
+	internal->gu8scanInProgress = 0;
 	/* Apply device specific initialization. */
-	ret = nm_drv_init(&u8WifiMode);
+	ret = nm_drv_init(dev, &u8WifiMode);
 	if(ret != M2M_SUCCESS) 	goto _EXIT0;
 	/* Initialize host interface module */
-	ret = hif_init(NULL);
+	ret = hif_init(dev, NULL);
 	if(ret != M2M_SUCCESS) 	goto _EXIT1;
 
 	/* This will be called in RIOT's driver */
 	/* hif_register_cb(M2M_REQ_GROUP_WIFI,m2m_wifi_cb); */
-	ret = nm_get_firmware_full_info(&strtmp);
+	ret = nm_get_firmware_full_info(dev, &strtmp);
 
 	M2M_INFO("Firmware ver   : %u.%u.%u Svnrev %u\n", strtmp.u8FirmwareMajor, strtmp.u8FirmwareMinor, strtmp.u8FirmwarePatch,strtmp.u16FirmwareSvnNum);
 	M2M_INFO("Firmware Build %s Time %s\n",strtmp.BuildDate,strtmp.BuildTime);
@@ -494,40 +476,40 @@ sint8 m2m_wifi_init(tstrWifiInitParam * param)
 	goto _EXIT0;
 
 _EXIT1:
-	nm_drv_deinit(NULL);
+	nm_drv_deinit(dev, NULL);
 _EXIT0:
 	return ret;
 }
 
-sint8  m2m_wifi_deinit(void * arg)
+sint8  m2m_wifi_deinit(winc1500_t *dev, void * arg)
 {
 	(void)arg;
 
-	hif_deinit(NULL);
+	hif_deinit(dev, NULL);
 
-	nm_drv_deinit(NULL);
+	nm_drv_deinit(dev, NULL);
 
 	return M2M_SUCCESS;
 }
 
 
-sint8 m2m_wifi_handle_events(void * arg)
+sint8 m2m_wifi_handle_events(winc1500_t *dev, void * arg)
 {
 	(void)arg;
 
-	return hif_handle_isr();
+	return hif_handle_isr(dev);
 }
 
-sint8 m2m_wifi_default_connect(void)
+sint8 m2m_wifi_default_connect(winc1500_t *dev)
 {
-	return hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_DEFAULT_CONNECT, NULL, 0,NULL, 0,0);
+	return hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_DEFAULT_CONNECT, NULL, 0,NULL, 0,0);
 }
 
-sint8 m2m_wifi_connect(char *pcSsid, uint8 u8SsidLen, uint8 u8SecType, void *pvAuthInfo, uint16 u16Ch)
+sint8 m2m_wifi_connect(winc1500_t *dev, char *pcSsid, uint8 u8SsidLen, uint8 u8SecType, void *pvAuthInfo, uint16 u16Ch)
 {
-	return m2m_wifi_connect_sc(pcSsid, u8SsidLen, u8SecType, pvAuthInfo,  u16Ch,0);
+	return m2m_wifi_connect_sc(dev, pcSsid, u8SsidLen, u8SecType, pvAuthInfo,  u16Ch,0);
 }
-sint8 m2m_wifi_connect_sc(char *pcSsid, uint8 u8SsidLen, uint8 u8SecType, void *pvAuthInfo, uint16 u16Ch, uint8 u8NoSaveCred)
+sint8 m2m_wifi_connect_sc(winc1500_t *dev, char *pcSsid, uint8 u8SsidLen, uint8 u8SecType, void *pvAuthInfo, uint16 u16Ch, uint8 u8NoSaveCred)
 {
 	sint8				ret = M2M_SUCCESS;
 	tstrM2mWifiConnect	strConnect;
@@ -578,7 +560,7 @@ sint8 m2m_wifi_connect_sc(char *pcSsid, uint8 u8SsidLen, uint8 u8SecType, void *
 	m2m_memcpy(strConnect.au8SSID, (uint8*)pcSsid, u8SsidLen);
 	strConnect.au8SSID[u8SsidLen]	= 0;
 	strConnect.u16Ch				= NM_BSP_B_L_16(u16Ch);
-	/* Credentials will be Not be saved if u8NoSaveCred is set */ 
+	/* Credentials will be Not be saved if u8NoSaveCred is set */
 	strConnect.u8NoSaveCred 			= u8NoSaveCred ? 1:0;
 	pstrAuthInfo = &strConnect.strSec;
 	pstrAuthInfo->u8SecType		= u8SecType;
@@ -634,25 +616,25 @@ sint8 m2m_wifi_connect_sc(char *pcSsid, uint8 u8SsidLen, uint8 u8SecType, void *
 		goto ERR1;
 	}
 
-	ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_CONNECT, (uint8*)&strConnect, sizeof(tstrM2mWifiConnect),NULL, 0,0);
+	ret = hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_CONNECT, (uint8*)&strConnect, sizeof(tstrM2mWifiConnect),NULL, 0,0);
 
 ERR1:
 	return ret;
 }
 
-sint8 m2m_wifi_disconnect(void)
+sint8 m2m_wifi_disconnect(winc1500_t *dev)
 {
-	return hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_DISCONNECT, NULL, 0, NULL, 0,0);
+	return hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_DISCONNECT, NULL, 0, NULL, 0,0);
 }
-sint8 m2m_wifi_set_mac_address(uint8 au8MacAddress[6])
+sint8 m2m_wifi_set_mac_address(winc1500_t *dev, uint8 au8MacAddress[6])
 {
 	tstrM2mSetMacAddress strTmp;
 	m2m_memcpy((uint8*) strTmp.au8Mac, (uint8*) au8MacAddress, 6);
-	return hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_SET_MAC_ADDRESS,
+	return hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_SET_MAC_ADDRESS,
 		(uint8*) &strTmp, sizeof(tstrM2mSetMacAddress), NULL, 0,0);
 }
 
-sint8 m2m_wifi_set_static_ip(tstrM2MIPConfig * pstrStaticIPConf)
+sint8 m2m_wifi_set_static_ip(winc1500_t *dev, tstrM2MIPConfig * pstrStaticIPConf)
 {
 	pstrStaticIPConf->u32DNS = NM_BSP_B_L_32(pstrStaticIPConf->u32DNS);
 	pstrStaticIPConf->u32Gateway = NM_BSP_B_L_32(pstrStaticIPConf->u32Gateway);
@@ -660,17 +642,19 @@ sint8 m2m_wifi_set_static_ip(tstrM2MIPConfig * pstrStaticIPConf)
 		pstrStaticIPConf->u32StaticIP);
 	pstrStaticIPConf->u32SubnetMask = NM_BSP_B_L_32(
 		pstrStaticIPConf->u32SubnetMask);
-	return hif_send(M2M_REQ_GROUP_IP, M2M_IP_REQ_STATIC_IP_CONF,
+	return hif_send(dev, M2M_REQ_GROUP_IP, M2M_IP_REQ_STATIC_IP_CONF,
 		(uint8*) pstrStaticIPConf, sizeof(tstrM2MIPConfig), NULL, 0,0);
 }
 
-sint8 m2m_wifi_request_dhcp_client(void)
+sint8 m2m_wifi_request_dhcp_client(winc1500_t *dev)
 {
+	(void) dev;
 	/*legacy API should be removed */
 	return 0;
 }
-sint8 m2m_wifi_request_dhcp_server(uint8* addr)
+sint8 m2m_wifi_request_dhcp_server(winc1500_t *dev, uint8* addr)
 {
+	(void)dev;
 	(void)addr;
 
     /*legacy API should be removed */
@@ -685,24 +669,24 @@ sint8 m2m_wifi_request_dhcp_server(uint8* addr)
 @return		The function SHALL return 0 for success and a negative value otherwise.
 @sa			tstrM2mLsnInt , m2m_wifi_set_sleep_mode
 @pre		m2m_wifi_set_sleep_mode shall be called first
-@warning	The Function called once after initialization. 
+@warning	The Function called once after initialization.
 */
-sint8 m2m_wifi_enable_dhcp(uint8  u8DhcpEn )
+sint8 m2m_wifi_enable_dhcp(winc1500_t *dev, uint8  u8DhcpEn )
 {
 
 	uint8	u8Req;
 	u8Req = u8DhcpEn ? M2M_IP_REQ_ENABLE_DHCP : M2M_IP_REQ_DISABLE_DHCP;
-	return hif_send(M2M_REQ_GROUP_IP, u8Req, NULL, 0, NULL, 0, 0);
+	return hif_send(dev, M2M_REQ_GROUP_IP, u8Req, NULL, 0, NULL, 0, 0);
 
 
 }
 
-sint8 m2m_wifi_set_lsn_int(tstrM2mLsnInt* pstrM2mLsnInt)
+sint8 m2m_wifi_set_lsn_int(winc1500_t *dev, tstrM2mLsnInt* pstrM2mLsnInt)
 {
-	return hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_LSN_INT, (uint8*)pstrM2mLsnInt, sizeof(tstrM2mLsnInt), NULL, 0, 0);
+	return hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_LSN_INT, (uint8*)pstrM2mLsnInt, sizeof(tstrM2mLsnInt), NULL, 0, 0);
 }
 
-sint8 m2m_wifi_set_cust_InfoElement(uint8* pau8M2mCustInfoElement)
+sint8 m2m_wifi_set_cust_InfoElement(winc1500_t *dev, uint8* pau8M2mCustInfoElement)
 {
 
 	sint8  ret = M2M_ERR_FAIL;
@@ -710,43 +694,44 @@ sint8 m2m_wifi_set_cust_InfoElement(uint8* pau8M2mCustInfoElement)
 	{
 		if((pau8M2mCustInfoElement[0] + 1) < M2M_CUST_IE_LEN_MAX)
 		{
-			ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_CUST_INFO_ELEMENT|M2M_REQ_DATA_PKT, (uint8*)pau8M2mCustInfoElement, pau8M2mCustInfoElement[0]+1, NULL, 0, 0);
+			ret = hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_CUST_INFO_ELEMENT|M2M_REQ_DATA_PKT, (uint8*)pau8M2mCustInfoElement, pau8M2mCustInfoElement[0]+1, NULL, 0, 0);
 		}
 	}
 	return ret;
 }
 
-sint8 m2m_wifi_set_scan_options(tstrM2MScanOption* ptstrM2MScanOption)
+sint8 m2m_wifi_set_scan_options(winc1500_t *dev, tstrM2MScanOption* ptstrM2MScanOption)
 {
 	sint8	s8Ret = M2M_ERR_FAIL;
-	if(m2m_validate_scan_options (ptstrM2MScanOption) == M2M_SUCCESS)
+	if(m2m_validate_scan_options (dev, ptstrM2MScanOption) == M2M_SUCCESS)
 	{
-		s8Ret =  hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_SET_SCAN_OPTION, (uint8*)ptstrM2MScanOption, sizeof(tstrM2MScanOption),NULL, 0,0);
+		s8Ret =  hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_SET_SCAN_OPTION, (uint8*)ptstrM2MScanOption, sizeof(tstrM2MScanOption),NULL, 0,0);
 	}
 	return s8Ret;
 }
-sint8 m2m_wifi_set_scan_region(uint16  ScanRegion)
+sint8 m2m_wifi_set_scan_region(winc1500_t *dev, uint16  ScanRegion)
 {
 	sint8	s8Ret = M2M_ERR_FAIL;
 	tstrM2MScanRegion strScanRegion;
 	strScanRegion.u16ScanRegion = ScanRegion;
-	s8Ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_SET_SCAN_REGION, (uint8*)&strScanRegion, sizeof(tstrM2MScanRegion),NULL, 0,0);
+	s8Ret = hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_SET_SCAN_REGION, (uint8*)&strScanRegion, sizeof(tstrM2MScanRegion),NULL, 0,0);
 	return s8Ret;
 }
-sint8 m2m_wifi_request_scan(uint8 ch)
+sint8 m2m_wifi_request_scan(winc1500_t *dev, uint8 ch)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	sint8	s8Ret = M2M_SUCCESS;
 
-	if(!gu8scanInProgress)
+	if(!internal->gu8scanInProgress)
 	{
 		if(((ch >= M2M_WIFI_CH_1) && (ch <= M2M_WIFI_CH_14)) || (ch == M2M_WIFI_CH_ALL))
 		{
 			tstrM2MScan strtmp;
 			strtmp.u8ChNum = ch;
-			s8Ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_SCAN, (uint8*)&strtmp, sizeof(tstrM2MScan),NULL, 0,0);
+			s8Ret = hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_SCAN, (uint8*)&strtmp, sizeof(tstrM2MScan),NULL, 0,0);
 			if(s8Ret == M2M_SUCCESS)
 			{
-				gu8scanInProgress = 1;
+				internal->gu8scanInProgress = 1;
 			}
 		}
 		else
@@ -761,23 +746,24 @@ sint8 m2m_wifi_request_scan(uint8 ch)
 	return s8Ret;
 }
 
-sint8 m2m_wifi_request_scan_passive(uint8 ch, uint16 scan_time)
+sint8 m2m_wifi_request_scan_passive(winc1500_t *dev, uint8 ch, uint16 scan_time)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	sint8	s8Ret = M2M_SUCCESS;
 
-	if(!gu8scanInProgress)
+	if(!internal->gu8scanInProgress)
 	{
 		if(((ch >= M2M_WIFI_CH_1) && (ch <= M2M_WIFI_CH_14)) || (ch == M2M_WIFI_CH_ALL))
 		{
 			tstrM2MScan strtmp;
 			strtmp.u8ChNum = ch;
-			
+
 			strtmp.u16PassiveScanTime = scan_time;
-			
-			s8Ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_PASSIVE_SCAN, (uint8*)&strtmp, sizeof(tstrM2MScan),NULL, 0,0);
+
+			s8Ret = hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_PASSIVE_SCAN, (uint8*)&strtmp, sizeof(tstrM2MScan),NULL, 0,0);
 			if(s8Ret == M2M_SUCCESS)
 			{
-				gu8scanInProgress = 1;
+				internal->gu8scanInProgress = 1;
 			}
 		}
 		else
@@ -792,11 +778,12 @@ sint8 m2m_wifi_request_scan_passive(uint8 ch, uint16 scan_time)
 	return s8Ret;
 }
 
-sint8 m2m_wifi_request_scan_ssid_list(uint8 ch,uint8 * u8Ssidlist)
+sint8 m2m_wifi_request_scan_ssid_list(winc1500_t *dev, uint8 ch,uint8 * u8Ssidlist)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	sint8	s8Ret = M2M_ERR_INVALID_ARG;
 
-	if(!gu8scanInProgress)
+	if(!internal->gu8scanInProgress)
 	{
 		if((((ch >= M2M_WIFI_CH_1) && (ch <= M2M_WIFI_CH_14)) || (ch == M2M_WIFI_CH_ALL))&&(u8Ssidlist != NULL))
 		{
@@ -808,7 +795,7 @@ sint8 m2m_wifi_request_scan_ssid_list(uint8 ch,uint8 * u8Ssidlist)
 				u16Lsize++;
 				while(u8Apnum)
 				{
-					if(u8Ssidlist[u16Lsize] >= M2M_MAX_SSID_LEN){ 
+					if(u8Ssidlist[u16Lsize] >= M2M_MAX_SSID_LEN){
 						goto EXIT;
 					}else {
 						u16Lsize += u8Ssidlist[u16Lsize] + 1;
@@ -816,10 +803,10 @@ sint8 m2m_wifi_request_scan_ssid_list(uint8 ch,uint8 * u8Ssidlist)
 					}
 				}
 				strtmp.u8ChNum = ch;
-				s8Ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_SCAN_SSID_LIST|M2M_REQ_DATA_PKT, (uint8*)&strtmp, sizeof(tstrM2MScan),u8Ssidlist, u16Lsize,sizeof(tstrM2MScan));
+				s8Ret = hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_SCAN_SSID_LIST|M2M_REQ_DATA_PKT, (uint8*)&strtmp, sizeof(tstrM2MScan),u8Ssidlist, u16Lsize,sizeof(tstrM2MScan));
 				if(s8Ret == M2M_SUCCESS)
 				{
-					gu8scanInProgress = 1;
+					internal->gu8scanInProgress = 1;
 				}
 			}
 		}
@@ -831,45 +818,47 @@ sint8 m2m_wifi_request_scan_ssid_list(uint8 ch,uint8 * u8Ssidlist)
 EXIT:
 	return s8Ret;
 }
-sint8 m2m_wifi_wps(uint8 u8TriggerType,const char  *pcPinNumber)
+sint8 m2m_wifi_wps(winc1500_t *dev, uint8 u8TriggerType,const char  *pcPinNumber)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	tstrM2MWPSConnect strtmp;
 
 	/* Stop Scan if it is ongoing.
 	*/
-	gu8scanInProgress = 0;
+	internal->gu8scanInProgress = 0;
 	strtmp.u8TriggerType = u8TriggerType;
 	/*If WPS is using PIN METHOD*/
 	if (u8TriggerType == WPS_PIN_TRIGGER)
 		m2m_memcpy ((uint8*)strtmp.acPinNumber,(uint8*) pcPinNumber,8);
-	return hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_WPS, (uint8*)&strtmp,sizeof(tstrM2MWPSConnect), NULL, 0,0);
+	return hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_WPS, (uint8*)&strtmp,sizeof(tstrM2MWPSConnect), NULL, 0,0);
 }
-sint8 m2m_wifi_wps_disable(void)
+sint8 m2m_wifi_wps_disable(winc1500_t *dev)
 {
 	sint8 ret = M2M_SUCCESS;
-	ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_DISABLE_WPS, NULL,0, NULL, 0, 0);
+	ret = hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_DISABLE_WPS, NULL,0, NULL, 0, 0);
 	return ret;
 }
 /*!
 @fn			NMI_API sint8 m2m_wifi_req_client_ctrl(uint8 cmd);
-@brief		Send a command to the PS Client (An WINC1500 board running the ps_firmware), 
+@brief		Send a command to the PS Client (An WINC1500 board running the ps_firmware),
 			if the PS client send any commands it will be received in wifi_cb M2M_WIFI_RESP_CLIENT_INFO
 @param [in]	cmd
 			Control command sent from PS Server to PS Client (command values defined by the application)
 @return		The function SHALL return M2M_SUCCESE for success and a negative value otherwise.
 @sa			m2m_wifi_req_server_init, M2M_WIFI_RESP_CLIENT_INFO
 @pre		m2m_wifi_req_server_init should be called first
-@warning	
+@warning
 */
-sint8 m2m_wifi_req_client_ctrl(uint8 u8Cmd)
+sint8 m2m_wifi_req_client_ctrl(winc1500_t *dev, uint8 u8Cmd)
 {
+	(void)dev;
 	(void)u8Cmd;
 
 	sint8 ret = M2M_SUCCESS;
 #ifdef _PS_SERVER_
 	tstrM2Mservercmd	strCmd;
 	strCmd.u8cmd = u8Cmd;
-	ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_CLIENT_CTRL, (uint8*)&strCmd, sizeof(tstrM2Mservercmd), NULL, 0, 0);
+	ret = hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_CLIENT_CTRL, (uint8*)&strCmd, sizeof(tstrM2Mservercmd), NULL, 0, 0);
 #else
 	M2M_ERR("_PS_SERVER_ is not defined\n");
 #endif
@@ -877,7 +866,7 @@ sint8 m2m_wifi_req_client_ctrl(uint8 u8Cmd)
 }
 /*!
 @fn			NMI_API sint8 m2m_wifi_req_server_init(uint8 ch);
-@brief		Initialize the PS Server, The WINC1500 support Non secure communication with another WINC1500, 
+@brief		Initialize the PS Server, The WINC1500 support Non secure communication with another WINC1500,
 			(SERVER/CLIENT) through one byte command (probe request and probe response) without any connection setup
 @param [in]	ch
 			Server listening channel
@@ -885,28 +874,29 @@ sint8 m2m_wifi_req_client_ctrl(uint8 u8Cmd)
 @sa			m2m_wifi_req_client_ctrl
 @warning	The server mode can't be used with any other modes (STA/P2P/AP)
 */
-sint8 m2m_wifi_req_server_init(uint8 ch)
+sint8 m2m_wifi_req_server_init(winc1500_t *dev, uint8 ch)
 {
+	(void)dev;
 	(void)ch;
-	
+
 	sint8 ret = M2M_SUCCESS;
 #ifdef _PS_SERVER_
 	tstrM2mServerInit strServer;
 	strServer.u8Channel = ch;
-	ret = hif_send(M2M_REQ_GROUP_WIFI,M2M_WIFI_REQ_SERVER_INIT, (uint8*)&strServer, sizeof(tstrM2mServerInit), NULL, 0, 0);
+	ret = hif_send(dev, M2M_REQ_GROUP_WIFI,M2M_WIFI_REQ_SERVER_INIT, (uint8*)&strServer, sizeof(tstrM2mServerInit), NULL, 0, 0);
 #else
 	M2M_ERR("_PS_SERVER_ is not defined\n");
 #endif
 	return ret;
 }
-sint8 m2m_wifi_p2p(uint8 u8Channel)
+sint8 m2m_wifi_p2p(winc1500_t *dev, uint8 u8Channel)
 {
 	sint8 ret = M2M_SUCCESS;
 	if((u8Channel == M2M_WIFI_CH_1) || (u8Channel == M2M_WIFI_CH_6) || (u8Channel == M2M_WIFI_CH_11))
 	{
 		tstrM2MP2PConnect strtmp;
 		strtmp.u8ListenChannel = u8Channel;
-		ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_ENABLE_P2P, (uint8*)&strtmp, sizeof(tstrM2MP2PConnect), NULL, 0,0);
+		ret = hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_ENABLE_P2P, (uint8*)&strtmp, sizeof(tstrM2MP2PConnect), NULL, 0,0);
 	}
 	else
 	{
@@ -915,51 +905,51 @@ sint8 m2m_wifi_p2p(uint8 u8Channel)
 	}
 	return ret;
 }
-sint8 m2m_wifi_p2p_disconnect(void)
+sint8 m2m_wifi_p2p_disconnect(winc1500_t *dev)
 {
 	sint8 ret = M2M_SUCCESS;
-	ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_DISABLE_P2P, NULL, 0, NULL, 0, 0);
+	ret = hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_DISABLE_P2P, NULL, 0, NULL, 0, 0);
 	return ret;
 }
-sint8 m2m_wifi_enable_ap(WINC1500_CONST tstrM2MAPConfig* pstrM2MAPConfig)
+sint8 m2m_wifi_enable_ap(winc1500_t *dev, WINC1500_CONST tstrM2MAPConfig* pstrM2MAPConfig)
 {
 	sint8 ret = M2M_ERR_FAIL;
-	if(M2M_SUCCESS == m2m_validate_ap_parameters(pstrM2MAPConfig))
+	if(M2M_SUCCESS == m2m_validate_ap_parameters(dev, pstrM2MAPConfig))
 	{
-		ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_ENABLE_AP, (uint8 *)pstrM2MAPConfig, sizeof(tstrM2MAPConfig), NULL, 0, 0);	
+		ret = hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_ENABLE_AP, (uint8 *)pstrM2MAPConfig, sizeof(tstrM2MAPConfig), NULL, 0, 0);
 	}
 	return ret;
 }
 
-sint8 m2m_wifi_set_gains(tstrM2mWifiGainsParams* pstrM2mGain)
+sint8 m2m_wifi_set_gains(winc1500_t *dev, tstrM2mWifiGainsParams* pstrM2mGain)
 {
 	sint8 ret = M2M_ERR_FAIL;
 	if(pstrM2mGain != NULL)
 	{
-		ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_SET_GAINS, (uint8 *)pstrM2mGain, sizeof(tstrM2mWifiGainsParams), NULL, 0, 0);	
+		ret = hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_SET_GAINS, (uint8 *)pstrM2mGain, sizeof(tstrM2mWifiGainsParams), NULL, 0, 0);
 	}
 	return ret;
 }
-sint8 m2m_wifi_disable_ap(void)
+sint8 m2m_wifi_disable_ap(winc1500_t *dev)
 {
 	sint8 ret = M2M_SUCCESS;
-	ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_DISABLE_AP, NULL, 0, NULL, 0, 0);
+	ret = hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_DISABLE_AP, NULL, 0, NULL, 0, 0);
 	return ret;
 }
 /*!
 @fn          NMI_API sint8 m2m_wifi_req_curr_rssi(void);
-@brief       Request the current RSSI for the current connected AP, 
-			 the response received in wifi_cb M2M_WIFI_RESP_CURRENT_RSSI	
-@sa          M2M_WIFI_RESP_CURRENT_RSSI              
+@brief       Request the current RSSI for the current connected AP,
+			 the response received in wifi_cb M2M_WIFI_RESP_CURRENT_RSSI
+@sa          M2M_WIFI_RESP_CURRENT_RSSI
 @return      The function shall return M2M_SUCCESS for success and a negative value otherwise.
 */
-sint8 m2m_wifi_req_curr_rssi(void)
+sint8 m2m_wifi_req_curr_rssi(winc1500_t *dev)
 {
 	sint8 ret = M2M_SUCCESS;
-	ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_CURRENT_RSSI, NULL, 0, NULL,0, 0);
+	ret = hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_CURRENT_RSSI, NULL, 0, NULL,0, 0);
 	return ret;
 }
-sint8 m2m_wifi_send_ethernet_pkt(uint8* pu8Packet,uint16 u16PacketSize)
+sint8 m2m_wifi_send_ethernet_pkt(winc1500_t *dev, uint8* pu8Packet,uint16 u16PacketSize)
 {
 	sint8	s8Ret = -1;
 	if((pu8Packet != NULL)&&(u16PacketSize>0))
@@ -968,7 +958,7 @@ sint8 m2m_wifi_send_ethernet_pkt(uint8* pu8Packet,uint16 u16PacketSize)
 
 		strTxPkt.u16PacketSize		= u16PacketSize;
 		strTxPkt.u16HeaderLength	= M2M_ETHERNET_HDR_LEN;
-		s8Ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_SEND_ETHERNET_PACKET | M2M_REQ_DATA_PKT,
+		s8Ret = hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_SEND_ETHERNET_PACKET | M2M_REQ_DATA_PKT,
 		(uint8*)&strTxPkt, sizeof(tstrM2MWifiTxPacketInfo), pu8Packet, u16PacketSize,  M2M_ETHERNET_HDR_OFFSET - M2M_HIF_HDR_OFFSET);
 	}
 	return s8Ret;
@@ -976,26 +966,26 @@ sint8 m2m_wifi_send_ethernet_pkt(uint8* pu8Packet,uint16 u16PacketSize)
 /*!
 @fn          NMI_API sint8 m2m_wifi_get_otp_mac_address(uint8 *pu8MacAddr, uint8 * pu8IsValid);
 @brief       Request the MAC address stored on the OTP (one time programmable) memory of the device.
-			 (the function is Blocking until response received)	
+			 (the function is Blocking until response received)
 @param [out] pu8MacAddr
 			 Output MAC address buffer of 6 bytes size. Valid only if *pu8Valid=1.
 @param [out] pu8IsValid
-		     A output boolean value to indicate the validity of pu8MacAddr in OTP. 
-		     Output zero if the OTP memory is not programmed, non-zero otherwise.	
+		     A output boolean value to indicate the validity of pu8MacAddr in OTP.
+		     Output zero if the OTP memory is not programmed, non-zero otherwise.
 @return      The function shall return M2M_SUCCESS for success and a negative value otherwise.
-@sa          m2m_wifi_get_mac_address             
+@sa          m2m_wifi_get_mac_address
 @pre         m2m_wifi_init required to call any WIFI/socket function
 */
-sint8 m2m_wifi_get_otp_mac_address(uint8 *pu8MacAddr, uint8* pu8IsValid)
+sint8 m2m_wifi_get_otp_mac_address(winc1500_t *dev, uint8 *pu8MacAddr, uint8* pu8IsValid)
 {
 	sint8 ret = M2M_SUCCESS;
-	ret = hif_chip_wake();
+	ret = hif_chip_wake(dev);
 	if(ret == M2M_SUCCESS)
 	{
-		ret = nmi_get_otp_mac_address(pu8MacAddr, pu8IsValid);
+		ret = nmi_get_otp_mac_address(dev, pu8MacAddr, pu8IsValid);
 		if(ret == M2M_SUCCESS)
 		{
-			ret = hif_chip_sleep();
+			ret = hif_chip_sleep(dev);
 		}
 	}
 	return ret;
@@ -1003,23 +993,23 @@ sint8 m2m_wifi_get_otp_mac_address(uint8 *pu8MacAddr, uint8* pu8IsValid)
 /*!
 @fn          NMI_API sint8 m2m_wifi_get_mac_address(uint8 *pu8MacAddr)
 @brief       Request the current MAC address of the device (the working mac address).
-			 (the function is Blocking until response received)	
+			 (the function is Blocking until response received)
 @param [out] pu8MacAddr
-			 Output MAC address buffer of 6 bytes size.	
+			 Output MAC address buffer of 6 bytes size.
 @return      The function shall return M2M_SUCCESS for success and a negative value otherwise.
-@sa          m2m_wifi_get_otp_mac_address             
+@sa          m2m_wifi_get_otp_mac_address
 @pre         m2m_wifi_init required to call any WIFI/socket function
 */
-sint8 m2m_wifi_get_mac_address(uint8 *pu8MacAddr)
+sint8 m2m_wifi_get_mac_address(winc1500_t *dev, uint8 *pu8MacAddr)
 {
 	sint8 ret = M2M_SUCCESS;
-	ret = hif_chip_wake();
+	ret = hif_chip_wake(dev);
 	if(ret == M2M_SUCCESS)
 	{
-		ret = nmi_get_mac_address(pu8MacAddr);
+		ret = nmi_get_mac_address(dev, pu8MacAddr);
 		if(ret == M2M_SUCCESS)
 		{
-			ret = hif_chip_sleep();
+			ret = hif_chip_sleep(dev);
 		}
 	}
 
@@ -1027,44 +1017,45 @@ sint8 m2m_wifi_get_mac_address(uint8 *pu8MacAddr)
 }
 /*!
 @fn          NMI_API sint8 m2m_wifi_req_scan_result(uint8 index);
-@brief       Reads the AP information from the Scan Result list with the given index, 
-			 the response received in wifi_cb M2M_WIFI_RESP_SCAN_RESULT, 
-			 the response pointer should be casted with tstrM2mWifiscanResult structure 	
-@param [in]  index 
-			 Index for the requested result, the index range start from 0 till number of AP's found 
-@sa          tstrM2mWifiscanResult,m2m_wifi_get_num_ap_found,m2m_wifi_request_scan             
+@brief       Reads the AP information from the Scan Result list with the given index,
+			 the response received in wifi_cb M2M_WIFI_RESP_SCAN_RESULT,
+			 the response pointer should be casted with tstrM2mWifiscanResult structure
+@param [in]  index
+			 Index for the requested result, the index range start from 0 till number of AP's found
+@sa          tstrM2mWifiscanResult,m2m_wifi_get_num_ap_found,m2m_wifi_request_scan
 @return      The function shall return M2M_SUCCESE for success and a negative value otherwise
-@pre         m2m_wifi_request_scan need to be called first, then m2m_wifi_get_num_ap_found 
+@pre         m2m_wifi_request_scan need to be called first, then m2m_wifi_get_num_ap_found
 			 to get the number of AP's found
 @warning     Function used only in STA mode only. the scan result updated only if scan request called,
-			 else it will be cashed in firmware for the host scan request result, 
-			 which mean if large delay occur between the scan request and the scan result request, 
+			 else it will be cashed in firmware for the host scan request result,
+			 which mean if large delay occur between the scan request and the scan result request,
 			 the result will not be up-to-date
 */
 
-sint8 m2m_wifi_req_scan_result(uint8 index)
+sint8 m2m_wifi_req_scan_result(winc1500_t *dev, uint8 index)
 {
 	sint8 ret = M2M_SUCCESS;
 	tstrM2mReqScanResult strReqScanRlt;
 	strReqScanRlt.u8Index = index;
-	ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_SCAN_RESULT, (uint8*) &strReqScanRlt, sizeof(tstrM2mReqScanResult), NULL, 0, 0);
+	ret = hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_SCAN_RESULT, (uint8*) &strReqScanRlt, sizeof(tstrM2mReqScanResult), NULL, 0, 0);
 	return ret;
 }
 /*!
 @fn          NMI_API uint8 m2m_wifi_get_num_ap_found(void);
-@brief       Reads the number of AP's found in the last Scan Request, 
-			 The function read the number of AP's from global variable which updated in the 
-			 wifi_cb in M2M_WIFI_RESP_SCAN_DONE.			 
-@sa          m2m_wifi_request_scan               
+@brief       Reads the number of AP's found in the last Scan Request,
+			 The function read the number of AP's from global variable which updated in the
+			 wifi_cb in M2M_WIFI_RESP_SCAN_DONE.
+@sa          m2m_wifi_request_scan
 @return      Return the number of AP's found in the last Scan Request.
-@pre         m2m_wifi_request_scan need to be called first 
-@warning     That function need to be called in the wifi_cb in M2M_WIFI_RESP_SCAN_DONE, 
+@pre         m2m_wifi_request_scan need to be called first
+@warning     That function need to be called in the wifi_cb in M2M_WIFI_RESP_SCAN_DONE,
 			 calling that function in any other place will return undefined/undated numbers.
 			 Function used only in STA mode only.
 */
-uint8 m2m_wifi_get_num_ap_found(void)
+uint8 m2m_wifi_get_num_ap_found(winc1500_t *dev)
 {
-	return gu8ChNum;
+	winc1500_internal_t *internal = &dev->internal;
+	return internal->gu8ChNum;
 }
 /*!
 @fn		    NMI_API uint8 m2m_wifi_get_sleep_mode(void);
@@ -1072,54 +1063,54 @@ uint8 m2m_wifi_get_num_ap_found(void)
 @return	    The current operating power saving mode.
 @sa		    tenuPowerSaveModes , m2m_wifi_set_sleep_mode
 */
-uint8 m2m_wifi_get_sleep_mode(void)
+uint8 m2m_wifi_get_sleep_mode(winc1500_t *dev)
 {
-	return hif_get_sleep_mode();
+	return hif_get_sleep_mode(dev);
 }
 /*!
 @fn			NMI_API sint8 m2m_wifi_set_sleep_mode(uint8 PsTyp, uint8 BcastEn);
-@brief      Set the power saving mode for the WINC1500. 
+@brief      Set the power saving mode for the WINC1500.
 @param [in]	PsTyp
 			Desired power saving mode. Supported types are defined in tenuPowerSaveModes.
 @param [in]	BcastEn
-			Broadcast reception enable flag. 
+			Broadcast reception enable flag.
 			If it is 1, the WINC1500 must be awake each DTIM Beacon for receiving Broadcast traffic.
-			If it is 0, the WINC1500 will not wakeup at the DTIM Beacon, but its wakeup depends only 
-			on the the configured Listen Interval. 
+			If it is 0, the WINC1500 will not wakeup at the DTIM Beacon, but its wakeup depends only
+			on the the configured Listen Interval.
 @return     The function SHALL return 0 for success and a negative value otherwise.
 @sa			tenuPowerSaveModes
-@warning    The function called once after initialization.  
+@warning    The function called once after initialization.
 */
-sint8 m2m_wifi_set_sleep_mode(uint8 PsTyp, uint8 BcastEn)
+sint8 m2m_wifi_set_sleep_mode(winc1500_t *dev, uint8 PsTyp, uint8 BcastEn)
 {
 	sint8 ret = M2M_SUCCESS;
 	tstrM2mPsType strPs;
 	strPs.u8PsType = PsTyp;
 	strPs.u8BcastEn = BcastEn;
-	ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_SLEEP, (uint8*) &strPs,sizeof(tstrM2mPsType), NULL, 0, 0);
+	ret = hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_SLEEP, (uint8*) &strPs,sizeof(tstrM2mPsType), NULL, 0, 0);
 	M2M_INFO("POWER SAVE %d\n",PsTyp);
-	hif_set_sleep_mode(PsTyp);
+	hif_set_sleep_mode(dev, PsTyp);
 	return ret;
 }
 /*!
 @fn	        NMI_API sint8 m2m_wifi_request_sleep(void)
 @brief	    Request from WINC1500 device to Sleep for specific time in the M2M_PS_MANUAL Power save mode (only).
 @param [in]	u32SlpReqTime
-			Request Sleep in ms 
+			Request Sleep in ms
 @return     The function SHALL return M2M_SUCCESS for success and a negative value otherwise.
 @sa         tenuPowerSaveModes , m2m_wifi_set_sleep_mode
-@warning	the Function should be called in M2M_PS_MANUAL power save only 
+@warning	the Function should be called in M2M_PS_MANUAL power save only
 */
-sint8 m2m_wifi_request_sleep(uint32 u32SlpReqTime)
+sint8 m2m_wifi_request_sleep(winc1500_t *dev, uint32 u32SlpReqTime)
 {
 	sint8 ret = M2M_SUCCESS;
 	uint8 psType;
-	psType = hif_get_sleep_mode();
+	psType = hif_get_sleep_mode(dev);
 	if(psType == M2M_PS_MANUAL)
 	{
 		tstrM2mSlpReqTime strPs;
 		strPs.u32SleepTime = u32SlpReqTime;
-		ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_DOZE, (uint8*) &strPs,sizeof(tstrM2mSlpReqTime), NULL, 0, 0);
+		ret = hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_DOZE, (uint8*) &strPs,sizeof(tstrM2mSlpReqTime), NULL, 0, 0);
 	}
 	return ret;
 }
@@ -1131,9 +1122,9 @@ sint8 m2m_wifi_request_sleep(uint32 u32SlpReqTime)
 @param [in]	u8DeviceNameLength
 			Length of the device name.
 @return		The function SHALL return M2M_SUCCESS for success and a negative value otherwise.
-@warning	The Function called once after initialization. 
+@warning	The Function called once after initialization.
 */
-sint8 m2m_wifi_set_device_name(uint8 *pu8DeviceName, uint8 u8DeviceNameLength)
+sint8 m2m_wifi_set_device_name(winc1500_t *dev, uint8 *pu8DeviceName, uint8 u8DeviceNameLength)
 {
 	tstrM2MDeviceNameConfig strDeviceName;
 	if(u8DeviceNameLength >= M2M_DEVICE_NAME_MAX)
@@ -1143,22 +1134,22 @@ sint8 m2m_wifi_set_device_name(uint8 *pu8DeviceName, uint8 u8DeviceNameLength)
 	//pu8DeviceName[u8DeviceNameLength] = '\0';
 	u8DeviceNameLength ++;
 	m2m_memcpy(strDeviceName.au8DeviceName, pu8DeviceName, u8DeviceNameLength);
-	return hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_SET_DEVICE_NAME,
+	return hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_SET_DEVICE_NAME,
 		(uint8*)&strDeviceName, sizeof(tstrM2MDeviceNameConfig), NULL, 0,0);
 }
-sint8 m2m_wifi_get_firmware_version(tstrM2mRev *pstrRev)
+sint8 m2m_wifi_get_firmware_version(winc1500_t *dev, tstrM2mRev *pstrRev)
 {
 	sint8 ret = M2M_SUCCESS;
-	ret = hif_chip_wake();
+	ret = hif_chip_wake(dev);
 	if(ret == M2M_SUCCESS)
 	{
-    	ret = nm_get_firmware_full_info(pstrRev);
-		hif_chip_sleep();
+    	ret = nm_get_firmware_full_info(dev, pstrRev);
+		hif_chip_sleep(dev);
 	}
 	return ret;
 }
 #ifdef CONF_MGMT
-sint8 m2m_wifi_enable_monitoring_mode(tstrM2MWifiMonitorModeCtrl *pstrMtrCtrl, uint8 *pu8PayloadBuffer,
+sint8 m2m_wifi_enable_monitoring_mode(winc1500_t *dev, tstrM2MWifiMonitorModeCtrl *pstrMtrCtrl, uint8 *pu8PayloadBuffer,
 								   uint16 u16BufferSize, uint16 u16DataOffset)
 {
 	sint8	s8Ret = -1;
@@ -1167,18 +1158,18 @@ sint8 m2m_wifi_enable_monitoring_mode(tstrM2MWifiMonitorModeCtrl *pstrMtrCtrl, u
 		gstrMgmtCtrl.pu8Buf		= pu8PayloadBuffer;
 		gstrMgmtCtrl.u16Sz		= u16BufferSize;
 		gstrMgmtCtrl.u16Offset	= u16DataOffset;
-		s8Ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_ENABLE_MONITORING,
+		s8Ret = hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_ENABLE_MONITORING,
 			(uint8*)pstrMtrCtrl, sizeof(tstrM2MWifiMonitorModeCtrl), NULL, 0,0);
 	}
 	return s8Ret;
 }
 
-sint8 m2m_wifi_disable_monitoring_mode(void)
+sint8 m2m_wifi_disable_monitoring_mode(winc1500_t *dev)
 {
-	return hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_DISABLE_MONITORING, NULL, 0, NULL, 0,0);
+	return hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_DISABLE_MONITORING, NULL, 0, NULL, 0,0);
 }
 
-sint8 m2m_wifi_send_wlan_pkt(uint8 *pu8WlanPacket, uint16 u16WlanHeaderLength, uint16 u16WlanPktSize)
+sint8 m2m_wifi_send_wlan_pkt(winc1500_t *dev, uint8 *pu8WlanPacket, uint16 u16WlanHeaderLength, uint16 u16WlanPktSize)
 {
 	sint8	s8Ret = -1;
 	if(pu8WlanPacket != NULL)
@@ -1187,21 +1178,22 @@ sint8 m2m_wifi_send_wlan_pkt(uint8 *pu8WlanPacket, uint16 u16WlanHeaderLength, u
 
 		strTxPkt.u16PacketSize		= u16WlanPktSize;
 		strTxPkt.u16HeaderLength	= u16WlanHeaderLength;
-		s8Ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_SEND_WIFI_PACKET | M2M_REQ_DATA_PKT,
+		s8Ret = hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_SEND_WIFI_PACKET | M2M_REQ_DATA_PKT,
 		(uint8*)&strTxPkt, sizeof(tstrM2MWifiTxPacketInfo), pu8WlanPacket, u16WlanPktSize, sizeof(tstrM2MWifiTxPacketInfo));
 	}
 	return s8Ret;
 }
 #endif
 
-sint8 m2m_wifi_start_provision_mode(tstrM2MAPConfig *pstrAPConfig, char *pcHttpServerDomainName, uint8 bEnableHttpRedirect)
+sint8 m2m_wifi_start_provision_mode(winc1500_t *dev, tstrM2MAPConfig *pstrAPConfig, char *pcHttpServerDomainName, uint8 bEnableHttpRedirect)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	sint8	s8Ret = M2M_ERR_FAIL;
 
 	if((pstrAPConfig != NULL))
 	{
 		tstrM2MProvisionModeConfig	strProvConfig;
-		if(M2M_SUCCESS == m2m_validate_ap_parameters(pstrAPConfig))
+		if(M2M_SUCCESS == m2m_validate_ap_parameters(dev, pstrAPConfig))
 		{
 			m2m_memcpy((uint8*)&strProvConfig.strApConfig, (uint8*)pstrAPConfig, sizeof(tstrM2MAPConfig));
 			if((m2m_strlen((uint8 *)pcHttpServerDomainName) <= 0) || (NULL == pcHttpServerDomainName))
@@ -1211,11 +1203,11 @@ sint8 m2m_wifi_start_provision_mode(tstrM2MAPConfig *pstrAPConfig, char *pcHttpS
 			}
 			m2m_memcpy((uint8*)strProvConfig.acHttpServerDomainName, (uint8*)pcHttpServerDomainName, 64);
 			strProvConfig.u8EnableRedirect = bEnableHttpRedirect;
-		
+
 			/* Stop Scan if it is ongoing.
 			*/
-			gu8scanInProgress = 0;
-			s8Ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_START_PROVISION_MODE | M2M_REQ_DATA_PKT, 
+			internal->gu8scanInProgress = 0;
+			s8Ret = hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_START_PROVISION_MODE | M2M_REQ_DATA_PKT,
 						(uint8*)&strProvConfig, sizeof(tstrM2MProvisionModeConfig), NULL, 0, 0);
 		}
 		else
@@ -1227,60 +1219,60 @@ ERR1:
 	return s8Ret;
 }
 
-sint8 m2m_wifi_stop_provision_mode(void)
+sint8 m2m_wifi_stop_provision_mode(winc1500_t *dev)
 {
-	return hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_STOP_PROVISION_MODE, NULL, 0, NULL, 0, 0);
+	return hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_STOP_PROVISION_MODE, NULL, 0, NULL, 0, 0);
 }
 
-sint8 m2m_wifi_get_connection_info(void)
+sint8 m2m_wifi_get_connection_info(winc1500_t *dev)
 {
-	return hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_GET_CONN_INFO, NULL, 0, NULL, 0, 0);
+	return hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_GET_CONN_INFO, NULL, 0, NULL, 0, 0);
 }
 
-sint8 m2m_wifi_set_sytem_time(uint32 u32UTCSeconds)
+sint8 m2m_wifi_set_sytem_time(winc1500_t *dev, uint32 u32UTCSeconds)
 {
-	/* 
+	/*
 		The firmware accepts timestamps relative to 1900 like NTP Timestamp.
 	*/
-	return hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_SET_SYS_TIME, (uint8*)&u32UTCSeconds, sizeof(tstrSystemTime), NULL, 0, 0);
+	return hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_SET_SYS_TIME, (uint8*)&u32UTCSeconds, sizeof(tstrSystemTime), NULL, 0, 0);
 }
 /*!
- * @fn             NMI_API sint8 m2m_wifi_get_sytem_time(void);   
+ * @fn             NMI_API sint8 m2m_wifi_get_sytem_time(void);
  * @see            m2m_wifi_enable_sntp
- 			  		tstrSystemTime   
+ 			  		tstrSystemTime
  * @note         get the system time from the sntp client
  *		         using the API \ref m2m_wifi_get_sytem_time.
  * @return        The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
  */
-sint8 m2m_wifi_get_sytem_time(void)
+sint8 m2m_wifi_get_sytem_time(winc1500_t *dev)
 {
-	return hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_GET_SYS_TIME, NULL,0, NULL, 0, 0);
+	return hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_GET_SYS_TIME, NULL,0, NULL, 0, 0);
 }
 
-sint8 m2m_wifi_enable_sntp(uint8 bEnable)
+sint8 m2m_wifi_enable_sntp(winc1500_t *dev, uint8 bEnable)
 {
 	uint8	u8Req;
 
 	u8Req = bEnable ? M2M_WIFI_REQ_ENABLE_SNTP_CLIENT : M2M_WIFI_REQ_DISABLE_SNTP_CLIENT;
-	return hif_send(M2M_REQ_GROUP_WIFI, u8Req, NULL, 0, NULL, 0, 0);
+	return hif_send(dev, M2M_REQ_GROUP_WIFI, u8Req, NULL, 0, NULL, 0, 0);
 }
 /*!
 @fn			NMI_API sint8 m2m_wifi_set_power_profile(uint8 u8PwrMode);
-@brief		Change the power profile mode 
+@brief		Change the power profile mode
 @param [in]	u8PwrMode
-			Change the WINC power profile to different mode 
+			Change the WINC power profile to different mode
 			PWR_LOW1/PWR_LOW2/PWR_HIGH/PWR_AUTO (tenuM2mPwrMode)
 @return		The function SHALL return M2M_SUCCESE for success and a negative value otherwise.
 @sa			tenuM2mPwrMode
 @pre		m2m_wifi_init
-@warning	must be called after the initializations and before any connection request and can't be changed in run time, 
+@warning	must be called after the initializations and before any connection request and can't be changed in run time,
 */
-sint8 m2m_wifi_set_power_profile(uint8 u8PwrMode)
+sint8 m2m_wifi_set_power_profile(winc1500_t *dev, uint8 u8PwrMode)
 {
 	sint8 ret = M2M_SUCCESS;
 	tstrM2mPwrMode strM2mPwrMode;
 	strM2mPwrMode.u8PwrMode = u8PwrMode;
-	ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_SET_POWER_PROFILE, (uint8*)&strM2mPwrMode,sizeof(tstrM2mPwrMode), NULL, 0, 0);
+	ret = hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_SET_POWER_PROFILE, (uint8*)&strM2mPwrMode,sizeof(tstrM2mPwrMode), NULL, 0, 0);
 	return ret;
 }
 /*!
@@ -1291,66 +1283,66 @@ sint8 m2m_wifi_set_power_profile(uint8 u8PwrMode)
 @return		The function SHALL return M2M_SUCCESE for success and a negative value otherwise.
 @sa			tenuM2mTxPwrLevel
 @pre		m2m_wifi_init
-@warning	
+@warning
 */
-sint8 m2m_wifi_set_tx_power(uint8 u8TxPwrLevel)
+sint8 m2m_wifi_set_tx_power(winc1500_t *dev, uint8 u8TxPwrLevel)
 {
 	sint8 ret = M2M_SUCCESS;
 	tstrM2mTxPwrLevel strM2mTxPwrLevel;
 	strM2mTxPwrLevel.u8TxPwrLevel = u8TxPwrLevel;
-	ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_SET_TX_POWER, (uint8*)&strM2mTxPwrLevel,sizeof(tstrM2mTxPwrLevel), NULL, 0, 0);
+	ret = hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_SET_TX_POWER, (uint8*)&strM2mTxPwrLevel,sizeof(tstrM2mTxPwrLevel), NULL, 0, 0);
 	return ret;
 }
 
 /*!
 @fn			NMI_API sint8 m2m_wifi_enable_firmware_logs(uint8 u8Enable);
-@brief		Enable or Disable logs in run time (Disable Firmware logs will 
+@brief		Enable or Disable logs in run time (Disable Firmware logs will
 			enhance the firmware start-up time and performance)
 @param [in]	u8Enable
 			Set 1 to enable the logs 0 for disable
 @return		The function SHALL return M2M_SUCCESE for success and a negative value otherwise.
 @sa			__DISABLE_FIRMWARE_LOGS__ (build option to disable logs from initializations)
 @pre		m2m_wifi_init
-@warning	
+@warning
 */
-sint8 m2m_wifi_enable_firmware_logs(uint8 u8Enable)
+sint8 m2m_wifi_enable_firmware_logs(winc1500_t *dev, uint8 u8Enable)
 {
 	sint8 ret = M2M_SUCCESS;
 	tstrM2mEnableLogs strM2mEnableLogs;
 	strM2mEnableLogs.u8Enable = u8Enable;
-	ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_SET_ENABLE_LOGS, (uint8*)&strM2mEnableLogs,sizeof(tstrM2mEnableLogs), NULL, 0, 0);
+	ret = hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_SET_ENABLE_LOGS, (uint8*)&strM2mEnableLogs,sizeof(tstrM2mEnableLogs), NULL, 0, 0);
 	return ret;
 }
 
 /*!
 @fn			NMI_API sint8 m2m_wifi_set_battery_voltage(uint16 u16BattVoltx100);
-@brief		Enable or Disable logs in run time (Disable Firmware logs will 
+@brief		Enable or Disable logs in run time (Disable Firmware logs will
 			enhance the firmware start-up time and performance)
 @param [in]	u16BattVoltx100
 			battery voltage multiplied by 100
 @return		The function SHALL return M2M_SUCCESE for success and a negative value otherwise.
 @sa			__DISABLE_FIRMWARE_LOGS__ (build option to disable logs from initializations)
 @pre		m2m_wifi_init
-@warning	
+@warning
 */
-sint8 m2m_wifi_set_battery_voltage(uint16 u16BattVoltx100)
+sint8 m2m_wifi_set_battery_voltage(winc1500_t *dev, uint16 u16BattVoltx100)
 {
 	sint8 ret = M2M_SUCCESS;
 	tstrM2mBatteryVoltage strM2mBattVol = {0};
 	strM2mBattVol.u16BattVolt = u16BattVoltx100;
-	ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_SET_BATTERY_VOLTAGE, (uint8*)&strM2mBattVol,sizeof(tstrM2mBatteryVoltage), NULL, 0, 0);
+	ret = hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_SET_BATTERY_VOLTAGE, (uint8*)&strM2mBattVol,sizeof(tstrM2mBatteryVoltage), NULL, 0, 0);
 	return ret;
 }
 /*!
 @fn        	 	 sint8 m2m_wifi_prng_get_random_bytes(uint8 * pu8PrngBuff,uint16 u16PrngSize)
-@brief     	 Get random bytes using the PRNG bytes.	      
+@brief     	 Get random bytes using the PRNG bytes.
 @param [in]    u16PrngSize
-		  	 Size of the required random bytes to be generated.   	 
+		  	 Size of the required random bytes to be generated.
 @param [in]    pu8PrngBuff
-		        Pointer to user allocated buffer.  		            
+		        Pointer to user allocated buffer.
 @return           The function SHALL return M2M_SUCCESE for success and a negative value otherwise.
 */
-sint8 m2m_wifi_prng_get_random_bytes(uint8 * pu8PrngBuff,uint16 u16PrngSize)
+sint8 m2m_wifi_prng_get_random_bytes(winc1500_t *dev, uint8 * pu8PrngBuff,uint16 u16PrngSize)
 {
 	sint8 ret = M2M_ERR_FAIL;
 	tstrPrng   strRng = {0};
@@ -1358,7 +1350,7 @@ sint8 m2m_wifi_prng_get_random_bytes(uint8 * pu8PrngBuff,uint16 u16PrngSize)
 	{
 		strRng.u16PrngSize = u16PrngSize;
 		strRng.pu8RngBuff  = pu8PrngBuff;
-		ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_GET_PRNG|M2M_REQ_DATA_PKT,(uint8 *)&strRng, sizeof(tstrPrng),NULL,0, 0);
+		ret = hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_GET_PRNG|M2M_REQ_DATA_PKT,(uint8 *)&strRng, sizeof(tstrPrng),NULL,0, 0);
 	}
 	else
 	{
@@ -1382,7 +1374,7 @@ sint8 m2m_wifi_prng_get_random_bytes(uint8 * pu8PrngBuff,uint16 u16PrngSize)
 	The function SHALL return 0 for success and a negative value otherwise.
 */
 
-NMI_API sint8 m2m_wifi_enable_mac_mcast(uint8* pu8MulticastMacAddress, uint8 u8AddRemove)
+NMI_API sint8 m2m_wifi_enable_mac_mcast(winc1500_t *dev, uint8* pu8MulticastMacAddress, uint8 u8AddRemove)
 {
 	sint8 s8ret = M2M_ERR_FAIL;
 	tstrM2MMulticastMac  strMulticastMac;
@@ -1392,7 +1384,7 @@ NMI_API sint8 m2m_wifi_enable_mac_mcast(uint8* pu8MulticastMacAddress, uint8 u8A
 		strMulticastMac.u8AddRemove = u8AddRemove;
 		m2m_memcpy(strMulticastMac.au8macaddress,pu8MulticastMacAddress,M2M_MAC_ADDRES_LEN);
 		M2M_DBG("mac multicast: %x:%x:%x:%x:%x:%x\n",strMulticastMac.au8macaddress[0],strMulticastMac.au8macaddress[1],strMulticastMac.au8macaddress[2],strMulticastMac.au8macaddress[3],strMulticastMac.au8macaddress[4],strMulticastMac.au8macaddress[5]);
-		s8ret = hif_send(M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_SET_MAC_MCAST, (uint8 *)&strMulticastMac,sizeof(tstrM2MMulticastMac),NULL,0,0);
+		s8ret = hif_send(dev, M2M_REQ_GROUP_WIFI, M2M_WIFI_REQ_SET_MAC_MCAST, (uint8 *)&strMulticastMac,sizeof(tstrM2MMulticastMac),NULL,0,0);
 	}
 
 	return s8ret;
@@ -1414,13 +1406,14 @@ NMI_API sint8 m2m_wifi_enable_mac_mcast(uint8* pu8MulticastMacAddress, uint8 u8A
 @return
 	The function SHALL return 0 for success and a negative value otherwise.
 */
-NMI_API sint8  m2m_wifi_set_receive_buffer(void* pvBuffer,uint16 u16BufferLen)
+NMI_API sint8  m2m_wifi_set_receive_buffer(winc1500_t *dev, void* pvBuffer,uint16 u16BufferLen)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	sint8 s8ret = M2M_SUCCESS;
 	if(pvBuffer != NULL)
 	{
-		gau8ethRcvBuf = pvBuffer;
-		gu16ethRcvBufSize= u16BufferLen;
+		internal->gau8ethRcvBuf = pvBuffer;
+		internal->gu16ethRcvBufSize= u16BufferLen;
 	}
 	else
 	{
diff --git a/winc1500/driver/source/nmasic.c b/winc1500/driver/source/nmasic.c
index 54883ff..77af78a 100644
--- a/winc1500/driver/source/nmasic.c
+++ b/winc1500/driver/source/nmasic.c
@@ -62,7 +62,7 @@
 #define TIMEOUT						(0xfffffffful)
 #define WAKUP_TRAILS_TIMEOUT		(4)
 
-sint8 chip_apply_conf(uint32 u32Conf)
+sint8 chip_apply_conf(winc1500_t *dev, uint32 u32Conf)
 {
 	sint8 ret = M2M_SUCCESS;
 	uint32 val32 = u32Conf;
@@ -87,10 +87,10 @@ sint8 chip_apply_conf(uint32 u32Conf)
 
 	val32 |= rHAVE_RESERVED1_BIT;
 	do  {
-		nm_write_reg(rNMI_GP_REG_1, val32);
+		nm_write_reg(dev, rNMI_GP_REG_1, val32);
 		if(val32 != 0) {		
 			uint32 reg = 0;
-			ret = nm_read_reg_with_ret(rNMI_GP_REG_1, &reg);
+			ret = nm_read_reg_with_ret(dev, rNMI_GP_REG_1, &reg);
 			if(ret == M2M_SUCCESS) {
 				if(reg == val32)
 					break;
@@ -102,86 +102,86 @@ sint8 chip_apply_conf(uint32 u32Conf)
 
 	return M2M_SUCCESS;
 }
-void chip_idle(void)
+void chip_idle(winc1500_t *dev)
 {
 	uint32 reg = 0;
-	nm_read_reg_with_ret(WAKE_CLK_REG, &reg);
+	nm_read_reg_with_ret(dev, WAKE_CLK_REG, &reg);
 	if(reg & NBIT1)
 	{
 		reg &=~ NBIT1;
-		nm_write_reg(WAKE_CLK_REG, reg);
+		nm_write_reg(dev, WAKE_CLK_REG, reg);
 	}
 }
 
-sint8 enable_interrupts(void)
+sint8 enable_interrupts(winc1500_t *dev)
 {
 	uint32 reg = 0;
 	sint8 ret = M2M_SUCCESS;
 	/**
 	interrupt pin mux select
 	**/
-	ret = nm_read_reg_with_ret(NMI_PIN_MUX_0, &reg);
+	ret = nm_read_reg_with_ret(dev, NMI_PIN_MUX_0, &reg);
 	if (M2M_SUCCESS != ret) goto ERR1;
 	
 	reg |= ((uint32) 1 << 8);
-	ret = nm_write_reg(NMI_PIN_MUX_0, reg);
+	ret = nm_write_reg(dev, NMI_PIN_MUX_0, reg);
 	if (M2M_SUCCESS != ret) goto ERR1;
 	
 	/**
 	interrupt enable
 	**/
-	ret = nm_read_reg_with_ret(NMI_INTR_ENABLE, &reg);
+	ret = nm_read_reg_with_ret(dev, NMI_INTR_ENABLE, &reg);
 	if (M2M_SUCCESS != ret) goto ERR1;
 	
 	reg |= ((uint32) 1 << 16);
-	ret = nm_write_reg(NMI_INTR_ENABLE, reg);
+	ret = nm_write_reg(dev, NMI_INTR_ENABLE, reg);
 	if (M2M_SUCCESS != ret) goto ERR1;
 ERR1:	
 	return ret;
 }
 
-sint8 cpu_start(void) {
+sint8 cpu_start(winc1500_t *dev) {
 	uint32 reg = 0;
 	sint8 ret;
 
 	/**
 	reset regs
 	*/
-	ret = nm_write_reg(BOOTROM_REG,0);
-	ret += nm_write_reg(NMI_STATE_REG,0);
-	ret += nm_write_reg(NMI_REV_REG,0);
+	ret = nm_write_reg(dev, BOOTROM_REG,0);
+	ret += nm_write_reg(dev, NMI_STATE_REG,0);
+	ret += nm_write_reg(dev, NMI_REV_REG,0);
 	/**
 	Go...
 	**/
-	ret += nm_read_reg_with_ret(0x1118, &reg);
+	ret += nm_read_reg_with_ret(dev, 0x1118, &reg);
 	reg |= (1 << 0);
-	ret += nm_write_reg(0x1118, reg);
-	ret += nm_read_reg_with_ret(NMI_GLB_RESET_0, &reg);
+	ret += nm_write_reg(dev, 0x1118, reg);
+	ret += nm_read_reg_with_ret(dev, NMI_GLB_RESET_0, &reg);
 	if ((reg & (1ul << 10)) == (1ul << 10)) {
 		reg &= ~(1ul << 10);
-		ret += nm_write_reg(NMI_GLB_RESET_0, reg);
+		ret += nm_write_reg(dev, NMI_GLB_RESET_0, reg);
 	}
 	reg |= (1ul << 10);
-	ret += nm_write_reg(NMI_GLB_RESET_0, reg);
+	ret += nm_write_reg(dev, NMI_GLB_RESET_0, reg);
 	nm_bsp_sleep(1);
 	return ret;
 }
 
-uint32 nmi_get_chipid(void)
+uint32 nmi_get_chipid(winc1500_t *dev)
 {
 	static uint32 chipid = 0;
 
 	if (chipid == 0) {
 		uint32 rfrevid;
 		
-		if((nm_read_reg_with_ret(0x1000, &chipid)) != M2M_SUCCESS) {
+		if((nm_read_reg_with_ret(dev, 0x1000, &chipid)) != M2M_SUCCESS) {
 			chipid = 0;
 			return 0;
 		}
 		//if((ret = nm_read_reg_with_ret(0x11fc, &revid)) != M2M_SUCCESS) {
 		//	return 0;
 		//}
-		if((nm_read_reg_with_ret(0x13f4, &rfrevid)) != M2M_SUCCESS) {
+		if((nm_read_reg_with_ret(dev, 0x13f4, &rfrevid)) != M2M_SUCCESS) {
 			chipid = 0;
 			return 0;
 		}
@@ -199,7 +199,7 @@ uint32 nmi_get_chipid(void)
 				chipid = 0x1002b2;
 			}
 		}else if(chipid == 0x1000F0) { 
-			if((nm_read_reg_with_ret(0x3B0000, &chipid)) != M2M_SUCCESS) {
+			if((nm_read_reg_with_ret(dev, 0x3B0000, &chipid)) != M2M_SUCCESS) {
 			chipid = 0;
 			return 0;
 			}
@@ -211,7 +211,7 @@ uint32 nmi_get_chipid(void)
 		if(chipid) {
 			UWORD32 flashid;
 
-			flashid = probe_spi_flash();
+			flashid = probe_spi_flash(dev);
 			if(flashid == 0x1230ef) {
 				chipid &= ~(0x0f0000);
 				chipid |= 0x050000;
@@ -230,112 +230,112 @@ uint32 nmi_get_chipid(void)
 	return chipid;
 }
 
-uint32 nmi_get_rfrevid(void)
+uint32 nmi_get_rfrevid(winc1500_t *dev)
 {
     uint32 rfrevid;
-    if((nm_read_reg_with_ret(0x13f4, &rfrevid)) != M2M_SUCCESS) {
+    if((nm_read_reg_with_ret(dev, 0x13f4, &rfrevid)) != M2M_SUCCESS) {
         rfrevid = 0;
         return 0;
     }
     return rfrevid;
 }
 
-void restore_pmu_settings_after_global_reset(void)
+void restore_pmu_settings_after_global_reset(winc1500_t *dev)
 {
 	/*
 	* Must restore PMU register value after
 	* global reset if PMU toggle is done at
 	* least once since the last hard reset.
 	*/
-	if(REV(nmi_get_chipid()) >= REV_2B0) {
-		nm_write_reg(0x1e48, 0xb78469ce);
+	if(REV(nmi_get_chipid(dev)) >= REV_2B0) {
+		nm_write_reg(dev, 0x1e48, 0xb78469ce);
 	}
 }
 
-void nmi_update_pll(void)
+void nmi_update_pll(winc1500_t *dev)
 {
 	uint32 pll;
 
-	pll = nm_read_reg(0x1428);
+	pll = nm_read_reg(dev, 0x1428);
 	pll &= ~0x1ul;
-	nm_write_reg(0x1428, pll);
+	nm_write_reg(dev, 0x1428, pll);
 	pll |= 0x1ul;
-	nm_write_reg(0x1428, pll);
+	nm_write_reg(dev, 0x1428, pll);
 
 }
-void nmi_set_sys_clk_src_to_xo(void)
+void nmi_set_sys_clk_src_to_xo(winc1500_t *dev)
 {
 	uint32 val32;
 
 	/* Switch system clock source to XO. This will take effect after nmi_update_pll(). */
-	val32 = nm_read_reg(0x141c);
+	val32 = nm_read_reg(dev, 0x141c);
 	val32 |= (1 << 2);
-	nm_write_reg(0x141c, val32);
+	nm_write_reg(dev, 0x141c, val32);
 
 	/* Do PLL update */
-	nmi_update_pll();
+	nmi_update_pll(dev);
 }
-sint8 chip_sleep(void)
+sint8 chip_sleep(winc1500_t *dev)
 {
 	uint32 reg;
 	sint8 ret = M2M_SUCCESS;
 	
 	while(1)
 	{
-		ret = nm_read_reg_with_ret(CORT_HOST_COMM,&reg);
+		ret = nm_read_reg_with_ret(dev, CORT_HOST_COMM,&reg);
 		if(ret != M2M_SUCCESS) goto ERR1;
 		if((reg & NBIT0) == 0) break;
 	}
 	
 	/* Clear bit 1 */
-	ret = nm_read_reg_with_ret(WAKE_CLK_REG, &reg);
+	ret = nm_read_reg_with_ret(dev, WAKE_CLK_REG, &reg);
 	if(ret != M2M_SUCCESS)goto ERR1;
 	if(reg & NBIT1)
 	{
 		reg &=~NBIT1;
-		ret = nm_write_reg(WAKE_CLK_REG, reg);
+		ret = nm_write_reg(dev, WAKE_CLK_REG, reg);
 		if(ret != M2M_SUCCESS)goto ERR1;
 	}
 	
-	ret = nm_read_reg_with_ret(HOST_CORT_COMM, &reg);
+	ret = nm_read_reg_with_ret(dev, HOST_CORT_COMM, &reg);
 	if(ret != M2M_SUCCESS)goto ERR1;
 	if(reg & NBIT0)
 	{
 		reg &= ~NBIT0;
-		ret = nm_write_reg(HOST_CORT_COMM, reg);
+		ret = nm_write_reg(dev, HOST_CORT_COMM, reg);
 		if(ret != M2M_SUCCESS)goto ERR1;
 	}
 
 ERR1:
 	return ret;
 }
-sint8 chip_wake(void)
+sint8 chip_wake(winc1500_t *dev)
 {
 	sint8 ret = M2M_SUCCESS;
 	uint32 reg = 0, clk_status_reg = 0,trials = 0;
 
-	ret = nm_read_reg_with_ret(HOST_CORT_COMM, &reg);
+	ret = nm_read_reg_with_ret(dev, HOST_CORT_COMM, &reg);
 	if(ret != M2M_SUCCESS)goto _WAKE_EXIT;
 	
 	if(!(reg & NBIT0))
 	{
 		/*USE bit 0 to indicate host wakeup*/
-		ret = nm_write_reg(HOST_CORT_COMM, reg|NBIT0);
+		ret = nm_write_reg(dev, HOST_CORT_COMM, reg|NBIT0);
 		if(ret != M2M_SUCCESS)goto _WAKE_EXIT;
 	}
 		
-	ret = nm_read_reg_with_ret(WAKE_CLK_REG, &reg);
+	ret = nm_read_reg_with_ret(dev, WAKE_CLK_REG, &reg);
 	if(ret != M2M_SUCCESS)goto _WAKE_EXIT;
 	/* Set bit 1 */
 	if(!(reg & NBIT1))
 	{
-		ret = nm_write_reg(WAKE_CLK_REG, reg | NBIT1);
+		ret = nm_write_reg(dev, WAKE_CLK_REG, reg | NBIT1);
 		if(ret != M2M_SUCCESS) goto _WAKE_EXIT;	
 	}
 
 	do
 	{
-		ret = nm_read_reg_with_ret(CLOCKS_EN_REG, &clk_status_reg);
+		ret = nm_read_reg_with_ret(dev, CLOCKS_EN_REG, &clk_status_reg);
 		if(ret != M2M_SUCCESS) {
 			M2M_ERR("Bus error (5).%d %lx\n",ret,clk_status_reg);
 			goto _WAKE_EXIT;
@@ -354,50 +354,50 @@ sint8 chip_wake(void)
 	}while(1);
 	
 	/*workaround sometimes spi fail to read clock regs after reading/writing clockless registers*/
-	nm_bus_reset();
+	nm_bus_reset(dev);
 	
 _WAKE_EXIT:
 	return ret;
 }
-sint8 cpu_halt(void)
+sint8 cpu_halt(winc1500_t *dev)
 {
 	sint8 ret;
 	uint32 reg = 0;
-	ret = nm_read_reg_with_ret(0x1118, &reg);
+	ret = nm_read_reg_with_ret(dev, 0x1118, &reg);
 	reg |= (1 << 0);
-	ret += nm_write_reg(0x1118, reg);
-	ret += nm_read_reg_with_ret(NMI_GLB_RESET_0, &reg);
+	ret += nm_write_reg(dev, 0x1118, reg);
+	ret += nm_read_reg_with_ret(dev, NMI_GLB_RESET_0, &reg);
 	if ((reg & (1ul << 10)) == (1ul << 10)) {
 		reg &= ~(1ul << 10);
-		ret += nm_write_reg(NMI_GLB_RESET_0, reg);
-		ret += nm_read_reg_with_ret(NMI_GLB_RESET_0, &reg);
+		ret += nm_write_reg(dev, NMI_GLB_RESET_0, reg);
+		ret += nm_read_reg_with_ret(dev, NMI_GLB_RESET_0, &reg);
 	}
 	return ret;
 }
-sint8 chip_reset_and_cpu_halt(void)
+sint8 chip_reset_and_cpu_halt(winc1500_t *dev)
 {
 	sint8 ret = M2M_SUCCESS;
 
 	/*Wakeup needed only for I2C interface*/
-	ret = chip_wake();
+	ret = chip_wake(dev);
 	if(ret != M2M_SUCCESS) goto ERR1;
 	/*Reset and CPU halt need for no wait board only*/
-	ret = chip_reset();
+	ret = chip_reset(dev);
 	if(ret != M2M_SUCCESS) goto ERR1;
-	ret = cpu_halt();
+	ret = cpu_halt(dev);
 	if(ret != M2M_SUCCESS) goto ERR1;	
 ERR1:
 	return ret;
 }
-sint8 chip_reset(void)
+sint8 chip_reset(winc1500_t *dev)
 {
 	sint8 ret = M2M_SUCCESS;
-	ret = nm_write_reg(NMI_GLB_RESET_0, 0);
+	ret = nm_write_reg(dev, NMI_GLB_RESET_0, 0);
 	nm_bsp_sleep(50);
 	return ret;
 }
 
-sint8 wait_for_bootrom(uint8 arg)
+sint8 wait_for_bootrom(winc1500_t *dev, uint8 arg)
 {
 	sint8 ret = M2M_SUCCESS;
 	uint32 reg = 0, cnt = 0;
@@ -410,13 +410,13 @@ sint8 wait_for_bootrom(uint8 arg)
 
 	reg = 0;
 	while(1) {
-		reg = nm_read_reg(0x1014);	/* wait for efuse loading done */
+		reg = nm_read_reg(dev, 0x1014);	/* wait for efuse loading done */
 		if (reg & 0x80000000) {
 			break;
 		}
 		nm_bsp_sleep(1); /* TODO: Why bus error if this delay is not here. */
 	}
-	reg = nm_read_reg(M2M_WAIT_FOR_HOST_REG);
+	reg = nm_read_reg(dev, M2M_WAIT_FOR_HOST_REG);
 	reg &= 0x1;
 
 	/* check if waiting for the host will be skipped or not */
@@ -426,7 +426,7 @@ sint8 wait_for_bootrom(uint8 arg)
 		while(reg != M2M_FINISH_BOOT_ROM)
 		{
 			nm_bsp_sleep(1);
-			reg = nm_read_reg(BOOTROM_REG);
+			reg = nm_read_reg(dev, BOOTROM_REG);
 
 			if(++cnt > TIMEOUT)
 			{
@@ -438,57 +438,57 @@ sint8 wait_for_bootrom(uint8 arg)
 	}
 	
 	if(M2M_WIFI_MODE_ATE_HIGH == arg) {
-		nm_write_reg(NMI_REV_REG, M2M_ATE_FW_START_VALUE);
-		nm_write_reg(NMI_STATE_REG, NBIT20);
+		nm_write_reg(dev, NMI_REV_REG, M2M_ATE_FW_START_VALUE);
+		nm_write_reg(dev, NMI_STATE_REG, NBIT20);
 	}else if(M2M_WIFI_MODE_ATE_LOW == arg) {
-		nm_write_reg(NMI_REV_REG, M2M_ATE_FW_START_VALUE);
-		nm_write_reg(NMI_STATE_REG, 0);
+		nm_write_reg(dev, NMI_REV_REG, M2M_ATE_FW_START_VALUE);
+		nm_write_reg(dev, NMI_STATE_REG, 0);
 	}else if(M2M_WIFI_MODE_ETHERNET == arg){
 		u32GpReg1 = rHAVE_ETHERNET_MODE_BIT;
-		nm_write_reg(NMI_STATE_REG, u32DriverVerInfo);
+		nm_write_reg(dev, NMI_STATE_REG, u32DriverVerInfo);
 	} else {
 		/*bypass this step*/
-		nm_write_reg(NMI_STATE_REG, u32DriverVerInfo);
+		nm_write_reg(dev, NMI_STATE_REG, u32DriverVerInfo);
 	}
 
-	if(REV(nmi_get_chipid()) >= REV_3A0){
-		chip_apply_conf(u32GpReg1 | rHAVE_USE_PMU_BIT);
+	if(REV(nmi_get_chipid(dev)) >= REV_3A0){
+		chip_apply_conf(dev, u32GpReg1 | rHAVE_USE_PMU_BIT);
 	} else {
-		chip_apply_conf(u32GpReg1);
+		chip_apply_conf(dev, u32GpReg1);
 	}
 	M2M_INFO("DriverVerInfo: 0x%08lx\n",u32DriverVerInfo);
 
-	nm_write_reg(BOOTROM_REG,M2M_START_FIRMWARE);
+	nm_write_reg(dev, BOOTROM_REG,M2M_START_FIRMWARE);
 
 #ifdef __ROM_TEST__
-	rom_test();
+	rom_test(dev);
 #endif /* __ROM_TEST__ */
 
 ERR2:
 	return ret;
 }
 
-sint8 wait_for_firmware_start(uint8 arg)
+sint8 wait_for_firmware_start(winc1500_t *dev, uint8 arg)
 {
 	sint8 ret = M2M_SUCCESS;
 	uint32 reg = 0, cnt = 0;
 	uint32 u32Timeout = TIMEOUT;
 	volatile uint32 regAddress = NMI_STATE_REG;
 	volatile uint32 checkValue = M2M_FINISH_INIT_STATE;
-	
+
 	if((M2M_WIFI_MODE_ATE_HIGH == arg)||(M2M_WIFI_MODE_ATE_LOW == arg)) {
 		regAddress = NMI_REV_REG;
 		checkValue = M2M_ATE_FW_IS_UP_VALUE;
 	} else {
 		/*bypass this step*/
 	}
-	
-	
+
+
 	while (checkValue != reg)
 	{
 		nm_bsp_sleep(2); /* TODO: Why bus error if this delay is not here. */
-		M2M_DBG("%x %x %x\n",(unsigned int)nm_read_reg(0x108c),(unsigned int)nm_read_reg(0x108c),(unsigned int)nm_read_reg(0x14A0));
-		reg = nm_read_reg(regAddress);
+		M2M_DBG("%x %x %x\n",(unsigned int)nm_read_reg(dev, 0x108c),(unsigned int)nm_read_reg(dev, 0x108c),(unsigned int)nm_read_reg(dev, 0x14A0));
+		reg = nm_read_reg(dev, regAddress);
 		if(++cnt >= u32Timeout)
 		{
 			M2M_DBG("Time out for wait firmware Run\n");
@@ -498,13 +498,13 @@ sint8 wait_for_firmware_start(uint8 arg)
 	}
 	if(M2M_FINISH_INIT_STATE == checkValue)
 	{
-		nm_write_reg(NMI_STATE_REG, 0);
+		nm_write_reg(dev, NMI_STATE_REG, 0);
 	}
 ERR:
 	return ret;
 }
 
-sint8 chip_deinit(void)
+sint8 chip_deinit(winc1500_t *dev)
 {
 	uint32 reg = 0;
 	sint8 ret;
@@ -512,13 +512,13 @@ sint8 chip_deinit(void)
 	/**
 	stop the firmware, need a re-download
 	**/
-	ret = nm_read_reg_with_ret(NMI_GLB_RESET_0, &reg);
+	ret = nm_read_reg_with_ret(dev, NMI_GLB_RESET_0, &reg);
 	if (ret != M2M_SUCCESS) {
 		M2M_ERR("failed to de-initialize\n");
 		goto ERR1;
 	}
 	reg &= ~(1 << 10);
-	ret = nm_write_reg(NMI_GLB_RESET_0, reg);
+	ret = nm_write_reg(dev, NMI_GLB_RESET_0, reg);
 	if (ret != M2M_SUCCESS) {
 		M2M_ERR("failed to de-initialize\n");
 		goto ERR1;
@@ -530,12 +530,12 @@ ERR1:
 
 #ifdef CONF_PERIPH
 
-sint8 set_gpio_dir(uint8 gpio, uint8 dir)
+sint8 set_gpio_dir(winc1500_t *dev, uint8 gpio, uint8 dir)
 {
 	uint32 val32;
 	sint8 ret;
 
-	ret = nm_read_reg_with_ret(0x20108, &val32);
+	ret = nm_read_reg_with_ret(dev, 0x20108, &val32);
 	if(ret != M2M_SUCCESS) goto _EXIT;
 
 	if(dir) {
@@ -544,17 +544,17 @@ sint8 set_gpio_dir(uint8 gpio, uint8 dir)
 		val32 &= ~(1ul << gpio);
 	}
 
-	ret = nm_write_reg(0x20108, val32);
+	ret = nm_write_reg(dev, 0x20108, val32);
 
 _EXIT:
 	return ret;
 }
-sint8 set_gpio_val(uint8 gpio, uint8 val)
+sint8 set_gpio_val(winc1500_t *dev, uint8 gpio, uint8 val)
 {
 	uint32 val32;
 	sint8 ret;
 
-	ret = nm_read_reg_with_ret(0x20100, &val32);
+	ret = nm_read_reg_with_ret(dev, 0x20100, &val32);
 	if(ret != M2M_SUCCESS) goto _EXIT;
 
 	if(val) {
@@ -563,18 +563,18 @@ sint8 set_gpio_val(uint8 gpio, uint8 val)
 		val32 &= ~(1ul << gpio);
 	}
 
-	ret = nm_write_reg(0x20100, val32);
+	ret = nm_write_reg(dev, 0x20100, val32);
 
 _EXIT:
 	return ret;
 }
 
-sint8 get_gpio_val(uint8 gpio, uint8* val)
+sint8 get_gpio_val(winc1500_t *dev, uint8 gpio, uint8* val)
 {
 	uint32 val32;
 	sint8 ret;
 
-	ret = nm_read_reg_with_ret(0x20104, &val32);
+	ret = nm_read_reg_with_ret(dev, 0x20104, &val32);
 	if(ret != M2M_SUCCESS) goto _EXIT;
 
 	*val = (uint8)((val32 >> gpio) & 0x01);
@@ -583,11 +583,11 @@ _EXIT:
 	return ret;
 }
 
-sint8 pullup_ctrl(uint32 pinmask, uint8 enable)
+sint8 pullup_ctrl(winc1500_t *dev, uint32 pinmask, uint8 enable)
 {
 	sint8 s8Ret;
 	uint32 val32;
-	s8Ret = nm_read_reg_with_ret(0x142c, &val32);
+	s8Ret = nm_read_reg_with_ret(dev, 0x142c, &val32);
 	if(s8Ret != M2M_SUCCESS) {
 		M2M_ERR("[pullup_ctrl]: failed to read\n");
 		goto _EXIT;
@@ -597,7 +597,7 @@ sint8 pullup_ctrl(uint32 pinmask, uint8 enable)
 		} else {
 		val32 |= pinmask;
 	}
-	s8Ret = nm_write_reg(0x142c, val32);
+	s8Ret = nm_write_reg(dev, 0x142c, val32);
 	if(s8Ret  != M2M_SUCCESS) {
 		M2M_ERR("[pullup_ctrl]: failed to write\n");
 		goto _EXIT;
@@ -607,17 +607,17 @@ _EXIT:
 }
 #endif /* CONF_PERIPH */
 
-sint8 nmi_get_otp_mac_address(uint8 *pu8MacAddr,  uint8 * pu8IsValid)
+sint8 nmi_get_otp_mac_address(winc1500_t *dev, uint8 *pu8MacAddr,  uint8 * pu8IsValid)
 {
 	sint8 ret;
 	uint32	u32RegValue;
 	uint8	mac[6];
 	tstrGpRegs strgp = {0};
 
-	ret = nm_read_reg_with_ret(rNMI_GP_REG_2, &u32RegValue);
+	ret = nm_read_reg_with_ret(dev, rNMI_GP_REG_2, &u32RegValue);
 	if(ret != M2M_SUCCESS) goto _EXIT_ERR;
 
-	ret = nm_read_block(u32RegValue|0x30000,(uint8*)&strgp,sizeof(tstrGpRegs));
+	ret = nm_read_block(dev, u32RegValue|0x30000,(uint8*)&strgp,sizeof(tstrGpRegs));
 	if(ret != M2M_SUCCESS) goto _EXIT_ERR;
 	u32RegValue = strgp.u32Mac_efuse_mib;
 
@@ -629,7 +629,7 @@ sint8 nmi_get_otp_mac_address(uint8 *pu8MacAddr,  uint8 * pu8IsValid)
 
 	M2M_DBG("OTP MAC\n");
 	u32RegValue >>=16;
-	ret = nm_read_block(u32RegValue|0x30000, mac, 6);
+	ret = nm_read_block(dev, u32RegValue|0x30000, mac, 6);
 	m2m_memcpy(pu8MacAddr,mac,6);
 	if(pu8IsValid) *pu8IsValid = 1;
 	return ret;
@@ -639,22 +639,22 @@ _EXIT_ERR:
 	return ret;
 }
 
-sint8 nmi_get_mac_address(uint8 *pu8MacAddr)
+sint8 nmi_get_mac_address(winc1500_t *dev, uint8 *pu8MacAddr)
 {
 	sint8 ret;
 	uint32	u32RegValue;
 	uint8	mac[6];
 	tstrGpRegs strgp = {0};
 
-	ret = nm_read_reg_with_ret(rNMI_GP_REG_2, &u32RegValue);
+	ret = nm_read_reg_with_ret(dev, rNMI_GP_REG_2, &u32RegValue);
 	if(ret != M2M_SUCCESS) goto _EXIT_ERR;
 
-	ret = nm_read_block(u32RegValue|0x30000,(uint8*)&strgp,sizeof(tstrGpRegs));
+	ret = nm_read_block(dev, u32RegValue|0x30000,(uint8*)&strgp,sizeof(tstrGpRegs));
 	if(ret != M2M_SUCCESS) goto _EXIT_ERR;
 	u32RegValue = strgp.u32Mac_efuse_mib;
 
 	u32RegValue &=0x0000ffff;
-	ret = nm_read_block(u32RegValue|0x30000, mac, 6);
+	ret = nm_read_block(dev, u32RegValue|0x30000, mac, 6);
 	m2m_memcpy(pu8MacAddr, mac, 6);
 
 	return ret;
diff --git a/winc1500/driver/source/nmasic.h b/winc1500/driver/source/nmasic.h
index 84a395b..128f551 100644
--- a/winc1500/driver/source/nmasic.h
+++ b/winc1500/driver/source/nmasic.h
@@ -66,7 +66,7 @@
 #define REV_2B0        (0x2B0)
 #define REV_B0         (0x2B0)
 #define REV_3A0        (0x3A0)
-#define GET_CHIPID()	nmi_get_chipid()
+#define GET_CHIPID(dev)	nmi_get_chipid(dev)
 #define ISNMC1000(id)   ((((id) & 0xfffff000) == 0x100000) ? 1 : 0)
 #define ISNMC1500(id)   ((((id) & 0xfffff000) == 0x150000) ? 1 : 0)
 #define ISNMC3000(id)   ((((id) & 0xfff00000) == 0x300000) ? 1 : 0)
@@ -96,117 +96,117 @@ typedef struct{
 *	@fn		cpu_halt
 *	@brief	
 */
-sint8 cpu_halt(void);
+sint8 cpu_halt(winc1500_t *dev);
 /*
 *	@fn		chip_sleep
 *	@brief	
 */
-sint8 chip_sleep(void);
+sint8 chip_sleep(winc1500_t *dev);
 /*
 *	@fn		chip_wake
 *	@brief	
 */
-sint8 chip_wake(void);
+sint8 chip_wake(winc1500_t *dev);
 /*
 *	@fn		chip_idle
 *	@brief	
 */
-void chip_idle(void);
+void chip_idle(winc1500_t *dev);
 /*
 *	@fn		enable_interrupts
 *	@brief	
 */
-sint8 enable_interrupts(void);
+sint8 enable_interrupts(winc1500_t *dev);
 /*
 *	@fn		cpu_start	
 *	@brief	
 */
-sint8 cpu_start(void);
+sint8 cpu_start(winc1500_t *dev);
 /*
 *	@fn		nmi_get_chipid
 *	@brief	
 */
-uint32 nmi_get_chipid(void);
+uint32 nmi_get_chipid(winc1500_t *dev);
 /*
 *	@fn		nmi_get_rfrevid
 *	@brief	
 */
-uint32 nmi_get_rfrevid(void);
+uint32 nmi_get_rfrevid(winc1500_t *dev);
 /*
 *	@fn		restore_pmu_settings_after_global_reset
 *	@brief	
 */
-void restore_pmu_settings_after_global_reset(void);
+void restore_pmu_settings_after_global_reset(winc1500_t *dev);
 /*
 *	@fn		nmi_update_pll
 *	@brief	
 */
-void nmi_update_pll(void);
+void nmi_update_pll(winc1500_t *dev);
 /*
 *	@fn		nmi_set_sys_clk_src_to_xo
 *	@brief	
 */
-void nmi_set_sys_clk_src_to_xo(void);
+void nmi_set_sys_clk_src_to_xo(winc1500_t *dev);
 /*
 *	@fn		chip_reset
 *	@brief	
 */
-sint8 chip_reset(void);
+sint8 chip_reset(winc1500_t *dev);
 /*
 *	@fn		wait_for_bootrom
 *	@brief	
 */
-sint8 wait_for_bootrom(uint8);
+sint8 wait_for_bootrom(winc1500_t *dev, uint8);
 /*
 *	@fn		wait_for_firmware_start
 *	@brief	
 */
-sint8 wait_for_firmware_start(uint8);
+sint8 wait_for_firmware_start(winc1500_t *dev, uint8);
 /*
 *	@fn		chip_deinit
 *	@brief	
 */
-sint8 chip_deinit(void);
+sint8 chip_deinit(winc1500_t *dev);
 /*
 *	@fn		chip_reset_and_cpu_halt
 *	@brief	
 */
-sint8 chip_reset_and_cpu_halt(void);
+sint8 chip_reset_and_cpu_halt(winc1500_t *dev);
 /*
 *	@fn		set_gpio_dir
 *	@brief	
 */
-sint8 set_gpio_dir(uint8 gpio, uint8 dir);
+sint8 set_gpio_dir(winc1500_t *dev, uint8 gpio, uint8 dir);
 /*
 *	@fn		set_gpio_val
 *	@brief	
 */
-sint8 set_gpio_val(uint8 gpio, uint8 val);
+sint8 set_gpio_val(winc1500_t *dev, uint8 gpio, uint8 val);
 /*
 *	@fn		get_gpio_val
 *	@brief	
 */
-sint8 get_gpio_val(uint8 gpio, uint8* val);
+sint8 get_gpio_val(winc1500_t *dev, uint8 gpio, uint8* val);
 /*
 *	@fn		pullup_ctrl
 *	@brief	
 */
-sint8 pullup_ctrl(uint32 pinmask, uint8 enable);
+sint8 pullup_ctrl(winc1500_t *dev, uint32 pinmask, uint8 enable);
 /*
 *	@fn		nmi_get_otp_mac_address
 *	@brief	
 */
-sint8 nmi_get_otp_mac_address(uint8 *pu8MacAddr, uint8 * pu8IsValid);
+sint8 nmi_get_otp_mac_address(winc1500_t *dev, uint8 *pu8MacAddr, uint8 * pu8IsValid);
 /*
 *	@fn		nmi_get_mac_address
 *	@brief	
 */
-sint8 nmi_get_mac_address(uint8 *pu8MacAddr);
+sint8 nmi_get_mac_address(winc1500_t *dev, uint8 *pu8MacAddr);
 /*
 *	@fn		chip_apply_conf
 *	@brief	
 */
-sint8 chip_apply_conf(uint32 u32conf);
+sint8 chip_apply_conf(winc1500_t *dev, uint32 u32conf);
 
 #ifdef __cplusplus
 	 }
diff --git a/winc1500/driver/source/nmbus.c b/winc1500/driver/source/nmbus.c
index 491a3d3..b073a44 100644
--- a/winc1500/driver/source/nmbus.c
+++ b/winc1500/driver/source/nmbus.c
@@ -55,10 +55,10 @@
 *	@date	11 July 2012
 *	@version	1.0
 */
-sint8 nm_bus_iface_init(void *pvInitVal)
+sint8 nm_bus_iface_init(winc1500_t *dev, void *pvInitVal)
 {
 	sint8 ret = M2M_SUCCESS;
-	ret = nm_bus_init(pvInitVal);
+	ret = nm_bus_init(dev, pvInitVal);
 	return ret;
 }
 
@@ -70,10 +70,10 @@ sint8 nm_bus_iface_init(void *pvInitVal)
 *	@date	07 April 2014
 *	@version	1.0
 */
-sint8 nm_bus_iface_deinit(void)
+sint8 nm_bus_iface_deinit(winc1500_t *dev)
 {
 	sint8 ret = M2M_SUCCESS;
-	ret = nm_bus_deinit();
+	ret = nm_bus_deinit(dev);
 
 	return ret;
 }
@@ -84,12 +84,12 @@ sint8 nm_bus_iface_deinit(void)
 *	@return	M2M_SUCCESS in case of success and M2M_ERR_BUS_FAIL in case of failure
 *	@version	1.0
 */
-sint8 nm_bus_reset(void)
+sint8 nm_bus_reset(winc1500_t *dev)
 {
 	sint8 ret = M2M_SUCCESS;
 #ifdef CONF_WINC_USE_UART
 #elif defined (CONF_WINC_USE_SPI)
-	return nm_spi_reset();
+	return nm_spi_reset(dev);
 #elif defined (CONF_WINC_USE_I2C)
 #else
 #error "Plesae define bus usage"
@@ -106,13 +106,16 @@ sint8 nm_bus_reset(void)
 *	@date	22 Oct 2014
 *	@version	1.0
 */
-sint8 nm_bus_iface_reconfigure(void *ptr)
+sint8 nm_bus_iface_reconfigure(winc1500_t *dev, void *ptr)
 {
+#ifndef CONF_WINC_USE_UART
+	(void)dev;
+#endif
 	(void)ptr;
 	
 	sint8 ret = M2M_SUCCESS;
 #ifdef CONF_WINC_USE_UART
-	ret = nm_uart_reconfigure(ptr);
+	ret = nm_uart_reconfigure(dev, ptr);
 #endif
 	return ret;
 }
@@ -126,14 +129,14 @@ sint8 nm_bus_iface_reconfigure(void *ptr)
 *	@date	11 July 2012
 *	@version	1.0
 */
-uint32 nm_read_reg(uint32 u32Addr)
+uint32 nm_read_reg(winc1500_t *dev, uint32 u32Addr)
 {
 #ifdef CONF_WINC_USE_UART
-	return nm_uart_read_reg(u32Addr);
+	return nm_uart_read_reg(dev, u32Addr);
 #elif defined (CONF_WINC_USE_SPI)
-	return nm_spi_read_reg(u32Addr);
+	return nm_spi_read_reg(dev, u32Addr);
 #elif defined (CONF_WINC_USE_I2C)
-	return nm_i2c_read_reg(u32Addr);
+	return nm_i2c_read_reg(dev, u32Addr);
 #else
 #error "Plesae define bus usage"
 #endif
@@ -152,14 +155,14 @@ uint32 nm_read_reg(uint32 u32Addr)
 *	@date	11 July 2012
 *	@version	1.0
 */
-sint8 nm_read_reg_with_ret(uint32 u32Addr, uint32* pu32RetVal)
+sint8 nm_read_reg_with_ret(winc1500_t *dev, uint32 u32Addr, uint32* pu32RetVal)
 {
 #ifdef CONF_WINC_USE_UART
-	return nm_uart_read_reg_with_ret(u32Addr,pu32RetVal);
+	return nm_uart_read_reg_with_ret(dev, u32Addr,pu32RetVal);
 #elif defined (CONF_WINC_USE_SPI)
-	return nm_spi_read_reg_with_ret(u32Addr,pu32RetVal);
+	return nm_spi_read_reg_with_ret(dev, u32Addr,pu32RetVal);
 #elif defined (CONF_WINC_USE_I2C)
-	return nm_i2c_read_reg_with_ret(u32Addr,pu32RetVal);
+	return nm_i2c_read_reg_with_ret(dev, u32Addr,pu32RetVal);
 #else
 #error "Plesae define bus usage"
 #endif
@@ -177,27 +180,27 @@ sint8 nm_read_reg_with_ret(uint32 u32Addr, uint32* pu32RetVal)
 *	@date	11 July 2012
 *	@version	1.0
 */
-sint8 nm_write_reg(uint32 u32Addr, uint32 u32Val)
+sint8 nm_write_reg(winc1500_t *dev, uint32 u32Addr, uint32 u32Val)
 {
 #ifdef CONF_WINC_USE_UART
-	return nm_uart_write_reg(u32Addr,u32Val);
+	return nm_uart_write_reg(dev, u32Addr,u32Val);
 #elif defined (CONF_WINC_USE_SPI)
-	return nm_spi_write_reg(u32Addr,u32Val);
+	return nm_spi_write_reg(dev, u32Addr,u32Val);
 #elif defined (CONF_WINC_USE_I2C)
-	return nm_i2c_write_reg(u32Addr,u32Val);
+	return nm_i2c_write_reg(dev, u32Addr,u32Val);
 #else
 #error "Plesae define bus usage"
 #endif
 }
 
-static sint8 p_nm_read_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
+static sint8 p_nm_read_block(winc1500_t *dev, uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
 {
 #ifdef CONF_WINC_USE_UART
-	return nm_uart_read_block(u32Addr,puBuf,u16Sz);
+	return nm_uart_read_block(dev, u32Addr,puBuf,u16Sz);
 #elif defined (CONF_WINC_USE_SPI)
-	return nm_spi_read_block(u32Addr,puBuf,u16Sz);
+	return nm_spi_read_block(dev, u32Addr,puBuf,u16Sz);
 #elif defined (CONF_WINC_USE_I2C)
-	return nm_i2c_read_block(u32Addr,puBuf,u16Sz);
+	return nm_i2c_read_block(dev, u32Addr,puBuf,u16Sz);
 #else
 #error "Plesae define bus usage"
 #endif
@@ -217,7 +220,7 @@ static sint8 p_nm_read_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
 *	@date	11 July 2012
 *	@version	1.0
 */ 
-sint8 nm_read_block(uint32 u32Addr, uint8 *puBuf, uint32 u32Sz)
+sint8 nm_read_block(winc1500_t *dev, uint32 u32Addr, uint8 *puBuf, uint32 u32Sz)
 {
 	uint16 u16MaxTrxSz = egstrNmBusCapabilities.u16MaxTrxSz - MAX_TRX_CFG_SZ;
 	uint32 off = 0;
@@ -227,12 +230,12 @@ sint8 nm_read_block(uint32 u32Addr, uint8 *puBuf, uint32 u32Sz)
 	{
 		if(u32Sz <= u16MaxTrxSz)
 		{
-			s8Ret += p_nm_read_block(u32Addr, &puBuf[off], (uint16)u32Sz);	
+			s8Ret += p_nm_read_block(dev, u32Addr, &puBuf[off], (uint16)u32Sz);
 			break;
 		}
 		else
 		{
-			s8Ret += p_nm_read_block(u32Addr, &puBuf[off], u16MaxTrxSz);
+			s8Ret += p_nm_read_block(dev, u32Addr, &puBuf[off], u16MaxTrxSz);
 			if(M2M_SUCCESS != s8Ret) break;
 			u32Sz -= u16MaxTrxSz;
 			off += u16MaxTrxSz;
@@ -243,14 +246,14 @@ sint8 nm_read_block(uint32 u32Addr, uint8 *puBuf, uint32 u32Sz)
 	return s8Ret;
 }
 
-static sint8 p_nm_write_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
+static sint8 p_nm_write_block(winc1500_t *dev, uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
 {
 #ifdef CONF_WINC_USE_UART
-	return nm_uart_write_block(u32Addr,puBuf,u16Sz);
+	return nm_uart_write_block(dev, u32Addr,puBuf,u16Sz);
 #elif defined (CONF_WINC_USE_SPI)
-	return nm_spi_write_block(u32Addr,puBuf,u16Sz);
+	return nm_spi_write_block(dev, u32Addr,puBuf,u16Sz);
 #elif defined (CONF_WINC_USE_I2C)
-	return nm_i2c_write_block(u32Addr,puBuf,u16Sz);
+	return nm_i2c_write_block(dev, u32Addr,puBuf,u16Sz);
 #else
 #error "Plesae define bus usage"
 #endif
@@ -270,7 +273,7 @@ static sint8 p_nm_write_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
 *	@date	11 July 2012
 *	@version	1.0
 */ 
-sint8 nm_write_block(uint32 u32Addr, uint8 *puBuf, uint32 u32Sz)
+sint8 nm_write_block(winc1500_t *dev, uint32 u32Addr, uint8 *puBuf, uint32 u32Sz)
 {
 	uint16 u16MaxTrxSz = egstrNmBusCapabilities.u16MaxTrxSz - MAX_TRX_CFG_SZ;
 	uint32 off = 0;
@@ -280,12 +283,12 @@ sint8 nm_write_block(uint32 u32Addr, uint8 *puBuf, uint32 u32Sz)
 	{
 		if(u32Sz <= u16MaxTrxSz)
 		{
-			s8Ret += p_nm_write_block(u32Addr, &puBuf[off], (uint16)u32Sz);	
+			s8Ret += p_nm_write_block(dev, u32Addr, &puBuf[off], (uint16)u32Sz);
 			break;
 		}
 		else
 		{
-			s8Ret += p_nm_write_block(u32Addr, &puBuf[off], u16MaxTrxSz);
+			s8Ret += p_nm_write_block(dev, u32Addr, &puBuf[off], u16MaxTrxSz);
 			if(M2M_SUCCESS != s8Ret) break;
 			u32Sz -= u16MaxTrxSz;
 			off += u16MaxTrxSz;
diff --git a/winc1500/driver/source/nmbus.h b/winc1500/driver/source/nmbus.h
index 2ea7838..187faf2 100644
--- a/winc1500/driver/source/nmbus.h
+++ b/winc1500/driver/source/nmbus.h
@@ -55,7 +55,7 @@ extern "C"{
 *	@brief	Initialize bus interface
 *	@return	M2M_SUCCESS in case of success and M2M_ERR_BUS_FAIL in case of failure
 */
-sint8 nm_bus_iface_init(void *);
+sint8 nm_bus_iface_init(winc1500_t *dev, void *);
 
 
 /**
@@ -63,7 +63,7 @@ sint8 nm_bus_iface_init(void *);
 *	@brief	Deinitialize bus interface
 *	@return	M2M_SUCCESS in case of success and M2M_ERR_BUS_FAIL in case of failure
 */
-sint8 nm_bus_iface_deinit(void);
+sint8 nm_bus_iface_deinit(winc1500_t *dev);
 
 /**
 *	@fn		nm_bus_reset
@@ -71,14 +71,14 @@ sint8 nm_bus_iface_deinit(void);
 *	@return	M2M_SUCCESS in case of success and M2M_ERR_BUS_FAIL in case of failure
 *	@version	1.0
 */
-sint8 nm_bus_reset(void);
+sint8 nm_bus_reset(winc1500_t *dev);
 
 /**
 *	@fn		nm_bus_iface_reconfigure
 *	@brief	reconfigure bus interface
 *	@return	M2M_SUCCESS in case of success and M2M_ERR_BUS_FAIL in case of failure
 */
-sint8 nm_bus_iface_reconfigure(void *ptr);
+sint8 nm_bus_iface_reconfigure(winc1500_t *dev, void *ptr);
 
 /**
 *	@fn		nm_read_reg
@@ -87,7 +87,7 @@ sint8 nm_bus_iface_reconfigure(void *ptr);
 *				Register address
 *	@return	Register value
 */
-uint32 nm_read_reg(uint32 u32Addr);
+uint32 nm_read_reg(winc1500_t *dev, uint32 u32Addr);
 
 /**
 *	@fn		nm_read_reg_with_ret
@@ -98,7 +98,7 @@ uint32 nm_read_reg(uint32 u32Addr);
 *				Pointer to u32 variable used to return the read value
 *	@return	ZERO in case of success and M2M_ERR_BUS_FAIL in case of failure
 */
-sint8 nm_read_reg_with_ret(uint32 u32Addr, uint32* pu32RetVal);
+sint8 nm_read_reg_with_ret(winc1500_t *dev, uint32 u32Addr, uint32* pu32RetVal);
 
 /**
 *	@fn		nm_write_reg
@@ -109,7 +109,7 @@ sint8 nm_read_reg_with_ret(uint32 u32Addr, uint32* pu32RetVal);
 *				Value to be written to the register
 *	@return	ZERO in case of success and M2M_ERR_BUS_FAIL in case of failure
 */
-sint8 nm_write_reg(uint32 u32Addr, uint32 u32Val);
+sint8 nm_write_reg(winc1500_t *dev, uint32 u32Addr, uint32 u32Val);
 
 /**
 *	@fn		nm_read_block
@@ -122,7 +122,7 @@ sint8 nm_write_reg(uint32 u32Addr, uint32 u32Val);
 *				Number of bytes to read. The buffer size must be >= u32Sz
 *	@return	ZERO in case of success and M2M_ERR_BUS_FAIL in case of failure
 */ 
-sint8 nm_read_block(uint32 u32Addr, uint8 *puBuf, uint32 u32Sz);
+sint8 nm_read_block(winc1500_t *dev, uint32 u32Addr, uint8 *puBuf, uint32 u32Sz);
 
 /**
 *	@fn		nm_write_block
@@ -135,7 +135,7 @@ sint8 nm_read_block(uint32 u32Addr, uint8 *puBuf, uint32 u32Sz);
 *				Number of bytes to write. The buffer size must be >= u32Sz
 *	@return	ZERO in case of success and M2M_ERR_BUS_FAIL in case of failure
 */ 
-sint8 nm_write_block(uint32 u32Addr, uint8 *puBuf, uint32 u32Sz);
+sint8 nm_write_block(winc1500_t *dev, uint32 u32Addr, uint8 *puBuf, uint32 u32Sz);
 
 
 
diff --git a/winc1500/driver/source/nmdrv.c b/winc1500/driver/source/nmdrv.c
index 57e6f86..08de9b4 100644
--- a/winc1500/driver/source/nmdrv.c
+++ b/winc1500/driver/source/nmdrv.c
@@ -58,18 +58,18 @@
 *			    pointer holds address of structure "tstrM2mRev" that contains the firmware version parameters
 *	@version	1.0
 */
-sint8 nm_get_firmware_info(tstrM2mRev* M2mRev)
+sint8 nm_get_firmware_info(winc1500_t *dev, tstrM2mRev* M2mRev)
 {
 	uint16  curr_drv_ver, min_req_drv_ver,curr_firm_ver;
 	uint32	reg = 0;
 	sint8	ret = M2M_SUCCESS;
 
-	ret = nm_read_reg_with_ret(NMI_REV_REG, &reg);
+	ret = nm_read_reg_with_ret(dev, NMI_REV_REG, &reg);
 	//In case the Firmware running is ATE fw
 	if(M2M_ATE_FW_IS_UP_VALUE == reg)
 	{
 		//Read FW info again from the register specified for ATE
-		ret = nm_read_reg_with_ret(NMI_REV_REG_ATE, &reg);
+		ret = nm_read_reg_with_ret(dev, NMI_REV_REG_ATE, &reg);
 	}
 	M2mRev->u8DriverMajor	= M2M_GET_DRV_MAJOR(reg);
 	M2mRev->u8DriverMinor   = M2M_GET_DRV_MINOR(reg);
@@ -77,14 +77,14 @@ sint8 nm_get_firmware_info(tstrM2mRev* M2mRev)
 	M2mRev->u8FirmwareMajor	= M2M_GET_FW_MAJOR(reg);
 	M2mRev->u8FirmwareMinor = M2M_GET_FW_MINOR(reg);
 	M2mRev->u8FirmwarePatch = M2M_GET_FW_PATCH(reg);
-	M2mRev->u32Chipid	= nmi_get_chipid();
+	M2mRev->u32Chipid	= nmi_get_chipid(dev);
 	M2mRev->u16FirmwareSvnNum = 0;
 
 	curr_firm_ver   = M2M_MAKE_VERSION(M2mRev->u8FirmwareMajor, M2mRev->u8FirmwareMinor,M2mRev->u8FirmwarePatch);
 	curr_drv_ver    = M2M_MAKE_VERSION(M2M_RELEASE_VERSION_MAJOR_NO, M2M_RELEASE_VERSION_MINOR_NO, M2M_RELEASE_VERSION_PATCH_NO);
 	min_req_drv_ver = M2M_MAKE_VERSION(M2mRev->u8DriverMajor, M2mRev->u8DriverMinor,M2mRev->u8DriverPatch);
 	if(curr_drv_ver <  min_req_drv_ver) {
-		/*The current driver version should be larger or equal 
+		/*The current driver version should be larger or equal
 		than the min driver that the current firmware support  */
 		ret = M2M_ERR_FW_VER_MISMATCH;
 	}
@@ -104,7 +104,7 @@ sint8 nm_get_firmware_info(tstrM2mRev* M2mRev)
 *			    pointer holds address of structure "tstrM2mRev" that contains the firmware version parameters
 *	@version	1.0
 */
-sint8 nm_get_firmware_full_info(tstrM2mRev* pstrRev)
+sint8 nm_get_firmware_full_info(winc1500_t *dev, tstrM2mRev* pstrRev)
 {
 	uint16  curr_drv_ver, min_req_drv_ver,curr_firm_ver;
 	uint32	reg = 0;
@@ -113,19 +113,19 @@ sint8 nm_get_firmware_full_info(tstrM2mRev* pstrRev)
 	if (pstrRev != NULL)
 	{
 		m2m_memset((uint8*)pstrRev,0,sizeof(tstrM2mRev));
-		ret = nm_read_reg_with_ret(rNMI_GP_REG_2, &reg);
+		ret = nm_read_reg_with_ret(dev, rNMI_GP_REG_2, &reg);
 		if(ret == M2M_SUCCESS)
 		{
 			if(reg != 0)
 			{
-				ret = nm_read_block(reg|0x30000,(uint8*)&strgp,sizeof(tstrGpRegs));
+				ret = nm_read_block(dev, reg|0x30000,(uint8*)&strgp,sizeof(tstrGpRegs));
 				if(ret == M2M_SUCCESS)
 				{
 					reg = strgp.u32Firmware_Ota_rev;
 					reg &= 0x0000ffff;
 					if(reg != 0)
 					{
-						ret = nm_read_block(reg|0x30000,(uint8*)pstrRev,sizeof(tstrM2mRev));
+						ret = nm_read_block(dev, reg|0x30000,(uint8*)pstrRev,sizeof(tstrM2mRev));
 						if(ret == M2M_SUCCESS)
 						{
 							curr_firm_ver   = M2M_MAKE_VERSION(pstrRev->u8FirmwareMajor, pstrRev->u8FirmwareMinor,pstrRev->u8FirmwarePatch);
@@ -136,7 +136,7 @@ sint8 nm_get_firmware_full_info(tstrM2mRev* pstrRev)
 								goto EXIT;
 							}
 							if(curr_drv_ver <  min_req_drv_ver) {
-								/*The current driver version should be larger or equal 
+								/*The current driver version should be larger or equal
 								than the min driver that the current firmware support  */
 								ret = M2M_ERR_FW_VER_MISMATCH;
 								goto EXIT;
@@ -165,10 +165,10 @@ EXIT:
 *	@brief	Get Firmware version info
 *	@param [out]	M2mRev
 *			    pointer holds address of structure "tstrM2mRev" that contains the firmware version parameters
-			
+
 *	@version	1.0
 */
-sint8 nm_get_ota_firmware_info(tstrM2mRev* pstrRev)
+sint8 nm_get_ota_firmware_info(winc1500_t *dev, tstrM2mRev* pstrRev)
 {
 	uint16  curr_drv_ver, min_req_drv_ver,curr_firm_ver;
 	uint32	reg = 0;
@@ -178,19 +178,19 @@ sint8 nm_get_ota_firmware_info(tstrM2mRev* pstrRev)
 	if (pstrRev != NULL)
 	{
 		m2m_memset((uint8*)pstrRev,0,sizeof(tstrM2mRev));
-		ret = nm_read_reg_with_ret(rNMI_GP_REG_2, &reg);
+		ret = nm_read_reg_with_ret(dev, rNMI_GP_REG_2, &reg);
 		if(ret == M2M_SUCCESS)
 		{
 			if(reg != 0)
 			{
-				ret = nm_read_block(reg|0x30000,(uint8*)&strgp,sizeof(tstrGpRegs));
+				ret = nm_read_block(dev, reg|0x30000,(uint8*)&strgp,sizeof(tstrGpRegs));
 				if(ret == M2M_SUCCESS)
 				{
 					reg = strgp.u32Firmware_Ota_rev;
 					reg >>= 16;
 					if(reg != 0)
 					{
-						ret = nm_read_block(reg|0x30000,(uint8*)pstrRev,sizeof(tstrM2mRev));
+						ret = nm_read_block(dev, reg|0x30000,(uint8*)pstrRev,sizeof(tstrM2mRev));
 						if(ret == M2M_SUCCESS)
 						{
 							curr_firm_ver   = M2M_MAKE_VERSION(pstrRev->u8FirmwareMajor, pstrRev->u8FirmwareMinor,pstrRev->u8FirmwarePatch);
@@ -201,7 +201,7 @@ sint8 nm_get_ota_firmware_info(tstrM2mRev* pstrRev)
 								goto EXIT;
 							}
 							if(curr_drv_ver <  min_req_drv_ver) {
-								/*The current driver version should be larger or equal 
+								/*The current driver version should be larger or equal
 								than the min driver that the current firmware support  */
 								ret = M2M_ERR_FW_VER_MISMATCH;
 							}
@@ -237,11 +237,11 @@ EXIT:
 *	@date	10 Oct 2014
 *	@version	1.0
 */
-sint8 nm_drv_init_download_mode(void)
+sint8 nm_drv_init_download_mode(winc1500_t *dev)
 {
 	sint8 ret = M2M_SUCCESS;
 
-	ret = nm_bus_iface_init(NULL);
+	ret = nm_bus_iface_init(dev, NULL);
 	if (M2M_SUCCESS != ret) {
 		M2M_ERR("[nmi start]: fail init bus\n");
 		goto ERR1;
@@ -250,21 +250,21 @@ sint8 nm_drv_init_download_mode(void)
 	/**
 		TODO:reset the chip and halt the cpu in case of no wait efuse is set (add the no wait effuse check)
 	*/
-	if(!ISNMC3000(GET_CHIPID()))
+	if(!ISNMC3000(GET_CHIPID(dev)))
 	{
 		/*Execuate that function only for 1500A/B, no room in 3000, but it may be needed in 3400 no wait*/
-		chip_reset_and_cpu_halt();
+		chip_reset_and_cpu_halt(dev);
 	}
 
 #ifdef CONF_WINC_USE_SPI
 	/* Must do this after global reset to set SPI data packet size. */
-	nm_spi_init();
+	nm_spi_init(dev);
 #endif
 
-	M2M_INFO("Chip ID %lx\n", nmi_get_chipid());
+	M2M_INFO("Chip ID %lx\n", nmi_get_chipid(dev));
 
 	/*disable all interrupt in ROM (to disable uart) in 2b0 chip*/
-	nm_write_reg(0x20300,0);
+	nm_write_reg(dev, 0x20300,0);
 
 ERR1:
 	return ret;
@@ -280,11 +280,11 @@ ERR1:
 *	@date	15 July 2012
 *	@version	1.0
 */
-sint8 nm_drv_init(void * arg)
+sint8 nm_drv_init(winc1500_t *dev, void * arg)
 {
 	sint8 ret = M2M_SUCCESS;
 	uint8 u8Mode;
-	
+
 	if(NULL != arg) {
 		u8Mode = *((uint8 *)arg);
 		if((u8Mode < M2M_WIFI_MODE_NORMAL)||(u8Mode >= M2M_WIFI_MODE_MAX)) {
@@ -293,8 +293,8 @@ sint8 nm_drv_init(void * arg)
 	} else {
 		u8Mode = M2M_WIFI_MODE_NORMAL;
 	}
-	
-	ret = nm_bus_iface_init(NULL);
+
+	ret = nm_bus_iface_init(dev, NULL);
 	if (M2M_SUCCESS != ret) {
 		M2M_ERR("[nmi start]: fail init bus\n");
 		goto ERR1;
@@ -303,10 +303,10 @@ sint8 nm_drv_init(void * arg)
 #ifdef BUS_ONLY
 	return;
 #endif
-	
-	
+
+
 #ifdef NO_HW_CHIP_EN
-	ret = chip_wake();
+	ret = chip_wake(dev);
 	if (M2M_SUCCESS != ret) {
 		M2M_ERR("[nmi start]: fail chip_wakeup\n");
 		goto ERR2;
@@ -314,40 +314,40 @@ sint8 nm_drv_init(void * arg)
 	/**
 	Go...
 	**/
-	ret = chip_reset();
+	ret = chip_reset(dev);
 	if (M2M_SUCCESS != ret) {
 		goto ERR2;
 	}
 #endif
-	M2M_INFO("Chip ID %lx\n", nmi_get_chipid());
+	M2M_INFO("Chip ID %lx\n", nmi_get_chipid(dev));
 #ifdef CONF_WINC_USE_SPI
 	/* Must do this after global reset to set SPI data packet size. */
-	nm_spi_init();
+	nm_spi_init(dev);
 #endif
-	ret = wait_for_bootrom(u8Mode);
+	ret = wait_for_bootrom(dev, u8Mode);
 	if (M2M_SUCCESS != ret) {
 		goto ERR2;
 	}
-		
-	ret = wait_for_firmware_start(u8Mode);
+
+	ret = wait_for_firmware_start(dev, u8Mode);
 	if (M2M_SUCCESS != ret) {
 		goto ERR2;
 	}
-	
+
 	if((M2M_WIFI_MODE_ATE_HIGH == u8Mode)||(M2M_WIFI_MODE_ATE_LOW == u8Mode)) {
 		goto ERR1;
 	} else {
 		/*continue running*/
 	}
-	
-	ret = enable_interrupts();
+
+	ret = enable_interrupts(dev);
 	if (M2M_SUCCESS != ret) {
 		M2M_ERR("failed to enable interrupts..\n");
 		goto ERR2;
 	}
 	return ret;
 ERR2:
-	nm_bus_iface_deinit();
+	nm_bus_iface_deinit(dev);
 ERR1:
 	return ret;
 }
@@ -359,33 +359,33 @@ ERR1:
 *	@date	17 July 2012
 *	@version	1.0
 */
-sint8 nm_drv_deinit(void * arg)
+sint8 nm_drv_deinit(winc1500_t *dev, void * arg)
 {
 	(void)arg;
-	
+
 	sint8 ret;
 
-	ret = chip_deinit();
+	ret = chip_deinit(dev);
 	if (M2M_SUCCESS != ret) {
 		M2M_ERR("[nmi stop]: chip_deinit fail\n");
 		goto ERR1;
 	}
-	
+
 	/* Disable SPI flash to save power when the chip is off */
-	ret = spi_flash_enable(0);
+	ret = spi_flash_enable(dev, 0);
 	if (M2M_SUCCESS != ret) {
 		M2M_ERR("[nmi stop]: SPI flash disable fail\n");
 		goto ERR1;
 	}
 
-	ret = nm_bus_iface_deinit();
+	ret = nm_bus_iface_deinit(dev);
 	if (M2M_SUCCESS != ret) {
 		M2M_ERR("[nmi stop]: fail init bus\n");
 		goto ERR1;
 	}
 #ifdef CONF_WINC_USE_SPI
 	/* Must do this after global reset to set SPI data packet size. */
-	nm_spi_deinit();
+	nm_spi_deinit(dev);
 #endif
 
 ERR1:
diff --git a/winc1500/driver/source/nmdrv.h b/winc1500/driver/source/nmdrv.h
index 6a416b2..31b884b 100644
--- a/winc1500/driver/source/nmdrv.h
+++ b/winc1500/driver/source/nmdrv.h
@@ -83,7 +83,7 @@ typedef struct {
 *			    pointer holds address of structure "tstrM2mRev" that contains the firmware version parameters
 *	@version	1.0
 */
-sint8 nm_get_firmware_info(tstrM2mRev* M2mRev);
+sint8 nm_get_firmware_info(winc1500_t *dev, tstrM2mRev* M2mRev);
 /**
 *	@fn		nm_get_firmware_full_info(tstrM2mRev* pstrRev)
 *	@brief	Get Firmware version info
@@ -91,7 +91,7 @@ sint8 nm_get_firmware_info(tstrM2mRev* M2mRev);
 *			    pointer holds address of structure "tstrM2mRev" that contains the firmware version parameters
 *	@version	1.0
 */
-sint8 nm_get_firmware_full_info(tstrM2mRev* pstrRev);
+sint8 nm_get_firmware_full_info(winc1500_t *dev, tstrM2mRev* pstrRev);
 /**
 *	@fn		nm_get_ota_firmware_info(tstrM2mRev* pstrRev)
 *	@brief	Get Firmware version info
@@ -100,13 +100,13 @@ sint8 nm_get_firmware_full_info(tstrM2mRev* pstrRev);
 			
 *	@version	1.0
 */
-sint8 nm_get_ota_firmware_info(tstrM2mRev* pstrRev);
+sint8 nm_get_ota_firmware_info(winc1500_t *dev, tstrM2mRev* pstrRev);
 /*
 *	@fn		nm_drv_init
 *	@brief	Initialize NMC1000 driver
 *	@return	ZERO in case of success and Negative error code in case of failure
 */
-sint8 nm_drv_init_download_mode(void);
+sint8 nm_drv_init_download_mode(winc1500_t *dev);
 
 /*
 *	@fn		nm_drv_init
@@ -117,7 +117,7 @@ sint8 nm_drv_init_download_mode(void);
 *	@return	ZERO in case of success and Negative error code in case of failure
 
 */
-sint8 nm_drv_init(void * arg);
+sint8 nm_drv_init(winc1500_t *dev, void * arg);
 
 /**
 *	@fn		nm_drv_deinit
@@ -127,7 +127,7 @@ sint8 nm_drv_init(void * arg);
 *				Generic argument TBD
 *	@return	ZERO in case of success and Negative error code in case of failure
 */
-sint8 nm_drv_deinit(void * arg);
+sint8 nm_drv_deinit(winc1500_t *dev, void * arg);
 
 #ifdef __cplusplus
 	 }
diff --git a/winc1500/driver/source/nmspi.c b/winc1500/driver/source/nmspi.c
index 9e76aa9..689c2bf 100644
--- a/winc1500/driver/source/nmspi.c
+++ b/winc1500/driver/source/nmspi.c
@@ -94,33 +94,31 @@
 #define DATA_PKT_SZ_8K			(8 * 1024)
 #define DATA_PKT_SZ				DATA_PKT_SZ_8K
 
-static uint8 	gu8Crc_off	=   0;
-
-static sint8 nmi_spi_read(uint8* b, uint16 sz)
+static sint8 nmi_spi_read(winc1500_t *dev, uint8* b, uint16 sz)
 {
 	tstrNmSpiRw spi;
 	spi.pu8InBuf = NULL;
 	spi.pu8OutBuf = b;
 	spi.u16Sz = sz;
-	return nm_bus_ioctl(NM_BUS_IOCTL_RW, &spi);
+	return nm_bus_ioctl(dev, NM_BUS_IOCTL_RW, &spi);
 }
 
-static sint8 nmi_spi_write(uint8* b, uint16 sz)
+static sint8 nmi_spi_write(winc1500_t *dev, uint8* b, uint16 sz)
 {
 	tstrNmSpiRw spi;
 	spi.pu8InBuf = b;
 	spi.pu8OutBuf = NULL;
 	spi.u16Sz = sz;
-	return nm_bus_ioctl(NM_BUS_IOCTL_RW, &spi);
+	return nm_bus_ioctl(dev, NM_BUS_IOCTL_RW, &spi);
 }
 #ifndef USE_OLD_SPI_SW
-static sint8 nmi_spi_rw(uint8 *bin,uint8* bout,uint16 sz)
+static sint8 nmi_spi_rw(winc1500_t *dev, uint8 *bin,uint8* bout,uint16 sz)
 {
 	tstrNmSpiRw spi;
 	spi.pu8InBuf = bin;
 	spi.pu8OutBuf = bout;
 	spi.u16Sz = sz;
-	return nm_bus_ioctl(NM_BUS_IOCTL_RW, &spi);	
+	return nm_bus_ioctl(dev, NM_BUS_IOCTL_RW, &spi);
 }
 #endif
 /********************************************
@@ -202,8 +200,9 @@ static uint8 crc7(uint8 crc, const uint8 *buffer, uint32 len)
 #define DATA_PKT_SZ_8K			(8 * 1024)
 #define DATA_PKT_SZ				DATA_PKT_SZ_8K
 
-static sint8 spi_cmd(uint8 cmd, uint32 adr, uint32 u32data, uint32 sz,uint8 clockless)
+static sint8 spi_cmd(winc1500_t *dev, uint8 cmd, uint32 adr, uint32 u32data, uint32 sz,uint8 clockless)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	uint8 bc[9];
 	uint8 len = 5;
 	sint8 result = N_OK;
@@ -286,12 +285,12 @@ static sint8 spi_cmd(uint8 cmd, uint32 adr, uint32 u32data, uint32 sz,uint8 cloc
 	}
 
 	if (result) {
-		if (!gu8Crc_off)
+		if (!internal->gu8Crc_off)
 			bc[len-1] = (crc7(0x7f, (const uint8 *)&bc[0], len-1)) << 1;
 		else
 			len-=1;
 
-		if (M2M_SUCCESS != nmi_spi_write(bc, len)) {
+		if (M2M_SUCCESS != nmi_spi_write(dev, bc, len)) {
 			M2M_ERR("[nmi spi]: Failed cmd write, bus error...\n");
 			result = N_FAIL;
 		}
@@ -300,25 +299,26 @@ static sint8 spi_cmd(uint8 cmd, uint32 adr, uint32 u32data, uint32 sz,uint8 cloc
 	return result;
 }
 
-static sint8 spi_data_rsp(uint8 cmd)
+static sint8 spi_data_rsp(winc1500_t *dev, uint8 cmd)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	(void)cmd;
-	
+
 	uint8 len;
 	uint8 rsp[3];
 	sint8 result = N_OK;
 
-    if (!gu8Crc_off)
+    if (!internal->gu8Crc_off)
 		len = 2;
 	else
 		len = 3;
 
-	if (M2M_SUCCESS != nmi_spi_read(&rsp[0], len)) {
+	if (M2M_SUCCESS != nmi_spi_read(dev, &rsp[0], len)) {
 		M2M_ERR("[nmi spi]: Failed bus error...\n");
 		result = N_FAIL;
 		goto _fail_;
 	}
-		
+
 	if((rsp[len-1] != 0)||(rsp[len-2] != 0xC3))
 	{
 		M2M_ERR("[nmi spi]: Failed data response read, %x %x %x\n",rsp[0],rsp[1],rsp[2]);
@@ -330,7 +330,7 @@ _fail_:
 	return result;
 }
 
-static sint8 spi_cmd_rsp(uint8 cmd)
+static sint8 spi_cmd_rsp(winc1500_t *dev, uint8 cmd)
 {
 	uint8 rsp;
 	sint8 result = N_OK;
@@ -342,7 +342,7 @@ static sint8 spi_cmd_rsp(uint8 cmd)
 	if ((cmd == CMD_RESET) ||
 		 (cmd == CMD_TERMINATE) ||
 		 (cmd == CMD_REPEAT)) {
-		if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
+		if (M2M_SUCCESS != nmi_spi_read(dev, &rsp, 1)) {
 			result = N_FAIL;
 			goto _fail_;
 		}
@@ -352,7 +352,7 @@ static sint8 spi_cmd_rsp(uint8 cmd)
 	s8RetryCnt = SPI_RESP_RETRY_COUNT;
 	do
 	{
-		if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
+		if (M2M_SUCCESS != nmi_spi_read(dev, &rsp, 1)) {
 			M2M_ERR("[nmi spi]: Failed cmd response read, bus error...\n");
 			result = N_FAIL;
 			goto _fail_;
@@ -366,7 +366,7 @@ static sint8 spi_cmd_rsp(uint8 cmd)
 	s8RetryCnt = SPI_RESP_RETRY_COUNT;
 	do
 	{
-		if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
+		if (M2M_SUCCESS != nmi_spi_read(dev, &rsp, 1)) {
 			M2M_ERR("[nmi spi]: Failed cmd response read, bus error...\n");
 			result = N_FAIL;
 			goto _fail_;
@@ -378,8 +378,9 @@ _fail_:
 	return result;
 }
 #ifndef USE_OLD_SPI_SW
-static int spi_cmd_complete(uint8_t cmd, uint32_t adr, uint8_t *b, uint32_t sz, uint8_t clockless)
+static int spi_cmd_complete(winc1500_t *dev, uint8_t cmd, uint32_t adr, uint8_t *b, uint32_t sz, uint8_t clockless)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	uint8_t wb[32], rb[32];
 	uint8_t wix, rix;
 	uint32_t len2;
@@ -468,7 +469,7 @@ static int spi_cmd_complete(uint8_t cmd, uint32_t adr, uint8_t *b, uint32_t sz,
 		return result;
 	}
 
-	if (!gu8Crc_off) {
+	if (!internal->gu8Crc_off) {
 		wb[len-1] = (crc7(0x7f, (const uint8_t *)&wb[0], len-1)) << 1;
 	} else {
 		len -=1;
@@ -486,7 +487,7 @@ static int spi_cmd_complete(uint8_t cmd, uint32_t adr, uint8_t *b, uint32_t sz,
 		(cmd == CMD_REPEAT)) {
 			len2 = len + (NUM_SKIP_BYTES + NUM_RSP_BYTES + NUM_DUMMY_BYTES);
 	} else if ((cmd == CMD_INTERNAL_READ) || (cmd == CMD_SINGLE_READ)) {
-		if (!gu8Crc_off) {
+		if (!internal->gu8Crc_off) {
 			len2 = len + (NUM_RSP_BYTES + NUM_DATA_HDR_BYTES + NUM_DATA_BYTES 
 			+ NUM_CRC_BYTES + NUM_DUMMY_BYTES);	
 		} else {
@@ -622,7 +623,7 @@ static int spi_cmd_complete(uint8_t cmd, uint32_t adr, uint8_t *b, uint32_t sz,
 					return result;
 				}
 
-				if (!gu8Crc_off) {						
+				if (!internal->gu8Crc_off) {
 					/**
 					Read Crc
 					**/
@@ -659,7 +660,7 @@ static int spi_cmd_complete(uint8_t cmd, uint32_t adr, uint8_t *b, uint32_t sz,
 					/**
 					Read bytes
 					**/
-					if (nmi_spi_read(&b[ix], nbytes) != M2M_SUCCESS) {
+					if (nmi_spi_read(dev, &b[ix], nbytes) != M2M_SUCCESS) {
 						M2M_ERR("[nmi spi]: Failed data block read, bus error...\n");
 						result = N_FAIL;
 						goto _error_;
@@ -668,8 +669,8 @@ static int spi_cmd_complete(uint8_t cmd, uint32_t adr, uint8_t *b, uint32_t sz,
 					/**
 					Read Crc
 					**/
-					if (!gu8Crc_off) {
-						if (nmi_spi_read(crc, 2) != M2M_SUCCESS) {
+					if (!internal->gu8Crc_off) {
+						if (nmi_spi_read(dev, crc, 2) != M2M_SUCCESS) {
 							M2M_ERR("[nmi spi]: Failed data block crc read, bus error...\n");
 							result = N_FAIL;
 							goto _error_;
@@ -701,7 +702,7 @@ static int spi_cmd_complete(uint8_t cmd, uint32_t adr, uint8_t *b, uint32_t sz,
 					**/
 					retry = SPI_RESP_RETRY_COUNT;
 					do {
-						if (nmi_spi_read(&rsp, 1) != M2M_SUCCESS) {
+						if (nmi_spi_read(dev, &rsp, 1) != M2M_SUCCESS) {
 							M2M_ERR("[nmi spi]: Failed data response read, bus error...\n");
 							result = N_FAIL;
 							break;
@@ -717,7 +718,7 @@ static int spi_cmd_complete(uint8_t cmd, uint32_t adr, uint8_t *b, uint32_t sz,
 					/**
 					Read bytes
 					**/
-					if (nmi_spi_read(&b[ix], nbytes) != M2M_SUCCESS) {
+					if (nmi_spi_read(dev, &b[ix], nbytes) != M2M_SUCCESS) {
 						M2M_ERR("[nmi spi]: Failed data block read, bus error...\n");
 						result = N_FAIL;
 						break;
@@ -726,8 +727,8 @@ static int spi_cmd_complete(uint8_t cmd, uint32_t adr, uint8_t *b, uint32_t sz,
 					/**
 					Read Crc
 					**/
-					if (!gu8Crc_off) {
-						if (nmi_spi_read(crc, 2) != M2M_SUCCESS) {
+					if (!internal->gu8Crc_off) {
+						if (nmi_spi_read(dev, crc, 2) != M2M_SUCCESS) {
 							M2M_ERR("[nmi spi]: Failed data block crc read, bus error...\n");
 							result = N_FAIL;
 							break;
@@ -743,8 +744,9 @@ _error_:
 	return result;
 }
 #endif
-static sint8 spi_data_read(uint8 *b, uint16 sz,uint8 clockless)
+static sint8 spi_data_read(winc1500_t *dev, uint8 *b, uint16 sz,uint8 clockless)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	sint16 retry, ix, nbytes;
 	sint8 result = N_OK;
 	uint8 crc[2];
@@ -765,7 +767,7 @@ static sint8 spi_data_read(uint8 *b, uint16 sz,uint8 clockless)
 		**/
 		retry = SPI_RESP_RETRY_COUNT;
 		do {
-			if (M2M_SUCCESS != nmi_spi_read(&rsp, 1)) {
+			if (M2M_SUCCESS != nmi_spi_read(dev, &rsp, 1)) {
 				M2M_ERR("[nmi spi]: Failed data response read, bus error...\n");
 				result = N_FAIL;
 				break;
@@ -786,7 +788,7 @@ static sint8 spi_data_read(uint8 *b, uint16 sz,uint8 clockless)
 		/**
 			Read bytes
 		**/
-		if (M2M_SUCCESS != nmi_spi_read(&b[ix], nbytes)) {
+		if (M2M_SUCCESS != nmi_spi_read(dev, &b[ix], nbytes)) {
 			M2M_ERR("[nmi spi]: Failed data block read, bus error...\n");
 			result = N_FAIL;
 			break;
@@ -796,8 +798,8 @@ static sint8 spi_data_read(uint8 *b, uint16 sz,uint8 clockless)
 			/**
 			Read Crc
 			**/
-			if (!gu8Crc_off) {
-				if (M2M_SUCCESS != nmi_spi_read(crc, 2)) {
+			if (!internal->gu8Crc_off) {
+				if (M2M_SUCCESS != nmi_spi_read(dev, crc, 2)) {
 					M2M_ERR("[nmi spi]: Failed data block crc read, bus error...\n");
 					result = N_FAIL;
 					break;
@@ -812,8 +814,9 @@ static sint8 spi_data_read(uint8 *b, uint16 sz,uint8 clockless)
 	return result;
 }
 
-static sint8 spi_data_write(uint8 *b, uint16 sz)
+static sint8 spi_data_write(winc1500_t *dev, uint8 *b, uint16 sz)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	sint16 ix;
 	uint16 nbytes;
 	sint8 result = 1;
@@ -846,7 +849,7 @@ static sint8 spi_data_write(uint8 *b, uint16 sz)
 				order = 0x2;
 		}
 		cmd |= order;
-		if (M2M_SUCCESS != nmi_spi_write(&cmd, 1)) {
+		if (M2M_SUCCESS != nmi_spi_write(dev, &cmd, 1)) {
 			M2M_ERR("[nmi spi]: Failed data block cmd write, bus error...\n");
 			result = N_FAIL;
 			break;
@@ -855,7 +858,7 @@ static sint8 spi_data_write(uint8 *b, uint16 sz)
 		/**
 			Write data
 		**/
-		if (M2M_SUCCESS != nmi_spi_write(&b[ix], nbytes)) {
+		if (M2M_SUCCESS != nmi_spi_write(dev, &b[ix], nbytes)) {
 			M2M_ERR("[nmi spi]: Failed data block write, bus error...\n");
 			result = N_FAIL;
 			break;
@@ -864,8 +867,8 @@ static sint8 spi_data_write(uint8 *b, uint16 sz)
 		/**
 			Write Crc
 		**/
-		if (!gu8Crc_off) {
-			if (M2M_SUCCESS != nmi_spi_write(crc, 2)) {
+		if (!internal->gu8Crc_off) {
+			if (M2M_SUCCESS != nmi_spi_write(dev, crc, 2)) {
 				M2M_ERR("[nmi spi]: Failed data block crc write, bus error...\n");
 				result = N_FAIL;
 				break;
@@ -892,7 +895,7 @@ static sint8 spi_data_write(uint8 *b, uint16 sz)
 
 ********************************************/
 
-static sint8 spi_write_reg(uint32 addr, uint32 u32data)
+static sint8 spi_write_reg(winc1500_t *dev, uint32 addr, uint32 u32data)
 {
 	uint8 retry = SPI_RETRY_COUNT;
 	sint8 result = N_OK;
@@ -915,13 +918,13 @@ _RETRY_:
 	}
 
 #if defined USE_OLD_SPI_SW
-	result = spi_cmd(cmd, addr, u32data, 4, clockless);
+	result = spi_cmd(dev, cmd, addr, u32data, 4, clockless);
 	if (result != N_OK) {
 		M2M_ERR("[nmi spi]: Failed cmd, write reg (%08x)...\n", (unsigned int)addr);
 		goto _FAIL_;
 	}
 
-	result = spi_cmd_rsp(cmd);
+	result = spi_cmd_rsp(dev, cmd);
 	if (result != N_OK) {
 		M2M_ERR("[nmi spi]: Failed cmd response, write reg (%08x)...\n", (unsigned int)addr);
 		goto _FAIL_;
@@ -929,7 +932,7 @@ _RETRY_:
 
 #else
 
-	result = spi_cmd_complete(cmd, addr, (uint8*)&u32data, 4, clockless);
+	result = spi_cmd_complete(dev, cmd, addr, (uint8*)&u32data, 4, clockless);
 	if (result != N_OK) {
 		M2M_ERR( "[nmi spi]: Failed cmd, write reg (%08x)...\n", addr);
 		goto _FAIL_;
@@ -940,8 +943,8 @@ _FAIL_:
 	if(result != N_OK)
 	{
 		nm_bsp_sleep(1);
-		spi_cmd(CMD_RESET, 0, 0, 0, 0);
-		spi_cmd_rsp(CMD_RESET);
+		spi_cmd(dev, CMD_RESET, 0, 0, 0, 0);
+		spi_cmd_rsp(dev, CMD_RESET);
 		M2M_ERR("Reset and retry %d %lx %lx\n",retry,addr,u32data);
 		nm_bsp_sleep(1);
 		retry--;
@@ -951,7 +954,7 @@ _FAIL_:
 	return result;
 }
 
-static sint8 nm_spi_write(uint32 addr, uint8 *buf, uint16 size)
+static sint8 nm_spi_write(winc1500_t *dev, uint32 addr, uint8 *buf, uint16 size)
 {
 	sint8 result;
 	uint8 retry = SPI_RETRY_COUNT;
@@ -967,19 +970,19 @@ _RETRY_:
 	if (size == 1)
 		size = 2;
 
-	result = spi_cmd(cmd, addr, 0, size,0);
+	result = spi_cmd(dev, cmd, addr, 0, size,0);
 	if (result != N_OK) {
 		M2M_ERR("[nmi spi]: Failed cmd, write block (%08x)...\n", (unsigned int)addr);
 		goto _FAIL_;
 	}
 
-	result = spi_cmd_rsp(cmd);
+	result = spi_cmd_rsp(dev, cmd);
 	if (result != N_OK) {
 		M2M_ERR("[nmi spi ]: Failed cmd response, write block (%08x)...\n", (unsigned int)addr);
 		goto _FAIL_;
 	}
 #else
-	result = spi_cmd_complete(cmd, addr, NULL, size, 0);
+	result = spi_cmd_complete(dev, cmd, addr, NULL, size, 0);
 	if (result != N_OK) {
 		M2M_ERR( "[nmi spi]: Failed cmd, write block (%08x)...\n", addr);
 		goto _FAIL_;
@@ -989,7 +992,7 @@ _RETRY_:
 	/**
 		Data
 	**/
-	result = spi_data_write(buf, size);
+	result = spi_data_write(dev, buf, size);
 	if (result != N_OK) {
 		M2M_ERR("[nmi spi]: Failed block data write...\n");
 		goto _FAIL_;
@@ -997,7 +1000,7 @@ _RETRY_:
 	/**
 		Data RESP
 	**/
-	result = spi_data_rsp(cmd);
+	result = spi_data_rsp(dev, cmd);
 	if (result != N_OK) {
 		M2M_ERR("[nmi spi]: Failed block data write...\n");
 		goto _FAIL_;
@@ -1007,8 +1010,8 @@ _FAIL_:
 	if(result != N_OK)
 	{
 		nm_bsp_sleep(1);
-		spi_cmd(CMD_RESET, 0, 0, 0, 0);
-		spi_cmd_rsp(CMD_RESET);
+		spi_cmd(dev, CMD_RESET, 0, 0, 0, 0);
+		spi_cmd_rsp(dev, CMD_RESET);
 		M2M_ERR("Reset and retry %d %lx %d\n",retry,addr,size);
 		nm_bsp_sleep(1);
 		retry--;
@@ -1019,7 +1022,7 @@ _FAIL_:
 	return result;
 }
 
-static sint8 spi_read_reg(uint32 addr, uint32 *u32data)
+static sint8 spi_read_reg(winc1500_t *dev, uint32 addr, uint32 *u32data)
 {
 	uint8 retry = SPI_RETRY_COUNT;
 	sint8 result = N_OK;
@@ -1044,26 +1047,26 @@ _RETRY_:
 	}
 
 #if defined USE_OLD_SPI_SW
-	result = spi_cmd(cmd, addr, 0, 4, clockless);
+	result = spi_cmd(dev, cmd, addr, 0, 4, clockless);
 	if (result != N_OK) {
 		M2M_ERR("[nmi spi]: Failed cmd, read reg (%08x)...\n", (unsigned int)addr);
 		goto _FAIL_;
 	}
 
-	result = spi_cmd_rsp(cmd);
+	result = spi_cmd_rsp(dev, cmd);
 	if (result != N_OK) {
 		M2M_ERR("[nmi spi]: Failed cmd response, read reg (%08x)...\n", (unsigned int)addr);
 		goto _FAIL_;
 	}
 
 	/* to avoid endianess issues */
-	result = spi_data_read(&tmp[0], 4, clockless);
+	result = spi_data_read(dev, &tmp[0], 4, clockless);
 	if (result != N_OK) {
 		M2M_ERR("[nmi spi]: Failed data read...\n");
 		goto _FAIL_;
 	}
 #else
-	result = spi_cmd_complete(cmd, addr, (uint8*)&tmp[0], 4, clockless);
+	result = spi_cmd_complete(dev, cmd, addr, (uint8*)&tmp[0], 4, clockless);
 	if (result != N_OK) {
 		M2M_ERR( "[nmi spi]: Failed cmd, read reg (%08x)...\n", addr);
 		goto _FAIL_;
@@ -1075,24 +1078,24 @@ _RETRY_:
 		((uint32)tmp[1] << 8) |
 		((uint32)tmp[2] << 16) |
 		((uint32)tmp[3] << 24);
-		
+
 _FAIL_:
 	if(result != N_OK)
 	{
-		
+
 		nm_bsp_sleep(1);
-		spi_cmd(CMD_RESET, 0, 0, 0, 0);
-		spi_cmd_rsp(CMD_RESET);
+		spi_cmd(dev, CMD_RESET, 0, 0, 0, 0);
+		spi_cmd_rsp(dev, CMD_RESET);
 		M2M_ERR("Reset and retry %d %lx\n",retry,addr);
 		nm_bsp_sleep(1);
 		retry--;
 		if(retry) goto _RETRY_;
 	}
-		
+
 	return result;
 }
 
-static sint8 nm_spi_read(uint32 addr, uint8 *buf, uint16 size)
+static sint8 nm_spi_read(winc1500_t *dev, uint32 addr, uint8 *buf, uint16 size)
 {
 	uint8 cmd = CMD_DMA_EXT_READ;
 	sint8 result;
@@ -1114,13 +1117,13 @@ _RETRY_:
 		size = 2;
 		single_byte_workaround = 1;
 	}
-	result = spi_cmd(cmd, addr, 0, size,0);
+	result = spi_cmd(dev, cmd, addr, 0, size,0);
 	if (result != N_OK) {
 		M2M_ERR("[nmi spi]: Failed cmd, read block (%08x)...\n", (unsigned int)addr);
 		goto _FAIL_;
 	}
 
-	result = spi_cmd_rsp(cmd);
+	result = spi_cmd_rsp(dev, cmd);
 	if (result != N_OK) {
 		M2M_ERR("[nmi spi]: Failed cmd response, read block (%08x)...\n", (unsigned int)addr);
 		goto _FAIL_;
@@ -1131,18 +1134,18 @@ _RETRY_:
 	**/
 	if (single_byte_workaround)
 	{
-		result = spi_data_read(tmp, size,0);
+		result = spi_data_read(dev, tmp, size,0);
 		buf[0] = tmp[0];
 	}
 	else
-		result = spi_data_read(buf, size,0);
+		result = spi_data_read(dev, buf, size,0);
 
 	if (result != N_OK) {
 		M2M_ERR("[nmi spi]: Failed block data read...\n");
 		goto _FAIL_;
 	}
 #else
-	result = spi_cmd_complete(cmd, addr, buf, size, 0);
+	result = spi_cmd_complete(dev, cmd, addr, buf, size, 0);
 	if (result != N_OK) {
 		M2M_ERR("[nmi spi]: Failed cmd, read block (%08x)...\n", addr);
 		goto _FAIL_;
@@ -1153,8 +1156,8 @@ _FAIL_:
 	if(result != N_OK)
 	{
 		nm_bsp_sleep(1);
-		spi_cmd(CMD_RESET, 0, 0, 0, 0);
-		spi_cmd_rsp(CMD_RESET);
+		spi_cmd(dev, CMD_RESET, 0, 0, 0, 0);
+		spi_cmd_rsp(dev, CMD_RESET);
 		M2M_ERR("Reset and retry %d %lx %d\n",retry,addr,size);
 		nm_bsp_sleep(1);
 		retry--;
@@ -1170,12 +1173,12 @@ _FAIL_:
 
 ********************************************/
 
-static void spi_init_pkt_sz(void)
+static void spi_init_pkt_sz(winc1500_t *dev)
 {
 	uint32 val32;
 
 	/* Make sure SPI max. packet size fits the defined DATA_PKT_SZ.  */
-	val32 = nm_spi_read_reg(SPI_BASE+0x24);
+	val32 = nm_spi_read_reg(dev, SPI_BASE+0x24);
 	val32 &= ~(0x7 << 4);
 	switch(DATA_PKT_SZ)
 	{
@@ -1187,13 +1190,13 @@ static void spi_init_pkt_sz(void)
 	case 8192: val32 |= (5 << 4); break;
 
 	}
-	nm_spi_write_reg(SPI_BASE+0x24, val32);
+	nm_spi_write_reg(dev, SPI_BASE+0x24, val32);
 }
 
-sint8 nm_spi_reset(void)
+sint8 nm_spi_reset(winc1500_t *dev)
 {
-	spi_cmd(CMD_RESET, 0, 0, 0, 0);
-	spi_cmd_rsp(CMD_RESET);
+	spi_cmd(dev, CMD_RESET, 0, 0, 0, 0);
+	spi_cmd_rsp(dev, CMD_RESET);
 	return M2M_SUCCESS;
 }
 
@@ -1205,52 +1208,53 @@ sint8 nm_spi_reset(void)
 *	@date	11 July 2012
 *	@version	1.0
 */
-sint8 nm_spi_init(void)
+sint8 nm_spi_init(winc1500_t *dev)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	uint32 chipid;
 	uint32 reg = 0;
-	
+
 
 	/**
 		configure protocol
 	**/
-	gu8Crc_off = 0;
+	internal->gu8Crc_off = 0;
 
 	// TODO: We can remove the CRC trials if there is a definite way to reset
 	// the SPI to it's initial value.
-	if (!spi_read_reg(NMI_SPI_PROTOCOL_CONFIG, &reg)) {
+	if (!spi_read_reg(dev, NMI_SPI_PROTOCOL_CONFIG, &reg)) {
 		/* Read failed. Try with CRC off. This might happen when module
 		is removed but chip isn't reset*/
-		gu8Crc_off = 1;
+		internal->gu8Crc_off = 1;
 		M2M_ERR("[nmi spi]: Failed internal read protocol with CRC on, retyring with CRC off...\n");
-		if (!spi_read_reg(NMI_SPI_PROTOCOL_CONFIG, &reg)){
+		if (!spi_read_reg(dev, NMI_SPI_PROTOCOL_CONFIG, &reg)){
 			// Reaad failed with both CRC on and off, something went bad
 			M2M_ERR( "[nmi spi]: Failed internal read protocol...\n");
 			return 0;
 		}
 	}
-	if(gu8Crc_off == 0)
+	if(internal->gu8Crc_off == 0)
 	{
 		reg &= ~0xc;	/* disable crc checking */
 		reg &= ~0x70;
 		reg |= (0x5 << 4);
-		if (!spi_write_reg(NMI_SPI_PROTOCOL_CONFIG, reg)) {
+		if (!spi_write_reg(dev, NMI_SPI_PROTOCOL_CONFIG, reg)) {
 			M2M_ERR( "[nmi spi]: Failed internal write protocol reg...\n");
 			return 0;
 		}
-		gu8Crc_off = 1;
+		internal->gu8Crc_off = 1;
 	}
 
 	/**
 		make sure can read back chip id correctly
 	**/
-	if (!spi_read_reg(0x1000, &chipid)) {
+	if (!spi_read_reg(dev, 0x1000, &chipid)) {
 		M2M_ERR("[nmi spi]: Fail cmd read chip id...\n");
 		return M2M_ERR_BUS_FAIL;
 	}
 
 	M2M_DBG("[nmi spi]: chipid (%08x)\n", (unsigned int)chipid);
-	spi_init_pkt_sz();
+	spi_init_pkt_sz(dev);
 
 
 	return M2M_SUCCESS;
@@ -1258,15 +1262,16 @@ sint8 nm_spi_init(void)
 
 /*
 *	@fn		nm_spi_init
-*	@brief	DeInitialize the SPI 
+*	@brief	DeInitialize the SPI
 *	@return	M2M_SUCCESS in case of success and M2M_ERR_BUS_FAIL in case of failure
 *	@author	Samer Sarhan
 *	@date	27 Feb 2015
 *	@version	1.0
-*/ 
-sint8 nm_spi_deinit(void)
+*/
+sint8 nm_spi_deinit(winc1500_t *dev)
 {
-	gu8Crc_off = 0;
+	winc1500_internal_t *internal = &dev->internal;
+	internal->gu8Crc_off = 0;
 	return M2M_SUCCESS;
 }
 
@@ -1280,11 +1285,11 @@ sint8 nm_spi_deinit(void)
 *	@date	11 July 2012
 *	@version	1.0
 */
-uint32 nm_spi_read_reg(uint32 u32Addr)
+uint32 nm_spi_read_reg(winc1500_t *dev, uint32 u32Addr)
 {
 	uint32 u32Val;
 
-	spi_read_reg(u32Addr, &u32Val);
+	spi_read_reg(dev, u32Addr, &u32Val);
 
 	return u32Val;
 }
@@ -1301,11 +1306,11 @@ uint32 nm_spi_read_reg(uint32 u32Addr)
 *	@date	11 July 2012
 *	@version	1.0
 */
-sint8 nm_spi_read_reg_with_ret(uint32 u32Addr, uint32* pu32RetVal)
+sint8 nm_spi_read_reg_with_ret(winc1500_t *dev, uint32 u32Addr, uint32* pu32RetVal)
 {
 	sint8 s8Ret;
 
-	s8Ret = spi_read_reg(u32Addr,pu32RetVal);
+	s8Ret = spi_read_reg(dev, u32Addr,pu32RetVal);
 
 	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
 	else s8Ret = M2M_ERR_BUS_FAIL;
@@ -1325,11 +1330,11 @@ sint8 nm_spi_read_reg_with_ret(uint32 u32Addr, uint32* pu32RetVal)
 *	@date	11 July 2012
 *	@version	1.0
 */
-sint8 nm_spi_write_reg(uint32 u32Addr, uint32 u32Val)
+sint8 nm_spi_write_reg(winc1500_t *dev, uint32 u32Addr, uint32 u32Val)
 {
 	sint8 s8Ret;
 
-	s8Ret = spi_write_reg(u32Addr, u32Val);
+	s8Ret = spi_write_reg(dev, u32Addr, u32Val);
 
 	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
 	else s8Ret = M2M_ERR_BUS_FAIL;
@@ -1351,11 +1356,11 @@ sint8 nm_spi_write_reg(uint32 u32Addr, uint32 u32Val)
 *	@date	11 July 2012
 *	@version	1.0
 */
-sint8 nm_spi_read_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
+sint8 nm_spi_read_block(winc1500_t *dev, uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
 {
 	sint8 s8Ret;
 
-	s8Ret = nm_spi_read(u32Addr, puBuf, u16Sz);
+	s8Ret = nm_spi_read(dev, u32Addr, puBuf, u16Sz);
 
 	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
 	else s8Ret = M2M_ERR_BUS_FAIL;
@@ -1377,11 +1382,11 @@ sint8 nm_spi_read_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
 *	@date	11 July 2012
 *	@version	1.0
 */
-sint8 nm_spi_write_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
+sint8 nm_spi_write_block(winc1500_t *dev, uint32 u32Addr, uint8 *puBuf, uint16 u16Sz)
 {
 	sint8 s8Ret;
 
-	s8Ret = nm_spi_write(u32Addr, puBuf, u16Sz);
+	s8Ret = nm_spi_write(dev, u32Addr, puBuf, u16Sz);
 
 	if(N_OK == s8Ret) s8Ret = M2M_SUCCESS;
 	else s8Ret = M2M_ERR_BUS_FAIL;
diff --git a/winc1500/driver/source/nmspi.h b/winc1500/driver/source/nmspi.h
index a1bd4a9..ba3ae23 100644
--- a/winc1500/driver/source/nmspi.h
+++ b/winc1500/driver/source/nmspi.h
@@ -53,20 +53,20 @@
 *	@brief	Initialize the SPI
 *	@return	ZERO in case of success and M2M_ERR_BUS_FAIL in case of failure
 */
-sint8 nm_spi_init(void);
+sint8 nm_spi_init(winc1500_t *dev);
 /**
 *	@fn		nm_spi_reset
 *	@brief	reset the SPI
 *	@return	ZERO in case of success and M2M_ERR_BUS_FAIL in case of failure
 */
-sint8 nm_spi_reset(void);
+sint8 nm_spi_reset(winc1500_t *dev);
 
 /**
 *	@fn		nm_spi_deinit
 *	@brief	DeInitialize the SPI 
 *	@return	ZERO in case of success and M2M_ERR_BUS_FAIL in case of failure
 */ 
-sint8 nm_spi_deinit(void);
+sint8 nm_spi_deinit(winc1500_t *dev);
 
 /**
 *	@fn		nm_spi_read_reg
@@ -75,7 +75,7 @@ sint8 nm_spi_deinit(void);
 *				Register address
 *	@return	Register value
 */
-uint32 nm_spi_read_reg(uint32 u32Addr);
+uint32 nm_spi_read_reg(winc1500_t *dev, uint32 u32Addr);
 
 /**
 *	@fn		nm_spi_read_reg_with_ret
@@ -86,7 +86,7 @@ uint32 nm_spi_read_reg(uint32 u32Addr);
 *				Pointer to u32 variable used to return the read value
 *	@return	ZERO in case of success and M2M_ERR_BUS_FAIL in case of failure
 */
-sint8 nm_spi_read_reg_with_ret(uint32 u32Addr, uint32* pu32RetVal);
+sint8 nm_spi_read_reg_with_ret(winc1500_t *dev, uint32 u32Addr, uint32* pu32RetVal);
 
 /**
 *	@fn		nm_spi_write_reg
@@ -97,7 +97,7 @@ sint8 nm_spi_read_reg_with_ret(uint32 u32Addr, uint32* pu32RetVal);
 *				Value to be written to the register
 *	@return	ZERO in case of success and M2M_ERR_BUS_FAIL in case of failure
 */
-sint8 nm_spi_write_reg(uint32 u32Addr, uint32 u32Val);
+sint8 nm_spi_write_reg(winc1500_t *dev, uint32 u32Addr, uint32 u32Val);
 
 /**
 *	@fn		nm_spi_read_block
@@ -110,7 +110,7 @@ sint8 nm_spi_write_reg(uint32 u32Addr, uint32 u32Val);
 *				Number of bytes to read. The buffer size must be >= u16Sz
 *	@return	ZERO in case of success and M2M_ERR_BUS_FAIL in case of failure
 */
-sint8 nm_spi_read_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz);
+sint8 nm_spi_read_block(winc1500_t *dev, uint32 u32Addr, uint8 *puBuf, uint16 u16Sz);
 
 /**
 *	@fn		nm_spi_write_block
@@ -123,7 +123,7 @@ sint8 nm_spi_read_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz);
 *				Number of bytes to write. The buffer size must be >= u16Sz
 *	@return	ZERO in case of success and M2M_ERR_BUS_FAIL in case of failure
 */
-sint8 nm_spi_write_block(uint32 u32Addr, uint8 *puBuf, uint16 u16Sz);
+sint8 nm_spi_write_block(winc1500_t *dev, uint32 u32Addr, uint8 *puBuf, uint16 u16Sz);
 
 #ifdef __cplusplus
 	 }
diff --git a/winc1500/socket/include/socket.h b/winc1500/socket/include/socket.h
index 5789627..ef55a24 100644
--- a/winc1500/socket/include/socket.h
+++ b/winc1500/socket/include/socket.h
@@ -852,7 +852,7 @@ typedef struct{
 	tstrSocketListenMsg
 	tstrSocketBindMsg 
 */
-typedef void (*tpfAppSocketCb) (SOCKET sock, uint8 u8Msg, void * pvMsg);
+typedef void (*tpfAppSocketCb) (winc1500_t *dev, SOCKET sock, uint8 u8Msg, void * pvMsg);
 
 
 /*!
@@ -870,7 +870,7 @@ typedef void (*tpfAppSocketCb) (SOCKET sock, uint8 u8Msg, void * pvMsg);
 @param [in]	u32ServerIP
 				Server IPv4 address encoded in NW byte order format. If it is Zero, then the DNS resolution failed.
 */
-typedef void (*tpfAppResolveCb) (uint8* pu8DomainName, uint32 u32ServerIP);
+typedef void (*tpfAppResolveCb) (winc1500_t *dev, uint8* pu8DomainName, uint32 u32ServerIP);
 
 /*!
 @typedef \
@@ -893,7 +893,7 @@ typedef void (*tpfAppResolveCb) (uint8* pu8DomainName, uint32 u32ServerIP);
 				- PING_ERR_DEST_UNREACH
 				- PING_ERR_TIMEOUT
 */
-typedef void (*tpfPingCb)(uint32 u32IPAddr, uint32 u32RTT, uint8 u8ErrorCode);
+typedef void (*tpfPingCb)(winc1500_t *dev, uint32 u32IPAddr, uint32 u32RTT, uint8 u8ErrorCode);
  
  /**@}*/ 
 /*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
@@ -954,7 +954,7 @@ This example demonstrates the use of the socketinit for socket initialization fo
 
 \endcode
 */
-NMI_API void socketInit(void);
+NMI_API void socketInit(winc1500_t *dev);
 
 
 /*!
@@ -966,7 +966,7 @@ NMI_API void socketInit(void);
 	The function performs the necessary cleanup for the socket library static data
 	It must be invoked as the last any socket operation is performed on any active sockets.
 */
-NMI_API void socketDeinit(void);
+NMI_API void socketDeinit(winc1500_t *dev);
 
 
 /** @} */
@@ -1040,7 +1040,7 @@ NMI_API void socketDeinit(void);
 	m2m_wifi_connect((char *)MAIN_WLAN_SSID, sizeof(MAIN_WLAN_SSID), MAIN_WLAN_AUTH, (char *)MAIN_WLAN_PSK, M2M_WIFI_CH_ALL);
 	\endcode
 */
-NMI_API void registerSocketCallback(tpfAppSocketCb socket_cb, tpfAppResolveCb resolve_cb);
+NMI_API void registerSocketCallback(winc1500_t *dev, tpfAppSocketCb socket_cb, tpfAppResolveCb resolve_cb);
 
 
 /** @} */
@@ -1118,7 +1118,7 @@ static SOCKET ssl_socket = -1;
 ssl_socket = socket(AF_INET, SOCK_STREAM, SOCK_FLAGS_SSL));
 @endcode
 */
-NMI_API SOCKET socket(uint16 u16Domain, uint8 u8Type, uint8 u8Flags);
+NMI_API SOCKET socket(winc1500_t *dev, uint16 u16Domain, uint8 u8Type, uint8 u8Flags);
 
 
 /** @} */
@@ -1201,7 +1201,7 @@ NMI_API SOCKET socket(uint16 u16Domain, uint8 u8Type, uint8 u8Flags);
 	}
 @endcode	
 */
-NMI_API sint8 bind(SOCKET sock, struct sockaddr *pstrAddr, uint8 u8AddrLen);
+NMI_API sint8 bind(winc1500_t *dev, SOCKET sock, struct sockaddr *pstrAddr, uint8 u8AddrLen);
 
 
 /** @} */
@@ -1325,7 +1325,7 @@ This example demonstrates the call of the listen socket operation after a succes
 
 @endcode
 */
-NMI_API sint8 listen(SOCKET sock, uint8 backlog);
+NMI_API sint8 listen(winc1500_t *dev, SOCKET sock, uint8 backlog);
 /** @} */
 /** @defgroup AcceptFn accept
  *    @ingroup SocketAPI
@@ -1355,7 +1355,7 @@ NMI_API sint8 listen(SOCKET sock, uint8 backlog);
 	- [SOCK_ERR_INVALID_ARG](@ref SOCK_ERR_INVALID_ARG)
 		Indicating passing invalid arguments such as negative socket ID.
 */
-NMI_API sint8 accept(SOCKET sock, struct sockaddr *addr, uint8 *addrlen);
+NMI_API sint8 accept(winc1500_t *dev, SOCKET sock, struct sockaddr *addr, uint8 *addrlen);
 /** @} */
 /** @defgroup ConnectFn connect
  *    @ingroup SocketAPI
@@ -1459,7 +1459,7 @@ NMI_API sint8 accept(SOCKET sock, struct sockaddr *addr, uint8 *addrlen);
 	}
 @endcode
 */
-NMI_API sint8 connect(SOCKET sock, struct sockaddr *pstrAddr, uint8 u8AddrLen);
+NMI_API sint8 connect(winc1500_t *dev, SOCKET sock, struct sockaddr *pstrAddr, uint8 u8AddrLen);
 /** @} */
 /** @defgroup ReceiveFn recv
  *    @ingroup SocketAPI
@@ -1569,7 +1569,7 @@ NMI_API sint8 connect(SOCKET sock, struct sockaddr *pstrAddr, uint8 u8AddrLen);
 }
 @endcode
 */
-NMI_API sint16 recv(SOCKET sock, void *pvRecvBuf, uint16 u16BufLen, uint32 u32Timeoutmsec);
+NMI_API sint16 recv(winc1500_t *dev, SOCKET sock, void *pvRecvBuf, uint16 u16BufLen, uint32 u32Timeoutmsec);
 /** @} */
 /** @defgroup ReceiveFromSocketFn recvfrom
  *   @ingroup SocketAPI
@@ -1683,7 +1683,7 @@ NMI_API sint16 recv(SOCKET sock, void *pvRecvBuf, uint16 u16BufLen, uint32 u32Ti
 }
 @endcode
 */
-NMI_API sint16 recvfrom(SOCKET sock, void *pvRecvBuf, uint16 u16BufLen, uint32 u32Timeoutmsec);
+NMI_API sint16 recvfrom(winc1500_t *dev, SOCKET sock, void *pvRecvBuf, uint16 u16BufLen, uint32 u32Timeoutmsec);
 /** @} */
 /** @defgroup SendFn send
  *   @ingroup SocketAPI
@@ -1746,7 +1746,7 @@ NMI_API sint16 recvfrom(SOCKET sock, void *pvRecvBuf, uint16 u16BufLen, uint32 u
 @return		
 	The function shall return @ref SOCK_ERR_NO_ERROR for successful operation and a negative value (indicating the error) otherwise. 
 */
-NMI_API sint16 send(SOCKET sock, void *pvSendBuffer, uint16 u16SendLength, uint16 u16Flags);
+NMI_API sint16 send(winc1500_t *dev, SOCKET sock, void *pvSendBuffer, uint16 u16SendLength, uint16 u16Flags);
 /** @} */
 /** @defgroup SendToSocketFn sendto
  *  @ingroup SocketAPI
@@ -1805,7 +1805,7 @@ NMI_API sint16 send(SOCKET sock, void *pvSendBuffer, uint16 u16SendLength, uint1
 @return
 	The function  returns @ref SOCK_ERR_NO_ERROR for successful operation and a negative value (indicating the error) otherwise. 
 */
-NMI_API sint16 sendto(SOCKET sock, void *pvSendBuffer, uint16 u16SendLength, uint16 flags, struct sockaddr *pstrDestAddr, uint8 u8AddrLen);
+NMI_API sint16 sendto(winc1500_t *dev, SOCKET sock, void *pvSendBuffer, uint16 u16SendLength, uint16 flags, struct sockaddr *pstrDestAddr, uint8 u8AddrLen);
 /** @} */
 /** @defgroup CloseSocketFn close
  *  @ingroup SocketAPI
@@ -1834,7 +1834,7 @@ NMI_API sint16 sendto(SOCKET sock, void *pvSendBuffer, uint16 u16SendLength, uin
 @return		
 	The function returned @ref SOCK_ERR_NO_ERROR for successful operation and a negative value (indicating the error) otherwise. 
 */
-NMI_API sint8 close(SOCKET sock);
+NMI_API sint8 close(winc1500_t *dev, SOCKET sock);
 
 
 /** @} */
@@ -1859,7 +1859,7 @@ NMI_API sint8 close(SOCKET sock);
 	(eg. "192.168.10.1" will be expressed as 0x010AA8C0).
 		
 */
-NMI_API uint32 nmi_inet_addr(char *pcIpAddr);
+NMI_API uint32 nmi_inet_addr(winc1500_t *dev, char *pcIpAddr);
 
 
 /** @} */
@@ -1888,7 +1888,7 @@ NMI_API uint32 nmi_inet_addr(char *pcIpAddr);
 	- [SOCK_ERR_NO_ERROR](@ref SOCK_ERR_NO_ERROR)
 	- [SOCK_ERR_INVALID_ARG](@ref SOCK_ERR_INVALID_ARG)
 */
-NMI_API sint8 gethostbyname(uint8 * pcHostName);
+NMI_API sint8 gethostbyname(winc1500_t *dev, uint8 * pcHostName);
 
 
 /** @} */
@@ -1909,7 +1909,7 @@ NMI_API sint8 sslEnableCertExpirationCheck(tenuSslCertExpSettings enuValidationS
 
 @sa		tenuSslCertExpSettings
 */
-NMI_API sint8 sslEnableCertExpirationCheck(tenuSslCertExpSettings enuValidationSetting);
+NMI_API sint8 sslEnableCertExpirationCheck(winc1500_t *dev, tenuSslCertExpSettings enuValidationSetting);
 
 
 /** @} */
@@ -1993,7 +1993,7 @@ NMI_API sint8 sslEnableCertExpirationCheck(tenuSslCertExpSettings enuValidationS
 	and a negative value (indicating the error) otherwise. 
 @sa SOL_SOCKET, SOL_SSL_SOCKET, IP_ADD_MEMBERSHIP, IP_DROP_MEMBERSHIP
 */
-NMI_API sint8 setsockopt(SOCKET socket, uint8 u8Level, uint8 option_name,
+NMI_API sint8 setsockopt(winc1500_t *dev, SOCKET socket, uint8 u8Level, uint8 option_name,
        const void *option_value, uint16 u16OptionLen);
 
 
@@ -2023,7 +2023,7 @@ NMI_API sint8 setsockopt(SOCKET socket, uint8 u8Level, uint8 option_name,
 @return
 	The function shall return ZERO for successful operation and a negative value otherwise.
 */
-NMI_API sint8 getsockopt(SOCKET sock, uint8 u8Level, uint8 u8OptName, const void *pvOptValue, uint8* pu8OptLen);
+NMI_API sint8 getsockopt(winc1500_t *dev, SOCKET sock, uint8 u8Level, uint8 u8OptName, const void *pvOptValue, uint8* pu8OptLen);
 /** @} */
 
 /**@}*/
@@ -2050,7 +2050,7 @@ NMI_API sint8 getsockopt(SOCKET sock, uint8 u8Level, uint8 u8OptName, const void
 @see           nmi_inet_addr       
 @return        The function returns @ref M2M_SUCCESS for successful operations and a negative value otherwise.
 */
-NMI_API sint8 m2m_ping_req(uint32 u32DstIP, uint8 u8TTL, tpfPingCb fpPingCb);
+NMI_API sint8 m2m_ping_req(winc1500_t *dev, uint32 u32DstIP, uint8 u8TTL, tpfPingCb fpPingCb);
 /**@}*/
 
 
diff --git a/winc1500/socket/source/socket.c b/winc1500/socket/source/socket.c
index e4d269f..65721fc 100644
--- a/winc1500/socket/source/socket.c
+++ b/winc1500/socket/source/socket.c
@@ -39,6 +39,9 @@
  *
  */
 
+// Disabled when RIOT's network stack is used.
+#if	!defined(MODULE_NETDEV_ETH)
+
 /*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
 INCLUDES
 *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
@@ -66,8 +69,8 @@ MACROS
 #define UDP_TX_PACKET_OFFSET				(IP_PACKET_OFFSET + UDP_IP_HEADER_LENGTH)
 #define SSL_TX_PACKET_OFFSET				(TCP_TX_PACKET_OFFSET + TLS_RECORD_HEADER_LENGTH)
 
-#define SOCKET_REQUEST(reqID, reqArgs, reqSize, reqPayload, reqPayloadSize, reqPayloadOffset)		\
-	hif_send(M2M_REQ_GROUP_IP, reqID, reqArgs, reqSize, reqPayload, reqPayloadSize, reqPayloadOffset)
+#define SOCKET_REQUEST(dev, reqID, reqArgs, reqSize, reqPayload, reqPayloadSize, reqPayloadOffset)		\
+	hif_send(dev, M2M_REQ_GROUP_IP, reqID, reqArgs, reqSize, reqPayload, reqPayloadSize, reqPayloadOffset)
 
 
 #define SSL_FLAGS_ACTIVE					NBIT0
@@ -92,35 +95,10 @@ typedef struct{
 	uint16		u16SessionID;
 }tstrCloseCmd;
 
-
-/*!
-*  @brief
-*/
-typedef struct{
-	uint8				*pu8UserBuffer;
-	uint16				u16UserBufferSize;
-	uint16				u16SessionID;
-	uint16				u16DataOffset;
-	uint8				bIsUsed;
-	uint8				u8SSLFlags;
-	uint8				bIsRecvPending;
-}tstrSocket;
-
 /*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*
 GLOBALS
 *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
 
-volatile sint8					gsockerrno;
-volatile tstrSocket				gastrSockets[MAX_SOCKET];
-volatile uint8					gu8OpCode;
-volatile uint16					gu16BufferSize;
-volatile uint16					gu16SessionID = 0;	
-
-volatile tpfAppSocketCb		    gpfAppSocketCb;
-volatile tpfAppResolveCb		gpfAppResolveCb;
-volatile uint8					gbSocketInit = 0;
-volatile tpfPingCb				gfpPingCb;
-
 /*********************************************************************
 Function
 		Socket_ReadSocketData
@@ -141,10 +119,11 @@ Version
 Date
 		17 July 2012
 *********************************************************************/
-NMI_API void Socket_ReadSocketData(SOCKET sock, tstrSocketRecvMsg *pstrRecv,uint8 u8SocketMsg,
+NMI_API void Socket_ReadSocketData(winc1500_t *dev, SOCKET sock, tstrSocketRecvMsg *pstrRecv,uint8 u8SocketMsg,
 								  uint32 u32StartAddress,uint16 u16ReadCount)
 {
-	if((u16ReadCount > 0) && (gastrSockets[sock].pu8UserBuffer != NULL) && (gastrSockets[sock].u16UserBufferSize > 0) && (gastrSockets[sock].bIsUsed == 1))
+	winc1500_internal_t *internal = &dev->internal;
+	if((u16ReadCount > 0) && (internal->gastrSockets[sock].pu8UserBuffer != NULL) && (internal->gastrSockets[sock].u16UserBufferSize > 0) && (internal->gastrSockets[sock].bIsUsed == 1))
 	{
 		uint32	u32Address = u32StartAddress;
 		uint16	u16Read;
@@ -156,29 +135,29 @@ NMI_API void Socket_ReadSocketData(SOCKET sock, tstrSocketRecvMsg *pstrRecv,uint
 		{
 			u8SetRxDone = 1;
 			u16Read = u16ReadCount;
-			s16Diff	= u16Read - gastrSockets[sock].u16UserBufferSize;
+			s16Diff	= u16Read - internal->gastrSockets[sock].u16UserBufferSize;
 			if(s16Diff > 0)
 			{
 				u8SetRxDone = 0;
-				u16Read		= gastrSockets[sock].u16UserBufferSize;
+				u16Read		= internal->gastrSockets[sock].u16UserBufferSize;
 			}
 			
-			if(hif_receive(u32Address, gastrSockets[sock].pu8UserBuffer, u16Read, u8SetRxDone) == M2M_SUCCESS)
+			if(hif_receive(dev, u32Address, internal->gastrSockets[sock].pu8UserBuffer, u16Read, u8SetRxDone) == M2M_SUCCESS)
 			{
-				pstrRecv->pu8Buffer			= gastrSockets[sock].pu8UserBuffer;
+				pstrRecv->pu8Buffer			= internal->gastrSockets[sock].pu8UserBuffer;
 				pstrRecv->s16BufferSize		= u16Read;
 				pstrRecv->u16RemainingSize	-= u16Read;
 
-				if (gpfAppSocketCb)
-					gpfAppSocketCb(sock,u8SocketMsg, pstrRecv);
+				if (internal->gpfAppSocketCb)
+					internal->gpfAppSocketCb(dev, sock,u8SocketMsg, pstrRecv);
 
 				u16ReadCount -= u16Read;
 				u32Address += u16Read;
 
-				if((!gastrSockets[sock].bIsUsed) && (u16ReadCount))
+				if((!internal->gastrSockets[sock].bIsUsed) && (u16ReadCount))
 				{
 					M2M_DBG("Application Closed Socket While Rx Is not Complete\n");
-					if(hif_receive(0, NULL, 0, 1) == M2M_SUCCESS)
+					if(hif_receive(dev, 0, NULL, 0, 1) == M2M_SUCCESS)
 						M2M_DBG("hif_receive Success\n");
 					else
 						M2M_DBG("hif_receive Fail\n");
@@ -213,84 +192,85 @@ Version
 Date
 		17 July 2012
 *********************************************************************/
-static void m2m_ip_cb(uint8 u8OpCode, uint16 u16BufferSize,uint32 u32Address)
+static void m2m_ip_cb(winc1500_t *dev, uint8 u8OpCode, uint16 u16BufferSize,uint32 u32Address)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	M2M_DBG("m2m_ip_cb called: %u\n", u8OpCode);
 	if((u8OpCode == SOCKET_CMD_BIND) || (u8OpCode == SOCKET_CMD_SSL_BIND))
 	{
 		tstrBindReply		strBindReply;
 		tstrSocketBindMsg	strBind;
 
-		if(hif_receive(u32Address, (uint8*)&strBindReply, sizeof(tstrBindReply), 0) == M2M_SUCCESS)
+		if(hif_receive(dev, u32Address, (uint8*)&strBindReply, sizeof(tstrBindReply), 0) == M2M_SUCCESS)
 		{
 			strBind.status = strBindReply.s8Status;
-			if(gpfAppSocketCb)
-				gpfAppSocketCb(strBindReply.sock,SOCKET_MSG_BIND,&strBind);
+			if(internal->gpfAppSocketCb)
+				internal->gpfAppSocketCb(dev, strBindReply.sock,SOCKET_MSG_BIND,&strBind);
 		}
 	}
 	else if(u8OpCode == SOCKET_CMD_LISTEN)
 	{
 		tstrListenReply			strListenReply;
 		tstrSocketListenMsg		strListen;
-		if(hif_receive(u32Address, (uint8*)&strListenReply, sizeof(tstrListenReply), 0) == M2M_SUCCESS)
+		if(hif_receive(dev, u32Address, (uint8*)&strListenReply, sizeof(tstrListenReply), 0) == M2M_SUCCESS)
 		{
 			strListen.status = strListenReply.s8Status;
-			if(gpfAppSocketCb)
-				gpfAppSocketCb(strListenReply.sock,SOCKET_MSG_LISTEN, &strListen);
+			if(internal->gpfAppSocketCb)
+				internal->gpfAppSocketCb(dev, strListenReply.sock,SOCKET_MSG_LISTEN, &strListen);
 		}
 	}
 	else if(u8OpCode == SOCKET_CMD_ACCEPT)
 	{
 		tstrAcceptReply			strAcceptReply;
 		tstrSocketAcceptMsg		strAccept;
-		if(hif_receive(u32Address, (uint8*)&strAcceptReply, sizeof(tstrAcceptReply), 0) == M2M_SUCCESS)
+		if(hif_receive(dev, u32Address, (uint8*)&strAcceptReply, sizeof(tstrAcceptReply), 0) == M2M_SUCCESS)
 		{
 			if(strAcceptReply.sConnectedSock >= 0)
 			{
-				gastrSockets[strAcceptReply.sConnectedSock].u8SSLFlags 		= gastrSockets[strAcceptReply.sListenSock].u8SSLFlags;
-				gastrSockets[strAcceptReply.sConnectedSock].bIsUsed 		= 1;
-				gastrSockets[strAcceptReply.sConnectedSock].u16DataOffset 	= strAcceptReply.u16AppDataOffset - M2M_HIF_HDR_OFFSET;
+				internal->gastrSockets[strAcceptReply.sConnectedSock].u8SSLFlags 		= internal->gastrSockets[strAcceptReply.sListenSock].u8SSLFlags;
+				internal->gastrSockets[strAcceptReply.sConnectedSock].bIsUsed 		= 1;
+				internal->gastrSockets[strAcceptReply.sConnectedSock].u16DataOffset 	= strAcceptReply.u16AppDataOffset - M2M_HIF_HDR_OFFSET;
 
 				/* The session ID is used to distinguish different socket connections
 					by comparing the assigned session ID to the one reported by the firmware*/
-				++gu16SessionID;
-				if(gu16SessionID == 0)
-					++gu16SessionID;
+				++internal->gu16SessionID;
+				if(internal->gu16SessionID == 0)
+					++internal->gu16SessionID;
 
-				gastrSockets[strAcceptReply.sConnectedSock].u16SessionID = gu16SessionID;
-				M2M_DBG("Socket %d session ID = %d\n",strAcceptReply.sConnectedSock , gu16SessionID );		
+				internal->gastrSockets[strAcceptReply.sConnectedSock].u16SessionID = internal->gu16SessionID;
+				M2M_DBG("Socket %d session ID = %d\n",strAcceptReply.sConnectedSock , internal->gu16SessionID );		
 			}
 			strAccept.sock = strAcceptReply.sConnectedSock;
 			strAccept.strAddr.sin_family		= AF_INET;
 			strAccept.strAddr.sin_port = strAcceptReply.strAddr.u16Port;
 			strAccept.strAddr.sin_addr.s_addr = strAcceptReply.strAddr.u32IPAddr;
-			if(gpfAppSocketCb)
-				gpfAppSocketCb(strAcceptReply.sListenSock, SOCKET_MSG_ACCEPT, &strAccept);
+			if(internal->gpfAppSocketCb)
+				internal->gpfAppSocketCb(dev, strAcceptReply.sListenSock, SOCKET_MSG_ACCEPT, &strAccept);
 		}
 	}
 	else if((u8OpCode == SOCKET_CMD_CONNECT) || (u8OpCode == SOCKET_CMD_SSL_CONNECT))
 	{
 		tstrConnectReply		strConnectReply;
 		tstrSocketConnectMsg	strConnMsg;
-		if(hif_receive(u32Address, (uint8*)&strConnectReply, sizeof(tstrConnectReply), 0) == M2M_SUCCESS)
+		if(hif_receive(dev, u32Address, (uint8*)&strConnectReply, sizeof(tstrConnectReply), 0) == M2M_SUCCESS)
 		{
 			strConnMsg.sock		= strConnectReply.sock;
 			strConnMsg.s8Error	= strConnectReply.s8Error;
 			if(strConnectReply.s8Error == SOCK_ERR_NO_ERROR)
 			{
-				gastrSockets[strConnectReply.sock].u16DataOffset = strConnectReply.u16AppDataOffset - M2M_HIF_HDR_OFFSET;
+				internal->gastrSockets[strConnectReply.sock].u16DataOffset = strConnectReply.u16AppDataOffset - M2M_HIF_HDR_OFFSET;
 			}
-			if(gpfAppSocketCb)
-				gpfAppSocketCb(strConnectReply.sock,SOCKET_MSG_CONNECT, &strConnMsg);
+			if(internal->gpfAppSocketCb)
+				internal->gpfAppSocketCb(dev, strConnectReply.sock,SOCKET_MSG_CONNECT, &strConnMsg);
 		}
 	}
 	else if(u8OpCode == SOCKET_CMD_DNS_RESOLVE)
 	{
 		tstrDnsReply	strDnsReply;
-		if(hif_receive(u32Address, (uint8*)&strDnsReply, sizeof(tstrDnsReply), 0) == M2M_SUCCESS)
+		if(hif_receive(dev, u32Address, (uint8*)&strDnsReply, sizeof(tstrDnsReply), 0) == M2M_SUCCESS)
 		{
-			if(gpfAppResolveCb)
-				gpfAppResolveCb((uint8*)strDnsReply.acHostName, strDnsReply.u32HostIP);
+			if(internal->gpfAppResolveCb)
+				internal->gpfAppResolveCb(dev, (uint8*)strDnsReply.acHostName, strDnsReply.u32HostIP);
 		}
 	}
 	else if((u8OpCode == SOCKET_CMD_RECV) || (u8OpCode == SOCKET_CMD_RECVFROM) || (u8OpCode == SOCKET_CMD_SSL_RECV))
@@ -309,7 +289,7 @@ static void m2m_ip_cb(uint8 u8OpCode, uint16 u16BufferSize,uint32 u32Address)
 		/* Read RECV REPLY data structure.
 		*/
 		u16ReadSize = sizeof(tstrRecvReply);
-		if(hif_receive(u32Address, (uint8*)&strRecvReply, u16ReadSize, 0) == M2M_SUCCESS)
+		if(hif_receive(dev, u32Address, (uint8*)&strRecvReply, u16ReadSize, 0) == M2M_SUCCESS)
 		{
 			uint16 u16SessionID = 0;
 
@@ -319,14 +299,14 @@ static void m2m_ip_cb(uint8 u8OpCode, uint16 u16BufferSize,uint32 u32Address)
 			
 			/* Reset the Socket RX Pending Flag.
 			*/
-			gastrSockets[sock].bIsRecvPending = 0;
+			internal->gastrSockets[sock].bIsRecvPending = 0;
 
 			s16RecvStatus	= NM_BSP_B_L_16(strRecvReply.s16RecvStatus);
 			u16DataOffset	= NM_BSP_B_L_16(strRecvReply.u16DataOffset);
 			strRecvMsg.strRemoteAddr.sin_port 			= strRecvReply.strRemoteAddr.u16Port;
 			strRecvMsg.strRemoteAddr.sin_addr.s_addr 	= strRecvReply.strRemoteAddr.u32IPAddr;
 
-			if(u16SessionID == gastrSockets[sock].u16SessionID)
+			if(u16SessionID == internal->gastrSockets[sock].u16SessionID)
 			{
 				if((s16RecvStatus > 0) && (s16RecvStatus < u16BufferSize))
 				{
@@ -339,22 +319,22 @@ static void m2m_ip_cb(uint8 u8OpCode, uint16 u16BufferSize,uint32 u32Address)
 					the data is passed to the application in chunks according to its buffer size.
 					*/
 					u16ReadSize = (uint16)s16RecvStatus;
-					Socket_ReadSocketData(sock, &strRecvMsg, u8CallbackMsgID, u32Address, u16ReadSize);
+					Socket_ReadSocketData(dev, sock, &strRecvMsg, u8CallbackMsgID, u32Address, u16ReadSize);
 				}
 				else
 				{
 					strRecvMsg.s16BufferSize	= s16RecvStatus;
 					strRecvMsg.pu8Buffer		= NULL;
-					if(gpfAppSocketCb)
-						gpfAppSocketCb(sock,u8CallbackMsgID, &strRecvMsg);
+					if(internal->gpfAppSocketCb)
+						internal->gpfAppSocketCb(dev, sock,u8CallbackMsgID, &strRecvMsg);
 				}
 			}
 			else
 			{
-				M2M_DBG("Discard recv callback %d %d \n",u16SessionID , gastrSockets[sock].u16SessionID);
+				M2M_DBG("Discard recv callback %d %d \n",u16SessionID , internal->gastrSockets[sock].u16SessionID);
 				if(u16ReadSize < u16BufferSize)
 				{
-					if(hif_receive(0, NULL, 0, 1) == M2M_SUCCESS)
+					if(hif_receive(dev, 0, NULL, 0, 1) == M2M_SUCCESS)
 						M2M_DBG("hif_receive Success\n");
 					else
 						M2M_DBG("hif_receive Fail\n");
@@ -371,7 +351,7 @@ static void m2m_ip_cb(uint8 u8OpCode, uint16 u16BufferSize,uint32 u32Address)
 
 		if(u8OpCode == SOCKET_CMD_SENDTO)
 			u8CallbackMsgID = SOCKET_MSG_SENDTO;
-		sint8 ret = hif_receive(u32Address, (uint8_t*)&strReply, sizeof(tstrSendReply), 0);
+		sint8 ret = hif_receive(dev, u32Address, (uint8_t*)&strReply, sizeof(tstrSendReply), 0);
 		if(ret == M2M_SUCCESS)
 		{
 			uint16 u16SessionID = 0;
@@ -382,29 +362,29 @@ static void m2m_ip_cb(uint8 u8OpCode, uint16 u16BufferSize,uint32 u32Address)
 			
 			s16Rcvd = NM_BSP_B_L_16(strReply.s16SentBytes);
 
-			if(u16SessionID == gastrSockets[sock].u16SessionID)
+			if(u16SessionID == internal->gastrSockets[sock].u16SessionID)
 			{
-				if(gpfAppSocketCb)
-					gpfAppSocketCb(sock,u8CallbackMsgID, &s16Rcvd);
+				if(internal->gpfAppSocketCb)
+					internal->gpfAppSocketCb(dev, sock,u8CallbackMsgID, &s16Rcvd);
 			}
 			else
 			{
-				M2M_DBG("Discard send callback %d %d \n",u16SessionID , gastrSockets[sock].u16SessionID);
+				M2M_DBG("Discard send callback %d %d \n",u16SessionID , internal->gastrSockets[sock].u16SessionID);
 			}
 		}
 		else {
-				M2M_DBG("hif_receive() failed: %d\n",ret);
+				M2M_DBG("hif_receive(dev, ) failed: %d\n",ret);
 		}
 	}
 	else if(u8OpCode == SOCKET_CMD_PING)
 	{
 		tstrPingReply	strPingReply;
-		if(hif_receive(u32Address, (uint8*)&strPingReply, sizeof(tstrPingReply), 1) == M2M_SUCCESS)
+		if(hif_receive(dev, u32Address, (uint8*)&strPingReply, sizeof(tstrPingReply), 1) == M2M_SUCCESS)
 		{
-			gfpPingCb = (void (*)(uint32 , uint32 , uint8))strPingReply.u32CmdPrivate;
-			if(gfpPingCb != NULL)
+			internal->gfpPingCb = (void (*)(winc1500_t *, uint32 , uint32 , uint8))strPingReply.u32CmdPrivate;
+			if(internal->gfpPingCb != NULL)
 			{
-				gfpPingCb(strPingReply.u32IPAddr, strPingReply.u32RTT, strPingReply.u8ErrorCode);
+				internal->gfpPingCb(dev, strPingReply.u32IPAddr, strPingReply.u32RTT, strPingReply.u8ErrorCode);
 			}
 		}
 	}
@@ -427,14 +407,15 @@ Version
 Date
 		4 June 2012
 *********************************************************************/
-void socketInit(void)
+void socketInit(winc1500_t *dev)
 {
-	if(gbSocketInit == 0)
+	winc1500_internal_t *internal = &dev->internal;
+	if(internal->gbSocketInit == 0)
 	{
-		m2m_memset((uint8*)gastrSockets, 0, MAX_SOCKET * sizeof(tstrSocket));
-		hif_register_cb(M2M_REQ_GROUP_IP,m2m_ip_cb);
-		gbSocketInit	= 1;
-		gu16SessionID	= 0;
+		m2m_memset((uint8*)internal->gastrSockets, 0, MAX_SOCKET * sizeof(struct tstrSocket));
+		hif_register_cb(dev, M2M_REQ_GROUP_IP,m2m_ip_cb);
+		internal->gbSocketInit	= 1;
+		internal->gu16SessionID	= 0;
 	}
 }
 /*********************************************************************
@@ -455,13 +436,14 @@ Version
 Date
 		27 Feb 2015
 *********************************************************************/
-void socketDeinit(void)
-{	
-	m2m_memset((uint8*)gastrSockets, 0, MAX_SOCKET * sizeof(tstrSocket));
-	hif_register_cb(M2M_REQ_GROUP_IP, NULL);
-	gpfAppSocketCb	= NULL;
-	gpfAppResolveCb	= NULL;
-	gbSocketInit	= 0;
+void socketDeinit(winc1500_t *dev)
+{
+	winc1500_internal_t *internal = &dev->internal;
+	m2m_memset((uint8*)internal->gastrSockets, 0, MAX_SOCKET * sizeof(struct tstrSocket));
+	hif_register_cb(dev, M2M_REQ_GROUP_IP, NULL);
+	internal->gpfAppSocketCb	= NULL;
+	internal->gpfAppResolveCb	= NULL;
+	internal->gbSocketInit	= 0;
 }
 /*********************************************************************
 Function
@@ -481,10 +463,11 @@ Versio
 Date
 		4 June 2012
 *********************************************************************/
-void registerSocketCallback(tpfAppSocketCb pfAppSocketCb, tpfAppResolveCb pfAppResolveCb)
+void registerSocketCallback(winc1500_t *dev, tpfAppSocketCb pfAppSocketCb, tpfAppResolveCb pfAppResolveCb)
 {
-	gpfAppSocketCb = pfAppSocketCb;
-	gpfAppResolveCb = pfAppResolveCb;
+	winc1500_internal_t *internal = &dev->internal;
+	internal->gpfAppSocketCb = pfAppSocketCb;
+	internal->gpfAppResolveCb = pfAppResolveCb;
 }
 
 /*********************************************************************
@@ -507,12 +490,13 @@ Version
 Date
 		4 June 2012
 *********************************************************************/
-SOCKET socket(uint16 u16Domain, uint8 u8Type, uint8 u8Flags)
+SOCKET socket(winc1500_t *dev, uint16 u16Domain, uint8 u8Type, uint8 u8Flags)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	SOCKET					sock = -1;
 	uint8					u8SockID;
 	uint8					u8Count;
-	volatile tstrSocket		*pstrSock;
+	volatile struct tstrSocket		*pstrSock;
 	static volatile uint8	u8NextTcpSock	= 0;
 	static volatile uint8	u8NextUdpSock	= 0;
 
@@ -524,7 +508,7 @@ SOCKET socket(uint16 u16Domain, uint8 u8Type, uint8 u8Flags)
 			for(u8Count = 0; u8Count < TCP_SOCK_MAX; u8Count ++)
 			{
 				u8SockID	= u8NextTcpSock;
-				pstrSock	= &gastrSockets[u8NextTcpSock];
+				pstrSock	= &internal->gastrSockets[u8NextTcpSock];
 				u8NextTcpSock = (u8NextTcpSock + 1) % TCP_SOCK_MAX;
 				if(!pstrSock->bIsUsed)
 				{
@@ -535,7 +519,7 @@ SOCKET socket(uint16 u16Domain, uint8 u8Type, uint8 u8Flags)
 		}
 		else if(u8Type == SOCK_DGRAM)
 		{
-			volatile tstrSocket	*pastrUDPSockets = &gastrSockets[TCP_SOCK_MAX];
+			volatile struct tstrSocket	*pastrUDPSockets = &internal->gastrSockets[TCP_SOCK_MAX];
 			for(u8Count = 0; u8Count < UDP_SOCK_MAX; u8Count ++)
 			{
 				u8SockID		= u8NextUdpSock;
@@ -551,24 +535,24 @@ SOCKET socket(uint16 u16Domain, uint8 u8Type, uint8 u8Flags)
 
 		if(sock >= 0)
 		{
-			m2m_memset((uint8*)pstrSock, 0, sizeof(tstrSocket));
+			m2m_memset((uint8*)pstrSock, 0, sizeof(struct tstrSocket));
 			pstrSock->bIsUsed = 1;
 
 			/* The session ID is used to distinguish different socket connections
 				by comparing the assigned session ID to the one reported by the firmware*/
-			++gu16SessionID;
-			if(gu16SessionID == 0)
-				++gu16SessionID;
+			++internal->gu16SessionID;
+			if(internal->gu16SessionID == 0)
+				++internal->gu16SessionID;
 				
-			pstrSock->u16SessionID = gu16SessionID;
-            M2M_INFO("Socket %d session ID = %d\n",sock, gu16SessionID );
+			pstrSock->u16SessionID = internal->gu16SessionID;
+            M2M_INFO("Socket %d session ID = %d\n",sock, internal->gu16SessionID );
 
 			if(u8Flags & SOCKET_FLAGS_SSL)
 			{
 				tstrSSLSocketCreateCmd	strSSLCreate;
 				strSSLCreate.sslSock = sock;
 				pstrSock->u8SSLFlags = SSL_FLAGS_ACTIVE | SSL_FLAGS_NO_TX_COPY;
-				SOCKET_REQUEST(SOCKET_CMD_SSL_CREATE, (uint8*)&strSSLCreate, sizeof(tstrSSLSocketCreateCmd), 0, 0, 0);
+				SOCKET_REQUEST(dev, SOCKET_CMD_SSL_CREATE, (uint8*)&strSSLCreate, sizeof(tstrSSLSocketCreateCmd), 0, 0, 0);
 			}
 		}
 	}
@@ -593,14 +577,15 @@ Version
 Date
 		5 June 2012
 *********************************************************************/
-sint8 bind(SOCKET sock, struct sockaddr *pstrAddr, uint8 u8AddrLen)
+sint8 bind(winc1500_t *dev, SOCKET sock, struct sockaddr *pstrAddr, uint8 u8AddrLen)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
-	if((pstrAddr != NULL) && (sock >= 0) && (gastrSockets[sock].bIsUsed == 1) && (u8AddrLen != 0))
+	if((pstrAddr != NULL) && (sock >= 0) && (internal->gastrSockets[sock].bIsUsed == 1) && (u8AddrLen != 0))
 	{
 		tstrBindCmd			strBind;
 		uint8				u8CMD = SOCKET_CMD_BIND;
-		if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
+		if(internal->gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
 		{
 			u8CMD = SOCKET_CMD_SSL_BIND;
 		}
@@ -608,10 +593,10 @@ sint8 bind(SOCKET sock, struct sockaddr *pstrAddr, uint8 u8AddrLen)
 		/* Build the bind request. */
 		strBind.sock = sock;
 		m2m_memcpy((uint8 *)&strBind.strAddr, (uint8 *)pstrAddr, sizeof(tstrSockAddr));
-		strBind.u16SessionID		= gastrSockets[sock].u16SessionID;
+		strBind.u16SessionID		= internal->gastrSockets[sock].u16SessionID;
 		
 		/* Send the request. */
-		s8Ret = SOCKET_REQUEST(u8CMD, (uint8*)&strBind,sizeof(tstrBindCmd) , NULL , 0, 0);
+		s8Ret = SOCKET_REQUEST(dev, u8CMD, (uint8*)&strBind,sizeof(tstrBindCmd) , NULL , 0, 0);
 		if(s8Ret != SOCK_ERR_NO_ERROR)
 		{
 			s8Ret = SOCK_ERR_INVALID;
@@ -638,19 +623,20 @@ Version
 Date
 		5 June 2012
 *********************************************************************/
-sint8 listen(SOCKET sock, uint8 backlog)
+sint8 listen(winc1500_t *dev, SOCKET sock, uint8 backlog)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
 	
-	if(sock >= 0 && (gastrSockets[sock].bIsUsed == 1))
+	if(sock >= 0 && (internal->gastrSockets[sock].bIsUsed == 1))
 	{
 		tstrListenCmd		strListen;
 
 		strListen.sock = sock;
 		strListen.u8BackLog = backlog;
-		strListen.u16SessionID		= gastrSockets[sock].u16SessionID;
+		strListen.u16SessionID		= internal->gastrSockets[sock].u16SessionID;
 
-		s8Ret = SOCKET_REQUEST(SOCKET_CMD_LISTEN, (uint8*)&strListen, sizeof(tstrListenCmd), NULL, 0, 0);
+		s8Ret = SOCKET_REQUEST(dev, SOCKET_CMD_LISTEN, (uint8*)&strListen, sizeof(tstrListenCmd), NULL, 0, 0);
 		if(s8Ret != SOCK_ERR_NO_ERROR)
 		{
 			s8Ret = SOCK_ERR_INVALID;
@@ -676,14 +662,15 @@ Version
 Date
 		5 June 2012
 *********************************************************************/
-sint8 accept(SOCKET sock, struct sockaddr *addr, uint8 *addrlen)
+sint8 accept(winc1500_t *dev, SOCKET sock, struct sockaddr *addr, uint8 *addrlen)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	(void)addr;
 	(void)addrlen;
 
 	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
 	
-	if(sock >= 0 && (gastrSockets[sock].bIsUsed == 1) )
+	if(sock >= 0 && (internal->gastrSockets[sock].bIsUsed == 1) )
 	{
 		s8Ret = SOCK_ERR_NO_ERROR;
 	}
@@ -708,23 +695,24 @@ Version
 Date
 		5 June 2012
 *********************************************************************/
-sint8 connect(SOCKET sock, struct sockaddr *pstrAddr, uint8 u8AddrLen)
+sint8 connect(winc1500_t *dev, SOCKET sock, struct sockaddr *pstrAddr, uint8 u8AddrLen)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
-	if((sock >= 0) && (pstrAddr != NULL) && (gastrSockets[sock].bIsUsed == 1) && (u8AddrLen != 0))
+	if((sock >= 0) && (pstrAddr != NULL) && (internal->gastrSockets[sock].bIsUsed == 1) && (u8AddrLen != 0))
 	{
 		tstrConnectCmd	strConnect;
 		uint8			u8Cmd = SOCKET_CMD_CONNECT;
-		if((gastrSockets[sock].u8SSLFlags) & SSL_FLAGS_ACTIVE)
+		if((internal->gastrSockets[sock].u8SSLFlags) & SSL_FLAGS_ACTIVE)
 		{
 			u8Cmd = SOCKET_CMD_SSL_CONNECT;
-			strConnect.u8SslFlags = gastrSockets[sock].u8SSLFlags;
+			strConnect.u8SslFlags = internal->gastrSockets[sock].u8SSLFlags;
 		}
 		strConnect.sock = sock;
 		m2m_memcpy((uint8 *)&strConnect.strAddr, (uint8 *)pstrAddr, sizeof(tstrSockAddr));
 
-		strConnect.u16SessionID		= gastrSockets[sock].u16SessionID;
-		s8Ret = SOCKET_REQUEST(u8Cmd, (uint8*)&strConnect,sizeof(tstrConnectCmd), NULL, 0, 0);
+		strConnect.u16SessionID		= internal->gastrSockets[sock].u16SessionID;
+		s8Ret = SOCKET_REQUEST(dev, u8Cmd, (uint8*)&strConnect,sizeof(tstrConnectCmd), NULL, 0, 0);
 		if(s8Ret != SOCK_ERR_NO_ERROR)
 		{
 			s8Ret = SOCK_ERR_INVALID;
@@ -749,13 +737,14 @@ Version
 Date
 		5 June 2012
 *********************************************************************/
-sint16 send(SOCKET sock, void *pvSendBuffer, uint16 u16SendLength, uint16 flags)
+sint16 send(winc1500_t *dev, SOCKET sock, void *pvSendBuffer, uint16 u16SendLength, uint16 flags)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	(void)flags;
 
 	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
 	
-	if((sock >= 0) && (pvSendBuffer != NULL) && (u16SendLength <= SOCKET_BUFFER_MAX_LENGTH) && (gastrSockets[sock].bIsUsed == 1))
+	if((sock >= 0) && (pvSendBuffer != NULL) && (u16SendLength <= SOCKET_BUFFER_MAX_LENGTH) && (internal->gastrSockets[sock].bIsUsed == 1))
 	{
 		uint16			u16DataOffset;
 		tstrSendCmd		strSend;
@@ -766,19 +755,19 @@ sint16 send(SOCKET sock, void *pvSendBuffer, uint16 u16SendLength, uint16 flags)
 
 		strSend.sock			= sock;
 		strSend.u16DataSize		= NM_BSP_B_L_16(u16SendLength);
-		strSend.u16SessionID	= gastrSockets[sock].u16SessionID;
+		strSend.u16SessionID	= internal->gastrSockets[sock].u16SessionID;
 
 		if(sock >= TCP_SOCK_MAX)
 		{
 			u16DataOffset = UDP_TX_PACKET_OFFSET;
 		}
-		if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
+		if(internal->gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
 		{
 			u8Cmd			= SOCKET_CMD_SSL_SEND;
-			u16DataOffset	= gastrSockets[sock].u16DataOffset;
+			u16DataOffset	= internal->gastrSockets[sock].u16DataOffset;
 		}
 
-		s16Ret =  SOCKET_REQUEST(u8Cmd|M2M_REQ_DATA_PKT, (uint8*)&strSend, sizeof(tstrSendCmd), pvSendBuffer, u16SendLength, u16DataOffset);
+		s16Ret =  SOCKET_REQUEST(dev, u8Cmd|M2M_REQ_DATA_PKT, (uint8*)&strSend, sizeof(tstrSendCmd), pvSendBuffer, u16SendLength, u16DataOffset);
 		if(s16Ret != SOCK_ERR_NO_ERROR)
 		{
 			s16Ret = SOCK_ERR_BUFFER_FULL;
@@ -803,16 +792,17 @@ Version
 Date
 		4 June 2012
 *********************************************************************/
-sint16 sendto(SOCKET sock, void *pvSendBuffer, uint16 u16SendLength, uint16 flags, struct sockaddr *pstrDestAddr, uint8 u8AddrLen)
+sint16 sendto(winc1500_t *dev, SOCKET sock, void *pvSendBuffer, uint16 u16SendLength, uint16 flags, struct sockaddr *pstrDestAddr, uint8 u8AddrLen)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	(void)flags;
 	(void)u8AddrLen;
 	
 	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
 	
-	if((sock >= 0) && (pvSendBuffer != NULL) && (u16SendLength <= SOCKET_BUFFER_MAX_LENGTH) && (gastrSockets[sock].bIsUsed == 1))
+	if((sock >= 0) && (pvSendBuffer != NULL) && (u16SendLength <= SOCKET_BUFFER_MAX_LENGTH) && (internal->gastrSockets[sock].bIsUsed == 1))
 	{
-		if(gastrSockets[sock].bIsUsed)
+		if(internal->gastrSockets[sock].bIsUsed)
 		{
 			tstrSendCmd	strSendTo;
 
@@ -820,7 +810,7 @@ sint16 sendto(SOCKET sock, void *pvSendBuffer, uint16 u16SendLength, uint16 flag
 
 			strSendTo.sock			= sock;
 			strSendTo.u16DataSize	= NM_BSP_B_L_16(u16SendLength);
-			strSendTo.u16SessionID	= gastrSockets[sock].u16SessionID;
+			strSendTo.u16SessionID	= internal->gastrSockets[sock].u16SessionID;
 			
 			if(pstrDestAddr != NULL)
 			{
@@ -831,7 +821,7 @@ sint16 sendto(SOCKET sock, void *pvSendBuffer, uint16 u16SendLength, uint16 flag
 				strSendTo.strAddr.u16Port	= pstrAddr->sin_port;
 				strSendTo.strAddr.u32IPAddr	= pstrAddr->sin_addr.s_addr;
 			}
-			s16Ret = SOCKET_REQUEST(SOCKET_CMD_SENDTO|M2M_REQ_DATA_PKT, (uint8*)&strSendTo,  sizeof(tstrSendCmd),
+			s16Ret = SOCKET_REQUEST(dev, SOCKET_CMD_SENDTO|M2M_REQ_DATA_PKT, (uint8*)&strSendTo,  sizeof(tstrSendCmd),
 				pvSendBuffer, u16SendLength, UDP_TX_PACKET_OFFSET);
 
 			if(s16Ret != SOCK_ERR_NO_ERROR)
@@ -861,23 +851,24 @@ Version
 Date
 		5 June 2012
 *********************************************************************/
-sint16 recv(SOCKET sock, void *pvRecvBuf, uint16 u16BufLen, uint32 u32Timeoutmsec)
+sint16 recv(winc1500_t *dev, SOCKET sock, void *pvRecvBuf, uint16 u16BufLen, uint32 u32Timeoutmsec)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	sint16	s16Ret = SOCK_ERR_INVALID_ARG;
 	
-	if((sock >= 0) && (pvRecvBuf != NULL) && (u16BufLen != 0) && (gastrSockets[sock].bIsUsed == 1))
+	if((sock >= 0) && (pvRecvBuf != NULL) && (u16BufLen != 0) && (internal->gastrSockets[sock].bIsUsed == 1))
 	{
 		s16Ret = SOCK_ERR_NO_ERROR;
-		gastrSockets[sock].pu8UserBuffer 		= (uint8*)pvRecvBuf;
-		gastrSockets[sock].u16UserBufferSize 	= u16BufLen;
+		internal->gastrSockets[sock].pu8UserBuffer 		= (uint8*)pvRecvBuf;
+		internal->gastrSockets[sock].u16UserBufferSize 	= u16BufLen;
 
-		if(!gastrSockets[sock].bIsRecvPending)
+		if(!internal->gastrSockets[sock].bIsRecvPending)
 		{
 			tstrRecvCmd	strRecv;
 			uint8		u8Cmd = SOCKET_CMD_RECV;
 
-			gastrSockets[sock].bIsRecvPending = 1;
-			if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
+			internal->gastrSockets[sock].bIsRecvPending = 1;
+			if(internal->gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
 			{
 				u8Cmd = SOCKET_CMD_SSL_RECV;
 			}
@@ -888,9 +879,9 @@ sint16 recv(SOCKET sock, void *pvRecvBuf, uint16 u16BufLen, uint32 u32Timeoutmse
 			else
 				strRecv.u32Timeoutmsec = NM_BSP_B_L_32(u32Timeoutmsec);
 			strRecv.sock = sock;
-			strRecv.u16SessionID		= gastrSockets[sock].u16SessionID;
+			strRecv.u16SessionID		= internal->gastrSockets[sock].u16SessionID;
 		
-			s16Ret = SOCKET_REQUEST(u8Cmd, (uint8*)&strRecv, sizeof(tstrRecvCmd), NULL , 0, 0);
+			s16Ret = SOCKET_REQUEST(dev, u8Cmd, (uint8*)&strRecv, sizeof(tstrRecvCmd), NULL , 0, 0);
 			if(s16Ret != SOCK_ERR_NO_ERROR)
 			{
 				s16Ret = SOCK_ERR_BUFFER_FULL;
@@ -917,30 +908,31 @@ Version
 Date
 		4 June 2012
 *********************************************************************/
-sint8 close(SOCKET sock)
+sint8 close(winc1500_t *dev, SOCKET sock)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
     M2M_INFO("Sock to delete <%d>\n", sock);
-	if(sock >= 0 && (gastrSockets[sock].bIsUsed == 1))
+	if(sock >= 0 && (internal->gastrSockets[sock].bIsUsed == 1))
 	{
 		uint8	u8Cmd = SOCKET_CMD_CLOSE;
 		tstrCloseCmd strclose;
 		strclose.sock = sock; 
-		strclose.u16SessionID		= gastrSockets[sock].u16SessionID;
+		strclose.u16SessionID		= internal->gastrSockets[sock].u16SessionID;
 		
-		gastrSockets[sock].bIsUsed = 0;
-		gastrSockets[sock].u16SessionID =0;
+		internal->gastrSockets[sock].bIsUsed = 0;
+		internal->gastrSockets[sock].u16SessionID =0;
 		
-		if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
+		if(internal->gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
 		{
 			u8Cmd = SOCKET_CMD_SSL_CLOSE;
 		}
-		s8Ret = SOCKET_REQUEST(u8Cmd, (uint8*)&strclose, sizeof(tstrCloseCmd), NULL,0, 0);
+		s8Ret = SOCKET_REQUEST(dev, u8Cmd, (uint8*)&strclose, sizeof(tstrCloseCmd), NULL,0, 0);
 		if(s8Ret != SOCK_ERR_NO_ERROR)
 		{
 			s8Ret = SOCK_ERR_INVALID;
 		}
-		m2m_memset((uint8*)&gastrSockets[sock], 0, sizeof(tstrSocket));
+		m2m_memset((uint8*)&internal->gastrSockets[sock], 0, sizeof(struct tstrSocket));
 	}
 	return s8Ret;
 }
@@ -963,22 +955,23 @@ Version
 Date
 		5 June 2012
 *********************************************************************/
-sint16 recvfrom(SOCKET sock, void *pvRecvBuf, uint16 u16BufLen, uint32 u32Timeoutmsec)
+sint16 recvfrom(winc1500_t *dev, SOCKET sock, void *pvRecvBuf, uint16 u16BufLen, uint32 u32Timeoutmsec)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	sint16	s16Ret = SOCK_ERR_NO_ERROR;
-	if((sock >= 0) && (pvRecvBuf != NULL) && (u16BufLen != 0) && (gastrSockets[sock].bIsUsed == 1))
+	if((sock >= 0) && (pvRecvBuf != NULL) && (u16BufLen != 0) && (internal->gastrSockets[sock].bIsUsed == 1))
 	{
-		if(gastrSockets[sock].bIsUsed)
+		if(internal->gastrSockets[sock].bIsUsed)
 		{
 			s16Ret = SOCK_ERR_NO_ERROR;
-			gastrSockets[sock].pu8UserBuffer = (uint8*)pvRecvBuf;
-			gastrSockets[sock].u16UserBufferSize = u16BufLen;
+			internal->gastrSockets[sock].pu8UserBuffer = (uint8*)pvRecvBuf;
+			internal->gastrSockets[sock].u16UserBufferSize = u16BufLen;
 
-			if(!gastrSockets[sock].bIsRecvPending)
+			if(!internal->gastrSockets[sock].bIsRecvPending)
 			{
 				tstrRecvCmd	strRecv;
 
-				gastrSockets[sock].bIsRecvPending = 1;
+				internal->gastrSockets[sock].bIsRecvPending = 1;
 
 				/* Check the timeout value. */
 				if(u32Timeoutmsec == 0)
@@ -986,9 +979,9 @@ sint16 recvfrom(SOCKET sock, void *pvRecvBuf, uint16 u16BufLen, uint32 u32Timeou
 				else
 					strRecv.u32Timeoutmsec = NM_BSP_B_L_32(u32Timeoutmsec);
 				strRecv.sock = sock;
-				strRecv.u16SessionID		= gastrSockets[sock].u16SessionID;
+				strRecv.u16SessionID		= internal->gastrSockets[sock].u16SessionID;
 				
-				s16Ret = SOCKET_REQUEST(SOCKET_CMD_RECVFROM, (uint8*)&strRecv, sizeof(tstrRecvCmd), NULL , 0, 0);
+				s16Ret = SOCKET_REQUEST(dev, SOCKET_CMD_RECVFROM, (uint8*)&strRecv, sizeof(tstrRecvCmd), NULL , 0, 0);
 				if(s16Ret != SOCK_ERR_NO_ERROR)
 				{
 					s16Ret = SOCK_ERR_BUFFER_FULL;
@@ -1021,8 +1014,9 @@ Version
 Date
 		4 June 2012
 *********************************************************************/
-uint32 nmi_inet_addr(char *pcIpAddr)
+uint32 nmi_inet_addr(winc1500_t *dev, char *pcIpAddr)
 {
+	(void)dev;
 	uint8	tmp;
 	uint32	u32IP = 0;
 	uint8	au8IP[4];
@@ -1079,13 +1073,13 @@ Version
 Date
 		4 June 2012
 *********************************************************************/
-sint8 gethostbyname(uint8 * pcHostName)
+sint8 gethostbyname(winc1500_t *dev, uint8 * pcHostName)
 {
 	sint8	s8Err = SOCK_ERR_INVALID_ARG;
 	uint8	u8HostNameSize = (uint8)m2m_strlen(pcHostName);
 	if(u8HostNameSize <= HOSTNAME_MAX_SIZE)
 	{
-		s8Err = SOCKET_REQUEST(SOCKET_CMD_DNS_RESOLVE, (uint8*)pcHostName, u8HostNameSize + 1, NULL,0, 0);
+		s8Err = SOCKET_REQUEST(dev, SOCKET_CMD_DNS_RESOLVE, (uint8*)pcHostName, u8HostNameSize + 1, NULL,0, 0);
 	}
 	return s8Err;
 }
@@ -1107,23 +1101,24 @@ Version
 Date
 		9 September 2014
 *********************************************************************/
-static sint8 sslSetSockOpt(SOCKET sock, uint8  u8Opt, const void *pvOptVal, uint16 u16OptLen)
+static sint8 sslSetSockOpt(winc1500_t *dev, SOCKET sock, uint8  u8Opt, const void *pvOptVal, uint16 u16OptLen)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
 	if(sock < TCP_SOCK_MAX)
 	{
-		if(gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
+		if(internal->gastrSockets[sock].u8SSLFlags & SSL_FLAGS_ACTIVE)
 		{
 			if(u8Opt == SO_SSL_BYPASS_X509_VERIF)
 			{
 				int	optVal = *((int*)pvOptVal);
 				if(optVal)
 				{
-					gastrSockets[sock].u8SSLFlags |= SSL_FLAGS_BYPASS_X509;
+					internal->gastrSockets[sock].u8SSLFlags |= SSL_FLAGS_BYPASS_X509;
 				}
 				else
 				{
-					gastrSockets[sock].u8SSLFlags &= ~SSL_FLAGS_BYPASS_X509;
+					internal->gastrSockets[sock].u8SSLFlags &= ~SSL_FLAGS_BYPASS_X509;
 				}
 				s8Ret = SOCK_ERR_NO_ERROR;
 			}
@@ -1132,11 +1127,11 @@ static sint8 sslSetSockOpt(SOCKET sock, uint8  u8Opt, const void *pvOptVal, uint
 				int	optVal = *((int*)pvOptVal);
 				if(optVal)
 				{
-					gastrSockets[sock].u8SSLFlags |= SSL_FLAGS_CACHE_SESSION;
+					internal->gastrSockets[sock].u8SSLFlags |= SSL_FLAGS_CACHE_SESSION;
 				}
 				else
 				{
-					gastrSockets[sock].u8SSLFlags &= ~SSL_FLAGS_CACHE_SESSION;
+					internal->gastrSockets[sock].u8SSLFlags &= ~SSL_FLAGS_CACHE_SESSION;
 				}
 				s8Ret = SOCK_ERR_NO_ERROR;
 			}
@@ -1145,11 +1140,11 @@ static sint8 sslSetSockOpt(SOCKET sock, uint8  u8Opt, const void *pvOptVal, uint
 				int	optVal = *((int*)pvOptVal);
 				if(optVal)
 				{
-					gastrSockets[sock].u8SSLFlags |= SSL_FLAGS_CHECK_SNI;
+					internal->gastrSockets[sock].u8SSLFlags |= SSL_FLAGS_CHECK_SNI;
 				}
 				else
 				{
-					gastrSockets[sock].u8SSLFlags &= ~SSL_FLAGS_CHECK_SNI;
+					internal->gastrSockets[sock].u8SSLFlags &= ~SSL_FLAGS_CHECK_SNI;
 				}
 				s8Ret = SOCK_ERR_NO_ERROR;
 			}
@@ -1161,15 +1156,15 @@ static sint8 sslSetSockOpt(SOCKET sock, uint8  u8Opt, const void *pvOptVal, uint
 					tstrSSLSetSockOptCmd	strCmd;
 
 					strCmd.sock			= sock;
-					strCmd.u16SessionID	= gastrSockets[sock].u16SessionID;
+					strCmd.u16SessionID	= internal->gastrSockets[sock].u16SessionID;
 					strCmd.u8Option		= u8Opt;
 					strCmd.u32OptLen	= u16OptLen;
 					m2m_memcpy(strCmd.au8OptVal, pu8SNI, HOSTNAME_MAX_SIZE);
 					
-					if(SOCKET_REQUEST(SOCKET_CMD_SSL_SET_SOCK_OPT, (uint8*)&strCmd, sizeof(tstrSSLSetSockOptCmd),
+					if(SOCKET_REQUEST(dev, SOCKET_CMD_SSL_SET_SOCK_OPT, (uint8*)&strCmd, sizeof(tstrSSLSetSockOptCmd),
 						0, 0, 0) == M2M_ERR_MEM_ALLOC)
 					{
-						s8Ret = SOCKET_REQUEST(SOCKET_CMD_SSL_SET_SOCK_OPT | M2M_REQ_DATA_PKT, 
+						s8Ret = SOCKET_REQUEST(dev, SOCKET_CMD_SSL_SET_SOCK_OPT | M2M_REQ_DATA_PKT,
 							(uint8*)&strCmd, sizeof(tstrSSLSetSockOptCmd), 0, 0, 0);
 					}
 					s8Ret = SOCK_ERR_NO_ERROR;
@@ -1209,15 +1204,16 @@ Version
 Date
 		9 September 2014
 *********************************************************************/
-sint8 setsockopt(SOCKET sock, uint8  u8Level, uint8  option_name,
+sint8 setsockopt(winc1500_t *dev, SOCKET sock, uint8  u8Level, uint8  option_name,
        const void *option_value, uint16 u16OptionLen)
 {
+	winc1500_internal_t *internal = &dev->internal;
 	sint8	s8Ret = SOCK_ERR_INVALID_ARG;
-	if((sock >= 0)  && (option_value != NULL)  && (gastrSockets[sock].bIsUsed == 1))
+	if((sock >= 0)  && (option_value != NULL)  && (internal->gastrSockets[sock].bIsUsed == 1))
 	{
 		if(u8Level == SOL_SSL_SOCKET)
 		{
-			s8Ret = sslSetSockOpt(sock, option_name, option_value, u16OptionLen);
+			s8Ret = sslSetSockOpt(dev, sock, option_name, option_value, u16OptionLen);
 		}
 		else
 		{
@@ -1226,9 +1222,9 @@ sint8 setsockopt(SOCKET sock, uint8  u8Level, uint8  option_name,
 			strSetSockOpt.u8Option=option_name;
 			strSetSockOpt.sock = sock; 
 			strSetSockOpt.u32OptionValue = *(uint32*)option_value;
-			strSetSockOpt.u16SessionID		= gastrSockets[sock].u16SessionID;
+			strSetSockOpt.u16SessionID		= internal->gastrSockets[sock].u16SessionID;
 
-			s8Ret = SOCKET_REQUEST(u8Cmd, (uint8*)&strSetSockOpt, sizeof(tstrSetSocketOptCmd), NULL,0, 0);
+			s8Ret = SOCKET_REQUEST(dev, u8Cmd, (uint8*)&strSetSockOpt, sizeof(tstrSetSocketOptCmd), NULL,0, 0);
 			if(s8Ret != SOCK_ERR_NO_ERROR)
 			{
 				s8Ret = SOCK_ERR_INVALID;
@@ -1255,8 +1251,9 @@ Version
 Date
 		24 August 2014
 *********************************************************************/
-sint8 getsockopt(SOCKET sock, uint8 u8Level, uint8 u8OptName, const void *pvOptValue, uint8* pu8OptLen)
+sint8 getsockopt(winc1500_t *dev, SOCKET sock, uint8 u8Level, uint8 u8OptName, const void *pvOptValue, uint8* pu8OptLen)
 {
+	(void)dev;
 	(void)sock;
 	(void)u8Level;
 	(void)u8OptName;
@@ -1284,7 +1281,7 @@ Version
 Date
 	4 June 2015
 *********************************************************************/
-sint8 m2m_ping_req(uint32 u32DstIP, uint8 u8TTL, tpfPingCb fpPingCb)
+sint8 m2m_ping_req(winc1500_t *dev, uint32 u32DstIP, uint8 u8TTL, tpfPingCb fpPingCb)
 {
 	sint8	s8Ret = M2M_ERR_INVALID_ARG;
 
@@ -1297,7 +1294,7 @@ sint8 m2m_ping_req(uint32 u32DstIP, uint8 u8TTL, tpfPingCb fpPingCb)
 		strPingCmd.u32CmdPrivate	= (uint32)fpPingCb;
 		strPingCmd.u8TTL			= u8TTL;
 
-		s8Ret = SOCKET_REQUEST(SOCKET_CMD_PING, (uint8*)&strPingCmd, sizeof(tstrPingCmd), NULL, 0, 0);
+		s8Ret = SOCKET_REQUEST(dev, SOCKET_CMD_PING, (uint8*)&strPingCmd, sizeof(tstrPingCmd), NULL, 0, 0);
 	}
 	return s8Ret;
 }
@@ -1319,9 +1316,11 @@ Version
 Date
 	
 *********************************************************************/
-sint8 sslEnableCertExpirationCheck(tenuSslCertExpSettings enuValidationSetting)
+sint8 sslEnableCertExpirationCheck(winc1500_t *dev, tenuSslCertExpSettings enuValidationSetting)
 {
 	tstrSslCertExpSettings	strSettings;
 	strSettings.u32CertExpValidationOpt = (uint32)enuValidationSetting;
-	return SOCKET_REQUEST(SOCKET_CMD_SSL_EXP_CHECK, (uint8*)&strSettings, sizeof(tstrSslCertExpSettings), NULL, 0, 0);
-}
\ No newline at end of file
+	return SOCKET_REQUEST(dev, SOCKET_CMD_SSL_EXP_CHECK, (uint8*)&strSettings, sizeof(tstrSslCertExpSettings), NULL, 0, 0);
+}
+
+#endif	// !defined(MODULE_NETDEV_ETH)
diff --git a/winc1500/socket/source/socket_internal.h b/winc1500/socket/source/socket_internal.h
index cb21f59..6314160 100644
--- a/winc1500/socket/source/socket_internal.h
+++ b/winc1500/socket/source/socket_internal.h
@@ -58,7 +58,7 @@ INCLUDES
 FUNCTION PROTOTYPES
 *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
 
-NMI_API void Socket_ReadSocketData(SOCKET sock, tstrSocketRecvMsg *pstrRecv,uint8 u8SocketMsg,
+NMI_API void Socket_ReadSocketData(winc1500_t *dev, SOCKET sock, tstrSocketRecvMsg *pstrRecv,uint8 u8SocketMsg,
 								uint32 u32StartAddress,uint16 u16ReadCount);
 
 #ifdef  __cplusplus
diff --git a/winc1500/spi_flash/include/spi_flash.h b/winc1500/spi_flash/include/spi_flash.h
index 74b3a1a..0d68425 100644
--- a/winc1500/spi_flash/include/spi_flash.h
+++ b/winc1500/spi_flash/include/spi_flash.h
@@ -118,7 +118,7 @@
  *	@brief	Enable spi flash operations
  *	@version	1.0
  */
-sint8 spi_flash_enable(uint8 enable);
+sint8 spi_flash_enable(winc1500_t *dev, uint8 enable);
 /** \defgroup SPIFLASHAPI Function
  *   @ingroup SPIFLASH
  */
@@ -133,7 +133,7 @@ sint8 spi_flash_enable(uint8 enable);
  * @note         Returned value in Mb (Mega Bit).
  * @return      SPI flash size in case of success and a ZERO value in case of failure.
  */
-uint32 spi_flash_get_size(void);
+uint32 spi_flash_get_size(winc1500_t *dev);
  /**@}*/
 
   /** @defgroup SPiFlashRead spi_flash_read
@@ -160,7 +160,7 @@ uint32 spi_flash_get_size(void);
  * @sa             m2m_wifi_download_mode, spi_flash_get_size
  * @return        The function returns @ref M2M_SUCCESS for successful operations  and a negative value otherwise.
  */
-sint8 spi_flash_read(uint8 *pu8Buf, uint32 u32Addr, uint32 u32Sz);
+sint8 spi_flash_read(winc1500_t *dev, uint8 *pu8Buf, uint32 u32Addr, uint32 u32Sz);
  /**@}*/
 
   /** @defgroup SPiFlashWrite spi_flash_write
@@ -191,7 +191,7 @@ sint8 spi_flash_read(uint8 *pu8Buf, uint32 u32Addr, uint32 u32Sz);
  * @return       The function returns @ref M2M_SUCCESS for successful operations  and a negative value otherwise.
  
  */
-sint8 spi_flash_write(uint8* pu8Buf, uint32 u32Offset, uint32 u32Sz);
+sint8 spi_flash_write(winc1500_t *dev, uint8* pu8Buf, uint32 u32Offset, uint32 u32Sz);
  /**@}*/
 
   /** @defgroup SPiFlashErase spi_flash_erase
@@ -217,6 +217,6 @@ sint8 spi_flash_write(uint8* pu8Buf, uint32 u32Offset, uint32 u32Sz);
  * @return       The function returns @ref M2M_SUCCESS for successful operations  and a negative value otherwise.
 
  */
-sint8 spi_flash_erase(uint32 u32Offset, uint32 u32Sz);
+sint8 spi_flash_erase(winc1500_t *dev, uint32 u32Offset, uint32 u32Sz);
  /**@}*/
 #endif	//__SPI_FLASH_H__
diff --git a/winc1500/spi_flash/source/spi_flash.c b/winc1500/spi_flash/source/spi_flash.c
index c562762..d38608e 100644
--- a/winc1500/spi_flash/source/spi_flash.c
+++ b/winc1500/spi_flash/source/spi_flash.c
@@ -92,7 +92,7 @@ SPI Flash DMA
 *	@author		M. Abdelmawla
 *	@version	1.0
 */ 
-static sint8 spi_flash_read_status_reg(uint8 * val)
+static sint8 spi_flash_read_status_reg(winc1500_t *dev, uint8 * val)
 {
 	sint8 ret = M2M_SUCCESS;
 	uint8 cmd[1];
@@ -100,19 +100,19 @@ static sint8 spi_flash_read_status_reg(uint8 * val)
 
 	cmd[0] = 0x05;
 
-	ret += nm_write_reg(SPI_FLASH_DATA_CNT, 4);
-	ret += nm_write_reg(SPI_FLASH_BUF1, cmd[0]);
-	ret += nm_write_reg(SPI_FLASH_BUF_DIR, 0x01);
-	ret += nm_write_reg(SPI_FLASH_DMA_ADDR, DUMMY_REGISTER);
-	ret += nm_write_reg(SPI_FLASH_CMD_CNT, 1 | (1<<7));
+	ret += nm_write_reg(dev, SPI_FLASH_DATA_CNT, 4);
+	ret += nm_write_reg(dev, SPI_FLASH_BUF1, cmd[0]);
+	ret += nm_write_reg(dev, SPI_FLASH_BUF_DIR, 0x01);
+	ret += nm_write_reg(dev, SPI_FLASH_DMA_ADDR, DUMMY_REGISTER);
+	ret += nm_write_reg(dev, SPI_FLASH_CMD_CNT, 1 | (1<<7));
 	do
 	{
-		ret += nm_read_reg_with_ret(SPI_FLASH_TR_DONE, (uint32 *)&reg);
+		ret += nm_read_reg_with_ret(dev, SPI_FLASH_TR_DONE, (uint32 *)&reg);
 		if(M2M_SUCCESS != ret) break;
 	}
 	while(reg != 1);
 
-	reg = (M2M_SUCCESS == ret)?(nm_read_reg(DUMMY_REGISTER)):(0);
+	reg = (M2M_SUCCESS == ret)?(nm_read_reg(dev, DUMMY_REGISTER)):(0);
 	*val = (uint8)(reg & 0xff);
 	return ret;
 }
@@ -126,7 +126,7 @@ static sint8 spi_flash_read_status_reg(uint8 * val)
 *	@author		M. Abdelmawla
 *	@version	1.0
 */ 
-static uint8 spi_flash_read_security_reg(void)
+static uint8 spi_flash_read_security_reg(winc1500_t *dev)
 {
 	uint8	cmd[1];
 	uint32	reg;
@@ -134,18 +134,18 @@ static uint8 spi_flash_read_security_reg(void)
 
 	cmd[0] = 0x2b;
 
-	ret += nm_write_reg(SPI_FLASH_DATA_CNT, 1);
-	ret += nm_write_reg(SPI_FLASH_BUF1, cmd[0]);
-	ret += nm_write_reg(SPI_FLASH_BUF_DIR, 0x01);
-	ret += nm_write_reg(SPI_FLASH_DMA_ADDR, DUMMY_REGISTER);
-	ret += nm_write_reg(SPI_FLASH_CMD_CNT, 1 | (1<<7));
+	ret += nm_write_reg(dev, SPI_FLASH_DATA_CNT, 1);
+	ret += nm_write_reg(dev, SPI_FLASH_BUF1, cmd[0]);
+	ret += nm_write_reg(dev, SPI_FLASH_BUF_DIR, 0x01);
+	ret += nm_write_reg(dev, SPI_FLASH_DMA_ADDR, DUMMY_REGISTER);
+	ret += nm_write_reg(dev, SPI_FLASH_CMD_CNT, 1 | (1<<7));
 	do
 	{
-		ret += nm_read_reg_with_ret(SPI_FLASH_TR_DONE, (uint32 *)&reg);
+		ret += nm_read_reg_with_ret(dev, SPI_FLASH_TR_DONE, (uint32 *)&reg);
 		if(M2M_SUCCESS != ret) break;
 	}
 	while(reg != 1);
-	reg = (M2M_SUCCESS == ret)?(nm_read_reg(DUMMY_REGISTER)):(0);
+	reg = (M2M_SUCCESS == ret)?(nm_read_reg(dev, DUMMY_REGISTER)):(0);
 
 	return (sint8)reg & 0xff;
 }
@@ -157,7 +157,7 @@ static uint8 spi_flash_read_security_reg(void)
 *	@author		M. Abdelmawla
 *	@version	1.0
 */ 
-static sint8 spi_flash_gang_unblock(void)
+static sint8 spi_flash_gang_unblock(winc1500_t *dev)
 {
 	uint8	cmd[1];
 	uint32	val	= 0;
@@ -165,14 +165,14 @@ static sint8 spi_flash_gang_unblock(void)
 
 	cmd[0] = 0x98;
 
-	ret += nm_write_reg(SPI_FLASH_DATA_CNT, 0);
-	ret += nm_write_reg(SPI_FLASH_BUF1, cmd[0]);
-	ret += nm_write_reg(SPI_FLASH_BUF_DIR, 0x01);
-	ret += nm_write_reg(SPI_FLASH_DMA_ADDR, 0);
-	ret += nm_write_reg(SPI_FLASH_CMD_CNT, 1 | (1<<7));
+	ret += nm_write_reg(dev, SPI_FLASH_DATA_CNT, 0);
+	ret += nm_write_reg(dev, SPI_FLASH_BUF1, cmd[0]);
+	ret += nm_write_reg(dev, SPI_FLASH_BUF_DIR, 0x01);
+	ret += nm_write_reg(dev, SPI_FLASH_DMA_ADDR, 0);
+	ret += nm_write_reg(dev, SPI_FLASH_CMD_CNT, 1 | (1<<7));
 	do
 	{
-		ret += nm_read_reg_with_ret(SPI_FLASH_TR_DONE, (uint32 *)&val);
+		ret += nm_read_reg_with_ret(dev, SPI_FLASH_TR_DONE, (uint32 *)&val);
 		if(M2M_SUCCESS != ret) break;
 	}
 	while(val != 1);
@@ -187,7 +187,7 @@ static sint8 spi_flash_gang_unblock(void)
 *	@author		M. Abdelmawla
 *	@version	1.0
 */ 
-static sint8 spi_flash_clear_security_flags(void)
+static sint8 spi_flash_clear_security_flags(winc1500_t *dev)
 {
 	uint8 cmd[1];
 	uint32	val	= 0;
@@ -195,14 +195,14 @@ static sint8 spi_flash_clear_security_flags(void)
 
 	cmd[0] = 0x30;
 
-	ret += nm_write_reg(SPI_FLASH_DATA_CNT, 0);
-	ret += nm_write_reg(SPI_FLASH_BUF1, cmd[0]);
-	ret += nm_write_reg(SPI_FLASH_BUF_DIR, 0x01);
-	ret += nm_write_reg(SPI_FLASH_DMA_ADDR, 0);
-	ret += nm_write_reg(SPI_FLASH_CMD_CNT, 1 | (1<<7));
+	ret += nm_write_reg(dev, SPI_FLASH_DATA_CNT, 0);
+	ret += nm_write_reg(dev, SPI_FLASH_BUF1, cmd[0]);
+	ret += nm_write_reg(dev, SPI_FLASH_BUF_DIR, 0x01);
+	ret += nm_write_reg(dev, SPI_FLASH_DMA_ADDR, 0);
+	ret += nm_write_reg(dev, SPI_FLASH_CMD_CNT, 1 | (1<<7));
 	do
 	{
-		ret += nm_read_reg_with_ret(SPI_FLASH_TR_DONE, (uint32 *)&val);
+		ret += nm_read_reg_with_ret(dev, SPI_FLASH_TR_DONE, (uint32 *)&val);
 		if(M2M_SUCCESS != ret) break;
 	}
 	while(val != 1);
@@ -225,7 +225,7 @@ static sint8 spi_flash_clear_security_flags(void)
 *	@author		M. Abdelmawla
 *	@version	1.0
 */ 
-static sint8 spi_flash_load_to_cortus_mem(uint32 u32MemAdr, uint32 u32FlashAdr, uint32 u32Sz)
+static sint8 spi_flash_load_to_cortus_mem(winc1500_t *dev, uint32 u32MemAdr, uint32 u32FlashAdr, uint32 u32Sz)
 {
 	uint8 cmd[5];
 	uint32	val	= 0;
@@ -237,15 +237,15 @@ static sint8 spi_flash_load_to_cortus_mem(uint32 u32MemAdr, uint32 u32FlashAdr,
 	cmd[3] = (uint8)(u32FlashAdr);
 	cmd[4] = 0xA5;
 
-	ret += nm_write_reg(SPI_FLASH_DATA_CNT, u32Sz);
-	ret += nm_write_reg(SPI_FLASH_BUF1, cmd[0]|(cmd[1]<<8)|(cmd[2]<<16)|(cmd[3]<<24));
-	ret += nm_write_reg(SPI_FLASH_BUF2, cmd[4]);
-	ret += nm_write_reg(SPI_FLASH_BUF_DIR, 0x1f);
-	ret += nm_write_reg(SPI_FLASH_DMA_ADDR, u32MemAdr);
-	ret += nm_write_reg(SPI_FLASH_CMD_CNT, 5 | (1<<7));
+	ret += nm_write_reg(dev, SPI_FLASH_DATA_CNT, u32Sz);
+	ret += nm_write_reg(dev, SPI_FLASH_BUF1, cmd[0]|(cmd[1]<<8)|(cmd[2]<<16)|(cmd[3]<<24));
+	ret += nm_write_reg(dev, SPI_FLASH_BUF2, cmd[4]);
+	ret += nm_write_reg(dev, SPI_FLASH_BUF_DIR, 0x1f);
+	ret += nm_write_reg(dev, SPI_FLASH_DMA_ADDR, u32MemAdr);
+	ret += nm_write_reg(dev, SPI_FLASH_CMD_CNT, 5 | (1<<7));
 	do
 	{
-		ret += nm_read_reg_with_ret(SPI_FLASH_TR_DONE, (uint32 *)&val);
+		ret += nm_read_reg_with_ret(dev, SPI_FLASH_TR_DONE, (uint32 *)&val);
 		if(M2M_SUCCESS != ret) break;
 	}
 	while(val != 1);
@@ -263,7 +263,7 @@ static sint8 spi_flash_load_to_cortus_mem(uint32 u32MemAdr, uint32 u32FlashAdr,
 *	@author		M. Abdelmawla
 *	@version	1.0
 */ 
-static sint8 spi_flash_sector_erase(uint32 u32FlashAdr)
+static sint8 spi_flash_sector_erase(winc1500_t *dev, uint32 u32FlashAdr)
 {
 	uint8 cmd[4];
 	uint32	val	= 0;
@@ -274,14 +274,14 @@ static sint8 spi_flash_sector_erase(uint32 u32FlashAdr)
 	cmd[2] = (uint8)(u32FlashAdr >> 8);
 	cmd[3] = (uint8)(u32FlashAdr);
 
-	ret += nm_write_reg(SPI_FLASH_DATA_CNT, 0);
-	ret += nm_write_reg(SPI_FLASH_BUF1, cmd[0]|(cmd[1]<<8)|(cmd[2]<<16)|(cmd[3]<<24));
-	ret += nm_write_reg(SPI_FLASH_BUF_DIR, 0x0f);
-	ret += nm_write_reg(SPI_FLASH_DMA_ADDR, 0);
-	ret += nm_write_reg(SPI_FLASH_CMD_CNT, 4 | (1<<7));
+	ret += nm_write_reg(dev, SPI_FLASH_DATA_CNT, 0);
+	ret += nm_write_reg(dev, SPI_FLASH_BUF1, cmd[0]|(cmd[1]<<8)|(cmd[2]<<16)|(cmd[3]<<24));
+	ret += nm_write_reg(dev, SPI_FLASH_BUF_DIR, 0x0f);
+	ret += nm_write_reg(dev, SPI_FLASH_DMA_ADDR, 0);
+	ret += nm_write_reg(dev, SPI_FLASH_CMD_CNT, 4 | (1<<7));
 	do
 	{
-		ret += nm_read_reg_with_ret(SPI_FLASH_TR_DONE, (uint32 *)&val);
+		ret += nm_read_reg_with_ret(dev, SPI_FLASH_TR_DONE, (uint32 *)&val);
 		if(M2M_SUCCESS != ret) break;
 	}
 	while(val != 1);
@@ -297,7 +297,7 @@ static sint8 spi_flash_sector_erase(uint32 u32FlashAdr)
 *	@author		M. Abdelmawla
 *	@version	1.0
 */ 
-static sint8 spi_flash_write_enable(void)
+static sint8 spi_flash_write_enable(winc1500_t *dev)
 {
 	uint8 cmd[1];
 	uint32	val	= 0;
@@ -305,14 +305,14 @@ static sint8 spi_flash_write_enable(void)
 
 	cmd[0] = 0x06;
 
-	ret += nm_write_reg(SPI_FLASH_DATA_CNT, 0);
-	ret += nm_write_reg(SPI_FLASH_BUF1, cmd[0]);
-	ret += nm_write_reg(SPI_FLASH_BUF_DIR, 0x01);
-	ret += nm_write_reg(SPI_FLASH_DMA_ADDR, 0);
-	ret += nm_write_reg(SPI_FLASH_CMD_CNT, 1 | (1<<7));
+	ret += nm_write_reg(dev, SPI_FLASH_DATA_CNT, 0);
+	ret += nm_write_reg(dev, SPI_FLASH_BUF1, cmd[0]);
+	ret += nm_write_reg(dev, SPI_FLASH_BUF_DIR, 0x01);
+	ret += nm_write_reg(dev, SPI_FLASH_DMA_ADDR, 0);
+	ret += nm_write_reg(dev, SPI_FLASH_CMD_CNT, 1 | (1<<7));
 	do
 	{
-		ret += nm_read_reg_with_ret(SPI_FLASH_TR_DONE, (uint32 *)&val);
+		ret += nm_read_reg_with_ret(dev, SPI_FLASH_TR_DONE, (uint32 *)&val);
 		if(M2M_SUCCESS != ret) break;
 	}
 	while(val != 1);
@@ -327,21 +327,21 @@ static sint8 spi_flash_write_enable(void)
 *	@author		M. Abdelmawla
 *	@version	1.0
 */
-static sint8 spi_flash_write_disable(void)
+static sint8 spi_flash_write_disable(winc1500_t *dev)
 {
 	uint8 cmd[1];
 	uint32	val	= 0;
 	sint8	ret = M2M_SUCCESS;
 	cmd[0] = 0x04;
 
-	ret += nm_write_reg(SPI_FLASH_DATA_CNT, 0);
-	ret += nm_write_reg(SPI_FLASH_BUF1, cmd[0]);
-	ret += nm_write_reg(SPI_FLASH_BUF_DIR, 0x01);
-	ret += nm_write_reg(SPI_FLASH_DMA_ADDR, 0);
-	ret += nm_write_reg(SPI_FLASH_CMD_CNT, 1 | (1<<7));
+	ret += nm_write_reg(dev, SPI_FLASH_DATA_CNT, 0);
+	ret += nm_write_reg(dev, SPI_FLASH_BUF1, cmd[0]);
+	ret += nm_write_reg(dev, SPI_FLASH_BUF_DIR, 0x01);
+	ret += nm_write_reg(dev, SPI_FLASH_DMA_ADDR, 0);
+	ret += nm_write_reg(dev, SPI_FLASH_CMD_CNT, 1 | (1<<7));
 	do
 	{
-		ret += nm_read_reg_with_ret(SPI_FLASH_TR_DONE, (uint32 *)&val);
+		ret += nm_read_reg_with_ret(dev, SPI_FLASH_TR_DONE, (uint32 *)&val);
 		if(M2M_SUCCESS != ret) break;
 	}
 	while(val != 1);
@@ -362,7 +362,7 @@ static sint8 spi_flash_write_disable(void)
 *	@author		M. Abdelmawla
 *	@version	1.0
 */ 
-static sint8 spi_flash_page_program(uint32 u32MemAdr, uint32 u32FlashAdr, uint32 u32Sz)
+static sint8 spi_flash_page_program(winc1500_t *dev, uint32 u32MemAdr, uint32 u32FlashAdr, uint32 u32Sz)
 {
 	uint8 cmd[4];
 	uint32	val	= 0;
@@ -373,14 +373,14 @@ static sint8 spi_flash_page_program(uint32 u32MemAdr, uint32 u32FlashAdr, uint32
 	cmd[2] = (uint8)(u32FlashAdr >> 8);
 	cmd[3] = (uint8)(u32FlashAdr);
 
-	ret += nm_write_reg(SPI_FLASH_DATA_CNT, 0);
-	ret += nm_write_reg(SPI_FLASH_BUF1, cmd[0]|(cmd[1]<<8)|(cmd[2]<<16)|(cmd[3]<<24));
-	ret += nm_write_reg(SPI_FLASH_BUF_DIR, 0x0f);
-	ret += nm_write_reg(SPI_FLASH_DMA_ADDR, u32MemAdr);
-	ret += nm_write_reg(SPI_FLASH_CMD_CNT, 4 | (1<<7) | ((u32Sz & 0xfffff) << 8));
+	ret += nm_write_reg(dev, SPI_FLASH_DATA_CNT, 0);
+	ret += nm_write_reg(dev, SPI_FLASH_BUF1, cmd[0]|(cmd[1]<<8)|(cmd[2]<<16)|(cmd[3]<<24));
+	ret += nm_write_reg(dev, SPI_FLASH_BUF_DIR, 0x0f);
+	ret += nm_write_reg(dev, SPI_FLASH_DMA_ADDR, u32MemAdr);
+	ret += nm_write_reg(dev, SPI_FLASH_CMD_CNT, 4 | (1<<7) | ((u32Sz & 0xfffff) << 8));
 	do
 	{
-		ret += nm_read_reg_with_ret(SPI_FLASH_TR_DONE, (uint32 *)&val);
+		ret += nm_read_reg_with_ret(dev, SPI_FLASH_TR_DONE, (uint32 *)&val);
 		if(M2M_SUCCESS != ret) break;
 	}
 	while(val != 1);
@@ -401,13 +401,13 @@ static sint8 spi_flash_page_program(uint32 u32MemAdr, uint32 u32FlashAdr, uint32
 *	@author		M. Abdelmawla
 *	@version	1.0
 */ 
-static sint8 spi_flash_read_internal(uint8 *pu8Buf, uint32 u32Addr, uint32 u32Sz)
+static sint8 spi_flash_read_internal(winc1500_t *dev, uint8 *pu8Buf, uint32 u32Addr, uint32 u32Sz)
 {
 	sint8 ret = M2M_SUCCESS;
 	/* read size must be < 64KB */
-	ret = spi_flash_load_to_cortus_mem(HOST_SHARE_MEM_BASE, u32Addr, u32Sz);
+	ret = spi_flash_load_to_cortus_mem(dev, HOST_SHARE_MEM_BASE, u32Addr, u32Sz);
 	if(M2M_SUCCESS != ret) goto ERR;
-	ret = nm_read_block(HOST_SHARE_MEM_BASE, pu8Buf, u32Sz);
+	ret = nm_read_block(dev, HOST_SHARE_MEM_BASE, pu8Buf, u32Sz);
 ERR:
 	return ret;
 } 
@@ -425,21 +425,21 @@ ERR:
 *	@author		M. Abdelmawla
 *	@version	1.0
 */
-static sint8 spi_flash_pp(uint32 u32Offset, uint8 *pu8Buf, uint16 u16Sz)
+static sint8 spi_flash_pp(winc1500_t *dev, uint32 u32Offset, uint8 *pu8Buf, uint16 u16Sz)
 {
 	sint8 ret = M2M_SUCCESS;
 	uint8 tmp;
-	spi_flash_write_enable();
+	spi_flash_write_enable(dev);
 	/* use shared packet memory as temp mem */
-	ret += nm_write_block(HOST_SHARE_MEM_BASE, pu8Buf, u16Sz);
-	ret += spi_flash_page_program(HOST_SHARE_MEM_BASE, u32Offset, u16Sz);
-	ret += spi_flash_read_status_reg(&tmp);
+	ret += nm_write_block(dev, HOST_SHARE_MEM_BASE, pu8Buf, u16Sz);
+	ret += spi_flash_page_program(dev, HOST_SHARE_MEM_BASE, u32Offset, u16Sz);
+	ret += spi_flash_read_status_reg(dev, &tmp);
 	do
 	{
 		if(ret != M2M_SUCCESS) goto ERR;
-		ret += spi_flash_read_status_reg(&tmp);
+		ret += spi_flash_read_status_reg(dev, &tmp);
 	}while(tmp & 0x01);
-	ret += spi_flash_write_disable();
+	ret += spi_flash_write_disable(dev);
 ERR:
 	return ret;
 }
@@ -451,7 +451,7 @@ ERR:
 *	@author		M.S.M
 *	@version	1.0
 */
-static uint32 spi_flash_rdid(void)
+static uint32 spi_flash_rdid(winc1500_t *dev)
 {
 	unsigned char cmd[1];
 	uint32 reg = 0;
@@ -460,14 +460,14 @@ static uint32 spi_flash_rdid(void)
 
 	cmd[0] = 0x9f;
 
-	ret += nm_write_reg(SPI_FLASH_DATA_CNT, 4);
-	ret += nm_write_reg(SPI_FLASH_BUF1, cmd[0]);
-	ret += nm_write_reg(SPI_FLASH_BUF_DIR, 0x1);
-	ret += nm_write_reg(SPI_FLASH_DMA_ADDR, DUMMY_REGISTER);
-	ret += nm_write_reg(SPI_FLASH_CMD_CNT, 1 | (1<<7));
+	ret += nm_write_reg(dev, SPI_FLASH_DATA_CNT, 4);
+	ret += nm_write_reg(dev, SPI_FLASH_BUF1, cmd[0]);
+	ret += nm_write_reg(dev, SPI_FLASH_BUF_DIR, 0x1);
+	ret += nm_write_reg(dev, SPI_FLASH_DMA_ADDR, DUMMY_REGISTER);
+	ret += nm_write_reg(dev, SPI_FLASH_CMD_CNT, 1 | (1<<7));
 	do
 	{
-		ret += nm_read_reg_with_ret(SPI_FLASH_TR_DONE, (uint32 *)&reg);
+		ret += nm_read_reg_with_ret(dev, SPI_FLASH_TR_DONE, (uint32 *)&reg);
 		if(M2M_SUCCESS != ret) break;
 		if(++cnt > 500)
 		{
@@ -476,7 +476,7 @@ static uint32 spi_flash_rdid(void)
 		}
 	}
 	while(reg != 1);
-	reg = (M2M_SUCCESS == ret)?(nm_read_reg(DUMMY_REGISTER)):(0);
+	reg = (M2M_SUCCESS == ret)?(nm_read_reg(dev, DUMMY_REGISTER)):(0);
 	M2M_PRINT("Flash ID %x \n",(unsigned int)reg);
 	return reg;
 }
@@ -500,33 +500,33 @@ static void spi_flash_unlock(void)
 	}
 }
 #endif
-static void spi_flash_enter_low_power_mode(void) {
+static void spi_flash_enter_low_power_mode(winc1500_t *dev) {
 	volatile unsigned long tmp;
 	unsigned char* cmd = (unsigned char*) &tmp;
 
 	cmd[0] = 0xb9;
 
-	nm_write_reg(SPI_FLASH_DATA_CNT, 0);
-	nm_write_reg(SPI_FLASH_BUF1, cmd[0]);
-	nm_write_reg(SPI_FLASH_BUF_DIR, 0x1);
-	nm_write_reg(SPI_FLASH_DMA_ADDR, 0);
-	nm_write_reg(SPI_FLASH_CMD_CNT, 1 | (1 << 7));
-	while(nm_read_reg(SPI_FLASH_TR_DONE) != 1);
+	nm_write_reg(dev, SPI_FLASH_DATA_CNT, 0);
+	nm_write_reg(dev, SPI_FLASH_BUF1, cmd[0]);
+	nm_write_reg(dev, SPI_FLASH_BUF_DIR, 0x1);
+	nm_write_reg(dev, SPI_FLASH_DMA_ADDR, 0);
+	nm_write_reg(dev, SPI_FLASH_CMD_CNT, 1 | (1 << 7));
+	while(nm_read_reg(dev, SPI_FLASH_TR_DONE) != 1);
 }
 
 
-static void spi_flash_leave_low_power_mode(void) {
+static void spi_flash_leave_low_power_mode(winc1500_t *dev) {
 	volatile unsigned long tmp;
 	unsigned char* cmd = (unsigned char*) &tmp;
 
 	cmd[0] = 0xab;
 
-	nm_write_reg(SPI_FLASH_DATA_CNT, 0);
-	nm_write_reg(SPI_FLASH_BUF1, cmd[0]);
-	nm_write_reg(SPI_FLASH_BUF_DIR, 0x1);
-	nm_write_reg(SPI_FLASH_DMA_ADDR, 0);
-	nm_write_reg(SPI_FLASH_CMD_CNT,  1 | (1 << 7));
-	while(nm_read_reg(SPI_FLASH_TR_DONE) != 1);
+	nm_write_reg(dev, SPI_FLASH_DATA_CNT, 0);
+	nm_write_reg(dev, SPI_FLASH_BUF1, cmd[0]);
+	nm_write_reg(dev, SPI_FLASH_BUF_DIR, 0x1);
+	nm_write_reg(dev, SPI_FLASH_DMA_ADDR, 0);
+	nm_write_reg(dev, SPI_FLASH_CMD_CNT,  1 | (1 << 7));
+	while(nm_read_reg(dev, SPI_FLASH_TR_DONE) != 1);
 }
 /*********************************************/
 /* GLOBAL FUNCTIONS							 */
@@ -537,30 +537,30 @@ static void spi_flash_leave_low_power_mode(void) {
  *	@author	M. Abdelmawla
  *	@version	1.0
  */
-sint8 spi_flash_enable(uint8 enable)
+sint8 spi_flash_enable(winc1500_t *dev, uint8 enable)
 {
 	sint8 s8Ret = M2M_SUCCESS;
-	if(REV(nmi_get_chipid()) >= REV_3A0) {		
+	if(REV(nmi_get_chipid(dev)) >= REV_3A0) {
 		uint32 u32Val;
 		
 		/* Enable pinmux to SPI flash. */
-		s8Ret = nm_read_reg_with_ret(0x1410, &u32Val);
+		s8Ret = nm_read_reg_with_ret(dev, 0x1410, &u32Val);
 		if(s8Ret != M2M_SUCCESS) {
 			goto ERR1;
 		}
 		/* GPIO15/16/17/18 */
 		u32Val &= ~((0x7777ul) << 12);
 		u32Val |= ((0x1111ul) << 12);
-		nm_write_reg(0x1410, u32Val);
+		nm_write_reg(dev, 0x1410, u32Val);
 		if(enable) {
-			spi_flash_leave_low_power_mode();
+			spi_flash_leave_low_power_mode(dev);
 		} else {
-			spi_flash_enter_low_power_mode();
+			spi_flash_enter_low_power_mode(dev);
 		}
 		/* Disable pinmux to SPI flash to minimize leakage. */
 		u32Val &= ~((0x7777ul) << 12);
 		u32Val |= ((0x0010ul) << 12);
-		nm_write_reg(0x1410, u32Val);
+		nm_write_reg(dev, 0x1410, u32Val);
 	}
 ERR1:
 	return s8Ret;
@@ -579,14 +579,14 @@ ERR1:
 *	@author		M. Abdelmawla
 *	@version	1.0
 */ 
-sint8 spi_flash_read(uint8 *pu8Buf, uint32 u32offset, uint32 u32Sz)
+sint8 spi_flash_read(winc1500_t *dev, uint8 *pu8Buf, uint32 u32offset, uint32 u32Sz)
 {
 	sint8 ret = M2M_SUCCESS;
 	if(u32Sz > FLASH_BLOCK_SIZE)
 	{
 		do
 		{
-			ret = spi_flash_read_internal(pu8Buf, u32offset, FLASH_BLOCK_SIZE);
+			ret = spi_flash_read_internal(dev, pu8Buf, u32offset, FLASH_BLOCK_SIZE);
 			if(M2M_SUCCESS != ret) goto ERR;
 			u32Sz -= FLASH_BLOCK_SIZE;
 			u32offset += FLASH_BLOCK_SIZE;
@@ -594,7 +594,7 @@ sint8 spi_flash_read(uint8 *pu8Buf, uint32 u32offset, uint32 u32Sz)
 		} while(u32Sz > FLASH_BLOCK_SIZE);
 	}
 	
-	ret = spi_flash_read_internal(pu8Buf, u32offset, u32Sz);
+	ret = spi_flash_read_internal(dev, pu8Buf, u32offset, u32Sz);
 
 ERR:
 	return ret;
@@ -613,7 +613,7 @@ ERR:
 *	@author		M. Abdelmawla
 *	@version	1.0
 */ 
-sint8 spi_flash_write(uint8* pu8Buf, uint32 u32Offset, uint32 u32Sz)
+sint8 spi_flash_write(winc1500_t *dev, uint8* pu8Buf, uint32 u32Offset, uint32 u32Sz)
 {
 #ifdef PROFILING
 	uint32 t1 = 0;
@@ -641,7 +641,7 @@ sint8 spi_flash_write(uint8* pu8Buf, uint32 u32Offset, uint32 u32Sz)
 	if (u32off)/*first part of data in the address page*/
 	{
 		u32wsz = u32Blksz - u32off;
-		if(spi_flash_pp(u32Offset, pu8Buf, (uint16)BSP_MIN(u32Sz, u32wsz))!=M2M_SUCCESS)
+		if(spi_flash_pp(dev, u32Offset, pu8Buf, (uint16)BSP_MIN(u32Sz, u32wsz))!=M2M_SUCCESS)
 		{
 			ret = M2M_ERR_FAIL;
 			goto ERR;
@@ -656,7 +656,7 @@ sint8 spi_flash_write(uint8* pu8Buf, uint32 u32Offset, uint32 u32Sz)
 		u32wsz = BSP_MIN(u32Sz, u32Blksz);
 
 		/*write complete page or the remaining data*/
-		if(spi_flash_pp(u32Offset, pu8Buf, (uint16)u32wsz)!=M2M_SUCCESS)
+		if(spi_flash_pp(dev, u32Offset, pu8Buf, (uint16)u32wsz)!=M2M_SUCCESS)
 		{
 			ret = M2M_ERR_FAIL;
 			goto ERR;
@@ -690,7 +690,7 @@ ERR:
 *	@author		M. Abdelmawla
 *	@version	1.0
 */ 
-sint8 spi_flash_erase(uint32 u32Offset, uint32 u32Sz)
+sint8 spi_flash_erase(winc1500_t *dev, uint32 u32Offset, uint32 u32Sz)
 {
 	uint32 i = 0;
 	sint8 ret = M2M_SUCCESS;
@@ -702,14 +702,14 @@ sint8 spi_flash_erase(uint32 u32Offset, uint32 u32Sz)
 	M2M_PRINT("\r\n>Start erasing...\r\n");
 	for(i = u32Offset; i < (u32Sz +u32Offset); i += (16*FLASH_PAGE_SZ))
 	{
-		ret += spi_flash_write_enable();
-		ret += spi_flash_read_status_reg(&tmp);
-		ret += spi_flash_sector_erase(i + 10);
-		ret += spi_flash_read_status_reg(&tmp);
+		ret += spi_flash_write_enable(dev);
+		ret += spi_flash_read_status_reg(dev, &tmp);
+		ret += spi_flash_sector_erase(dev, i + 10);
+		ret += spi_flash_read_status_reg(dev, &tmp);
 		do
 		{
 			if(ret != M2M_SUCCESS) goto ERR;
-			ret += spi_flash_read_status_reg(&tmp);
+			ret += spi_flash_read_status_reg(dev, &tmp);
 		}while(tmp & 0x01);
 		
 	}
@@ -728,14 +728,14 @@ ERR:
 *	@author		M.S.M
 *	@version	1.0
 */
-uint32 spi_flash_get_size(void)
+uint32 spi_flash_get_size(winc1500_t *dev)
 {
 	uint32 u32FlashId = 0, u32FlashPwr = 0;
 	static uint32 gu32InernalFlashSize= 0;
 	
 	if(!gu32InernalFlashSize)
 	{
-		u32FlashId = spi_flash_rdid();//spi_flash_probe();
+		u32FlashId = spi_flash_rdid(dev);//spi_flash_probe();
 		if(u32FlashId != 0xffffffff)
 		{
 			/*flash size is the third byte from the FLASH RDID*/
-- 
2.19.1

