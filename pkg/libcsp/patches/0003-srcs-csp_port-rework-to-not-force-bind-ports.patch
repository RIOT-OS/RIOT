From ce06afea65620e79d1764f27735ff8a45f7c889a Mon Sep 17 00:00:00 2001
From: Francisco Molina <femolina@uc.cl>
Date: Fri, 8 Apr 2022 17:35:33 +0200
Subject: [PATCH 3/4] srcs/csp_port: rework to not force bind ports

---
 include/csp/csp_types.h |   2 +
 src/csp_port.c          | 247 ++++++++++++++++++++++++----------------
 src/csp_port.h          |   7 +-
 3 files changed, 160 insertions(+), 96 deletions(-)

diff --git a/include/csp/csp_types.h b/include/csp/csp_types.h
index 94b974a..7aeaf3f 100644
--- a/include/csp/csp_types.h
+++ b/include/csp/csp_types.h
@@ -33,6 +33,8 @@ typedef enum {
 
 /** Listen on all ports, primarily used with csp_bind() */
 #define CSP_ANY				255
+#define CSP_PORT_ANY		CSP_ANY
+#define CSP_PORT_UNSET		0
 
 /**
    Message priority.
diff --git a/src/csp_port.c b/src/csp_port.c
index a8aec59..c7d9720 100644
--- a/src/csp_port.c
+++ b/src/csp_port.c
@@ -6,126 +6,183 @@
 #include <string.h>
 
 #include <csp/csp.h>
+#include <csp/csp_id.h>
 #include <csp/csp_debug.h>
 #include <csp/arch/csp_queue.h>
 #include <csp_autoconfig.h>
 
 #include "csp_conn.h"
+#include "random.h"
 
 typedef enum {
-	PORT_CLOSED = 0,
-	PORT_OPEN = 1,
-	PORT_OPEN_CB = 2,
+    PORT_CLOSED     = 0,
+    PORT_OPEN       = 1,
+    PORT_OPEN_CB    = 2,
 } csp_port_state_t;
 
-typedef struct {
-	csp_port_state_t state;
-	union {
-		csp_socket_t * socket;
-		csp_callback_t callback;
-	};
+typedef struct csp_port {
+    union {
+        csp_socket_t *socket;
+        csp_callback_t callback;
+    };
+    csp_port_state_t state;
+    uint8_t port;
 } csp_port_t;
 
 /* We rely on the .bss section to clear this, so there is no csp_port_init() function */
-static csp_port_t ports[CSP_PORT_MAX_BIND + 2] = {0};
-
-csp_callback_t csp_port_get_callback(unsigned int port) {
-	
-	if (port > CSP_PORT_MAX_BIND) {
-		return NULL;
-	}
-
-	/* Check if port is open callback */
-	if (ports[port].state == PORT_OPEN_CB) {
-		return ports[port].callback;
-	}
-
-	/* If it's open socket, then return no callback */
-	if (ports[port].state == PORT_OPEN) {
-		return NULL;
-	}
-
-	/* Otherwise check if we have a match all callback */
-	if (ports[CSP_PORT_MAX_BIND + 1].state == PORT_OPEN_CB) {
-		return ports[CSP_PORT_MAX_BIND + 1].callback;
-	}
-
-	return NULL;
+static csp_port_t ports[CSP_PORT_MAX_BIND] = { 0 };
+
+bool csp_port_in_use(unsigned int port)
+{
+    for (uint8_t i = 0; i < CSP_PORT_MAX_BIND; i++) {
+        if (ports[i].port == port) {
+            return true;
+        }
+    }
+    return false;
 }
 
-csp_socket_t * csp_port_get_socket(unsigned int port) {
-
-	if (port > CSP_PORT_MAX_BIND) {
-		return NULL;
-	}
-
-	if (ports[port].state == PORT_OPEN) {
-		return ports[port].socket;
-	}
-
-	if (ports[port].state == PORT_OPEN_CB) {
-		return NULL;
-	}
-
-	if (ports[CSP_PORT_MAX_BIND + 1].state == PORT_OPEN) {
-		return ports[CSP_PORT_MAX_BIND + 1].socket;
-	}
-
-	return NULL;
+uint8_t csp_port_get_dyn_free(void)
+{
+    unsigned num = (csp_id_get_max_port() - 1);
+    unsigned count = num;
+
+    do {
+        uint8_t port = 1 + (random_uint32() % num);
+        if (!csp_port_in_use(port)) {
+            return port;
+        }
+        --count;
+    } while (count > 0);
+    return CSP_PORT_UNSET;
 }
 
-int csp_listen(csp_socket_t * socket, size_t backlog) {
-	socket->rx_queue = csp_queue_create_static(CSP_CONN_RXQUEUE_LEN, sizeof(csp_packet_t *), socket->rx_queue_static_data, &socket->rx_queue_static);
-	return CSP_ERR_NONE;
+uint8_t csp_port_get_dyn(void)
+{
+    return 1 + (random_uint32() % (csp_id_get_max_port() - 1));
 }
 
-int csp_bind(csp_socket_t * socket, uint8_t port) {
-
-	if (socket == NULL)
-		return CSP_ERR_INVAL;
-
-	if (port == CSP_ANY) {
-		port = CSP_PORT_MAX_BIND + 1;
-	} else if (port > CSP_PORT_MAX_BIND) {
-		csp_dbg_errno = CSP_DBG_ERR_INVALID_BIND_PORT;
-		return CSP_ERR_INVAL;
-	}
-
-	if (ports[port].state != PORT_CLOSED) {
-		csp_dbg_errno = CSP_DBG_ERR_PORT_ALREADY_IN_USE;
-		return CSP_ERR_USED;
-	}
+csp_port_t *csp_port_get(unsigned int port)
+{
+    if (port > csp_id_get_max_port() && port != CSP_PORT_ANY) {
+        return NULL;
+    }
+    for (uint8_t i = 0; i < CSP_PORT_MAX_BIND; i++) {
+        /* match for port or CSP_PORT_ANY */
+        if (ports[i].port == port || ports[i].port == CSP_PORT_ANY) {
+            if (ports[i].state != PORT_CLOSED) {
+                return &ports[i];
+            }
+            return NULL;
+        }
+    }
+    return NULL;
+}
 
-	/* Save listener */
-	ports[port].socket = socket;
-	ports[port].state = PORT_OPEN;
+csp_callback_t csp_port_get_callback(unsigned int port)
+{
+    csp_port_t *port_ptr = csp_port_get(port);
 
-	return CSP_ERR_NONE;
+    if (port_ptr) {
+        return (port_ptr->state == PORT_OPEN_CB) ? port_ptr->callback : NULL;
+    }
+    return NULL;
 }
 
-int csp_bind_callback(csp_callback_t callback, uint8_t port) {
+csp_socket_t *csp_port_get_socket(unsigned int port)
+{
+    csp_port_t *port_ptr = csp_port_get(port);
 
-	if (callback == NULL) {
-		csp_dbg_errno = CSP_DBG_ERR_INVALID_POINTER;
-		return CSP_DBG_ERR_INVALID_POINTER;
-	}
-
-	if (port == CSP_ANY) {
-		port = CSP_PORT_MAX_BIND + 1;
-	} else if (port > CSP_PORT_MAX_BIND) {
-		csp_dbg_errno = CSP_DBG_ERR_INVALID_BIND_PORT;
-		return CSP_DBG_ERR_INVALID_BIND_PORT;
-	}
+    if (port_ptr) {
+        return (port_ptr->state == PORT_OPEN) ? port_ptr->socket : NULL;
+    }
+    return NULL;
+}
 
-	if (ports[port].state != PORT_CLOSED) {
-		csp_dbg_errno = CSP_DBG_ERR_PORT_ALREADY_IN_USE;
-		return CSP_DBG_ERR_PORT_ALREADY_IN_USE;
-	}
+int csp_listen(csp_socket_t *socket, size_t backlog)
+{
+    socket->rx_queue = csp_queue_create_static(CSP_CONN_RXQUEUE_LEN, sizeof(csp_packet_t *),
+                                               socket->rx_queue_static_data,
+                                               &socket->rx_queue_static);
+    return CSP_ERR_NONE;
+}
 
-	/* Save listener */
-	ports[port].callback = callback;
-	ports[port].state = PORT_OPEN_CB;
+int csp_bind(csp_socket_t *socket, uint8_t port)
+{
+    if (socket == NULL) {
+        csp_dbg_errno = CSP_DBG_ERR_INVALID_POINTER;
+        return CSP_ERR_INVAL;
+    }
+
+    if (csp_port_in_use(port)) {
+        csp_dbg_errno = CSP_DBG_ERR_PORT_ALREADY_IN_USE;
+        return CSP_ERR_USED;
+    }
+
+    if (port > csp_id_get_max_port() && port != CSP_PORT_ANY) {
+        return CSP_ERR_INVAL;
+    }
+
+    for (uint8_t i = 0; i < CSP_PORT_MAX_BIND; i++) {
+        if (ports[i].state == PORT_CLOSED) {
+            ports[i].socket = socket;
+            ports[i].state = PORT_OPEN;
+            ports[i].port = port;
+            return CSP_ERR_NONE;
+        }
+    }
+    return CSP_ERR_NOMEM;
+}
 
-	return 0;
+int csp_bind_callback(csp_callback_t callback, uint8_t port)
+{
+    if (callback == NULL) {
+        csp_dbg_errno = CSP_DBG_ERR_INVALID_POINTER;
+        return CSP_ERR_INVAL;
+    }
+
+    if (csp_port_in_use(port)) {
+        csp_dbg_errno = CSP_DBG_ERR_PORT_ALREADY_IN_USE;
+        return CSP_ERR_USED;
+    }
+
+    if (port > csp_id_get_max_port() && port != CSP_PORT_ANY) {
+        return CSP_ERR_INVAL;
+    }
+
+    for (uint8_t i = 0; i < CSP_PORT_MAX_BIND; i++) {
+        if (ports[i].state == PORT_CLOSED) {
+            ports[i].callback = callback;
+            ports[i].state = PORT_OPEN_CB;
+            ports[i].port = port;
+            return CSP_ERR_NONE;
+        }
+    }
+    return CSP_ERR_NOMEM;
+}
 
+int csp_unbind_port(unsigned int port)
+{
+    if (port > csp_id_get_max_port() && port != CSP_PORT_ANY) {
+        return CSP_ERR_INVAL;
+    }
+
+    csp_port_t *port_ptr = csp_port_get(port);
+
+    if (port_ptr) {
+        if (port_ptr->state == PORT_OPEN) {
+            if (port_ptr->socket->rx_queue) {
+                csp_packet_t *packet;
+                while (csp_queue_dequeue(port_ptr->socket->rx_queue, &packet, 0) == CSP_QUEUE_OK) {
+                    if (packet != NULL) {
+                        csp_buffer_free(packet);
+                    }
+                }
+            }
+        }
+        port_ptr->state = PORT_CLOSED;
+        port_ptr->socket = NULL;
+        port_ptr->port = CSP_PORT_UNSET;
+    }
+    return CSP_ERR_NONE;
 }
diff --git a/src/csp_port.h b/src/csp_port.h
index 951e538..7cbe56a 100644
--- a/src/csp_port.h
+++ b/src/csp_port.h
@@ -5,4 +5,9 @@
 #include <csp/csp_types.h>
 
 csp_socket_t * csp_port_get_socket(unsigned int dport);
-csp_callback_t csp_port_get_callback(unsigned int port);
\ No newline at end of file
+csp_callback_t csp_port_get_callback(unsigned int port);
+
+int csp_unbind_port(unsigned int port);
+bool csp_port_in_use(unsigned int port);
+uint8_t csp_port_get_dyn(void);
+uint8_t csp_port_get_dyn_free(void);
-- 
2.32.0

