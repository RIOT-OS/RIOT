diff -crB stock/openwsn/02a-MAClow/IEEE802154.c dev/openwsn/02a-MAClow/IEEE802154.c
*** stock/openwsn/02a-MAClow/IEEE802154.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/02a-MAClow/IEEE802154.c	Wed Jan 29 10:33:22 2014
***************
*** 16,35 ****
  
  Note that we are writing the field from the end of the header to the beginning.
  
! \param msg             [in,out] The message to append the header to.
! \param frameType       [in]     Type of IEEE802.15.4 frame.
! \param securityEnabled [in]     Is security enabled on this frame?
! \param nextHop         [in]     Address of the next hop
  */
  void ieee802154_prependHeader(OpenQueueEntry_t* msg,
                                uint8_t           frameType,
                                bool              securityEnabled,
                                uint8_t           sequenceNumber,
                                open_addr_t*      nextHop) {
     uint8_t temp_8b;
     
     // previousHop address (always 64-bit)
!    packetfunctions_writeAddress(msg,idmanager_getMyID(ADDR_64B),LITTLE_ENDIAN);
     // nextHop address
     if (packetfunctions_isBroadcastMulticast(nextHop)) {
        //broadcast address is always 16-bit
--- 16,42 ----
  
  Note that we are writing the field from the end of the header to the beginning.
  
! \param[in,out] msg              The message to append the header to.
! \param[in]     frameType        Type of IEEE802.15.4 frame.
! \param[in]     ielistpresent    Is the IE list present¿
! \param[in]     frameVersion     IEEE802.15.4 frame version.
! \param[in]     securityEnabled  Is security enabled on this frame?
! \param[in]     sequenceNumber   Sequence number of this frame.
! \param[in]     nextHop          Address of the next hop
  */
  void ieee802154_prependHeader(OpenQueueEntry_t* msg,
                                uint8_t           frameType,
+                               uint8_t           ielistpresent,
+                               uint8_t           frameversion,
                                bool              securityEnabled,
                                uint8_t           sequenceNumber,
                                open_addr_t*      nextHop) {
     uint8_t temp_8b;
     
+    //General IEs here (those that are carried in all packets) -- None by now.
+    
     // previousHop address (always 64-bit)
!    packetfunctions_writeAddress(msg,idmanager_getMyID(ADDR_64B),OW_LITTLE_ENDIAN);
     // nextHop address
     if (packetfunctions_isBroadcastMulticast(nextHop)) {
        //broadcast address is always 16-bit
***************
*** 41,47 ****
        switch (nextHop->type) {
           case ADDR_16B:
           case ADDR_64B:
!             packetfunctions_writeAddress(msg,nextHop,LITTLE_ENDIAN);
              break;
           default:
              openserial_printCritical(COMPONENT_IEEE802154,ERR_WRONG_ADDR_TYPE,
--- 48,54 ----
        switch (nextHop->type) {
           case ADDR_16B:
           case ADDR_64B:
!             packetfunctions_writeAddress(msg,nextHop,OW_LITTLE_ENDIAN);
              break;
           default:
              openserial_printCritical(COMPONENT_IEEE802154,ERR_WRONG_ADDR_TYPE,
***************
*** 51,57 ****
        
     }
     // destpan
!    packetfunctions_writeAddress(msg,idmanager_getMyID(ADDR_PANID),LITTLE_ENDIAN);
     //dsn
     packetfunctions_reserveHeaderSize(msg,sizeof(uint8_t));
     *((uint8_t*)(msg->payload)) = sequenceNumber;
--- 58,64 ----
        
     }
     // destpan
!    packetfunctions_writeAddress(msg,idmanager_getMyID(ADDR_PANID),OW_LITTLE_ENDIAN);
     //dsn
     packetfunctions_reserveHeaderSize(msg,sizeof(uint8_t));
     *((uint8_t*)(msg->payload)) = sequenceNumber;
***************
*** 72,77 ****
--- 79,88 ----
        }
     }
     temp_8b             |= IEEE154_ADDR_EXT                << IEEE154_FCF_SRC_ADDR_MODE;
+    //poipoi xv IE list present
+    temp_8b             |= ielistpresent                   << IEEE154_FCF_IELIST_PRESENT;
+    temp_8b             |= frameversion                    << IEEE154_FCF_FRAME_VERSION;
+      
     *((uint8_t*)(msg->payload)) = temp_8b;
     //fcf (1st byte)
     packetfunctions_reserveHeaderSize(msg,sizeof(uint8_t));
***************
*** 93,100 ****
  
  Note We are writing the fields from the begnning of the header to the end.
  
! \param msg               [in,out] The message just received.
! \param ieee802514_header [out]    The internal header to write the data to.
  */
  void ieee802154_retrieveHeader(OpenQueueEntry_t*      msg,
                                 ieee802154_header_iht* ieee802514_header) {
--- 104,111 ----
  
  Note We are writing the fields from the begnning of the header to the end.
  
! \param[in,out] msg            The message just received.
! \param[out] ieee802514_header The internal header to write the data to.
  */
  void ieee802154_retrieveHeader(OpenQueueEntry_t*      msg,
                                 ieee802154_header_iht* ieee802514_header) {
***************
*** 117,122 ****
--- 128,141 ----
     // fcf, byte 2
     if (ieee802514_header->headerLength>msg->length) { return; } // no more to read!
     temp_8b = *((uint8_t*)(msg->payload)+ieee802514_header->headerLength);
+    //poipoi xv IE list present
+    ieee802514_header->ieListPresent  = (temp_8b >> IEEE154_FCF_IELIST_PRESENT     ) & 0x01;//1b
+    ieee802514_header->frameVersion   = (temp_8b >> IEEE154_FCF_FRAME_VERSION      ) & 0x03;//2b
+ 
+    if (ieee802514_header->ieListPresent==TRUE && ieee802514_header->frameVersion!=IEEE154_FRAMEVERSION){
+        return; //invalid packet accordint to p.64 IEEE15.4e
+    }
+    
     switch ( (temp_8b >> IEEE154_FCF_DEST_ADDR_MODE ) & 0x03 ) {
        case IEEE154_ADDR_NONE:
           ieee802514_header->dest.type = ADDR_NONE;
***************
*** 159,165 ****
     packetfunctions_readAddress(((uint8_t*)(msg->payload)+ieee802514_header->headerLength),
                                 ADDR_PANID,
                                 &ieee802514_header->panid,
!                                LITTLE_ENDIAN);
     ieee802514_header->headerLength += 2;
     // dest
     if (ieee802514_header->headerLength>msg->length) { return; } // no more to read!
--- 178,184 ----
     packetfunctions_readAddress(((uint8_t*)(msg->payload)+ieee802514_header->headerLength),
                                 ADDR_PANID,
                                 &ieee802514_header->panid,
!                                OW_LITTLE_ENDIAN);
     ieee802514_header->headerLength += 2;
     // dest
     if (ieee802514_header->headerLength>msg->length) { return; } // no more to read!
***************
*** 171,177 ****
               ((uint8_t*)(msg->payload)+ieee802514_header->headerLength),
               ADDR_16B,
               &ieee802514_header->dest,
!              LITTLE_ENDIAN
           );
           ieee802514_header->headerLength += 2;
           if (ieee802514_header->headerLength>msg->length) {  return; } // no more to read!
--- 190,196 ----
               ((uint8_t*)(msg->payload)+ieee802514_header->headerLength),
               ADDR_16B,
               &ieee802514_header->dest,
!              OW_LITTLE_ENDIAN
           );
           ieee802514_header->headerLength += 2;
           if (ieee802514_header->headerLength>msg->length) {  return; } // no more to read!
***************
*** 180,186 ****
           packetfunctions_readAddress(((uint8_t*)(msg->payload)+ieee802514_header->headerLength),
                                       ADDR_64B,
                                       &ieee802514_header->dest,
!                                      LITTLE_ENDIAN);
           ieee802514_header->headerLength += 8;
           if (ieee802514_header->headerLength>msg->length) {  return; } // no more to read!
           break;
--- 199,205 ----
           packetfunctions_readAddress(((uint8_t*)(msg->payload)+ieee802514_header->headerLength),
                                       ADDR_64B,
                                       &ieee802514_header->dest,
!                                      OW_LITTLE_ENDIAN);
           ieee802514_header->headerLength += 8;
           if (ieee802514_header->headerLength>msg->length) {  return; } // no more to read!
           break;
***************
*** 194,200 ****
           packetfunctions_readAddress(((uint8_t*)(msg->payload)+ieee802514_header->headerLength),
                                       ADDR_16B,
                                       &ieee802514_header->src,
!                                      LITTLE_ENDIAN);
           ieee802514_header->headerLength += 2;
           if (ieee802514_header->headerLength>msg->length) {  return; } // no more to read!
           break;
--- 213,219 ----
           packetfunctions_readAddress(((uint8_t*)(msg->payload)+ieee802514_header->headerLength),
                                       ADDR_16B,
                                       &ieee802514_header->src,
!                                      OW_LITTLE_ENDIAN);
           ieee802514_header->headerLength += 2;
           if (ieee802514_header->headerLength>msg->length) {  return; } // no more to read!
           break;
***************
*** 202,213 ****
           packetfunctions_readAddress(((uint8_t*)(msg->payload)+ieee802514_header->headerLength),
                                       ADDR_64B,
                                       &ieee802514_header->src,
!                                      LITTLE_ENDIAN);
           ieee802514_header->headerLength += 8;
           if (ieee802514_header->headerLength>msg->length) {  return; } // no more to read!
           break;
        // no need for a default, since case would have been caught above
     }
     // apply topology filter
     if (topology_isAcceptablePacket(ieee802514_header)==FALSE) {
        // the topology filter does accept this packet, return
--- 221,237 ----
           packetfunctions_readAddress(((uint8_t*)(msg->payload)+ieee802514_header->headerLength),
                                       ADDR_64B,
                                       &ieee802514_header->src,
!                                      OW_LITTLE_ENDIAN);
           ieee802514_header->headerLength += 8;
           if (ieee802514_header->headerLength>msg->length) {  return; } // no more to read!
           break;
        // no need for a default, since case would have been caught above
     }
+    
+    if (ieee802514_header->ieListPresent==TRUE && ieee802514_header->frameVersion!=IEEE154_FRAMEVERSION){
+        return; //invalid packet accordint to p.64 IEEE15.4e
+    }
+    
     // apply topology filter
     if (topology_isAcceptablePacket(ieee802514_header)==FALSE) {
        // the topology filter does accept this packet, return
diff -crB stock/openwsn/02a-MAClow/IEEE802154.h dev/openwsn/02a-MAClow/IEEE802154.h
*** stock/openwsn/02a-MAClow/IEEE802154.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/02a-MAClow/IEEE802154.h	Wed Jan 29 10:33:22 2014
***************
*** 2,8 ****
  #define __IEEE802154_H
  
  /**
! \addtogroup helpers
  \{
  \addtogroup IEEE802154
  \{
--- 2,8 ----
  #define __IEEE802154_H
  
  /**
! \addtogroup MAClow
  \{
  \addtogroup IEEE802154
  \{
***************
*** 18,27 ****
--- 18,36 ----
     IEEE154_FCF_FRAME_PENDING           = 4,
     IEEE154_FCF_ACK_REQ                 = 5,
     IEEE154_FCF_INTRAPAN                = 6,
+    IEEE154_FCF_IELIST_PRESENT          = 1,
     IEEE154_FCF_DEST_ADDR_MODE          = 2,
+    IEEE154_FCF_FRAME_VERSION           = 4,
     IEEE154_FCF_SRC_ADDR_MODE           = 6,
  };
  
+ 
+ enum IEEE802154_fcf_frameversion_enums {
+    IEEE154_FRAMEVERSION_2003           = 0, //ieee154-2003
+    IEEE154_FRAMEVERSION_2006           = 1, //ieee154-2006
+    IEEE154_FRAMEVERSION                = 2, //ieee154
+ };
+ 
  enum IEEE802154_fcf_type_enums {
     IEEE154_TYPE_BEACON                 = 0,
     IEEE154_TYPE_DATA                   = 1,
***************
*** 35,40 ****
--- 44,54 ----
     IEEE154_SEC_YES_SECURITY            = 1,
  };
  
+ enum IEEE802154_fcf_ielist_enums {
+    IEEE154_IELIST_NO                   = 0,
+    IEEE154_IELIST_YES                  = 1,
+ };
+ 
  enum IEEE802154_fcf_pending_enums {
     IEEE154_PENDING_NO_FRAMEPENDING     = 0,
     IEEE154_PENDING_YES_FRAMEPENDING    = 1,
***************
*** 66,71 ****
--- 80,87 ----
     bool        framePending;
     bool        ackRequested;
     bool        panIDCompression;
+    bool        ieListPresent;
+    uint8_t     frameVersion;
     uint8_t     dsn;
     open_addr_t panid;
     open_addr_t dest;
***************
*** 78,88 ****
  
  //=========================== prototypes ======================================
  
! void ieee802154_prependHeader  (OpenQueueEntry_t*      msg,
!                                 uint8_t                frameType,
!                                 bool                   securityEnabled,
!                                 uint8_t                sequenceNumber,
!                                 open_addr_t*           nextHop);
  void ieee802154_retrieveHeader (OpenQueueEntry_t*      msg,
                                  ieee802154_header_iht* ieee802514_header);
  
--- 94,107 ----
  
  //=========================== prototypes ======================================
  
! void ieee802154_prependHeader(OpenQueueEntry_t* msg,
!                               uint8_t           frameType,
!                               uint8_t           ielistpresent,
!                               uint8_t           frameversion,
!                               bool              securityEnabled,
!                               uint8_t           sequenceNumber,
!                               open_addr_t*      nextHop);
! 
  void ieee802154_retrieveHeader (OpenQueueEntry_t*      msg,
                                  ieee802154_header_iht* ieee802514_header);
  
diff -crB stock/openwsn/02a-MAClow/IEEE802154E.c dev/openwsn/02a-MAClow/IEEE802154E.c
*** stock/openwsn/02a-MAClow/IEEE802154E.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/02a-MAClow/IEEE802154E.c	Wed Jan 29 11:54:39 2014
***************
*** 14,126 ****
  #include "debugpins.h"
  #include "res.h"
  
  //=========================== variables =======================================
  
! typedef struct {
!    // misc
!    asn_t              asn;                  // current absolute slot number
!    slotOffset_t       slotOffset;           // current slot offset
!    slotOffset_t       nextActiveSlotOffset; // next active slot offset
!    PORT_TIMER_WIDTH   deSyncTimeout;        // how many slots left before looses sync
!    bool               isSync;               // TRUE iff mote is synchronized to network
!    // as shown on the chronogram
!    ieee154e_state_t   state;                // state of the FSM
!    OpenQueueEntry_t*  dataToSend;           // pointer to the data to send
!    OpenQueueEntry_t*  dataReceived;         // pointer to the data received
!    OpenQueueEntry_t*  ackToSend;            // pointer to the ack to send
!    OpenQueueEntry_t*  ackReceived;          // pointer to the ack received
!    PORT_TIMER_WIDTH   lastCapturedTime;     // last captured time
!    PORT_TIMER_WIDTH   syncCapturedTime;     // captured time used to sync
!    //channel hopping
!    uint8_t            freq;                 // frequency of the current slot
!    uint8_t            asnOffset;            // offset inside the frame
! } ieee154e_vars_t;
! 
! ieee154e_vars_t ieee154e_vars;
! 
! typedef struct {
!    PORT_TIMER_WIDTH          num_newSlot;
!    PORT_TIMER_WIDTH          num_timer;
!    PORT_TIMER_WIDTH          num_startOfFrame;
!    PORT_TIMER_WIDTH          num_endOfFrame;
! } ieee154e_dbg_t;
! 
! ieee154e_dbg_t ieee154e_dbg;
! 
! PRAGMA(pack(1));
! typedef struct {
!    uint8_t                   numSyncPkt;    // how many times synchronized on a non-ACK packet
!    uint8_t                   numSyncAck;    // how many times synchronized on an ACK
!    PORT_SIGNED_INT_WIDTH     minCorrection; // minimum time correction
!    PORT_SIGNED_INT_WIDTH     maxCorrection; // maximum time correction
!    uint8_t                   numDeSync;     // number of times a desync happened
! } ieee154e_stats_t;
! PRAGMA(pack());
  
! ieee154e_stats_t ieee154e_stats;
  
  //=========================== prototypes ======================================
! 
  // SYNCHRONIZING
! void     activity_synchronize_newSlot();
! void     activity_synchronize_startOfFrame(PORT_TIMER_WIDTH capturedTime);
! void     activity_synchronize_endOfFrame(PORT_TIMER_WIDTH capturedTime);
  // TX
! void     activity_ti1ORri1();
! void     activity_ti2();
! void     activity_tie1();
! void     activity_ti3();
! void     activity_tie2();
! void     activity_ti4(PORT_TIMER_WIDTH capturedTime);
! void     activity_tie3();
! void     activity_ti5(PORT_TIMER_WIDTH capturedTime);
! void     activity_ti6();
! void     activity_tie4();
! void     activity_ti7();
! void     activity_tie5();
! void     activity_ti8(PORT_TIMER_WIDTH capturedTime);
! void     activity_tie6();
! void     activity_ti9(PORT_TIMER_WIDTH capturedTime);
  // RX
! void     activity_ri2();
! void     activity_rie1();
! void     activity_ri3();
! void     activity_rie2();
! void     activity_ri4(PORT_TIMER_WIDTH capturedTime);
! void     activity_rie3();
! void     activity_ri5(PORT_TIMER_WIDTH capturedTime);
! void     activity_ri6();
! void     activity_rie4();
! void     activity_ri7();
! void     activity_rie5();
! void     activity_ri8(PORT_TIMER_WIDTH capturedTime);
! void     activity_rie6();
! void     activity_ri9(PORT_TIMER_WIDTH capturedTime);
  // frame validity check
! bool     isValidAdv(ieee802154_header_iht*     ieee802514_header);
  bool     isValidRxFrame(ieee802154_header_iht* ieee802514_header);
  bool     isValidAck(ieee802154_header_iht*     ieee802514_header,
                      OpenQueueEntry_t*          packetSent);
  // ASN handling
! void     incrementAsnOffset();
! void     asnWriteToAdv(OpenQueueEntry_t* advFrame);
! void     asnStoreFromAdv(OpenQueueEntry_t* advFrame);
  // synchronization
! void     synchronizePacket(PORT_TIMER_WIDTH timeReceived);
  void     synchronizeAck(PORT_SIGNED_INT_WIDTH timeCorrection);
  void     changeIsSync(bool newIsSync);
  // notifying upper layer
! void     notif_sendDone(OpenQueueEntry_t* packetSent, error_t error);
  void     notif_receive(OpenQueueEntry_t* packetReceived);
  // statistics
! void     resetStats();
  void     updateStats(PORT_SIGNED_INT_WIDTH timeCorrection);
  // misc
  uint8_t  calculateFrequency(uint8_t channelOffset);
  void     changeState(ieee154e_state_t newstate);
! void     endSlot();
! bool     debugPrint_asn();
! bool     debugPrint_isSync();
  
  //=========================== admin ===========================================
  
--- 14,99 ----
  #include "debugpins.h"
  #include "res.h"
  
+ #include "thread.h"
+ 
+ #define ENABLE_DEBUG (0)
+ #include "debug.h"
+ 
  //=========================== variables =======================================
  
! ieee154e_vars_t    ieee154e_vars;
! ieee154e_stats_t   ieee154e_stats;
! ieee154e_dbg_t     ieee154e_dbg;
  
! //static char openwsn_ieee802154e_rec_stack[KERNEL_CONF_STACKSIZE_MAIN];
! //static char openwsn_ieee802154e_send_stack[KERNEL_CONF_STACKSIZE_MAIN];
  
  //=========================== prototypes ======================================
! void isr_ieee154e_newSlot(void);
! void isr_ieee154e_timer(void);
  // SYNCHRONIZING
! void     activity_synchronize_newSlot(void);
! void     activity_synchronize_startOfFrame(PORT_RADIOTIMER_WIDTH capturedTime);
! void     activity_synchronize_endOfFrame(PORT_RADIOTIMER_WIDTH capturedTime);
  // TX
! void     activity_ti1ORri1(void);
! void     activity_ti2(void);
! void     activity_tie1(void);
! void     activity_ti3(void);
! void     activity_tie2(void);
! void     activity_ti4(PORT_RADIOTIMER_WIDTH capturedTime);
! void     activity_tie3(void);
! void     activity_ti5(PORT_RADIOTIMER_WIDTH capturedTime);
! void     activity_ti6(void);
! void     activity_tie4(void);
! void     activity_ti7(void);
! void     activity_tie5(void);
! void     activity_ti8(PORT_RADIOTIMER_WIDTH capturedTime);
! void     activity_tie6(void);
! void     activity_ti9(PORT_RADIOTIMER_WIDTH capturedTime);
  // RX
! void     activity_ri2(void);
! void     activity_rie1(void);
! void     activity_ri3(void);
! void     activity_rie2(void);
! void     activity_ri4(PORT_RADIOTIMER_WIDTH capturedTime);
! void     activity_rie3(void);
! void     activity_ri5(PORT_RADIOTIMER_WIDTH capturedTime);
! void     activity_ri6(void);
! void     activity_rie4(void);
! void     activity_ri7(void);
! void     activity_rie5(void);
! void     activity_ri8(PORT_RADIOTIMER_WIDTH capturedTime);
! void     activity_rie6(void);
! void     activity_ri9(PORT_RADIOTIMER_WIDTH capturedTime);
  // frame validity check
! 
  bool     isValidRxFrame(ieee802154_header_iht* ieee802514_header);
  bool     isValidAck(ieee802154_header_iht*     ieee802514_header,
                      OpenQueueEntry_t*          packetSent);
+ // IEs Handling
+ bool     ieee154e_processIEs(OpenQueueEntry_t* pkt, uint16_t *     lenIE);//xv poipoi
+ void     ieee154e_processSlotframeLinkIE(OpenQueueEntry_t* pkt,uint8_t * ptr);//xv poipoi
  // ASN handling
! void     incrementAsnOffset(void);
! void     asnStoreFromAdv(uint8_t* asn);
! void     joinPriorityStoreFromAdv(uint8_t jp);
  // synchronization
! void     synchronizePacket(PORT_RADIOTIMER_WIDTH timeReceived);
  void     synchronizeAck(PORT_SIGNED_INT_WIDTH timeCorrection);
  void     changeIsSync(bool newIsSync);
  // notifying upper layer
! void     notif_sendDone(OpenQueueEntry_t* packetSent, owerror_t error);
  void     notif_receive(OpenQueueEntry_t* packetReceived);
  // statistics
! void     resetStats(void);
  void     updateStats(PORT_SIGNED_INT_WIDTH timeCorrection);
  // misc
  uint8_t  calculateFrequency(uint8_t channelOffset);
  void     changeState(ieee154e_state_t newstate);
! void     endSlot(void);
! bool     debugPrint_asn(void);
! bool     debugPrint_isSync(void);
  
  //=========================== admin ===========================================
  
***************
*** 130,137 ****
  Call this function once before any other function in this module, possibly
  during boot-up.
  */
! void ieee154e_init() {
!    
     // initialize variables
     memset(&ieee154e_vars,0,sizeof(ieee154e_vars_t));
     memset(&ieee154e_dbg,0,sizeof(ieee154e_dbg_t));
--- 103,110 ----
  Call this function once before any other function in this module, possibly
  during boot-up.
  */
! void ieee154e_init(void) {
!     DEBUG(__PRETTY_FUNCTION__);
     // initialize variables
     memset(&ieee154e_vars,0,sizeof(ieee154e_vars_t));
     memset(&ieee154e_dbg,0,sizeof(ieee154e_dbg_t));
***************
*** 162,178 ****
  /**
  /brief Difference between some older ASN and the current ASN.
  
! \param someASN [in] some ASN to compare to the current
  
  \returns The ASN difference, or 0xffff if more than 65535 different
  */
! PORT_TIMER_WIDTH ieee154e_asnDiff(asn_t* someASN) {
!    PORT_TIMER_WIDTH diff;
     INTERRUPT_DECLARATION();
     DISABLE_INTERRUPTS();
     if (ieee154e_vars.asn.byte4 != someASN->byte4) {
        ENABLE_INTERRUPTS();
!       return (PORT_TIMER_WIDTH)0xFFFFFFFF;;
     }
     
     diff = 0;
--- 135,151 ----
  /**
  /brief Difference between some older ASN and the current ASN.
  
! \param[in] someASN some ASN to compare to the current
  
  \returns The ASN difference, or 0xffff if more than 65535 different
  */
! PORT_RADIOTIMER_WIDTH ieee154e_asnDiff(asn_t* someASN) {
!    PORT_RADIOTIMER_WIDTH diff;
     INTERRUPT_DECLARATION();
     DISABLE_INTERRUPTS();
     if (ieee154e_vars.asn.byte4 != someASN->byte4) {
        ENABLE_INTERRUPTS();
!       return (PORT_RADIOTIMER_WIDTH)0xFFFFFFFF;;
     }
     
     diff = 0;
***************
*** 184,190 ****
        diff += 0xffff-someASN->bytes0and1;
        diff += 1;
     } else {
!       diff = (PORT_TIMER_WIDTH)0xFFFFFFFF;;
     }
     ENABLE_INTERRUPTS();
     return diff;
--- 157,163 ----
        diff += 0xffff-someASN->bytes0and1;
        diff += 1;
     } else {
!       diff = (PORT_RADIOTIMER_WIDTH)0xFFFFFFFF;;
     }
     ENABLE_INTERRUPTS();
     return diff;
***************
*** 197,206 ****
  
  This function executes in ISR mode, when the new slot timer fires.
  */
! void isr_ieee154e_newSlot() {
     radio_setTimerPeriod(TsSlotDuration);
     if (ieee154e_vars.isSync==FALSE) {
!       activity_synchronize_newSlot();
     } else {
        activity_ti1ORri1();
     }
--- 170,183 ----
  
  This function executes in ISR mode, when the new slot timer fires.
  */
! void isr_ieee154e_newSlot(void) {
     radio_setTimerPeriod(TsSlotDuration);
     if (ieee154e_vars.isSync==FALSE) {
!       if (idmanager_getIsDAGroot()==TRUE) {
!          changeIsSync(TRUE);
!       } else {
!          activity_synchronize_newSlot();
!       }
     } else {
        activity_ti1ORri1();
     }
***************
*** 212,218 ****
  
  This function executes in ISR mode, when the FSM timer fires.
  */
! void isr_ieee154e_timer() {
     switch (ieee154e_vars.state) {
        case S_TXDATAOFFSET:
           activity_ti2();
--- 189,195 ----
  
  This function executes in ISR mode, when the FSM timer fires.
  */
! void isr_ieee154e_timer(void) {
     switch (ieee154e_vars.state) {
        case S_TXDATAOFFSET:
           activity_ti2();
***************
*** 291,297 ****
  
  This function executes in ISR mode.
  */
! void ieee154e_startOfFrame(PORT_TIMER_WIDTH capturedTime) {
     if (ieee154e_vars.isSync==FALSE) {
       activity_synchronize_startOfFrame(capturedTime);
     } else {
--- 268,274 ----
  
  This function executes in ISR mode.
  */
! void ieee154e_startOfFrame(PORT_RADIOTIMER_WIDTH capturedTime) {
     if (ieee154e_vars.isSync==FALSE) {
       activity_synchronize_startOfFrame(capturedTime);
     } else {
***************
*** 339,345 ****
  
  This function executes in ISR mode.
  */
! void ieee154e_endOfFrame(PORT_TIMER_WIDTH capturedTime) {
     if (ieee154e_vars.isSync==FALSE) {
        activity_synchronize_endOfFrame(capturedTime);
     } else {
--- 316,322 ----
  
  This function executes in ISR mode.
  */
! void ieee154e_endOfFrame(PORT_RADIOTIMER_WIDTH capturedTime) {
     if (ieee154e_vars.isSync==FALSE) {
        activity_synchronize_endOfFrame(capturedTime);
     } else {
***************
*** 379,385 ****
  
  \returns TRUE if this function printed something, FALSE otherwise.
  */
! bool debugPrint_asn() {
     asn_t output;
     output.byte4         =  ieee154e_vars.asn.byte4;
     output.bytes2and3    =  ieee154e_vars.asn.bytes2and3;
--- 356,362 ----
  
  \returns TRUE if this function printed something, FALSE otherwise.
  */
! bool debugPrint_asn(void) {
     asn_t output;
     output.byte4         =  ieee154e_vars.asn.byte4;
     output.bytes2and3    =  ieee154e_vars.asn.bytes2and3;
***************
*** 396,402 ****
  
  \returns TRUE if this function printed something, FALSE otherwise.
  */
! bool debugPrint_isSync() {
     uint8_t output=0;
     output = ieee154e_vars.isSync;
     openserial_printStatus(STATUS_ISSYNC,(uint8_t*)&output,sizeof(uint8_t));
--- 373,379 ----
  
  \returns TRUE if this function printed something, FALSE otherwise.
  */
! bool debugPrint_isSync(void) {
     uint8_t output=0;
     output = ieee154e_vars.isSync;
     openserial_printStatus(STATUS_ISSYNC,(uint8_t*)&output,sizeof(uint8_t));
***************
*** 411,419 ****
  
  \returns TRUE if this function printed something, FALSE otherwise.
  */
! bool debugPrint_macStats() {
     // send current stats over serial
     openserial_printStatus(STATUS_MACSTATS,(uint8_t*)&ieee154e_stats,sizeof(ieee154e_stats_t));
     return TRUE;
  }
  
--- 388,401 ----
  
  \returns TRUE if this function printed something, FALSE otherwise.
  */
! bool debugPrint_macStats(void) {
     // send current stats over serial
+    ieee154e_stats.dutyCycle/=(float)SUPERFRAME_LENGTH; //avg on the all slots of a frame
+    ieee154e_stats.dutyCycle/=STATUS_MAX;//because this is executed once every 10 times of debugprint
+    ieee154e_stats.dutyCycle*=100.0;//as is a percentage
     openserial_printStatus(STATUS_MACSTATS,(uint8_t*)&ieee154e_stats,sizeof(ieee154e_stats_t));
+    ieee154e_stats.dutyCycle=0; //reset for the next superframe.
+    
     return TRUE;
  }
  
***************
*** 421,427 ****
  
  //======= SYNCHRONIZING
  
! port_INLINE void activity_synchronize_newSlot() {
     // I'm in the middle of receiving a packet
     if (ieee154e_vars.state==S_SYNCRX) {
        return;
--- 403,409 ----
  
  //======= SYNCHRONIZING
  
! port_INLINE void activity_synchronize_newSlot(void) {
     // I'm in the middle of receiving a packet
     if (ieee154e_vars.state==S_SYNCRX) {
        return;
***************
*** 444,449 ****
--- 426,433 ----
        
        // switch on the radio in Rx mode.
        radio_rxEnable();
+       ieee154e_vars.radioOnInit=radio_getTimerValue();
+       ieee154e_vars.radioOnThisSlot=TRUE;
        radio_rxNow();
     }
     
***************
*** 461,467 ****
     }
  }
  
! port_INLINE void activity_synchronize_startOfFrame(PORT_TIMER_WIDTH capturedTime) {
     
     // don't care about packet if I'm not listening
     if (ieee154e_vars.state!=S_SYNCLISTEN) {
--- 445,451 ----
     }
  }
  
! port_INLINE void activity_synchronize_startOfFrame(PORT_RADIOTIMER_WIDTH capturedTime) {
     
     // don't care about packet if I'm not listening
     if (ieee154e_vars.state!=S_SYNCLISTEN) {
***************
*** 481,488 ****
     ieee154e_vars.syncCapturedTime = capturedTime;
  }
  
! port_INLINE void activity_synchronize_endOfFrame(PORT_TIMER_WIDTH capturedTime) {
     ieee802154_header_iht ieee802514_header;
     
     // check state
     if (ieee154e_vars.state!=S_SYNCRX) {
--- 465,473 ----
     ieee154e_vars.syncCapturedTime = capturedTime;
  }
  
! port_INLINE void activity_synchronize_endOfFrame(PORT_RADIOTIMER_WIDTH capturedTime) {
     ieee802154_header_iht ieee802514_header;
+    uint16_t lenIE=0;//len of IEs being received if any.
     
     // check state
     if (ieee154e_vars.state!=S_SYNCRX) {
***************
*** 566,588 ****
        ieee154e_vars.dataReceived->l2_dsn       = ieee802514_header.dsn;
        memcpy(&(ieee154e_vars.dataReceived->l2_nextORpreviousHop),&(ieee802514_header.src),sizeof(open_addr_t));
        
!       // toss the IEEE802.15.4 header
        packetfunctions_tossHeader(ieee154e_vars.dataReceived,ieee802514_header.headerLength);
        
        // break if invalid ADV
!       if (isValidAdv(&ieee802514_header)==FALSE) {
           // break from the do-while loop and execute the clean-up code below
           break;
        }
        
        // turn off the radio
        radio_rfOff();
        
!       // record the ASN from the ADV payload
!       asnStoreFromAdv(ieee154e_vars.dataReceived);
!       
!       // toss the ADV payload
!       packetfunctions_tossHeader(ieee154e_vars.dataReceived,ADV_PAYLOAD_LENGTH);
        
        // synchronize (for the first time) to the sender's ADV
        synchronizePacket(ieee154e_vars.syncCapturedTime);
--- 551,578 ----
        ieee154e_vars.dataReceived->l2_dsn       = ieee802514_header.dsn;
        memcpy(&(ieee154e_vars.dataReceived->l2_nextORpreviousHop),&(ieee802514_header.src),sizeof(open_addr_t));
        
!       // toss the IEEE802.15.4 header -- this does not include IEs as they are processed 
!       // next.
        packetfunctions_tossHeader(ieee154e_vars.dataReceived,ieee802514_header.headerLength);
        
+       // handle IEs -- xv poipoi
        // break if invalid ADV
!       if ((ieee802514_header.valid==TRUE                                                        && 
!           ieee802514_header.ieListPresent==TRUE                                                 &&
!           ieee802514_header.frameType==IEEE154_TYPE_BEACON                                      && 
!           packetfunctions_sameAddress(&ieee802514_header.panid,idmanager_getMyID(ADDR_PANID))   &&          
!           ieee154e_processIEs(ieee154e_vars.dataReceived,&lenIE))==FALSE) {
           // break from the do-while loop and execute the clean-up code below
           break;
        }
        
        // turn off the radio
        radio_rfOff();
+       //compute radio duty cycle
+       ieee154e_vars.radioOnTics+=(radio_getTimerValue()-ieee154e_vars.radioOnInit);
        
!       // toss the IEs including Synch
!       packetfunctions_tossHeader(ieee154e_vars.dataReceived,lenIE);
        
        // synchronize (for the first time) to the sender's ADV
        synchronizePacket(ieee154e_vars.syncCapturedTime);
***************
*** 619,631 ****
     changeState(S_SYNCLISTEN);
  }
  
  //======= TX
  
! port_INLINE void activity_ti1ORri1() {
     cellType_t  cellType;
     open_addr_t neighbor;
     uint8_t  i;
!    
     // increment ASN (do this first so debug pins are in sync)
     incrementAsnOffset();
     
--- 609,768 ----
     changeState(S_SYNCLISTEN);
  }
  
+ //xv poipoi - IE Handling 
+ port_INLINE bool ieee154e_processIEs(OpenQueueEntry_t* pkt, uint16_t * lenIE)
+ {
+   uint8_t ptr,byte0,byte1;
+   uint8_t temp_8b,gr_elem_id,subid;
+   uint16_t temp_16b,len,sublen;
+   volatile PORT_SIGNED_INT_WIDTH  timeCorrection;
+   
+   ptr=0;
+   //candidate IE header  if type ==0 header IE if type==1 payload IE
+   temp_8b = *((uint8_t*)(pkt->payload)+ptr);
+   ptr++;
+   temp_16b = temp_8b + ((*((uint8_t*)(pkt->payload)+ptr))<< 8);
+   ptr++;
+   *lenIE = ptr; 
+   if ((temp_16b & IEEE802154E_DESC_TYPE_PAYLOAD_IE) == IEEE802154E_DESC_TYPE_PAYLOAD_IE){
+   //payload IE - last bit is 1
+      len=(temp_16b & IEEE802154E_DESC_LEN_PAYLOAD_IE_MASK)>>IEEE802154E_DESC_LEN_PAYLOAD_IE_SHIFT;
+      gr_elem_id= (temp_16b & IEEE802154E_DESC_GROUPID_PAYLOAD_IE_MASK)>>IEEE802154E_DESC_GROUPID_PAYLOAD_IE_SHIFT; 
+   }else {
+   //header IE - last bit is 0
+      len=(temp_16b & IEEE802154E_DESC_LEN_HEADER_IE_MASK)>>IEEE802154E_DESC_LEN_HEADER_IE_SHIFT;
+      gr_elem_id = (temp_16b & IEEE802154E_DESC_ELEMENTID_HEADER_IE_MASK)>>IEEE802154E_DESC_ELEMENTID_HEADER_IE_SHIFT; 
+   }
+   
+   *lenIE += len; 
+   //now determine sub elements if any
+   switch(gr_elem_id){
+     //this is the only groupID that we parse. See page 82.  
+     case IEEE802154E_MLME_IE_GROUPID:
+       //IE content can be any of the sub-IEs. Parse and see which
+       do{
+         //read sub IE header
+         temp_8b = *((uint8_t*)(pkt->payload)+ptr);
+         ptr = ptr + 1;
+         temp_16b = temp_8b  +(*((uint8_t*)(pkt->payload)+ptr) << 8);
+         ptr = ptr + 1;
+         len = len - 2; //remove header fields len
+         if ((temp_16b & IEEE802154E_DESC_TYPE_LONG) == IEEE802154E_DESC_TYPE_LONG){
+            //long sub-IE - last bit is 1
+            sublen=(temp_16b & IEEE802154E_DESC_LEN_LONG_MLME_IE_MASK)>>IEEE802154E_DESC_LEN_LONG_MLME_IE_SHIFT;
+            subid= (temp_16b & IEEE802154E_DESC_SUBID_LONG_MLME_IE_MASK)>>IEEE802154E_DESC_SUBID_LONG_MLME_IE_SHIFT; 
+         }else {
+            //short IE - last bit is 0
+            sublen =(temp_16b & IEEE802154E_DESC_LEN_SHORT_MLME_IE_MASK)>>IEEE802154E_DESC_LEN_SHORT_MLME_IE_SHIFT;
+            subid = (temp_16b & IEEE802154E_DESC_SUBID_SHORT_MLME_IE_MASK)>>IEEE802154E_DESC_SUBID_SHORT_MLME_IE_SHIFT; 
+         }
+         switch(subid){
+         case IEEE802154E_MLME_SYNC_IE_SUBID:
+           //content is ASN and Join Priority 
+           if (idmanager_getIsDAGroot()==FALSE) {
+              asnStoreFromAdv((uint8_t*)(pkt->payload)+ptr);
+              ptr = ptr + 5; //add ASN len
+              joinPriorityStoreFromAdv(*((uint8_t*)(pkt->payload)+ptr));
+              ptr = ptr + 1;
+           }
+           break;
+         case IEEE802154E_MLME_SLOTFRAME_LINK_IE_SUBID:
+           ieee154e_processSlotframeLinkIE(pkt,&ptr); 
+           break;
+         case IEEE802154E_MLME_TIMESLOT_IE_SUBID:
+           //TODO
+           break;
+         default:
+           return FALSE;
+           break;
+         }
+         len = len - sublen;
+       } while(len>0);
+       
+       break;
+     //the rest are elementID  
+     case IEEE802154E_ACK_NACK_TIMECORRECTION_ELEMENTID:
+       //IE content is time correction -- apply the time correction on ack received.
+        if (idmanager_getIsDAGroot()==FALSE &&
+          neighbors_isPreferredParent(&(pkt->l2_nextORpreviousHop)) ) {
+          byte0 = *((uint8_t*)(pkt->payload)+ptr);
+          ptr++;
+          byte1 = *((uint8_t*)(pkt->payload)+ptr);
+          ptr++;
+          
+          timeCorrection  = (PORT_SIGNED_INT_WIDTH)((PORT_RADIOTIMER_WIDTH)byte1<<8 | (PORT_RADIOTIMER_WIDTH)byte0);
+          timeCorrection /=  US_PER_TICK;
+          timeCorrection  = -timeCorrection;
+          synchronizeAck(timeCorrection);
+       }
+       break; 
+     default:
+       *lenIE = 0;//no header or not recognized.
+        return FALSE;
+   }
+   if (*lenIE>127) {
+          // log the error
+       openserial_printError(COMPONENT_IEEE802154E,ERR_HEADER_TOO_LONG,
+                             (errorparameter_t)*lenIE,
+                             (errorparameter_t)1);
+   }
+   return TRUE;
+ }
+ 
+ port_INLINE void ieee154e_processSlotframeLinkIE(OpenQueueEntry_t* pkt,uint8_t * ptr){
+  uint8_t numSlotFrames,i,j,localptr;
+  slotframelink_IE_t sfInfo; 
+  linkInfo_subIE_t linkInfo;
+  localptr=*ptr; 
+   // number of slot frames 1B
+   numSlotFrames = *((uint8_t*)(pkt->payload)+localptr);
+   localptr++;
+   // for each slotframe
+   i=0;
+   while(i < numSlotFrames){
+    //1-slotftramehandle 1B
+     sfInfo.slotframehandle=*((uint8_t*)(pkt->payload)+localptr);
+     localptr++;
+     //2-slotframe size 2B
+     sfInfo.slotframesize = *((uint8_t*)(pkt->payload)+localptr);
+     localptr++;
+     sfInfo.slotframesize |= (*((uint8_t*)(pkt->payload)+localptr))<<8;
+     localptr++;;
+     //3-number of links 1B   
+     sfInfo.numlinks= *((uint8_t*)(pkt->payload)+localptr);
+     localptr++;
+    
+     for (j=0;j<sfInfo.numlinks;j++){
+       //for each link 5Bytes
+        //TimeSlot 2B
+        linkInfo.tsNum = *((uint8_t*)(pkt->payload)+localptr);
+        localptr++;
+        linkInfo.tsNum  |= (*((uint8_t*)(pkt->payload)+localptr))<<8;
+        localptr++;
+        //Ch.Offset 2B
+        linkInfo.choffset = *((uint8_t*)(pkt->payload)+localptr);
+        localptr++;
+        linkInfo.choffset  |= (*((uint8_t*)(pkt->payload)+localptr))<<8;
+        localptr++;
+        //LinkOption bitmap 1B
+        linkInfo.linkoptions = *((uint8_t*)(pkt->payload)+localptr);
+        localptr++;
+        //xv poipoi
+        //TODO - inform schedule of that link so it can update if needed.
+     } 
+     i++;
+   } 
+   *ptr=localptr;      
+ }
+ 
  //======= TX
  
! port_INLINE void activity_ti1ORri1(void) {
     cellType_t  cellType;
     open_addr_t neighbor;
     uint8_t  i;
!    synch_IE_t  syn_IE;
! 
     // increment ASN (do this first so debug pins are in sync)
     incrementAsnOffset();
     
***************
*** 703,711 ****
              // change state
              changeState(S_TXDATAOFFSET);
              // change owner
!             ieee154e_vars.dataToSend->owner = COMPONENT_IEEE802154E;
              // fill in the ASN field of the ADV
!             asnWriteToAdv(ieee154e_vars.dataToSend);
              // record that I attempt to transmit this packet
              ieee154e_vars.dataToSend->l2_numTxAttempts++;
              // arm tt1
--- 840,853 ----
              // change state
              changeState(S_TXDATAOFFSET);
              // change owner
!             ieee154e_vars.dataToSend->owner = COMPONENT_IEEE802154E;            
!             //copy synch IE  -- should be Little endian???
              // fill in the ASN field of the ADV
!             ieee154e_getAsn(syn_IE.asn);
!             syn_IE.join_priority = neighbors_getMyDAGrank()/(2*MINHOPRANKINCREASE); //poipoi -- use dagrank(rank) 
!        
!             memcpy(ieee154e_vars.dataToSend->l2_ASNpayload,&syn_IE,sizeof(synch_IE_t));
!             
              // record that I attempt to transmit this packet
              ieee154e_vars.dataToSend->l2_numTxAttempts++;
              // arm tt1
***************
*** 779,785 ****
     }
  }
  
! port_INLINE void activity_ti2() {
     // change state
     changeState(S_TXDATAPREPARE);
     
--- 921,927 ----
     }
  }
  
! port_INLINE void activity_ti2(void) {
     // change state
     changeState(S_TXDATAPREPARE);
     
***************
*** 787,793 ****
     ieee154e_vars.freq = calculateFrequency(schedule_getChannelOffset()); 
     
     // configure the radio for that frequency
-    //radio_setFrequency(frequency);
     radio_setFrequency(ieee154e_vars.freq);
     
     // load the packet in the radio's Tx buffer
--- 929,934 ----
***************
*** 796,802 ****
     
     // enable the radio in Tx mode. This does not send the packet.
     radio_txEnable();
!    
     // arm tt2
     radiotimer_schedule(DURATION_tt2);
     
--- 937,944 ----
     
     // enable the radio in Tx mode. This does not send the packet.
     radio_txEnable();
!    ieee154e_vars.radioOnInit=radio_getTimerValue();
!    ieee154e_vars.radioOnThisSlot=TRUE;
     // arm tt2
     radiotimer_schedule(DURATION_tt2);
     
***************
*** 804,810 ****
     changeState(S_TXDATAREADY);
  }
  
! port_INLINE void activity_tie1() {
     // log the error
     openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXDATAPREPARE_OVERFLOW,
                           (errorparameter_t)ieee154e_vars.state,
--- 946,952 ----
     changeState(S_TXDATAREADY);
  }
  
! port_INLINE void activity_tie1(void) {
     // log the error
     openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXDATAPREPARE_OVERFLOW,
                           (errorparameter_t)ieee154e_vars.state,
***************
*** 814,820 ****
     endSlot();
  }
  
! port_INLINE void activity_ti3() {
     // change state
     changeState(S_TXDATADELAY);
     
--- 956,962 ----
     endSlot();
  }
  
! port_INLINE void activity_ti3(void) {
     // change state
     changeState(S_TXDATADELAY);
     
***************
*** 825,831 ****
     radio_txNow();
  }
  
! port_INLINE void activity_tie2() {
     // log the error
     openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIO_OVERFLOWS,
                           (errorparameter_t)ieee154e_vars.state,
--- 967,973 ----
     radio_txNow();
  }
  
! port_INLINE void activity_tie2(void) {
     // log the error
     openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIO_OVERFLOWS,
                           (errorparameter_t)ieee154e_vars.state,
***************
*** 835,841 ****
     endSlot();
  }
  
! port_INLINE void activity_ti4(PORT_TIMER_WIDTH capturedTime) {
     // change state
     changeState(S_TXDATA);
     
--- 977,984 ----
     endSlot();
  }
  
! //start of frame interrupt
! port_INLINE void activity_ti4(PORT_RADIOTIMER_WIDTH capturedTime) {
     // change state
     changeState(S_TXDATA);
     
***************
*** 849,855 ****
     radiotimer_schedule(DURATION_tt4);
  }
  
! port_INLINE void activity_tie3() {
     // log the error
     openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
                           (errorparameter_t)ieee154e_vars.state,
--- 992,998 ----
     radiotimer_schedule(DURATION_tt4);
  }
  
! port_INLINE void activity_tie3(void) {
     // log the error
     openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
                           (errorparameter_t)ieee154e_vars.state,
***************
*** 859,865 ****
     endSlot();
  }
  
! port_INLINE void activity_ti5(PORT_TIMER_WIDTH capturedTime) {
     bool listenForAck;
     
     // change state
--- 1002,1008 ----
     endSlot();
  }
  
! port_INLINE void activity_ti5(PORT_RADIOTIMER_WIDTH capturedTime) {
     bool listenForAck;
     
     // change state
***************
*** 869,875 ****
     radiotimer_cancel();
     
     // turn off the radio
!    radio_rfOff();
     
     // record the captured time
     ieee154e_vars.lastCapturedTime = capturedTime;
--- 1012,1019 ----
     radiotimer_cancel();
     
     // turn off the radio
!     radio_rfOff();
!    ieee154e_vars.radioOnTics+=(radio_getTimerValue()-ieee154e_vars.radioOnInit);
     
     // record the captured time
     ieee154e_vars.lastCapturedTime = capturedTime;
***************
*** 896,902 ****
     }
  }
  
! port_INLINE void activity_ti6() {
     // change state
     changeState(S_RXACKPREPARE);
     
--- 1040,1046 ----
     }
  }
  
! port_INLINE void activity_ti6(void) {
     // change state
     changeState(S_RXACKPREPARE);
     
***************
*** 904,915 ****
     ieee154e_vars.freq = calculateFrequency(schedule_getChannelOffset()); 
     
     // configure the radio for that frequency
-    //radio_setFrequency(frequency);
     radio_setFrequency(ieee154e_vars.freq);
     
     // enable the radio in Rx mode. The radio is not actively listening yet.
     radio_rxEnable();
!    
     // arm tt6
     radiotimer_schedule(DURATION_tt6);
     
--- 1048,1060 ----
     ieee154e_vars.freq = calculateFrequency(schedule_getChannelOffset()); 
     
     // configure the radio for that frequency
     radio_setFrequency(ieee154e_vars.freq);
     
     // enable the radio in Rx mode. The radio is not actively listening yet.
     radio_rxEnable();
!    //caputre init of radio for duty cycle calculation
!    ieee154e_vars.radioOnInit=radio_getTimerValue();
!    ieee154e_vars.radioOnThisSlot=TRUE;
     // arm tt6
     radiotimer_schedule(DURATION_tt6);
     
***************
*** 917,923 ****
     changeState(S_RXACKREADY);
  }
  
! port_INLINE void activity_tie4() {
     // log the error
     openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXACKPREPARE_OVERFLOWS,
                           (errorparameter_t)ieee154e_vars.state,
--- 1062,1068 ----
     changeState(S_RXACKREADY);
  }
  
! port_INLINE void activity_tie4(void) {
     // log the error
     openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXACKPREPARE_OVERFLOWS,
                           (errorparameter_t)ieee154e_vars.state,
***************
*** 927,933 ****
     endSlot();
  }
  
! port_INLINE void activity_ti7() {
     // change state
     changeState(S_RXACKLISTEN);
     
--- 1072,1078 ----
     endSlot();
  }
  
! port_INLINE void activity_ti7(void) {
     // change state
     changeState(S_RXACKLISTEN);
     
***************
*** 938,944 ****
     radiotimer_schedule(DURATION_tt7);
  }
  
! port_INLINE void activity_tie5() {
     // indicate transmit failed to schedule to keep stats
     schedule_indicateTx(&ieee154e_vars.asn,FALSE);
     
--- 1083,1089 ----
     radiotimer_schedule(DURATION_tt7);
  }
  
! port_INLINE void activity_tie5(void) {
     // indicate transmit failed to schedule to keep stats
     schedule_indicateTx(&ieee154e_vars.asn,FALSE);
     
***************
*** 960,966 ****
     endSlot();
  }
  
! port_INLINE void activity_ti8(PORT_TIMER_WIDTH capturedTime) {
     // change state
     changeState(S_RXACK);
     
--- 1105,1111 ----
     endSlot();
  }
  
! port_INLINE void activity_ti8(PORT_RADIOTIMER_WIDTH capturedTime) {
     // change state
     changeState(S_RXACK);
     
***************
*** 974,989 ****
     radiotimer_schedule(DURATION_tt8);
  }
  
! port_INLINE void activity_tie6() {
     // abort
     endSlot();
  }
  
! port_INLINE void activity_ti9(PORT_TIMER_WIDTH capturedTime) {
     ieee802154_header_iht ieee802514_header;
     volatile PORT_SIGNED_INT_WIDTH  timeCorrection;
!    uint8_t byte0;
!    uint8_t byte1;
     
     // change state
     changeState(S_TXPROC);
--- 1119,1133 ----
     radiotimer_schedule(DURATION_tt8);
  }
  
! port_INLINE void activity_tie6(void) {
     // abort
     endSlot();
  }
  
! port_INLINE void activity_ti9(PORT_RADIOTIMER_WIDTH capturedTime) {
     ieee802154_header_iht ieee802514_header;
     volatile PORT_SIGNED_INT_WIDTH  timeCorrection;
!    uint16_t lenIE;
     
     // change state
     changeState(S_TXPROC);
***************
*** 993,998 ****
--- 1137,1144 ----
     
     // turn off the radio
     radio_rfOff();
+    //compute tics radio on.
+    ieee154e_vars.radioOnTics+=(radio_getTimerValue()-ieee154e_vars.radioOnInit);
     
     // record the captured time
     ieee154e_vars.lastCapturedTime = capturedTime;
***************
*** 1074,1090 ****
           // break from the do-while loop and execute the clean-up code below
           break;
        }
        
!       // resynchronize if I'm not a DAGroot and ACK from preferred parent
!       if (idmanager_getIsDAGroot()==FALSE &&
!           neighbors_isPreferredParent(&(ieee154e_vars.ackReceived->l2_nextORpreviousHop)) ) {
!          byte0 = ieee154e_vars.ackReceived->payload[0];
!          byte1 = ieee154e_vars.ackReceived->payload[1];
!          timeCorrection  = (PORT_SIGNED_INT_WIDTH)((PORT_TIMER_WIDTH)byte1<<8 | (PORT_TIMER_WIDTH)byte0);
!          timeCorrection /=  US_PER_TICK;
!          timeCorrection  = -timeCorrection;
!          synchronizeAck(timeCorrection);
        }
        
        // inform schedule of successful transmission
        schedule_indicateTx(&ieee154e_vars.asn,TRUE);
--- 1220,1237 ----
           // break from the do-while loop and execute the clean-up code below
           break;
        }
+       //hanlde IEs --xv poipoi
+       if (ieee802514_header.ieListPresent==FALSE){
+          break; //ack should contain IEs.
+       }
        
!       if (ieee154e_processIEs(ieee154e_vars.ackReceived,&lenIE)==FALSE){
!         //invalid IEs on ACK. 
!         break;
        }
+  
+       // toss the IEs including ACK -- xv poipoi
+       packetfunctions_tossHeader(ieee154e_vars.ackReceived,lenIE);
        
        // inform schedule of successful transmission
        schedule_indicateTx(&ieee154e_vars.asn,TRUE);
***************
*** 1108,1114 ****
  
  //======= RX
  
! port_INLINE void activity_ri2() {
  	// change state
     changeState(S_RXDATAPREPARE);
     
--- 1255,1261 ----
  
  //======= RX
  
! port_INLINE void activity_ri2(void) {
  	// change state
     changeState(S_RXDATAPREPARE);
     
***************
*** 1116,1127 ****
     ieee154e_vars.freq = calculateFrequency(schedule_getChannelOffset()); 
     
     // configure the radio for that frequency
-    //radio_setFrequency(frequency);
     radio_setFrequency(ieee154e_vars.freq);
     
     // enable the radio in Rx mode. The radio does not actively listen yet.
     radio_rxEnable();
!    
     
     // arm rt2
     radiotimer_schedule(DURATION_rt2);
--- 1263,1274 ----
     ieee154e_vars.freq = calculateFrequency(schedule_getChannelOffset()); 
     
     // configure the radio for that frequency
     radio_setFrequency(ieee154e_vars.freq);
     
     // enable the radio in Rx mode. The radio does not actively listen yet.
     radio_rxEnable();
!    ieee154e_vars.radioOnInit=radio_getTimerValue();
!    ieee154e_vars.radioOnThisSlot=TRUE;
     
     // arm rt2
     radiotimer_schedule(DURATION_rt2);
***************
*** 1130,1136 ****
     changeState(S_RXDATAREADY);
  }
  
! port_INLINE void activity_rie1() {
     // log the error
     openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXDATAPREPARE_OVERFLOWS,
                           (errorparameter_t)ieee154e_vars.state,
--- 1277,1283 ----
     changeState(S_RXDATAREADY);
  }
  
! port_INLINE void activity_rie1(void) {
     // log the error
     openserial_printError(COMPONENT_IEEE802154E,ERR_MAXRXDATAPREPARE_OVERFLOWS,
                           (errorparameter_t)ieee154e_vars.state,
***************
*** 1140,1146 ****
     endSlot();
  }
  
! port_INLINE void activity_ri3() {
     // change state
     changeState(S_RXDATALISTEN);
     
--- 1287,1293 ----
     endSlot();
  }
  
! port_INLINE void activity_ri3(void) {
     // change state
     changeState(S_RXDATALISTEN);
     
***************
*** 1151,1162 ****
     radiotimer_schedule(DURATION_rt3);
  }
  
! port_INLINE void activity_rie2() {
     // abort
     endSlot();
  }
  
! port_INLINE void activity_ri4(PORT_TIMER_WIDTH capturedTime) {
     // change state
     changeState(S_RXDATA);
     
--- 1298,1310 ----
     radiotimer_schedule(DURATION_rt3);
  }
  
! port_INLINE void activity_rie2(void) {
     // abort
     endSlot();
  }
  
! port_INLINE void activity_ri4(PORT_RADIOTIMER_WIDTH capturedTime) {
! 
     // change state
     changeState(S_RXDATA);
     
***************
*** 1168,1179 ****
     
     // record the captured time to sync
     ieee154e_vars.syncCapturedTime = capturedTime;
!    
!    // arm rt4
     radiotimer_schedule(DURATION_rt4);
  }
  
! port_INLINE void activity_rie3() {
     // log the error
     openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
                           (errorparameter_t)ieee154e_vars.state,
--- 1316,1327 ----
     
     // record the captured time to sync
     ieee154e_vars.syncCapturedTime = capturedTime;
! 
     radiotimer_schedule(DURATION_rt4);
  }
  
! port_INLINE void activity_rie3(void) {
!      
     // log the error
     openserial_printError(COMPONENT_IEEE802154E,ERR_WDDATADURATION_OVERFLOWS,
                           (errorparameter_t)ieee154e_vars.state,
***************
*** 1183,1200 ****
     endSlot();
  }
  
! port_INLINE void activity_ri5(PORT_TIMER_WIDTH capturedTime) {
     ieee802154_header_iht ieee802514_header;
     
     // change state
     changeState(S_TXACKOFFSET);
     
     // cancel rt4
     radiotimer_cancel();
!    
     // turn off the radio
!    radio_rfOff();
!    
     // get a buffer to put the (received) data in
     ieee154e_vars.dataReceived = openqueue_getFreePacketBuffer(COMPONENT_IEEE802154E);
     if (ieee154e_vars.dataReceived==NULL) {
--- 1331,1349 ----
     endSlot();
  }
  
! port_INLINE void activity_ri5(PORT_RADIOTIMER_WIDTH capturedTime) {
     ieee802154_header_iht ieee802514_header;
+    uint16_t lenIE=0;
     
     // change state
     changeState(S_TXACKOFFSET);
     
     // cancel rt4
     radiotimer_cancel();
! 
     // turn off the radio
!    //radio_rfOff();
!    ieee154e_vars.radioOnTics+=radio_getTimerValue()-ieee154e_vars.radioOnInit;
     // get a buffer to put the (received) data in
     ieee154e_vars.dataReceived = openqueue_getFreePacketBuffer(COMPONENT_IEEE802154E);
     if (ieee154e_vars.dataReceived==NULL) {
***************
*** 1267,1281 ****
        // toss the IEEE802.15.4 header
        packetfunctions_tossHeader(ieee154e_vars.dataReceived,ieee802514_header.headerLength);
        
!       // if I just received a valid ADV, record the ASN and toss the ADV payload
!       if (isValidAdv(&ieee802514_header)==TRUE) {
!          if (idmanager_getIsDAGroot()==FALSE) {
!             asnStoreFromAdv(ieee154e_vars.dataReceived);
!          }
!          // toss the ADV payload
!          packetfunctions_tossHeader(ieee154e_vars.dataReceived,ADV_PAYLOAD_LENGTH);
        }
        
        // record the captured time
        ieee154e_vars.lastCapturedTime = capturedTime;
        
--- 1416,1434 ----
        // toss the IEEE802.15.4 header
        packetfunctions_tossHeader(ieee154e_vars.dataReceived,ieee802514_header.headerLength);
        
!       // handle IEs xv poipoi
!       //reset join priority 
!       
!       if ((ieee802514_header.valid==TRUE &&
!           ieee802514_header.ieListPresent==TRUE && 
!           packetfunctions_sameAddress(&ieee802514_header.panid,idmanager_getMyID(ADDR_PANID)) && 
!           ieee154e_processIEs(ieee154e_vars.dataReceived,&lenIE))==FALSE) {
!           //log  that the packet is not carrying IEs
        }
        
+       // toss the IEs including Synch
+       packetfunctions_tossHeader(ieee154e_vars.dataReceived,lenIE);
+             
        // record the captured time
        ieee154e_vars.lastCapturedTime = capturedTime;
        
***************
*** 1317,1324 ****
     endSlot();
  }
  
! port_INLINE void activity_ri6() {
     PORT_SIGNED_INT_WIDTH timeCorrection;
     
     // change state
     changeState(S_TXACKPREPARE);
--- 1470,1478 ----
     endSlot();
  }
  
! port_INLINE void activity_ri6(void) {
     PORT_SIGNED_INT_WIDTH timeCorrection;
+    header_IE_descriptor_t header_desc;
     
     // change state
     changeState(S_TXACKPREPARE);
***************
*** 1345,1363 ****
     
     // calculate the time timeCorrection (this is the time when the packet arrive w.r.t the time it should be.
     timeCorrection = (PORT_SIGNED_INT_WIDTH)((PORT_SIGNED_INT_WIDTH)ieee154e_vars.syncCapturedTime-(PORT_SIGNED_INT_WIDTH)TsTxOffset);
!    
     // add the payload to the ACK (i.e. the timeCorrection)
!    packetfunctions_reserveHeaderSize(ieee154e_vars.ackToSend,sizeof(IEEE802154E_ACK_ht));
     timeCorrection  = -timeCorrection;
     timeCorrection *= US_PER_TICK;
!    ieee154e_vars.ackToSend->payload[0] = (uint8_t)((((PORT_TIMER_WIDTH)timeCorrection)   ) & 0xff);
!    ieee154e_vars.ackToSend->payload[1] = (uint8_t)((((PORT_TIMER_WIDTH)timeCorrection)>>8) & 0xff);
     
     // prepend the IEEE802.15.4 header to the ACK
     ieee154e_vars.ackToSend->l2_frameType = IEEE154_TYPE_ACK;
     ieee154e_vars.ackToSend->l2_dsn       = ieee154e_vars.dataReceived->l2_dsn;
     ieee802154_prependHeader(ieee154e_vars.ackToSend,
                              ieee154e_vars.ackToSend->l2_frameType,
                              IEEE154_SEC_NO_SECURITY,
                              ieee154e_vars.dataReceived->l2_dsn,
                              &(ieee154e_vars.dataReceived->l2_nextORpreviousHop)
--- 1499,1527 ----
     
     // calculate the time timeCorrection (this is the time when the packet arrive w.r.t the time it should be.
     timeCorrection = (PORT_SIGNED_INT_WIDTH)((PORT_SIGNED_INT_WIDTH)ieee154e_vars.syncCapturedTime-(PORT_SIGNED_INT_WIDTH)TsTxOffset);
!     
     // add the payload to the ACK (i.e. the timeCorrection)
!    packetfunctions_reserveHeaderSize(ieee154e_vars.ackToSend,sizeof(ack_timecorrection_IE_t));
     timeCorrection  = -timeCorrection;
     timeCorrection *= US_PER_TICK;
!    ieee154e_vars.ackToSend->payload[0] = (uint8_t)((((PORT_RADIOTIMER_WIDTH)timeCorrection)   ) & 0xff);
!    ieee154e_vars.ackToSend->payload[1] = (uint8_t)((((PORT_RADIOTIMER_WIDTH)timeCorrection)>>8) & 0xff);
!    
!    // add header IE header -- xv poipoi -- pkt is filled in reverse order..
!    packetfunctions_reserveHeaderSize(ieee154e_vars.ackToSend,sizeof(header_IE_descriptor_t));
!    //create the header for ack IE
!    header_desc.length_elementid_type=(sizeof(ack_timecorrection_IE_t)<< IEEE802154E_DESC_LEN_HEADER_IE_SHIFT)|
!                                      (IEEE802154E_ACK_NACK_TIMECORRECTION_ELEMENTID << IEEE802154E_DESC_ELEMENTID_HEADER_IE_SHIFT)|
!                                      IEEE802154E_DESC_TYPE_SHORT; 
!    memcpy(ieee154e_vars.ackToSend->payload,&header_desc,sizeof(header_IE_descriptor_t));
     
     // prepend the IEEE802.15.4 header to the ACK
     ieee154e_vars.ackToSend->l2_frameType = IEEE154_TYPE_ACK;
     ieee154e_vars.ackToSend->l2_dsn       = ieee154e_vars.dataReceived->l2_dsn;
     ieee802154_prependHeader(ieee154e_vars.ackToSend,
                              ieee154e_vars.ackToSend->l2_frameType,
+                             IEEE154_IELIST_YES,//ie in ack
+                             IEEE154_FRAMEVERSION,//enhanced ack
                              IEEE154_SEC_NO_SECURITY,
                              ieee154e_vars.dataReceived->l2_dsn,
                              &(ieee154e_vars.dataReceived->l2_nextORpreviousHop)
***************
*** 1370,1376 ****
     ieee154e_vars.freq = calculateFrequency(schedule_getChannelOffset()); 
     
     // configure the radio for that frequency
-    //radio_setFrequency(frequency);
     radio_setFrequency(ieee154e_vars.freq);
     
     // load the packet in the radio's Tx buffer
--- 1534,1539 ----
***************
*** 1379,1385 ****
     
     // enable the radio in Tx mode. This does not send that packet.
     radio_txEnable();
!    
     // arm rt6
     radiotimer_schedule(DURATION_rt6);
     
--- 1542,1549 ----
     
     // enable the radio in Tx mode. This does not send that packet.
     radio_txEnable();
!    ieee154e_vars.radioOnInit=radio_getTimerValue();
!    ieee154e_vars.radioOnThisSlot=TRUE;
     // arm rt6
     radiotimer_schedule(DURATION_rt6);
     
***************
*** 1387,1393 ****
     changeState(S_TXACKREADY);
  }
  
! port_INLINE void activity_rie4() {
     // log the error
     openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXACKPREPARE_OVERFLOWS,
                           (errorparameter_t)ieee154e_vars.state,
--- 1551,1557 ----
     changeState(S_TXACKREADY);
  }
  
! port_INLINE void activity_rie4(void) {
     // log the error
     openserial_printError(COMPONENT_IEEE802154E,ERR_MAXTXACKPREPARE_OVERFLOWS,
                           (errorparameter_t)ieee154e_vars.state,
***************
*** 1397,1403 ****
     endSlot();
  }
  
! port_INLINE void activity_ri7() {
     // change state
     changeState(S_TXACKDELAY);
     
--- 1561,1567 ----
     endSlot();
  }
  
! port_INLINE void activity_ri7(void) {
     // change state
     changeState(S_TXACKDELAY);
     
***************
*** 1405,1414 ****
     radiotimer_schedule(DURATION_rt7);
     
     // give the 'go' to transmit
!    radio_txNow();
  }
  
! port_INLINE void activity_rie5() {
     // log the error
     openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIOTX_OVERFLOWS,
                           (errorparameter_t)ieee154e_vars.state,
--- 1569,1578 ----
     radiotimer_schedule(DURATION_rt7);
     
     // give the 'go' to transmit
!    radio_txNow(); 
  }
  
! port_INLINE void activity_rie5(void) {
     // log the error
     openserial_printError(COMPONENT_IEEE802154E,ERR_WDRADIOTX_OVERFLOWS,
                           (errorparameter_t)ieee154e_vars.state,
***************
*** 1418,1424 ****
     endSlot();
  }
  
! port_INLINE void activity_ri8(PORT_TIMER_WIDTH capturedTime) {
     // change state
     changeState(S_TXACK);
     
--- 1582,1588 ----
     endSlot();
  }
  
! port_INLINE void activity_ri8(PORT_RADIOTIMER_WIDTH capturedTime) {
     // change state
     changeState(S_TXACK);
     
***************
*** 1432,1438 ****
     radiotimer_schedule(DURATION_rt8);
  }
  
! port_INLINE void activity_rie6() {
     // log the error
     openserial_printError(COMPONENT_IEEE802154E,ERR_WDACKDURATION_OVERFLOWS,
                           (errorparameter_t)ieee154e_vars.state,
--- 1596,1602 ----
     radiotimer_schedule(DURATION_rt8);
  }
  
! port_INLINE void activity_rie6(void) {
     // log the error
     openserial_printError(COMPONENT_IEEE802154E,ERR_WDACKDURATION_OVERFLOWS,
                           (errorparameter_t)ieee154e_vars.state,
***************
*** 1442,1448 ****
     endSlot();
  }
  
! port_INLINE void activity_ri9(PORT_TIMER_WIDTH capturedTime) {
     // change state
     changeState(S_RXPROC);
     
--- 1606,1612 ----
     endSlot();
  }
  
! port_INLINE void activity_ri9(PORT_RADIOTIMER_WIDTH capturedTime) {
     // change state
     changeState(S_RXPROC);
     
***************
*** 1476,1502 ****
  //======= frame validity check
  
  /**
- \brief Decides whether the packet I just received is a valid ADV
- 
- \param [in] ieee802514_header IEEE802.15.4 header of the packet I just
-             received.
- 
- A valid ADV frame satisfies the following conditions:
- - its IEEE802.15.4 header is well formatted
- - it's a BEACON frame
- - it's sent to the my PANid
- - its payload length is the expected ADV payload length
- 
- \returns TRUE if packet is a valid ADV, FALSE otherwise
- */
- port_INLINE bool isValidAdv(ieee802154_header_iht* ieee802514_header) {
-    return ieee802514_header->valid==TRUE                                                         && \
-           ieee802514_header->frameType==IEEE154_TYPE_BEACON                                      && \
-           packetfunctions_sameAddress(&ieee802514_header->panid,idmanager_getMyID(ADDR_PANID))   && \
-           ieee154e_vars.dataReceived->length==ADV_PAYLOAD_LENGTH;
- }
- 
- /**
  \brief Decides whether the packet I just received is valid received frame.
  
  A valid Rx frame satisfies the following constraints:
--- 1640,1645 ----
***************
*** 1505,1511 ****
  - it's sent on the same PANid as mine
  - it's for me (unicast or broadcast)
  
! \param [in] ieee802514_header IEEE802.15.4 header of the packet I just received
  
  \returns TRUE if packet is valid received frame, FALSE otherwise
  */
--- 1648,1654 ----
  - it's sent on the same PANid as mine
  - it's for me (unicast or broadcast)
  
! \param[in] ieee802514_header IEEE802.15.4 header of the packet I just received
  
  \returns TRUE if packet is valid received frame, FALSE otherwise
  */
***************
*** 1533,1540 ****
  - the packet is unicast to me
  - the packet comes from the neighbor I sent the data to
  
! \param [in] ieee802514_header IEEE802.15.4 header of the packet I just received
! \param [in] packetSent points to the packet I just sent
  
  \returns TRUE if packet is a valid ACK, FALSE otherwise.
  */
--- 1676,1683 ----
  - the packet is unicast to me
  - the packet comes from the neighbor I sent the data to
  
! \param[in] ieee802514_header IEEE802.15.4 header of the packet I just received
! \param[in] packetSent points to the packet I just sent
  
  \returns TRUE if packet is a valid ACK, FALSE otherwise.
  */
***************
*** 1557,1563 ****
  
  //======= ASN handling
  
! port_INLINE void incrementAsnOffset() {
     // increment the asn
     ieee154e_vars.asn.bytes0and1++;
     if (ieee154e_vars.asn.bytes0and1==0) {
--- 1700,1706 ----
  
  //======= ASN handling
  
! port_INLINE void incrementAsnOffset(void) {
     // increment the asn
     ieee154e_vars.asn.bytes0and1++;
     if (ieee154e_vars.asn.bytes0and1==0) {
***************
*** 1571,1610 ****
     ieee154e_vars.asnOffset   = (ieee154e_vars.asnOffset+1)%16;
  }
  
! port_INLINE void asnWriteToAdv(OpenQueueEntry_t* advFrame) {
!    advFrame->l2_payload[0]   = (ieee154e_vars.asn.bytes0and1     & 0xff);
!    advFrame->l2_payload[1]   = (ieee154e_vars.asn.bytes0and1/256 & 0xff);
!    advFrame->l2_payload[2]   = (ieee154e_vars.asn.bytes2and3     & 0xff);
!    advFrame->l2_payload[3]   = (ieee154e_vars.asn.bytes2and3/256 & 0xff);
!    advFrame->l2_payload[4]   =  ieee154e_vars.asn.byte4;
! }
! 
! //from upper layer that want to send the ASN to compute timming or latency
! void asnWriteToPkt(OpenQueueEntry_t* frame) {
!    frame->payload[0]         = (ieee154e_vars.asn.bytes0and1     & 0xff);
!    frame->payload[1]         = (ieee154e_vars.asn.bytes0and1/256 & 0xff);
!    frame->payload[2]         = (ieee154e_vars.asn.bytes2and3     & 0xff);
!    frame->payload[3]         = (ieee154e_vars.asn.bytes2and3/256 & 0xff);
!    frame->payload[4]         =  ieee154e_vars.asn.byte4;
  }
  
! void asnWriteToSerial(uint8_t* array) {
!    array[0]                  = (ieee154e_vars.asn.bytes0and1     & 0xff);
!    array[1]                  = (ieee154e_vars.asn.bytes0and1/256 & 0xff);
!    array[2]                  = (ieee154e_vars.asn.bytes2and3     & 0xff);
!    array[3]                  = (ieee154e_vars.asn.bytes2and3/256 & 0xff);
!    array[4]                  =  ieee154e_vars.asn.byte4;
  }
  
  
! port_INLINE void asnStoreFromAdv(OpenQueueEntry_t* advFrame) {
     
     // store the ASN
!    ieee154e_vars.asn.bytes0and1   =     ieee154e_vars.dataReceived->payload[0]+
!                                     256*ieee154e_vars.dataReceived->payload[1];
!    ieee154e_vars.asn.bytes2and3   =     ieee154e_vars.dataReceived->payload[2]+
!                                     256*ieee154e_vars.dataReceived->payload[3];
!    ieee154e_vars.asn.byte4        =     ieee154e_vars.dataReceived->payload[4];
     
     // determine the current slotOffset
     /*
--- 1714,1742 ----
     ieee154e_vars.asnOffset   = (ieee154e_vars.asnOffset+1)%16;
  }
  
! //from upper layer that want to send the ASN to compute timing or latency
! port_INLINE void ieee154e_getAsn(uint8_t* array) {
!    array[0]         = (ieee154e_vars.asn.bytes0and1     & 0xff);
!    array[1]         = (ieee154e_vars.asn.bytes0and1/256 & 0xff);
!    array[2]         = (ieee154e_vars.asn.bytes2and3     & 0xff);
!    array[3]         = (ieee154e_vars.asn.bytes2and3/256 & 0xff);
!    array[4]         =  ieee154e_vars.asn.byte4;
  }
  
! port_INLINE void joinPriorityStoreFromAdv(uint8_t jp){
!   ieee154e_vars.dataReceived->l2_joinPriority = jp;
!   ieee154e_vars.dataReceived->l2_joinPriorityPresent = TRUE;     
  }
  
  
! port_INLINE void asnStoreFromAdv(uint8_t* asn) {
     
     // store the ASN
!    ieee154e_vars.asn.bytes0and1   =     asn[0]+
!                                     256*asn[1];
!    ieee154e_vars.asn.bytes2and3   =     asn[2]+
!                                     256*asn[3];
!    ieee154e_vars.asn.byte4        =     asn[4];
     
     // determine the current slotOffset
     /*
***************
*** 1624,1634 ****
  
  //======= synchronization
  
! void synchronizePacket(PORT_TIMER_WIDTH timeReceived) {
     PORT_SIGNED_INT_WIDTH  timeCorrection;
!    PORT_TIMER_WIDTH newPeriod;
!    PORT_TIMER_WIDTH currentValue;
!    PORT_TIMER_WIDTH currentPeriod;
     // record the current timer value and period
     currentValue                   =  radio_getTimerValue();
     currentPeriod                  =  radio_getTimerPeriod();
--- 1756,1766 ----
  
  //======= synchronization
  
! void synchronizePacket(PORT_RADIOTIMER_WIDTH timeReceived) {
     PORT_SIGNED_INT_WIDTH  timeCorrection;
!    PORT_RADIOTIMER_WIDTH newPeriod;
!    PORT_RADIOTIMER_WIDTH currentValue;
!    PORT_RADIOTIMER_WIDTH currentPeriod;
     // record the current timer value and period
     currentValue                   =  radio_getTimerValue();
     currentPeriod                  =  radio_getTimerPeriod();
***************
*** 1641,1647 ****
        newPeriod                  +=  TsSlotDuration;
        incrementAsnOffset();
     }
!    newPeriod                      =  (PORT_TIMER_WIDTH)((PORT_SIGNED_INT_WIDTH)newPeriod+timeCorrection);
     // resynchronize by applying the new period
     radio_setTimerPeriod(newPeriod);
     // reset the de-synchronization timeout
--- 1773,1779 ----
        newPeriod                  +=  TsSlotDuration;
        incrementAsnOffset();
     }
!    newPeriod                      =  (PORT_RADIOTIMER_WIDTH)((PORT_SIGNED_INT_WIDTH)newPeriod+timeCorrection);
     // resynchronize by applying the new period
     radio_setTimerPeriod(newPeriod);
     // reset the de-synchronization timeout
***************
*** 1664,1674 ****
  }
  
  void synchronizeAck(PORT_SIGNED_INT_WIDTH timeCorrection) {
!    PORT_TIMER_WIDTH newPeriod;
!    PORT_TIMER_WIDTH currentPeriod;
     // calculate new period
     currentPeriod                  =  radio_getTimerPeriod();
!    newPeriod                      =  (PORT_TIMER_WIDTH)((PORT_SIGNED_INT_WIDTH)currentPeriod-timeCorrection);
     // resynchronize by applying the new period
     radio_setTimerPeriod(newPeriod);
     // reset the de-synchronization timeout
--- 1796,1807 ----
  }
  
  void synchronizeAck(PORT_SIGNED_INT_WIDTH timeCorrection) {
!    PORT_RADIOTIMER_WIDTH newPeriod;
!    PORT_RADIOTIMER_WIDTH currentPeriod;
     // calculate new period
     currentPeriod                  =  radio_getTimerPeriod();
!    newPeriod                      =  (PORT_RADIOTIMER_WIDTH)((PORT_SIGNED_INT_WIDTH)currentPeriod-timeCorrection);
! 
     // resynchronize by applying the new period
     radio_setTimerPeriod(newPeriod);
     // reset the de-synchronization timeout
***************
*** 1704,1710 ****
  
  //======= notifying upper layer
  
! void notif_sendDone(OpenQueueEntry_t* packetSent, error_t error) {
     // record the outcome of the trasmission attempt
     packetSent->l2_sendDoneError   = error;
     // record the current ASN
--- 1837,1843 ----
  
  //======= notifying upper layer
  
! void notif_sendDone(OpenQueueEntry_t* packetSent, owerror_t error) {
     // record the outcome of the trasmission attempt
     packetSent->l2_sendDoneError   = error;
     // record the current ASN
***************
*** 1714,1719 ****
--- 1847,1855 ----
     packetSent->owner              = COMPONENT_IEEE802154E_TO_RES;
     // post RES's sendDone task
     scheduler_push_task(task_resNotifSendDone,TASKPRIO_RESNOTIF_TXDONE);
+    /*thread_create(openwsn_ieee802154e_send_stack, KERNEL_CONF_STACKSIZE_MAIN, 
+                   PRIORITY_OPENWSN_IEEE802154E, CREATE_STACKTEST, 
+                   task_resNotifSendDone, "task resNotifSendDone");*/
     // wake up the scheduler
     SCHEDULER_WAKEUP();
  }
***************
*** 1726,1744 ****
     // associate this packet with the virtual component
     // COMPONENT_IEEE802154E_TO_RES so RES can knows it's for it
     packetReceived->owner          = COMPONENT_IEEE802154E_TO_RES;
     // post RES's Receive task
     scheduler_push_task(task_resNotifReceive,TASKPRIO_RESNOTIF_RX);
     // wake up the scheduler
     SCHEDULER_WAKEUP();
  }
  
  //======= stats
  
! port_INLINE void resetStats() {
     ieee154e_stats.numSyncPkt      =    0;
     ieee154e_stats.numSyncAck      =    0;
     ieee154e_stats.minCorrection   =  127;
     ieee154e_stats.maxCorrection   = -127;
     // do not reset the number of de-synchronizations
  }
  
--- 1862,1885 ----
     // associate this packet with the virtual component
     // COMPONENT_IEEE802154E_TO_RES so RES can knows it's for it
     packetReceived->owner          = COMPONENT_IEEE802154E_TO_RES;
+ 
     // post RES's Receive task
     scheduler_push_task(task_resNotifReceive,TASKPRIO_RESNOTIF_RX);
+    /*thread_create(openwsn_ieee802154e_rec_stack, KERNEL_CONF_STACKSIZE_MAIN, 
+                   PRIORITY_OPENWSN_IEEE802154E, CREATE_STACKTEST, 
+                   task_resNotifSendDone, "task resNotifSendDone");*/
     // wake up the scheduler
     SCHEDULER_WAKEUP();
  }
  
  //======= stats
  
! port_INLINE void resetStats(void) {
     ieee154e_stats.numSyncPkt      =    0;
     ieee154e_stats.numSyncAck      =    0;
     ieee154e_stats.minCorrection   =  127;
     ieee154e_stats.maxCorrection   = -127;
+    ieee154e_stats.dutyCycle       =    0;
     // do not reset the number of de-synchronizations
  }
  
***************
*** 1769,1775 ****
  to use a single-channel sniffer; but you can not schedule two links on two
  different channel offsets in the same slot.
  
! \param [in] channelOffset channel offset for the current slot
  
  \returns The calculated frequency channel, an integer between 11 and 26.
  */
--- 1910,1916 ----
  to use a single-channel sniffer; but you can not schedule two links on two
  different channel offsets in the same slot.
  
! \param[in] channelOffset channel offset for the current slot
  
  \returns The calculated frequency channel, an integer between 11 and 26.
  */
***************
*** 1785,1791 ****
  Besides simply updating the state global variable,
  this function toggles the FSM debug pin.
  
! \param [in] newstate The state the IEEE802.15.4e FSM is now in.
  */
  void changeState(ieee154e_state_t newstate) {
     // update the state
--- 1926,1932 ----
  Besides simply updating the state global variable,
  this function toggles the FSM debug pin.
  
! \param[in] newstate The state the IEEE802.15.4e FSM is now in.
  */
  void changeState(ieee154e_state_t newstate) {
     // update the state
***************
*** 1839,1848 ****
  function should already have been done. If this is not the case, this function
  will do that for you, but assume that something went wrong.
  */
! void endSlot() {
     // turn off the radio
     radio_rfOff();
!    
     // clear any pending timer
     radiotimer_cancel();
     
--- 1980,1994 ----
  function should already have been done. If this is not the case, this function
  will do that for you, but assume that something went wrong.
  */
! void endSlot(void) {
!   
!    float aux; //duty cycle helper.
     // turn off the radio
     radio_rfOff();
!    // compute the duty cycle if radio has been turned on
!    if (ieee154e_vars.radioOnThisSlot==TRUE){  
!       ieee154e_vars.radioOnTics+=(radio_getTimerValue()-ieee154e_vars.radioOnInit);
!    }
     // clear any pending timer
     radiotimer_cancel();
     
***************
*** 1850,1855 ****
--- 1996,2008 ----
     ieee154e_vars.lastCapturedTime = 0;
     ieee154e_vars.syncCapturedTime = 0;
     
+    //instant duty cycle.. average is computed at debugprint_macstats.
+    aux=(float)ieee154e_vars.radioOnTics/(float)radio_getTimerPeriod();
+    ieee154e_stats.dutyCycle+=aux;//accumulate and avg will be done on serial print
+    //clear vars for duty cycle on this slot   
+    ieee154e_vars.radioOnTics=0;
+    ieee154e_vars.radioOnThisSlot=FALSE;
+    
     // clean up dataToSend
     if (ieee154e_vars.dataToSend!=NULL) {
        // if everything went well, dataToSend was set to NULL in ti9
***************
*** 1899,1908 ****
        ieee154e_vars.ackReceived = NULL;
     }
     
     // change state
     changeState(S_SLEEP);
  }
  
! bool ieee154e_isSynch(){
     return ieee154e_vars.isSync;
! }
\ No newline at end of file
--- 2052,2062 ----
        ieee154e_vars.ackReceived = NULL;
     }
     
+    
     // change state
     changeState(S_SLEEP);
  }
  
! bool ieee154e_isSynch(void){
     return ieee154e_vars.isSync;
! }
diff -crB stock/openwsn/02a-MAClow/IEEE802154E.h dev/openwsn/02a-MAClow/IEEE802154E.h
*** stock/openwsn/02a-MAClow/IEEE802154E.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/02a-MAClow/IEEE802154E.h	Wed Jan 29 10:33:22 2014
***************
*** 10,15 ****
--- 10,16 ----
  
  #include "openwsn.h"
  #include "board_info.h"
+ #include "schedule.h"
  
  //=========================== debug define ====================================
  
***************
*** 25,30 ****
--- 26,79 ----
  #define LIMITLARGETIMECORRECTION     5 // threshold number of ticks to declare a timeCorrection "large"
  #define LENGTH_IEEE154_MAX         128 // max length of a valid radio packet  
  
+ //15.4e information elements related
+ #define IEEE802154E_PAYLOAD_DESC_LEN_SHIFT              0x04
+ #define IEEE802154E_PAYLOAD_DESC_GROUP_ID_MLME         (0x01 << 1) //includes shift 1
+ #define IEEE802154E_DESC_TYPE_LONG                      0x01
+ #define IEEE802154E_DESC_TYPE_SHORT                     0x00
+ 
+ #define IEEE802154E_DESC_TYPE_HEADER_IE                 0x00
+ #define IEEE802154E_DESC_TYPE_PAYLOAD_IE                0x01
+ //len field on PAYLOAD/HEADER DESC
+ #define IEEE802154E_DESC_LEN_HEADER_IE_MASK             0xFE00
+ #define IEEE802154E_DESC_LEN_PAYLOAD_IE_MASK            0xFFE0
+ 
+ #define IEEE802154E_DESC_LEN_HEADER_IE_SHIFT            9
+ #define IEEE802154E_DESC_LEN_PAYLOAD_IE_SHIFT           5
+ 
+ //groupID/elementID field on PAYLOAD/HEADER DESC
+ #define IEEE802154E_DESC_ELEMENTID_HEADER_IE_MASK       0x01FE
+ #define IEEE802154E_DESC_GROUPID_PAYLOAD_IE_MASK        0x001E
+ 
+ #define IEEE802154E_DESC_ELEMENTID_HEADER_IE_SHIFT      1
+ #define IEEE802154E_DESC_GROUPID_PAYLOAD_IE_SHIFT       1
+ 
+ //MLME Sub IE LONG page 83
+ #define IEEE802154E_DESC_LEN_LONG_MLME_IE_MASK          0xFFE0
+ #define IEEE802154E_DESC_SUBID_LONG_MLME_IE_MASK        0x001E
+ 
+ #define IEEE802154E_DESC_LEN_LONG_MLME_IE_SHIFT         5
+ #define IEEE802154E_DESC_SUBID_LONG_MLME_IE_SHIFT       1
+ 
+ //MLME Sub IE SHORT page 82
+ #define IEEE802154E_DESC_LEN_SHORT_MLME_IE_MASK          0xFF00
+ #define IEEE802154E_DESC_SUBID_SHORT_MLME_IE_MASK        0x00FE
+ 
+ #define IEEE802154E_DESC_LEN_SHORT_MLME_IE_SHIFT         8
+ #define IEEE802154E_DESC_SUBID_SHORT_MLME_IE_SHIFT       1
+ 
+ 
+ #define IEEE802154E_MLME_SYNC_IE_SUBID                  0x1A
+ #define IEEE802154E_MLME_SYNC_IE_SUBID_SHIFT            1
+ #define IEEE802154E_MLME_SLOTFRAME_LINK_IE_SUBID        0x1B
+ #define IEEE802154E_MLME_SLOTFRAME_LINK_IE_SUBID_SHIFT  1
+ #define IEEE802154E_MLME_TIMESLOT_IE_SUBID              0x1c
+ #define IEEE802154E_MLME_TIMESLOT_IE_SUBID_SHIFT        1
+ 
+ #define IEEE802154E_MLME_IE_GROUPID                     0x01
+ #define IEEE802154E_ACK_NACK_TIMECORRECTION_ELEMENTID   0x1E
+ 
+ #define IEEE802154E_
  /**
  When a packet is received, it is written inside the OpenQueueEntry_t->packet
  buffer, starting at the byte defined below. When a packet is relayed, it
***************
*** 81,86 ****
--- 130,136 ----
     TsLongGT                  =   43,                  //  1300us
     TsTxAckDelay              =  151,                  //  4606us
     TsShortGT                 =   16,                  //   500us
+ //   TsShortGT                 =   30,                  //   900us, stm32 can work well with this value
     TsSlotDuration            =  PORT_TsSlotDuration,  // 15000us
     // execution speed related
     maxTxDataPrepare          =  PORT_maxTxDataPrepare,
***************
*** 97,102 ****
--- 147,159 ----
  };
  
  
+ //shift of bytes in the linkOption bitmap
+ enum ieee154e_linkOption_enum {
+    FLAG_TX_S              = 7,
+    FLAG_RX_S              = 6,
+    FLAG_SHARED_S          = 5,
+    FLAG_TIMEKEEPING_S     = 4,   
+ };
  
  // FSM timer durations (combinations of atomic durations)
  // TX
***************
*** 125,150 ****
     PORT_SIGNED_INT_WIDTH timeCorrection;
  } IEEE802154E_ACK_ht;
  
! #define ADV_PAYLOAD_LENGTH 5
  
! //=========================== variables =======================================
  
  //=========================== prototypes ======================================
  
  // admin
! void               ieee154e_init();
  // public
! PORT_TIMER_WIDTH   ieee154e_asnDiff(asn_t* someASN);
! bool               ieee154e_isSynch();
! void               asnWriteToPkt(OpenQueueEntry_t* frame);
! void               asnWriteToSerial(uint8_t* array);
  // events
! void               ieee154e_startOfFrame(PORT_TIMER_WIDTH capturedTime);
! void               ieee154e_endOfFrame(PORT_TIMER_WIDTH capturedTime);
  // misc
! bool               debugPrint_asn();
! bool               debugPrint_isSync();
! bool               debugPrint_macStats();
  
  /**
  \}
--- 182,304 ----
     PORT_SIGNED_INT_WIDTH timeCorrection;
  } IEEE802154E_ACK_ht;
  
! //includes payload header IE short + MLME short Header + Sync IE
! #define ADV_PAYLOAD_LENGTH sizeof(payload_IE_descriptor_t) + \
!                            sizeof(MLME_IE_subHeader_t)     + \
!                            sizeof(synch_IE_t)
! 
! 
! 
! 
! //=========================== module variables ================================
! 
! typedef struct {
!    // misc
!    asn_t              asn;                  // current absolute slot number
!    slotOffset_t       slotOffset;           // current slot offset
!    slotOffset_t       nextActiveSlotOffset; // next active slot offset
!    PORT_RADIOTIMER_WIDTH   deSyncTimeout;        // how many slots left before looses sync
!    bool               isSync;               // TRUE iff mote is synchronized to network
!    // as shown on the chronogram
!    ieee154e_state_t   state;                // state of the FSM
!    OpenQueueEntry_t*  dataToSend;           // pointer to the data to send
!    OpenQueueEntry_t*  dataReceived;         // pointer to the data received
!    OpenQueueEntry_t*  ackToSend;            // pointer to the ack to send
!    OpenQueueEntry_t*  ackReceived;          // pointer to the ack received
!    PORT_RADIOTIMER_WIDTH   lastCapturedTime;     // last captured time
!    PORT_RADIOTIMER_WIDTH   syncCapturedTime;     // captured time used to sync
!    //channel hopping
!    uint8_t            freq;                 // frequency of the current slot
!    uint8_t            asnOffset;            // offset inside the frame
!    
!    PORT_RADIOTIMER_WIDTH radioOnInit;  //when within the slot the radio turns on
!    PORT_RADIOTIMER_WIDTH radioOnTics;//how many tics within the slot the radio is on
!    bool             radioOnThisSlot; //to control if the radio has been turned on in a slot.
! } ieee154e_vars_t;
! 
! PRAGMA(pack(1));
! typedef struct {
!    uint8_t                   numSyncPkt;    // how many times synchronized on a non-ACK packet
!    uint8_t                   numSyncAck;    // how many times synchronized on an ACK
!    PORT_SIGNED_INT_WIDTH     minCorrection; // minimum time correction
!    PORT_SIGNED_INT_WIDTH     maxCorrection; // maximum time correction
!    uint8_t                   numDeSync;     // number of times a desync happened
!    float                     dutyCycle;     // mac dutyCycle at each superframe
! } ieee154e_stats_t;
! PRAGMA(pack());
  
! typedef struct {
!    PORT_RADIOTIMER_WIDTH          num_newSlot;
!    PORT_RADIOTIMER_WIDTH          num_timer;
!    PORT_RADIOTIMER_WIDTH          num_startOfFrame;
!    PORT_RADIOTIMER_WIDTH          num_endOfFrame;
! } ieee154e_dbg_t;
! 
! 
! //=========================== IEs =============================================
! //the header for all header IEs
! typedef struct{
!    uint16_t length_elementid_type; 
! }header_IE_descriptor_t; 
! //header descriptor. elementid will be 0 as described in 15.4e pag. 81
! //type is 0 as described on p. 80
! 
! 
! //the content for ack ie -- it is a header IE with values - element id =0x1e len=2 type=0
! PRAGMA(pack(1));
! typedef struct {
!     int16_t timesync_info;
! }ack_timecorrection_IE_t;
! PRAGMA(pack());
! //the header for all payload IEs
! 
! 
! typedef struct{//11b len 4b gid 1b type
!    uint16_t length_groupid_type; //bytes on the IE content- that is the embedded MLME or Header IE.
!   //groupid == 0x01 MLME | type long = 1
! }payload_IE_descriptor_t; // payload descriptor. groupid will be 1 as described in 15.4e pag. 81
! 
! //MLME sub id header appended to payload descriptor. we use group id=1 type=1
! typedef struct{
!    uint16_t length_subID_type;
! }MLME_IE_subHeader_t;
! 
! //the Synchronization IE. it is a payload IE with values - subid=0x1a type=0 (short) len=6 
! PRAGMA(pack(1));
! typedef struct {
!     uint8_t asn[5];
!     uint8_t join_priority;
! }synch_IE_t;
! PRAGMA(pack());
! 
! //the Slotframe and Link IE
! typedef struct {
!     uint8_t slotframehandle;
!     uint16_t slotframesize;
!     uint8_t numlinks;
! }slotframelink_IE_t;
! 
! typedef struct {
!     uint16_t tsNum;
!     uint16_t choffset;
!     uint8_t linkoptions;
! }linkInfo_subIE_t;
  
  //=========================== prototypes ======================================
  
  // admin
! void               ieee154e_init(void);
  // public
! PORT_RADIOTIMER_WIDTH   ieee154e_asnDiff(asn_t* someASN);
! bool               ieee154e_isSynch(void);
! void               ieee154e_getAsn(uint8_t* array);
  // events
! void               ieee154e_startOfFrame(PORT_RADIOTIMER_WIDTH capturedTime);
! void               ieee154e_endOfFrame(PORT_RADIOTIMER_WIDTH capturedTime);
  // misc
! bool               debugPrint_asn(void);
! bool               debugPrint_isSync(void);
! bool               debugPrint_macStats(void);
  
  /**
  \}
diff -crB stock/openwsn/02a-MAClow/Makefile dev/openwsn/02a-MAClow/Makefile
*** stock/openwsn/02a-MAClow/Makefile	Tue Jan 28 12:35:56 2014
--- dev/openwsn/02a-MAClow/Makefile	Wed Jan 29 10:33:22 2014
***************
*** 0 ****
--- 1,32 ----
+ SUBMOD:=$(shell basename $(CURDIR)).a
+ #BINDIR = $(RIOTBASE)/bin/
+ SRC = $(wildcard *.c)
+ OBJ = $(SRC:%.c=$(BINDIR)%.o)
+ DEP = $(SRC:%.c=$(BINDIR)%.d)
+ 
+ INCLUDES += -I$(RIOTBASE) -I$(RIOTBASE)/sys/include -I$(RIOTBASE)/core/include -I$(RIOTBASE)/drivers/include -I$(RIOTBASE)/drivers/cc110x_ng/include -I$(RIOTBASE)/cpu/arm_common/include -I$(RIOTBASE)/sys/net/include/
+ INCLUDES += -I$(CURDIR)/02a-MAClow
+ INCLUDES += -I$(CURDIR)/02b-MAChigh
+ INCLUDES += -I$(CURDIR)/03a-IPHC
+ INCLUDES += -I$(CURDIR)/03b-IPv6
+ INCLUDES += -I$(CURDIR)/04-TRAN
+ INCLUDES += -I$(CURDIR)/cross-layers
+ 
+ .PHONY: $(BINDIR)$(SUBMOD)
+ 
+ $(BINDIR)$(SUBMOD): $(OBJ)
+ 	$(AD)$(AR) rcs $(BINDIR)$(MODULE) $(OBJ)
+ 
+ # pull in dependency info for *existing* .o files
+ -include $(OBJ:.o=.d)
+ 
+ # compile and generate dependency info
+ $(BINDIR)%.o: %.c
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -c $*.c -o $(BINDIR)$*.o
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -MM $*.c > $(BINDIR)$*.d
+ 	@printf "$(BINDIR)" | cat - $(BINDIR)$*.d > /tmp/riot_out && mv /tmp/riot_out $(BINDIR)$*.d
+ 
+ # remove compilation products
+ 
+ clean:
+ 	rm -f $(OBJ) $(DEP)
diff -crB stock/openwsn/02a-MAClow/stupidmac/Makefile dev/openwsn/02a-MAClow/stupidmac/Makefile
*** stock/openwsn/02a-MAClow/stupidmac/Makefile	Tue Jan 28 12:35:56 2014
--- dev/openwsn/02a-MAClow/stupidmac/Makefile	Wed Jan 29 10:33:22 2014
***************
*** 0 ****
--- 1,4 ----
+ MODULE:=$(shell basename $(CURDIR))
+ INCLUDES += -I$(RIOTBASE) -I$(RIOTBASE)/sys/include -I$(RIOTBASE)/core/include -I$(RIOTBASE)/drivers/include -I$(RIOTBASE)/drivers/cc110x_ng/include -I$(RIOTBASE)/cpu/arm_common/include -I$(RIOTBASE)/sys/net/include/
+ 
+ include $(RIOTBASE)/Makefile.base
\ No newline at end of file
diff -crB stock/openwsn/02a-MAClow/stupidmac/stupidmac.c dev/openwsn/02a-MAClow/stupidmac/stupidmac.c
*** stock/openwsn/02a-MAClow/stupidmac/stupidmac.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/02a-MAClow/stupidmac/stupidmac.c	Wed Jan 29 10:33:22 2014
***************
*** 31,44 ****
  //=========================== prototypes ======================================
  
  #include "IEEE802154_common.c"
! void packetReceived();
! void armRandomBackoffTimer();
  void change_state(uint8_t newstate);
  
  //======= from upper layer
  
  //in stupidMAC, the radio is always on, listening
! void stupidmac_init() {
     radio_rxOn(openwsn_frequency_channel);
     change_state(S_IDLE_LISTENING);
     stupidmac_dataFrameToSend = NULL;
--- 31,44 ----
  //=========================== prototypes ======================================
  
  #include "IEEE802154_common.c"
! void packetReceived(void);
! void armRandomBackoffTimer(void);
  void change_state(uint8_t newstate);
  
  //======= from upper layer
  
  //in stupidMAC, the radio is always on, listening
! void stupidmac_init(void) {
     radio_rxOn(openwsn_frequency_channel);
     change_state(S_IDLE_LISTENING);
     stupidmac_dataFrameToSend = NULL;
***************
*** 238,244 ****
  
  //=========================== private =========================================
  
! void packetReceived() {
     if (stupidmac_dataFrameReceived->length>0) {
        //packet contains payload destined to an upper layer
        nores_receive(stupidmac_dataFrameReceived);
--- 238,244 ----
  
  //=========================== private =========================================
  
! void packetReceived(void) {
     if (stupidmac_dataFrameReceived->length>0) {
        //packet contains payload destined to an upper layer
        nores_receive(stupidmac_dataFrameReceived);
***************
*** 249,255 ****
     stupidmac_dataFrameReceived = NULL;
  }
  
! void armRandomBackoffTimer() {
     timer_startOneShot(TIMER_MAC_BACKOFF,MINBACKOFF); //TODO randomize
  }
  
--- 249,255 ----
     stupidmac_dataFrameReceived = NULL;
  }
  
! void armRandomBackoffTimer(void) {
     timer_startOneShot(TIMER_MAC_BACKOFF,MINBACKOFF); //TODO randomize
  }
  
***************
*** 271,284 ****
     }
  }
  
! bool stupidmac_debugPrint() {
     return FALSE;
  }
  
  //======= timers firing
  
  //periodic timer used to transmit, and to trigger serial input/output
! void timer_mac_periodic_fired() {
  #ifndef SERIALINSCHEDULER
     openserial_stop();
  #endif
--- 271,284 ----
     }
  }
  
! bool stupidmac_debugPrint(void) {
     return FALSE;
  }
  
  //======= timers firing
  
  //periodic timer used to transmit, and to trigger serial input/output
! void timer_mac_periodic_fired(void) {
  #ifndef SERIALINSCHEDULER
     openserial_stop();
  #endif
***************
*** 297,303 ****
  
  //this function is the one which really initiates the transmission of a packet.
  //It only does so if the MAC layer is in S_IDLE_LISTENING stupidmac_state, otherwise it defers
! void timer_mac_backoff_fired() {
     if (stupidmac_state==S_IDLE_LISTENING) {
        if (stupidmac_dataFrameToSend!=NULL) {
           openserial_printError(COMPONENT_MAC,ERR_DATAFRAMETOSEND_ERROR,
--- 297,303 ----
  
  //this function is the one which really initiates the transmission of a packet.
  //It only does so if the MAC layer is in S_IDLE_LISTENING stupidmac_state, otherwise it defers
! void timer_mac_backoff_fired(void) {
     if (stupidmac_state==S_IDLE_LISTENING) {
        if (stupidmac_dataFrameToSend!=NULL) {
           openserial_printError(COMPONENT_MAC,ERR_DATAFRAMETOSEND_ERROR,
***************
*** 326,332 ****
     }
  }
  
! void timer_mac_watchdog_fired() {
     switch (stupidmac_state) {
        case S_TX_RXACK:
           //I'm a transmitter, didn't receive ACK (end of TX sequence).
--- 326,332 ----
     }
  }
  
! void timer_mac_watchdog_fired(void) {
     switch (stupidmac_state) {
        case S_TX_RXACK:
           //I'm a transmitter, didn't receive ACK (end of TX sequence).
diff -crB stock/openwsn/02a-MAClow/stupidmac/stupidmac.h dev/openwsn/02a-MAClow/stupidmac/stupidmac.h
*** stock/openwsn/02a-MAClow/stupidmac/stupidmac.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/02a-MAClow/stupidmac/stupidmac.h	Wed Jan 29 10:33:22 2014
***************
*** 47,60 ****
     ACK_WAIT_TIME         =    327, // 10ms
  };
  
! void    stupidmac_init();
! error_t stupidmac_send(OpenQueueEntry_t* msg);
! void    stupidmac_sendDone(OpenQueueEntry_t* msg, error_t error);
  void    stupidmac_packet_received(OpenQueueEntry_t* pkt);
! void    stupidmac_sendDone(OpenQueueEntry_t* packetReceived, error_t error);
! void    timer_mac_backoff_fired();
! void    timer_mac_watchdog_fired();
! void    timer_mac_periodic_fired();
! bool    stupidmac_debugPrint();
  
  #endif
--- 47,60 ----
     ACK_WAIT_TIME         =    327, // 10ms
  };
  
! void    stupidmac_init(void);
! owerror_t stupidmac_send(OpenQueueEntry_t* msg);
! void    stupidmac_sendDone(OpenQueueEntry_t* msg, owerror_t error);
  void    stupidmac_packet_received(OpenQueueEntry_t* pkt);
! void    stupidmac_sendDone(OpenQueueEntry_t* packetReceived, owerror_t error);
! void    timer_mac_backoff_fired(void);
! void    timer_mac_watchdog_fired(void);
! void    timer_mac_periodic_fired(void);
! bool    stupidmac_debugPrint(void);
  
  #endif
diff -crB stock/openwsn/02a-MAClow/topology.c dev/openwsn/02a-MAClow/topology.c
*** stock/openwsn/02a-MAClow/topology.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/02a-MAClow/topology.c	Wed Jan 29 10:33:22 2014
***************
*** 4,13 ****
  
  //=========================== defines =========================================
  
! #define TOPOLOGY_MOTE1 0x6f
! #define TOPOLOGY_MOTE2 0xb9
! #define TOPOLOGY_MOTE3 0x3b
! 
  //=========================== variables =======================================
  
  //=========================== prototypes ======================================
--- 4,13 ----
  
  //=========================== defines =========================================
  
! #define TOPOLOGY_MOTE1 0x01
! #define TOPOLOGY_MOTE2 0x02
! #define TOPOLOGY_MOTE3 0x03
! #define TOPOLOGY_MOTE4 0x04
  //=========================== variables =======================================
  
  //=========================== prototypes ======================================
***************
*** 32,39 ****
              returnVal=FALSE;
           }
           break;
!       case TOPOLOGY_MOTE3:
!          if (ieee802514_header->src.addr_64b[7]==TOPOLOGY_MOTE2) {
              returnVal=TRUE;
           } else {
              returnVal=FALSE;
--- 32,47 ----
              returnVal=FALSE;
           }
           break;
!        case TOPOLOGY_MOTE3:
!          if (ieee802514_header->src.addr_64b[7]==TOPOLOGY_MOTE2 ||
!              ieee802514_header->src.addr_64b[7]==TOPOLOGY_MOTE4) {
!             returnVal=TRUE;
!          } else {
!             returnVal=FALSE;
!          }
!          break;
!        case TOPOLOGY_MOTE4:
!          if (ieee802514_header->src.addr_64b[7]==TOPOLOGY_MOTE3) {
              returnVal=TRUE;
           } else {
              returnVal=FALSE;
diff -crB stock/openwsn/02b-MAChigh/Makefile dev/openwsn/02b-MAChigh/Makefile
*** stock/openwsn/02b-MAChigh/Makefile	Tue Jan 28 12:35:56 2014
--- dev/openwsn/02b-MAChigh/Makefile	Wed Jan 29 10:33:22 2014
***************
*** 0 ****
--- 1,32 ----
+ SUBMOD:=$(shell basename $(CURDIR)).a
+ #BINDIR = $(RIOTBASE)/bin/
+ SRC = $(wildcard *.c)
+ OBJ = $(SRC:%.c=$(BINDIR)%.o)
+ DEP = $(SRC:%.c=$(BINDIR)%.d)
+ 
+ INCLUDES += -I$(RIOTBASE) -I$(RIOTBASE)/sys/include -I$(RIOTBASE)/core/include -I$(RIOTBASE)/drivers/include -I$(RIOTBASE)/drivers/cc110x_ng/include -I$(RIOTBASE)/cpu/arm_common/include -I$(RIOTBASE)/sys/net/include/
+ INCLUDES += -I$(CURDIR)/02a-MAClow
+ INCLUDES += -I$(CURDIR)/02b-MAChigh
+ INCLUDES += -I$(CURDIR)/03a-IPHC
+ INCLUDES += -I$(CURDIR)/03b-IPv6
+ INCLUDES += -I$(CURDIR)/04-TRAN
+ INCLUDES += -I$(CURDIR)/cross-layers
+ 
+ .PHONY: $(BINDIR)$(SUBMOD)
+ 
+ $(BINDIR)$(SUBMOD): $(OBJ)
+ 	$(AD)$(AR) rcs $(BINDIR)$(MODULE) $(OBJ)
+ 
+ # pull in dependency info for *existing* .o files
+ -include $(OBJ:.o=.d)
+ 
+ # compile and generate dependency info
+ $(BINDIR)%.o: %.c
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -c $*.c -o $(BINDIR)$*.o
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -MM $*.c > $(BINDIR)$*.d
+ 	@printf "$(BINDIR)" | cat - $(BINDIR)$*.d > /tmp/riot_out && mv /tmp/riot_out $(BINDIR)$*.d
+ 
+ # remove compilation products
+ 
+ clean:
+ 	rm -f $(OBJ) $(DEP)
diff -crB stock/openwsn/02b-MAChigh/neighbors.c dev/openwsn/02b-MAChigh/neighbors.c
*** stock/openwsn/02b-MAChigh/neighbors.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/02b-MAChigh/neighbors.c	Wed Jan 29 10:33:22 2014
***************
*** 8,20 ****
  
  //=========================== variables =======================================
  
- typedef struct {
-    neighborRow_t        neighbors[MAXNUMNEIGHBORS];
-    dagrank_t            myDAGrank;
-    uint8_t              debugRow;
-    icmpv6rpl_dio_ht*    dio; //keep it global to be able to debug correctly.
- } neighbors_vars_t;
- 
  neighbors_vars_t neighbors_vars;
  
  //=========================== prototypes ======================================
--- 8,13 ----
***************
*** 22,28 ****
  void registerNewNeighbor(
          open_addr_t* neighborID,
          int8_t       rssi,
!         asn_t*       asnTimestamp
       );
  bool isNeighbor(open_addr_t* neighbor);
  void removeNeighbor(uint8_t neighborIndex);
--- 15,23 ----
  void registerNewNeighbor(
          open_addr_t* neighborID,
          int8_t       rssi,
!         asn_t*       asnTimestamp,
!         bool         joinPrioPresent,
!         uint8_t      joinPrio
       );
  bool isNeighbor(open_addr_t* neighbor);
  void removeNeighbor(uint8_t neighborIndex);
***************
*** 36,42 ****
  /**
  \brief Initializes this module.
  */
! void neighbors_init() {
     
     // clear module variables
     memset(&neighbors_vars,0,sizeof(neighbors_vars_t));
--- 31,37 ----
  /**
  \brief Initializes this module.
  */
! void neighbors_init(void) {
     
     // clear module variables
     memset(&neighbors_vars,0,sizeof(neighbors_vars_t));
***************
*** 56,62 ****
  
  \returns This mote's current DAG rank.
  */
! dagrank_t neighbors_getMyDAGrank() {
     return neighbors_vars.myDAGrank;
  }
  
--- 51,57 ----
  
  \returns This mote's current DAG rank.
  */
! dagrank_t neighbors_getMyDAGrank(void) {
     return neighbors_vars.myDAGrank;
  }
  
***************
*** 65,71 ****
  
  \returns The number of neighbors this mote's currently knows of.
  */
! uint8_t neighbors_getNumNeighbors() {
     uint8_t i;
     uint8_t returnVal;
     
--- 60,66 ----
  
  \returns The number of neighbors this mote's currently knows of.
  */
! uint8_t neighbors_getNumNeighbors(void) {
     uint8_t i;
     uint8_t returnVal;
     
***************
*** 81,87 ****
  /**
  \brief Retrieve my preferred parent's EUI64 address.
  
! \param [out] addressToWrite Where to write the preferred parent's address to.
  */
  bool neighbors_getPreferredParentEui64(open_addr_t* addressToWrite) {
     uint8_t   i;
--- 76,82 ----
  /**
  \brief Retrieve my preferred parent's EUI64 address.
  
! \param[out] addressToWrite Where to write the preferred parent's address to.
  */
  bool neighbors_getPreferredParentEui64(open_addr_t* addressToWrite) {
     uint8_t   i;
***************
*** 140,146 ****
  
  \returns A pointer to the neighbor's address, or NULL if no KA is needed.
  */
! open_addr_t* neighbors_getKANeighbor() {
     uint8_t         i;
     uint16_t        timeSinceHeard;
     open_addr_t*    addrPreferred;
--- 135,141 ----
  
  \returns A pointer to the neighbor's address, or NULL if no KA is needed.
  */
! open_addr_t* neighbors_getKANeighbor(void) {
     uint8_t         i;
     uint16_t        timeSinceHeard;
     open_addr_t*    addrPreferred;
***************
*** 185,191 ****
  /**
  \brief Indicate whether some neighbor is a stable neighbor
  
! \param address [in] The address of the neighbor, a full 128-bit IPv6 addres.
  
  \returns TRUE if that neighbor is stable, FALSE otherwise.
  */
--- 180,186 ----
  /**
  \brief Indicate whether some neighbor is a stable neighbor
  
! \param[in] address The address of the neighbor, a full 128-bit IPv6 addres.
  
  \returns TRUE if that neighbor is stable, FALSE otherwise.
  */
***************
*** 224,230 ****
  /**
  \brief Indicate whether some neighbor is a preferred neighbor.
  
! \param address [in] The EUI64 address of the neighbor.
  
  \returns TRUE if that neighbor is preferred, FALSE otherwise.
  */
--- 219,225 ----
  /**
  \brief Indicate whether some neighbor is a preferred neighbor.
  
! \param[in] address The EUI64 address of the neighbor.
  
  \returns TRUE if that neighbor is preferred, FALSE otherwise.
  */
***************
*** 253,259 ****
  /**
  \brief Indicate whether some neighbor has a lower DAG rank that me.
  
! \param index [in] The index of that neighbor in the neighbor table.
  
  \returns TRUE if that neighbor has a lower DAG rank than me, FALSE otherwise.
  */
--- 248,254 ----
  /**
  \brief Indicate whether some neighbor has a lower DAG rank that me.
  
! \param[in] index The index of that neighbor in the neighbor table.
  
  \returns TRUE if that neighbor has a lower DAG rank than me, FALSE otherwise.
  */
***************
*** 274,280 ****
  /**
  \brief Indicate whether some neighbor has a lower DAG rank that me.
  
! \param index [in] The index of that neighbor in the neighbor table.
  
  \returns TRUE if that neighbor has a lower DAG rank than me, FALSE otherwise.
  */
--- 269,275 ----
  /**
  \brief Indicate whether some neighbor has a lower DAG rank that me.
  
! \param[in] index The index of that neighbor in the neighbor table.
  
  \returns TRUE if that neighbor has a lower DAG rank than me, FALSE otherwise.
  */
***************
*** 306,319 ****
  - stableNeighbor
  - switchStabilityCounter
  
! \param l2_src [in] MAC source address of the packet, i.e. the neighbor who sent
!                    the packet just received.
! \param rssi   [in] RSSI with which this packet was received.
! \param asnTs  [in] ASN at which this packet was received.
  */
  void neighbors_indicateRx(open_addr_t* l2_src,
                            int8_t       rssi,
!                           asn_t*       asnTs) {
     uint8_t i;
     bool    newNeighbor;
     
--- 301,316 ----
  - stableNeighbor
  - switchStabilityCounter
  
! \param[in] l2_src MAC source address of the packet, i.e. the neighbor who sent
!    the packet just received.
! \param[in] rssi   RSSI with which this packet was received.
! \param[in] asnTs  ASN at which this packet was received.
  */
  void neighbors_indicateRx(open_addr_t* l2_src,
                            int8_t       rssi,
!                           asn_t*       asnTs,
!                           bool         joinPrioPresent,
!                           uint8_t      joinPrio) {
     uint8_t i;
     bool    newNeighbor;
     
***************
*** 329,334 ****
--- 326,335 ----
           neighbors_vars.neighbors[i].numRx++;
           neighbors_vars.neighbors[i].rssi=rssi;
           memcpy(&neighbors_vars.neighbors[i].asn,asnTs,sizeof(asn_t));
+          //update jp
+          if (joinPrioPresent==TRUE){
+             neighbors_vars.neighbors[i].joinPrio=joinPrio;
+          }
           
           // update stableNeighbor, switchStabilityCounter
           if (neighbors_vars.neighbors[i].stableNeighbor==FALSE) {
***************
*** 360,366 ****
     
     // register new neighbor
     if (newNeighbor==TRUE) {
!       registerNewNeighbor(l2_src, rssi, asnTs);
     }
  }
  
--- 361,367 ----
     
     // register new neighbor
     if (newNeighbor==TRUE) {
!       registerNewNeighbor(l2_src, rssi, asnTs, joinPrioPresent,joinPrio);
     }
  }
  
***************
*** 375,386 ****
  - numTxACK
  - asn
  
! \param l2_dest [in] MAC destination address of the packet, i.e. the neighbor
!                     who I just sent the packet to.
! \param numTxAttempts [in] Number of transmission attempts to this neighbor.
! \param was_finally_acked [in] TRUE iff the packet was ACK'ed by the neighbor
!                on final transmission attempt.
! \param asnTs   [in] ASN of the last transmission attempt.
  */
  void neighbors_indicateTx(open_addr_t* l2_dest,
                            uint8_t      numTxAttempts,
--- 376,387 ----
  - numTxACK
  - asn
  
! \param[in] l2_dest MAC destination address of the packet, i.e. the neighbor
!    who I just sent the packet to.
! \param[in] numTxAttempts Number of transmission attempts to this neighbor.
! \param[in] was_finally_acked TRUE iff the packet was ACK'ed by the neighbor
!    on final transmission attempt.
! \param[in] asnTs ASN of the last transmission attempt.
  */
  void neighbors_indicateTx(open_addr_t* l2_dest,
                            uint8_t      numTxAttempts,
***************
*** 423,430 ****
  The fields which are updated are:
  - DAGrank
  
! \param msg  [in] The received message with msg->payload pointing to the DIO
!                  header.
  */
  void neighbors_indicateRxDIO(OpenQueueEntry_t* msg) {
     uint8_t          i;
--- 424,431 ----
  The fields which are updated are:
  - DAGrank
  
! \param[in] msg The received message with msg->payload pointing to the DIO
!    header.
  */
  void neighbors_indicateRxDIO(OpenQueueEntry_t* msg) {
     uint8_t          i;
***************
*** 438,448 ****
        for (i=0;i<MAXNUMNEIGHBORS;i++) {
           if (isThisRowMatching(&(msg->l2_nextORpreviousHop),i)) {
              if (
!                   neighbors_vars.dio->rank>neighbors_vars.neighbors[i].DAGrank &&
!                   neighbors_vars.dio->rank - neighbors_vars.neighbors[i].DAGrank>DEFAULTLINKCOST
                 ) {
                  // the new DAGrank looks suspiciously high, only increment a bit
!                 neighbors_vars.neighbors[i].DAGrank += DEFAULTLINKCOST;
                  openserial_printError(COMPONENT_NEIGHBORS,ERR_LARGE_DAGRANK,
                                 (errorparameter_t)neighbors_vars.dio->rank,
                                 (errorparameter_t)neighbors_vars.neighbors[i].DAGrank);
--- 439,449 ----
        for (i=0;i<MAXNUMNEIGHBORS;i++) {
           if (isThisRowMatching(&(msg->l2_nextORpreviousHop),i)) {
              if (
!                   neighbors_vars.dio->rank > neighbors_vars.neighbors[i].DAGrank &&
!                   neighbors_vars.dio->rank - neighbors_vars.neighbors[i].DAGrank >(DEFAULTLINKCOST*2*MINHOPRANKINCREASE)
                 ) {
                  // the new DAGrank looks suspiciously high, only increment a bit
!                 neighbors_vars.neighbors[i].DAGrank += (DEFAULTLINKCOST*2*MINHOPRANKINCREASE);
                  openserial_printError(COMPONENT_NEIGHBORS,ERR_LARGE_DAGRANK,
                                 (errorparameter_t)neighbors_vars.dio->rank,
                                 (errorparameter_t)neighbors_vars.neighbors[i].DAGrank);
***************
*** 490,498 ****
    very low DAGrank, I may want to change by routing parent.
  - I became a DAGroot, so my DAGrank should be 0.
  */
! void neighbors_updateMyDAGrankAndNeighborPreference() {
     uint8_t   i;
!    uint8_t   linkCost;
     uint32_t  tentativeDAGrank; // 32-bit since is used to sum
     uint8_t   prefParentIdx;
     bool      prefParentFound;
--- 491,499 ----
    very low DAGrank, I may want to change by routing parent.
  - I became a DAGroot, so my DAGrank should be 0.
  */
! void neighbors_updateMyDAGrankAndNeighborPreference(void) {
     uint8_t   i;
!    uint16_t  rankIncrease;
     uint32_t  tentativeDAGrank; // 32-bit since is used to sum
     uint8_t   prefParentIdx;
     bool      prefParentFound;
***************
*** 517,527 ****
           neighbors_vars.neighbors[i].parentPreference=0;
           // calculate link cost to this neighbor
           if (neighbors_vars.neighbors[i].numTxACK==0) {
!             linkCost = DEFAULTLINKCOST;
           } else {
!             linkCost = (uint8_t)((((float)neighbors_vars.neighbors[i].numTx)/((float)neighbors_vars.neighbors[i].numTxACK))*10.0);
           }
!          tentativeDAGrank = neighbors_vars.neighbors[i].DAGrank+linkCost;
           if ( tentativeDAGrank<neighbors_vars.myDAGrank &&
                tentativeDAGrank<MAXDAGRANK) {
              // found better parent, lower my DAGrank
--- 518,529 ----
           neighbors_vars.neighbors[i].parentPreference=0;
           // calculate link cost to this neighbor
           if (neighbors_vars.neighbors[i].numTxACK==0) {
!             rankIncrease = DEFAULTLINKCOST*2*MINHOPRANKINCREASE;
           } else {
!         	//6TiSCH minimal draft using OF0 for rank computation
!             rankIncrease = (uint16_t)((((float)neighbors_vars.neighbors[i].numTx)/((float)neighbors_vars.neighbors[i].numTxACK))*2*MINHOPRANKINCREASE);
           }
!          tentativeDAGrank = neighbors_vars.neighbors[i].DAGrank+rankIncrease;
           if ( tentativeDAGrank<neighbors_vars.myDAGrank &&
                tentativeDAGrank<MAXDAGRANK) {
              // found better parent, lower my DAGrank
***************
*** 550,556 ****
  
  \returns TRUE if this function printed something, FALSE otherwise.
  */
! bool debugPrint_neighbors() {
     debugNeighborEntry_t temp;
     neighbors_vars.debugRow=(neighbors_vars.debugRow+1)%MAXNUMNEIGHBORS;
     temp.row=neighbors_vars.debugRow;
--- 552,558 ----
  
  \returns TRUE if this function printed something, FALSE otherwise.
  */
! bool debugPrint_neighbors(void) {
     debugNeighborEntry_t temp;
     neighbors_vars.debugRow=(neighbors_vars.debugRow+1)%MAXNUMNEIGHBORS;
     temp.row=neighbors_vars.debugRow;
***************
*** 584,590 ****
  
  void registerNewNeighbor(open_addr_t* address,
                           int8_t       rssi,
!                          asn_t*       asnTimestamp) {
     uint8_t  i,j;
     bool     iHaveAPreferedParent;
     // filter errors
--- 586,594 ----
  
  void registerNewNeighbor(open_addr_t* address,
                           int8_t       rssi,
!                          asn_t*       asnTimestamp,
!                          bool         joinPrioPresent,
!                          uint8_t      joinPrio) {
     uint8_t  i,j;
     bool     iHaveAPreferedParent;
     // filter errors
***************
*** 613,619 ****
              neighbors_vars.neighbors[i].numTx                  = 0;
              neighbors_vars.neighbors[i].numTxACK               = 0;
              memcpy(&neighbors_vars.neighbors[i].asn,asnTimestamp,sizeof(asn_t));
!             // do I already have a preferred parent ?
              iHaveAPreferedParent = FALSE;
              for (j=0;j<MAXNUMNEIGHBORS;j++) {
                 if (neighbors_vars.neighbors[j].parentPreference==MAXPREFERENCE) {
--- 617,629 ----
              neighbors_vars.neighbors[i].numTx                  = 0;
              neighbors_vars.neighbors[i].numTxACK               = 0;
              memcpy(&neighbors_vars.neighbors[i].asn,asnTimestamp,sizeof(asn_t));
!             //update jp
!             if (joinPrioPresent==TRUE){
!                neighbors_vars.neighbors[i].joinPrio=joinPrio;
!             }
!             
!             
!             // do I already have a preferred parent ? -- TODO change to use JP
              iHaveAPreferedParent = FALSE;
              for (j=0;j<MAXNUMNEIGHBORS;j++) {
                 if (neighbors_vars.neighbors[j].parentPreference==MAXPREFERENCE) {
diff -crB stock/openwsn/02b-MAChigh/neighbors.h dev/openwsn/02b-MAChigh/neighbors.h
*** stock/openwsn/02b-MAChigh/neighbors.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/02b-MAChigh/neighbors.h	Wed Jan 29 10:33:22 2014
***************
*** 21,26 ****
--- 21,27 ----
  
  #define MAXDAGRANK                0xffff
  #define DEFAULTDAGRANK            MAXDAGRANK
+ #define MINHOPRANKINCREASE        256  //default value in RPL and Minimal 6TiSCH draft
  
  //=========================== typedef =========================================
  
***************
*** 38,43 ****
--- 39,45 ----
     uint8_t          numTxACK;
     uint8_t          numWraps;//number of times the tx counter wraps. can be removed if memory is a restriction. also check openvisualizer then.
     asn_t            asn;
+    uint8_t          joinPrio;
  } neighborRow_t;
  PRAGMA(pack());
  
***************
*** 58,73 ****
  } netDebugNeigborEntry_t;
  PRAGMA(pack());
  
! //=========================== variables =======================================
  
  //=========================== prototypes ======================================
  
! void          neighbors_init();
  // getters
! dagrank_t     neighbors_getMyDAGrank();
! uint8_t       neighbors_getNumNeighbors();
  bool          neighbors_getPreferredParentEui64(open_addr_t* addressToWrite);
! open_addr_t*  neighbors_getKANeighbor();
  // interrogators
  bool          neighbors_isStableNeighbor(open_addr_t* address);
  bool          neighbors_isPreferredParent(open_addr_t* address);
--- 60,83 ----
  } netDebugNeigborEntry_t;
  PRAGMA(pack());
  
! //=========================== module variables ================================
!    
! typedef struct {
!    neighborRow_t        neighbors[MAXNUMNEIGHBORS];
!    dagrank_t            myDAGrank;
!    uint8_t              debugRow;
!    icmpv6rpl_dio_ht*    dio; //keep it global to be able to debug correctly.
! } neighbors_vars_t;
  
  //=========================== prototypes ======================================
  
! void          neighbors_init(void);
  // getters
! dagrank_t     neighbors_getMyDAGrank(void);
! uint8_t       neighbors_getNumNeighbors(void);
  bool          neighbors_getPreferredParentEui64(open_addr_t* addressToWrite);
! open_addr_t*  neighbors_getKANeighbor(void);
! 
  // interrogators
  bool          neighbors_isStableNeighbor(open_addr_t* address);
  bool          neighbors_isPreferredParent(open_addr_t* address);
***************
*** 78,85 ****
  void          neighbors_indicateRx(
                     open_addr_t*        l2_src,
                     int8_t              rssi,
!                    asn_t*              asnTimestamp
                );
  void          neighbors_indicateTx(
                     open_addr_t*        dest,
                     uint8_t             numTxAttempts,
--- 88,98 ----
  void          neighbors_indicateRx(
                     open_addr_t*        l2_src,
                     int8_t              rssi,
!                    asn_t*              asnTimestamp,
!                    bool                joinPrioPresent,
!                    uint8_t             joinPrio
                );
+ 
  void          neighbors_indicateTx(
                     open_addr_t*        dest,
                     uint8_t             numTxAttempts,
***************
*** 90,98 ****
  // get addresses
  void          neighbors_getNeighbor(open_addr_t* address,uint8_t addr_type,uint8_t index);
  // managing routing info
! void          neighbors_updateMyDAGrankAndNeighborPreference();
  // debug
! bool          debugPrint_neighbors();
  void          debugNetPrint_neighbors(netDebugNeigborEntry_t* schlist);
            
  /**
--- 103,111 ----
  // get addresses
  void          neighbors_getNeighbor(open_addr_t* address,uint8_t addr_type,uint8_t index);
  // managing routing info
! void          neighbors_updateMyDAGrankAndNeighborPreference(void);
  // debug
! bool          debugPrint_neighbors(void);
  void          debugNetPrint_neighbors(netDebugNeigborEntry_t* schlist);
            
  /**
diff -crB stock/openwsn/02b-MAChigh/res.c dev/openwsn/02b-MAChigh/res.c
*** stock/openwsn/02b-MAChigh/res.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/02b-MAChigh/res.c	Wed Jan 29 11:48:23 2014
***************
*** 9,38 ****
  #include "openrandom.h"
  #include "scheduler.h"
  #include "opentimers.h"
! #include "debugpins.h"
! //=========================== variables =======================================
  
! typedef struct {
!    uint16_t        periodMaintenance;
!    bool            busySendingKa;        // TRUE when busy sending a keep-alive
!    bool            busySendingAdv;       // TRUE when busy sending an advertisement
!    uint8_t         dsn;                  // current data sequence number
!    uint8_t         MacMgtTaskCounter;    // counter to determine what management task to do
!    opentimer_id_t  timerId;
! } res_vars_t;
  
  res_vars_t res_vars;
  
  //=========================== prototypes ======================================
  
! error_t res_send_internal(OpenQueueEntry_t* msg);
! void    sendAdv();
! void    sendKa();
! void    res_timer_cb();
  
  //=========================== public ==========================================
  
! void res_init() {
     res_vars.periodMaintenance = 872+(openrandom_get16b()&0xff); // fires every 1 sec on average
     res_vars.busySendingKa     = FALSE;
     res_vars.busySendingAdv    = FALSE;
--- 9,38 ----
  #include "openrandom.h"
  #include "scheduler.h"
  #include "opentimers.h"
! //#include "debugpins.h"
! 
! #include "thread.h"
! 
! #define ENABLE_DEBUG (0)
! #include "debug.h"
  
! 
! //=========================== variables =======================================
  
  res_vars_t res_vars;
+ //static char openwsn_res_stack[KERNEL_CONF_STACKSIZE_MAIN];
  
  //=========================== prototypes ======================================
  
! owerror_t res_send_internal(OpenQueueEntry_t* msg, uint8_t iePresent,uint8_t frameVersion);
! void    sendAdv(void);
! void    sendKa(void);
! void    res_timer_cb(void);
! uint8_t res_copySlotFrameAndLinkIE(OpenQueueEntry_t* adv);//returns reserved size
  
  //=========================== public ==========================================
  
! void res_init(void) {
     res_vars.periodMaintenance = 872+(openrandom_get16b()&0xff); // fires every 1 sec on average
     res_vars.busySendingKa     = FALSE;
     res_vars.busySendingAdv    = FALSE;
***************
*** 51,74 ****
  
  \returns TRUE if this function printed something, FALSE otherwise.
  */
! bool debugPrint_myDAGrank() {
!    uint8_t output=0;
     output = neighbors_getMyDAGrank();
!    openserial_printStatus(STATUS_DAGRANK,(uint8_t*)&output,sizeof(uint8_t));
     return TRUE;
  }
  
  //======= from upper layer
  
! error_t res_send(OpenQueueEntry_t *msg) {
     msg->owner        = COMPONENT_RES;
     msg->l2_frameType = IEEE154_TYPE_DATA;
!    return res_send_internal(msg);
  }
  
  //======= from lower layer
  
! void task_resNotifSendDone() {
     OpenQueueEntry_t* msg;
     // get recently-sent packet from openqueue
     msg = openqueue_resGetSentPacket();
--- 51,75 ----
  
  \returns TRUE if this function printed something, FALSE otherwise.
  */
! // TODO: was bool but complained "conflicting types"
! uint8_t debugPrint_myDAGrank(void) {
!    uint16_t output=0;
     output = neighbors_getMyDAGrank();
!    openserial_printStatus(STATUS_DAGRANK,(uint8_t*)&output,sizeof(uint16_t));
     return TRUE;
  }
  
  //======= from upper layer
  
! owerror_t res_send(OpenQueueEntry_t *msg) {
     msg->owner        = COMPONENT_RES;
     msg->l2_frameType = IEEE154_TYPE_DATA;
!    return res_send_internal(msg,IEEE154_IELIST_NO,IEEE154_FRAMEVERSION_2006);
  }
  
  //======= from lower layer
  
! void task_resNotifSendDone(void) {
     OpenQueueEntry_t* msg;
     // get recently-sent packet from openqueue
     msg = openqueue_resGetSentPacket();
***************
*** 120,126 ****
     }
  }
  
! void task_resNotifReceive() {
     OpenQueueEntry_t* msg;
     
     // get received packet from openqueue
--- 121,127 ----
     }
  }
  
! void task_resNotifReceive(void) {
     OpenQueueEntry_t* msg;
     
     // get received packet from openqueue
***************
*** 140,146 ****
     // indicate reception (to update statistics)
     neighbors_indicateRx(&(msg->l2_nextORpreviousHop),
                          msg->l1_rssi,
!                         &msg->l2_asn);
     
     // send the packet up the stack, if it qualifies
     switch (msg->l2_frameType) {
--- 141,151 ----
     // indicate reception (to update statistics)
     neighbors_indicateRx(&(msg->l2_nextORpreviousHop),
                          msg->l1_rssi,
!                         &msg->l2_asn,
!                         msg->l2_joinPriorityPresent,
!                         msg->l2_joinPriority);
!    
!    msg->l2_joinPriorityPresent=FALSE; //reset it to avoid race conditions with this var.
     
     // send the packet up the stack, if it qualifies
     switch (msg->l2_frameType) {
***************
*** 177,188 ****
  
  The body of this function executes one of the MAC management task.
  */
! void timers_res_fired() {
     res_vars.MacMgtTaskCounter = (res_vars.MacMgtTaskCounter+1)%10;
     if (res_vars.MacMgtTaskCounter==0) {
        sendAdv(); // called every 10s
     } else {
        sendKa();  // called every second, except once every 10s
     }
  }
  
--- 182,194 ----
  
  The body of this function executes one of the MAC management task.
  */
! void timers_res_fired(void) {
     res_vars.MacMgtTaskCounter = (res_vars.MacMgtTaskCounter+1)%10;
     if (res_vars.MacMgtTaskCounter==0) {
        sendAdv(); // called every 10s
     } else {
        sendKa();  // called every second, except once every 10s
+       //leds_debug_toggle();
     }
  }
  
***************
*** 196,206 ****
  virtual component COMPONENT_RES_TO_IEEE802154E. Whenever it gets a change,
  IEEE802154E will handle the packet.
  
! \param [in] msg The packet to the transmitted
  
  \returns E_SUCCESS iff successful.
  */
! error_t res_send_internal(OpenQueueEntry_t* msg) {
     // assign a number of retries
     if (packetfunctions_isBroadcastMulticast(&(msg->l2_nextORpreviousHop))==TRUE) {
        msg->l2_retriesLeft = 1;
--- 202,212 ----
  virtual component COMPONENT_RES_TO_IEEE802154E. Whenever it gets a change,
  IEEE802154E will handle the packet.
  
! \param[in] msg The packet to the transmitted
  
  \returns E_SUCCESS iff successful.
  */
! owerror_t res_send_internal(OpenQueueEntry_t* msg, uint8_t iePresent, uint8_t frameVersion) {
     // assign a number of retries
     if (packetfunctions_isBroadcastMulticast(&(msg->l2_nextORpreviousHop))==TRUE) {
        msg->l2_retriesLeft = 1;
***************
*** 218,223 ****
--- 224,231 ----
     // add a IEEE802.15.4 header
     ieee802154_prependHeader(msg,
                              msg->l2_frameType,
+                             iePresent,
+                             frameVersion,
                              IEEE154_SEC_NO_SECURITY,
                              msg->l2_dsn,
                              &(msg->l2_nextORpreviousHop)
***************
*** 236,243 ****
  timers_res_fired() function, but is declared as a separate function for better
  readability of the code.
  */
! port_INLINE void sendAdv() {
     OpenQueueEntry_t* adv;
     
     if (ieee154e_isSynch()==FALSE) {
        // I'm not sync'ed
--- 244,254 ----
  timers_res_fired() function, but is declared as a separate function for better
  readability of the code.
  */
! port_INLINE void sendAdv(void) {
     OpenQueueEntry_t* adv;
+    payload_IE_descriptor_t payload_IE_desc;
+    MLME_IE_subHeader_t mlme_subHeader;
+    uint8_t slotframeIElen=0;
     
     if (ieee154e_isSynch()==FALSE) {
        // I'm not sync'ed
***************
*** 272,281 ****
     adv->owner   = COMPONENT_RES;
     
     // reserve space for ADV-specific header
!    packetfunctions_reserveHeaderSize(adv, ADV_PAYLOAD_LENGTH);
!    // the actual value of the current ASN will be written by the
     // IEEE802.15.4e when transmitting
!    
     // some l2 information about this packet
     adv->l2_frameType                     = IEEE154_TYPE_BEACON;
     adv->l2_nextORpreviousHop.type        = ADDR_16B;
--- 283,315 ----
     adv->owner   = COMPONENT_RES;
     
     // reserve space for ADV-specific header
!    // xv poipoi -- reserving for IEs  -- reverse order.
!    //TODO reserve here for slotframe and link IE with minimal schedule information
!    slotframeIElen = res_copySlotFrameAndLinkIE(adv);
!    //create Sync IE with JP and ASN 
!    packetfunctions_reserveHeaderSize(adv, sizeof(synch_IE_t));//the asn + jp
!    adv->l2_ASNpayload               = adv->payload; //keep a pointer to where the ASN should be.
!    // the actual value of the current ASN and JP will be written by the
     // IEEE802.15.4e when transmitting
!    packetfunctions_reserveHeaderSize(adv, sizeof(MLME_IE_subHeader_t));//the MLME header
!    //copy mlme sub-header               
!    mlme_subHeader.length_subID_type=sizeof(synch_IE_t) << IEEE802154E_DESC_LEN_SHORT_MLME_IE_SHIFT;
!    mlme_subHeader.length_subID_type |= (IEEE802154E_MLME_SYNC_IE_SUBID << IEEE802154E_MLME_SYNC_IE_SUBID_SHIFT) | IEEE802154E_DESC_TYPE_SHORT;
!    //little endian          
!    adv->payload[0]= mlme_subHeader.length_subID_type & 0xFF;
!    adv->payload[1]= (mlme_subHeader.length_subID_type >> 8) & 0xFF;
!     
!    packetfunctions_reserveHeaderSize(adv, sizeof(payload_IE_descriptor_t));//the payload IE header
!    //prepare IE headers and copy them to the ADV 
!    
!    payload_IE_desc.length_groupid_type = (sizeof(MLME_IE_subHeader_t)+sizeof(synch_IE_t)+slotframeIElen)<<IEEE802154E_DESC_LEN_PAYLOAD_IE_SHIFT;
!    payload_IE_desc.length_groupid_type |=  (IEEE802154E_PAYLOAD_DESC_GROUP_ID_MLME  | IEEE802154E_DESC_TYPE_LONG); //
!    
!    //copy header into the packet
!    //little endian
!    adv->payload[0]= payload_IE_desc.length_groupid_type & 0xFF;
!    adv->payload[1]= (payload_IE_desc.length_groupid_type >> 8) & 0xFF;
!   
     // some l2 information about this packet
     adv->l2_frameType                     = IEEE154_TYPE_BEACON;
     adv->l2_nextORpreviousHop.type        = ADDR_16B;
***************
*** 283,294 ****
     adv->l2_nextORpreviousHop.addr_16b[1] = 0xff;
     
     // put in queue for MAC to handle
!    res_send_internal(adv);
     
     // I'm now busy sending an ADV
     res_vars.busySendingAdv = TRUE;
  }
  
  /**
  \brief Send an keep-alive message, if nessary.
  
--- 317,401 ----
     adv->l2_nextORpreviousHop.addr_16b[1] = 0xff;
     
     // put in queue for MAC to handle
!    res_send_internal(adv,IEEE154_IELIST_YES,IEEE154_FRAMEVERSION);
     
     // I'm now busy sending an ADV
     res_vars.busySendingAdv = TRUE;
  }
  
+ port_INLINE uint8_t res_copySlotFrameAndLinkIE(OpenQueueEntry_t* adv){
+   MLME_IE_subHeader_t mlme_subHeader;
+   uint8_t len=0;
+   uint8_t linkOption=0;
+   uint16_t slot=SCHEDULE_MINIMAL_6TISCH_ACTIVE_CELLS+SCHEDULE_MINIMAL_6TISCH_EB_CELLS;
+   
+   //reverse order and little endian. -- 
+  
+   //for each link in the schedule (in basic configuration)
+   //copy to adv 1B linkOption bitmap
+   //copy to adv 2B ch.offset
+   //copy to adv 2B timeslot
+  
+   //shared cells
+   linkOption = (1<<FLAG_TX_S)|(1<<FLAG_RX_S)|(1<<FLAG_SHARED_S);
+   while(slot>SCHEDULE_MINIMAL_6TISCH_EB_CELLS){
+     packetfunctions_reserveHeaderSize(adv,5);
+     //ts
+     adv->payload[0]= slot & 0xFF;
+     adv->payload[1]= (slot >> 8) & 0xFF;
+     //ch.offset as minimal draft
+     adv->payload[2]= 0x00;
+     adv->payload[3]= 0x00;
+     //linkOption
+     adv->payload[4]= linkOption;
+     len+=5;
+     slot--;
+   }
+  
+   //eb slot
+   linkOption = (1<<FLAG_TX_S)|(1<<FLAG_RX_S)|(1<<FLAG_SHARED_S)|(1<<FLAG_TIMEKEEPING_S);
+   packetfunctions_reserveHeaderSize(adv,5);
+   len+=5;
+  //ts
+   adv->payload[0]= SCHEDULE_MINIMAL_6TISCH_EB_CELLS & 0xFF;
+   adv->payload[1]= (SCHEDULE_MINIMAL_6TISCH_EB_CELLS >> 8) & 0xFF;
+   //ch.offset as minimal draft
+   adv->payload[2]= 0x00;
+   adv->payload[3]= 0x00;
+  
+   adv->payload[4]= linkOption;
+  //now slotframe ie general fields
+     //1B number of links == 6 
+     //Slotframe Size 2B = 101 timeslots
+     //1B slotframe handle (id)
+   packetfunctions_reserveHeaderSize(adv,5);//
+   len+=5;
+   
+   adv->payload[0]= SCHEDULE_MINIMAL_6TISCH_DEFAULT_SLOTFRAME_NUMBER;  
+   adv->payload[1]= SCHEDULE_MINIMAL_6TISCH_DEFAULT_SLOTFRAME_HANDLE;
+   adv->payload[2]= SCHEDULE_MINIMAL_6TISCH_SLOTFRAME_SIZE & 0xFF;
+   adv->payload[3]= (SCHEDULE_MINIMAL_6TISCH_SLOTFRAME_SIZE >> 8) & 0xFF;
+   adv->payload[4]= 0x06; //number of links
+   
+   //MLME sub IE header 
+   //1b -15 short ==0x00
+   //7b -8-14 Sub-ID=0x1b
+   //8b - Length = 2 mlme-header + 5 slotframe general header +(6links*5bytes each) 
+   packetfunctions_reserveHeaderSize(adv, sizeof(MLME_IE_subHeader_t));//the MLME header
+    
+    
+    //copy mlme sub-header               
+   mlme_subHeader.length_subID_type = len << IEEE802154E_DESC_LEN_SHORT_MLME_IE_SHIFT;
+   mlme_subHeader.length_subID_type |= (IEEE802154E_MLME_SLOTFRAME_LINK_IE_SUBID << IEEE802154E_MLME_SYNC_IE_SUBID_SHIFT) | IEEE802154E_DESC_TYPE_SHORT;
+   
+   //little endian          
+   adv->payload[0]= mlme_subHeader.length_subID_type & 0xFF;
+   adv->payload[1]= (mlme_subHeader.length_subID_type >> 8) & 0xFF;
+   len+=2;//count len of mlme header
+    
+   return len;
+ }
+ 
  /**
  \brief Send an keep-alive message, if nessary.
  
***************
*** 296,302 ****
  timers_res_fired() function, but is declared as a separate function for better
  readability of the code.
  */
! port_INLINE void sendKa() {
     OpenQueueEntry_t* kaPkt;
     open_addr_t*      kaNeighAddr;
     
--- 403,409 ----
  timers_res_fired() function, but is declared as a separate function for better
  readability of the code.
  */
! port_INLINE void sendKa(void) {
     OpenQueueEntry_t* kaPkt;
     open_addr_t*      kaNeighAddr;
     
***************
*** 344,355 ****
     memcpy(&(kaPkt->l2_nextORpreviousHop),kaNeighAddr,sizeof(open_addr_t));
     
     // put in queue for MAC to handle
!    res_send_internal(kaPkt);
     
     // I'm now busy sending a KA
     res_vars.busySendingKa = TRUE;
  }
  
! void res_timer_cb() {
     scheduler_push_task(timers_res_fired,TASKPRIO_RES);
  }
\ No newline at end of file
--- 451,466 ----
     memcpy(&(kaPkt->l2_nextORpreviousHop),kaNeighAddr,sizeof(open_addr_t));
     
     // put in queue for MAC to handle
!    res_send_internal(kaPkt,IEEE154_IELIST_NO,IEEE154_FRAMEVERSION_2006);
     
     // I'm now busy sending a KA
     res_vars.busySendingKa = TRUE;
  }
  
! void res_timer_cb(void) {
!    DEBUG(__PRETTY_FUNCTION__);
     scheduler_push_task(timers_res_fired,TASKPRIO_RES);
+    /*thread_create(openwsn_res_stack, KERNEL_CONF_STACKSIZE_MAIN, 
+                  PRIORITY_OPENWSN_RES, CREATE_STACKTEST, 
+                  timers_res_fired, "timers res fired");*/
  }
\ No newline at end of file
diff -crB stock/openwsn/02b-MAChigh/res.h dev/openwsn/02b-MAChigh/res.h
*** stock/openwsn/02b-MAChigh/res.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/02b-MAChigh/res.h	Wed Jan 29 10:33:22 2014
***************
*** 7,28 ****
  \addtogroup RES
  \{
  */
  
  //=========================== define ==========================================
  
  //=========================== typedef =========================================
  
! //=========================== variables =======================================
  
  //=========================== prototypes ======================================
  
! void    res_init();
! bool    debugPrint_myDAGrank();
  // from upper layer
! error_t res_send(OpenQueueEntry_t *msg);
  // from lower layer
! void    task_resNotifSendDone();
! void    task_resNotifReceive();
  
  /**
  \}
--- 7,38 ----
  \addtogroup RES
  \{
  */
+ #include "opentimers.h"
  
  //=========================== define ==========================================
  
  //=========================== typedef =========================================
  
! //=========================== module variables ================================
! 
! typedef struct {
!    uint16_t        periodMaintenance;
!    bool            busySendingKa;        // TRUE when busy sending a keep-alive
!    bool            busySendingAdv;       // TRUE when busy sending an advertisement
!    uint8_t         dsn;                  // current data sequence number
!    uint8_t         MacMgtTaskCounter;    // counter to determine what management task to do
!    opentimer_id_t  timerId;
! } res_vars_t;
  
  //=========================== prototypes ======================================
  
! void    res_init(void);
! uint8_t    debugPrint_myDAGrank(void); // TODO: was bool but complained "conflicting types"
  // from upper layer
! owerror_t res_send(OpenQueueEntry_t *msg);
  // from lower layer
! void    task_resNotifSendDone(void);
! void    task_resNotifReceive(void);
  
  /**
  \}
diff -crB stock/openwsn/02b-MAChigh/schedule.c dev/openwsn/02b-MAChigh/schedule.c
*** stock/openwsn/02b-MAChigh/schedule.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/02b-MAChigh/schedule.c	Wed Jan 29 10:33:22 2014
***************
*** 2,26 ****
  #include "schedule.h"
  #include "openserial.h"
  #include "openrandom.h"
  
  //=========================== variables =======================================
  
- typedef struct {
-    scheduleEntry_t  scheduleBuf[MAXACTIVESLOTS];
-    scheduleEntry_t* currentScheduleEntry;
-    uint16_t         frameLength;
-    uint8_t          backoffExponent;
-    uint8_t          backoff;
-    slotOffset_t     debugPrintRow;
- } schedule_vars_t;
- 
  schedule_vars_t schedule_vars;
- 
- typedef struct {
-    uint8_t          numActiveSlotsCur;
-    uint8_t          numActiveSlotsMax;
- } schedule_dbg_t;
- 
  schedule_dbg_t schedule_dbg;
  
  //=========================== prototypes ======================================
--- 2,12 ----
  #include "schedule.h"
  #include "openserial.h"
  #include "openrandom.h"
+ #include "packetfunctions.h"
  
  //=========================== variables =======================================
  
  schedule_vars_t schedule_vars;
  schedule_dbg_t schedule_dbg;
  
  //=========================== prototypes ======================================
***************
*** 31,44 ****
  
  //=== admin
  
! void schedule_init() {
     uint8_t         i;
     slotOffset_t    running_slotOffset;
     open_addr_t     temp_neighbor;
  
     // reset local variables
     memset(&schedule_vars,0,sizeof(schedule_vars_t));
!    for (i=0;i<MAXACTIVESLOTS;i++){
        schedule_resetEntry(&schedule_vars.scheduleBuf[i]);
     }
     schedule_vars.backoffExponent = MINBE-1;
--- 17,30 ----
  
  //=== admin
  
! void schedule_init(void) {
     uint8_t         i;
     slotOffset_t    running_slotOffset;
     open_addr_t     temp_neighbor;
  
     // reset local variables
     memset(&schedule_vars,0,sizeof(schedule_vars_t));
!    for (i=0;i<MAXACTIVESLOTS;i++) {
        schedule_resetEntry(&schedule_vars.scheduleBuf[i]);
     }
     schedule_vars.backoffExponent = MINBE-1;
***************
*** 58,64 ****
           CELLTYPE_ADV,            // type of slot
           FALSE,                   // shared?
           0,                       // channel offset
!          &temp_neighbor           // neighbor
        );
        running_slotOffset++;
     } 
--- 44,51 ----
           CELLTYPE_ADV,            // type of slot
           FALSE,                   // shared?
           0,                       // channel offset
!          &temp_neighbor,           // neighbor
!          FALSE                     //no update but insert
        );
        running_slotOffset++;
     } 
***************
*** 72,78 ****
           CELLTYPE_TXRX,           // type of slot
           TRUE,                    // shared?
           0,                       // channel offset
!          &temp_neighbor           // neighbor
        );
        running_slotOffset++;
     }
--- 59,66 ----
           CELLTYPE_TXRX,           // type of slot
           TRUE,                    // shared?
           0,                       // channel offset
!          &temp_neighbor,          // neighbor
!          FALSE                    //no update but insert
        );
        running_slotOffset++;
     }
***************
*** 84,90 ****
        CELLTYPE_SERIALRX,          // type of slot
        FALSE,                      // shared?
        0,                          // channel offset
!       &temp_neighbor              // neighbor
     );
     running_slotOffset++;
     /*
--- 72,79 ----
        CELLTYPE_SERIALRX,          // type of slot
        FALSE,                      // shared?
        0,                          // channel offset
!       &temp_neighbor,             // neighbor
!       FALSE                       //no update but insert
     );
     running_slotOffset++;
     /*
***************
*** 109,132 ****
  
  \returns TRUE if this function printed something, FALSE otherwise.
  */
! bool debugPrint_schedule() {
     debugScheduleEntry_t temp;
!    schedule_vars.debugPrintRow    = (schedule_vars.debugPrintRow+1)%MAXACTIVESLOTS;
!    temp.row                       = schedule_vars.debugPrintRow;
!    //copy element  by element to the struct that will  be serialized. we don't want to sent the pointer through the serial port.
!    temp.scheduleEntry.channelOffset  = schedule_vars.scheduleBuf[schedule_vars.debugPrintRow].channelOffset;
!    temp.scheduleEntry.numRx  = schedule_vars.scheduleBuf[schedule_vars.debugPrintRow].numRx;
!    temp.scheduleEntry.numTx=schedule_vars.scheduleBuf[schedule_vars.debugPrintRow].numTx;
!    temp.scheduleEntry.numTxACK=schedule_vars.scheduleBuf[schedule_vars.debugPrintRow].numTxACK;
!    temp.scheduleEntry.lastUsedAsn=schedule_vars.scheduleBuf[schedule_vars.debugPrintRow].lastUsedAsn;
!    temp.scheduleEntry.neighbor=schedule_vars.scheduleBuf[schedule_vars.debugPrintRow].neighbor;
!    temp.scheduleEntry.shared=schedule_vars.scheduleBuf[schedule_vars.debugPrintRow].shared;
!    temp.scheduleEntry.slotOffset=schedule_vars.scheduleBuf[schedule_vars.debugPrintRow].slotOffset;
!    temp.scheduleEntry.type=schedule_vars.scheduleBuf[schedule_vars.debugPrintRow].type;
!             
     openserial_printStatus(STATUS_SCHEDULE,
           (uint8_t*)&temp,
!          sizeof(debugScheduleEntry_t));
     return TRUE;
  }
  
--- 98,139 ----
  
  \returns TRUE if this function printed something, FALSE otherwise.
  */
! bool debugPrint_schedule(void) {
     debugScheduleEntry_t temp;
!    
!    schedule_vars.debugPrintRow         = (schedule_vars.debugPrintRow+1)%MAXACTIVESLOTS;
!    
!    temp.row                            = schedule_vars.debugPrintRow;
!    temp.slotOffset                     = \
!       schedule_vars.scheduleBuf[schedule_vars.debugPrintRow].slotOffset;
!    temp.type                           = \
!       schedule_vars.scheduleBuf[schedule_vars.debugPrintRow].type;
!    temp.shared                         = \
!       schedule_vars.scheduleBuf[schedule_vars.debugPrintRow].shared;
!    temp.channelOffset                  = \
!       schedule_vars.scheduleBuf[schedule_vars.debugPrintRow].channelOffset;
!    memcpy(
!       &temp.neighbor,
!       &schedule_vars.scheduleBuf[schedule_vars.debugPrintRow].neighbor,
!       sizeof(open_addr_t)
!    );
!    temp.numRx                          = \
!       schedule_vars.scheduleBuf[schedule_vars.debugPrintRow].numRx;
!    temp.numTx                          = \
!       schedule_vars.scheduleBuf[schedule_vars.debugPrintRow].numTx;
!    temp.numTxACK                       = \
!       schedule_vars.scheduleBuf[schedule_vars.debugPrintRow].numTxACK;
!    memcpy(
!       &temp.lastUsedAsn,
!       &schedule_vars.scheduleBuf[schedule_vars.debugPrintRow].lastUsedAsn,
!       sizeof(asn_t)
!    );
!    
     openserial_printStatus(STATUS_SCHEDULE,
           (uint8_t*)&temp,
!          sizeof(debugScheduleEntry_t)
!    );
!    
     return TRUE;
  }
  
***************
*** 138,144 ****
  
  \returns TRUE if this function printed something, FALSE otherwise.
  */
! bool debugPrint_backoff() {
     uint8_t temp[2];
     temp[0] = schedule_vars.backoffExponent;
     temp[1] = schedule_vars.backoff;
--- 145,151 ----
  
  \returns TRUE if this function printed something, FALSE otherwise.
  */
! bool debugPrint_backoff(void) {
     uint8_t temp[2];
     temp[0] = schedule_vars.backoffExponent;
     temp[1] = schedule_vars.backoff;
***************
*** 163,194 ****
  }
  
  /**
  \brief Add a new active slot into the schedule.
  
! \param newFrameLength The new frame length.
  */
! void schedule_addActiveSlot(slotOffset_t    slotOffset,
        cellType_t      type,
        bool            shared,
!       uint8_t         channelOffset,
!       open_addr_t*    neighbor) {
     scheduleEntry_t* slotContainer;
     scheduleEntry_t* previousSlotWalker;
     scheduleEntry_t* nextSlotWalker;
     INTERRUPT_DECLARATION();
     DISABLE_INTERRUPTS();
! 
     // find an empty schedule entry container
     slotContainer = &schedule_vars.scheduleBuf[0];
     while (slotContainer->type!=CELLTYPE_OFF &&
           slotContainer<=&schedule_vars.scheduleBuf[MAXACTIVESLOTS-1]) {
!       slotContainer++;
     }
     if (slotContainer>&schedule_vars.scheduleBuf[MAXACTIVESLOTS-1]) {
        // schedule has overflown
        openserial_printCritical(COMPONENT_SCHEDULE,ERR_SCHEDULE_OVERFLOWN,
                              (errorparameter_t)0,
                              (errorparameter_t)0);
     }
     // fill that schedule entry with parameters passed
     slotContainer->slotOffset                = slotOffset;
--- 170,274 ----
  }
  
  /**
+ \brief get the information of a spcific slot.
+ 
+ \param slotOffset
+ \param neighbor
+ \param info
+ */
+ void  schedule_getSlotInfo(
+    slotOffset_t         slotOffset,
+    open_addr_t*         neighbor,
+    slotinfo_element_t*  info
+ ){
+                            
+    scheduleEntry_t* slotContainer;
+   
+    // find an empty schedule entry container
+    slotContainer = &schedule_vars.scheduleBuf[0];
+    while (slotContainer->type!=CELLTYPE_OFF && slotContainer<=&schedule_vars.scheduleBuf[MAXACTIVESLOTS-1]) {
+        //check that this entry for that neighbour and timeslot is not already scheduled.
+        if (packetfunctions_sameAddress(neighbor,&(slotContainer->neighbor))&& (slotContainer->slotOffset==slotOffset)){
+                //it exists so this is an update.
+                info->link_type                 = slotContainer->type;
+                info->shared                    =slotContainer->shared;
+                info->channelOffset             = slotContainer->channelOffset;
+                return; //as this is an update. No need to re-insert as it is in the same position on the list.
+         }
+         slotContainer++;
+    }
+    //return cell type off.
+    info->link_type                 = CELLTYPE_OFF;
+    info->shared                    = FALSE;
+    info->channelOffset             = 0;//set to zero if not set.                          
+ }
+ 
+ /**
  \brief Add a new active slot into the schedule.
  
! If udpate param is set then update it in case it exists.
! 
! \param slotOffset
! \param type
! \param shared
! \param channelOffset
! \param neighbor
! \param isUpdate
  */
! owerror_t schedule_addActiveSlot(
!       slotOffset_t    slotOffset,
        cellType_t      type,
        bool            shared,
!       channelOffset_t channelOffset,
!       open_addr_t*    neighbor,
!       bool            isUpdate
!    ) {
!    
!    owerror_t outcome;
!    
     scheduleEntry_t* slotContainer;
     scheduleEntry_t* previousSlotWalker;
     scheduleEntry_t* nextSlotWalker;
     INTERRUPT_DECLARATION();
     DISABLE_INTERRUPTS();
!    
!    
     // find an empty schedule entry container
     slotContainer = &schedule_vars.scheduleBuf[0];
     while (slotContainer->type!=CELLTYPE_OFF &&
           slotContainer<=&schedule_vars.scheduleBuf[MAXACTIVESLOTS-1]) {
!   
!            //check that this entry for that neighbour and timeslot is not already scheduled.
!            if (type!=CELLTYPE_SERIALRX && type!=CELLTYPE_MORESERIALRX &&  
!                (packetfunctions_sameAddress(neighbor,&(slotContainer->neighbor))||
!                  (slotContainer->neighbor.type==ADDR_ANYCAST && isUpdate==TRUE))
!                  &&(slotContainer->slotOffset==slotOffset)){
!                //it exists so this is an update.
!                slotContainer->type                      = type;
!                slotContainer->shared                    = shared;
!                slotContainer->channelOffset             = channelOffset;
!                memcpy(&slotContainer->neighbor,neighbor,sizeof(open_addr_t));//update the address too!
!                schedule_dbg.numUpdatedSlotsCur++;
!                ENABLE_INTERRUPTS();
!                return E_SUCCESS; //as this is an update. No need to re-insert as it is in the same position on the list.
!            }
!            
!            slotContainer++;
!    }
!    
!    if (isUpdate==TRUE) {
!      //we are trying to update an item that is not in the schedule list.
!      ENABLE_INTERRUPTS();
!      return E_FAIL;
     }
     if (slotContainer>&schedule_vars.scheduleBuf[MAXACTIVESLOTS-1]) {
        // schedule has overflown
+       outcome=E_FAIL;
        openserial_printCritical(COMPONENT_SCHEDULE,ERR_SCHEDULE_OVERFLOWN,
                              (errorparameter_t)0,
                              (errorparameter_t)0);
+       
+       
     }
     // fill that schedule entry with parameters passed
     slotContainer->slotOffset                = slotOffset;
***************
*** 242,250 ****
--- 322,399 ----
     if (schedule_dbg.numActiveSlotsCur>schedule_dbg.numActiveSlotsMax) {
        schedule_dbg.numActiveSlotsMax        = schedule_dbg.numActiveSlotsCur;
     }
+    outcome=E_SUCCESS;
     ENABLE_INTERRUPTS();
+    return outcome;
+ }
+ 
+ 
+ 
+ owerror_t   schedule_removeActiveSlot(slotOffset_t   slotOffset, open_addr_t*   neighbor){
+   
+    owerror_t outcome;
+    
+    scheduleEntry_t* slotContainer;
+    scheduleEntry_t* previousSlotWalker;
+ 
+    INTERRUPT_DECLARATION();
+    DISABLE_INTERRUPTS();
+    
+    
+    // find the schedule entry
+    slotContainer = &schedule_vars.scheduleBuf[0];
+    while (slotContainer->type!=CELLTYPE_OFF && slotContainer<=&schedule_vars.scheduleBuf[MAXACTIVESLOTS-1]) {
+           //check that this entry for that neighbour and timeslot is not already scheduled.
+            if (packetfunctions_sameAddress(neighbor,&(slotContainer->neighbor))&& (slotContainer->slotOffset==slotOffset)){
+                break;
+            }
+            slotContainer++;
+    }
+   
+    if (slotContainer->next==slotContainer) {
+       // this is the last active slot
+ 
+       // the next slot of this slot is NULL
+       slotContainer->next                   = NULL;
+ 
+       // current slot points to this slot
+       schedule_vars.currentScheduleEntry    = NULL;
+    } else  {
+       // this is NOT the last active slot
+ 
+       // find the previous in the schedule
+       previousSlotWalker                    = schedule_vars.currentScheduleEntry;
+       
+       while (1) {
+         if ((previousSlotWalker->next=slotContainer)){
+             break;
+          }
+          previousSlotWalker                 = previousSlotWalker->next;
+       }
+       // remove this element from the linked list
+       previousSlotWalker->next              = slotContainer->next;//my next;
+       slotContainer->next                   = NULL;
+    }
+ 
+     // clear that schedule entry 
+     slotContainer->slotOffset                = 0;
+     slotContainer->type                      = CELLTYPE_OFF;
+     slotContainer->shared                    = FALSE;
+     slotContainer->channelOffset             = 0;
+     memset(&slotContainer->neighbor,0,sizeof(open_addr_t));
+ 
+     // maintain debug stats
+     schedule_dbg.numActiveSlotsCur--;
+    
+     outcome=E_SUCCESS;
+     ENABLE_INTERRUPTS();
+     
+     return outcome;
  }
  
+ 
+ 
+ 
  //=== from IEEE802154E: reading the schedule and updating statistics
  
  void schedule_syncSlotOffset(slotOffset_t targetSlotOffset) {
***************
*** 256,262 ****
     ENABLE_INTERRUPTS();
  }
  
! void schedule_advanceSlot() {
     INTERRUPT_DECLARATION();
     DISABLE_INTERRUPTS();
     // advance to next active slot
--- 405,411 ----
     ENABLE_INTERRUPTS();
  }
  
! void schedule_advanceSlot(void) {
     INTERRUPT_DECLARATION();
     DISABLE_INTERRUPTS();
     // advance to next active slot
***************
*** 264,270 ****
     ENABLE_INTERRUPTS();
  }
  
! slotOffset_t schedule_getNextActiveSlotOffset() {
     slotOffset_t res;   
     INTERRUPT_DECLARATION();
     
--- 413,419 ----
     ENABLE_INTERRUPTS();
  }
  
! slotOffset_t schedule_getNextActiveSlotOffset(void) {
     slotOffset_t res;   
     INTERRUPT_DECLARATION();
     
***************
*** 281,287 ****
  
  \returns The frame length.
  */
! frameLength_t schedule_getFrameLength() {
     frameLength_t res;
     INTERRUPT_DECLARATION();
     
--- 430,436 ----
  
  \returns The frame length.
  */
! frameLength_t schedule_getFrameLength(void) {
     frameLength_t res;
     INTERRUPT_DECLARATION();
     
***************
*** 297,303 ****
  
  \returns The type of the current schedule entry.
  */
! cellType_t schedule_getType() {
     cellType_t res;
     INTERRUPT_DECLARATION();
     DISABLE_INTERRUPTS();
--- 446,452 ----
  
  \returns The type of the current schedule entry.
  */
! cellType_t schedule_getType(void) {
     cellType_t res;
     INTERRUPT_DECLARATION();
     DISABLE_INTERRUPTS();
***************
*** 323,329 ****
  
  \returns The channel offset of the current schedule entry.
  */
! channelOffset_t schedule_getChannelOffset() {
     channelOffset_t res;
     INTERRUPT_DECLARATION();
     DISABLE_INTERRUPTS();
--- 472,478 ----
  
  \returns The channel offset of the current schedule entry.
  */
! channelOffset_t schedule_getChannelOffset(void) {
     channelOffset_t res;
     INTERRUPT_DECLARATION();
     DISABLE_INTERRUPTS();
***************
*** 344,350 ****
  
  \returns TRUE if it is OK to send on this slot, FALSE otherwise.
   */
! bool schedule_getOkToSend() {
     bool returnVal;
     
     INTERRUPT_DECLARATION();
--- 493,499 ----
  
  \returns TRUE if it is OK to send on this slot, FALSE otherwise.
   */
! bool schedule_getOkToSend(void) {
     bool returnVal;
     
     INTERRUPT_DECLARATION();
***************
*** 377,383 ****
  /**
  \brief Reset the backoff and backoffExponent.
  */
! void schedule_resetBackoff() {
     INTERRUPT_DECLARATION();
     DISABLE_INTERRUPTS();
     
--- 526,532 ----
  /**
  \brief Reset the backoff and backoffExponent.
  */
! void schedule_resetBackoff(void) {
     INTERRUPT_DECLARATION();
     DISABLE_INTERRUPTS();
     
***************
*** 459,472 ****
     pScheduleEntry->type                     = CELLTYPE_OFF;
     pScheduleEntry->shared                   = FALSE;
     pScheduleEntry->channelOffset            = 0;
     pScheduleEntry->neighbor.type            = ADDR_NONE;
!    pScheduleEntry->neighbor.addr_64b[0]     = 0x14;
!    pScheduleEntry->neighbor.addr_64b[1]     = 0x15;
!    pScheduleEntry->neighbor.addr_64b[2]     = 0x92;
!    pScheduleEntry->neighbor.addr_64b[3]     = 0x09;
!    pScheduleEntry->neighbor.addr_64b[4]     = 0x02;
!    pScheduleEntry->neighbor.addr_64b[5]     = 0x2c;
!    pScheduleEntry->neighbor.addr_64b[6]     = 0x00;
     pScheduleEntry->numRx                    = 0;
     pScheduleEntry->numTx                    = 0;
     pScheduleEntry->numTxACK                 = 0;
--- 608,617 ----
     pScheduleEntry->type                     = CELLTYPE_OFF;
     pScheduleEntry->shared                   = FALSE;
     pScheduleEntry->channelOffset            = 0;
+ 
     pScheduleEntry->neighbor.type            = ADDR_NONE;
!    memset(&pScheduleEntry->neighbor.addr_64b[0], 0x00, sizeof(pScheduleEntry->neighbor.addr_64b));
! 
     pScheduleEntry->numRx                    = 0;
     pScheduleEntry->numTx                    = 0;
     pScheduleEntry->numTxACK                 = 0;
diff -crB stock/openwsn/02b-MAChigh/schedule.h dev/openwsn/02b-MAChigh/schedule.h
*** stock/openwsn/02b-MAChigh/schedule.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/02b-MAChigh/schedule.h	Wed Jan 29 10:33:22 2014
***************
*** 17,26 ****
  
  The superframe repears over time and can be arbitrarly long.
  */
! #define SUPERFRAME_LENGTH    9
  
  #define NUMADVSLOTS          1
! #define NUMSHAREDTXRX        4
  #define NUMSERIALRX          3
  
  /**
--- 17,26 ----
  
  The superframe repears over time and can be arbitrarly long.
  */
! #define SUPERFRAME_LENGTH    11 //should be 101
  
  #define NUMADVSLOTS          1
! #define NUMSHAREDTXRX        5
  #define NUMSERIALRX          3
  
  /**
***************
*** 50,56 ****
  See MINBE for an explanation of backoff.
  */
  #define MAXBE                4
! 
  
  //=========================== typedef =========================================
  
--- 50,61 ----
  See MINBE for an explanation of backoff.
  */
  #define MAXBE                4
! //6tisch minimal draft
! #define SCHEDULE_MINIMAL_6TISCH_ACTIVE_CELLS                      5
! #define SCHEDULE_MINIMAL_6TISCH_EB_CELLS                          1
! #define SCHEDULE_MINIMAL_6TISCH_SLOTFRAME_SIZE                  101
! #define SCHEDULE_MINIMAL_6TISCH_DEFAULT_SLOTFRAME_HANDLE          1 //id of slotframe
! #define SCHEDULE_MINIMAL_6TISCH_DEFAULT_SLOTFRAME_NUMBER          1 //1 slotframe by default.
  
  //=========================== typedef =========================================
  
***************
*** 84,94 ****
  } scheduleEntry_t;
  //PRAGMA(pack());
  
! //copy of the previous one but without the pointer and packed
  PRAGMA(pack(1));
  typedef struct {
     slotOffset_t    slotOffset;
!    cellType_t      type;
     bool            shared;
     uint8_t         channelOffset;
     open_addr_t     neighbor;
--- 89,109 ----
  } scheduleEntry_t;
  //PRAGMA(pack());
  
! //used to debug through ipv6 pkt. 
! 
! PRAGMA(pack(1));
! typedef struct {
!    uint8_t last_addr_byte;//last byte of the address; poipoi could be [0]; endianness
!    uint8_t slotOffset;
!    channelOffset_t channelOffset;
! }netDebugScheduleEntry_t;
! PRAGMA(pack());
! 
  PRAGMA(pack(1));
  typedef struct {
+    uint8_t         row;
     slotOffset_t    slotOffset;
!    uint8_t         type;
     bool            shared;
     uint8_t         channelOffset;
     open_addr_t     neighbor;
***************
*** 96,148 ****
     uint8_t         numTx;
     uint8_t         numTxACK;
     asn_t           lastUsedAsn;
! } scheduleEntryDebug_t;
  PRAGMA(pack());
  
! //used to debug through ipv6 pkt. 
! 
! PRAGMA(pack(1));
  typedef struct {
!    uint8_t last_addr_byte;//last byte of the address; poipoi could be [0]; endianness
!    uint8_t slotOffset;
!    uint8_t channelOffset;
! }netDebugScheduleEntry_t;
  PRAGMA(pack());
  
- PRAGMA(pack(1));
  typedef struct {
!    uint8_t         row;
!    scheduleEntryDebug_t scheduleEntry;
! } debugScheduleEntry_t;
! PRAGMA(pack());
  
! //=========================== variables =======================================
  
  //=========================== prototypes ======================================
  
  // admin
! void               schedule_init();
! bool               debugPrint_schedule();
! bool               debugPrint_backoff();
  // from uRES
  void               schedule_setFrameLength(frameLength_t newFrameLength);
! void               schedule_addActiveSlot(
                          slotOffset_t   slotOffset,
                          cellType_t     type,
                          bool           shared,
                          uint8_t        channelOffset,
!                         open_addr_t*   neighbor
!                    );
  // from IEEE802154E
  void               schedule_syncSlotOffset(slotOffset_t targetSlotOffset);
! void               schedule_advanceSlot();
! slotOffset_t       schedule_getNextActiveSlotOffset();
! frameLength_t      schedule_getFrameLength();
! cellType_t         schedule_getType();
  void               schedule_getNeighbor(open_addr_t* addrToWrite);
! channelOffset_t    schedule_getChannelOffset();
! bool               schedule_getOkToSend();
! void               schedule_resetBackoff();
  void               schedule_indicateRx(asn_t*   asnTimestamp);
  void               schedule_indicateTx(
                          asn_t*    asnTimestamp,
--- 111,179 ----
     uint8_t         numTx;
     uint8_t         numTxACK;
     asn_t           lastUsedAsn;
! } debugScheduleEntry_t;
  PRAGMA(pack());
  
! PRAGMA(pack(1)); //elements for slot info 
  typedef struct {
!   uint8_t address[LENGTH_ADDR64b];// 
!   cellType_t link_type;// rx,tx etc...
!   bool shared;
!   slotOffset_t slotOffset;
!   channelOffset_t channelOffset;
! }slotinfo_element_t;
  PRAGMA(pack());
+ //=========================== variables =======================================
  
  typedef struct {
!    scheduleEntry_t  scheduleBuf[MAXACTIVESLOTS];
!    scheduleEntry_t* currentScheduleEntry;
!    uint16_t         frameLength;
!    uint8_t          backoffExponent;
!    uint8_t          backoff;
!    slotOffset_t     debugPrintRow;
! } schedule_vars_t;
  
! typedef struct {
!    uint8_t          numActiveSlotsCur;
!    uint8_t          numActiveSlotsMax;
!    uint8_t          numUpdatedSlotsCur;
! } schedule_dbg_t;
  
  //=========================== prototypes ======================================
  
  // admin
! void               schedule_init(void);
! bool               debugPrint_schedule(void);
! bool               debugPrint_backoff(void);
  // from uRES
  void               schedule_setFrameLength(frameLength_t newFrameLength);
! owerror_t            schedule_addActiveSlot(
                          slotOffset_t   slotOffset,
                          cellType_t     type,
                          bool           shared,
                          uint8_t        channelOffset,
!                         open_addr_t*   neighbor,
!                         bool isUpdate);
! 
! void               schedule_getSlotInfo(slotOffset_t   slotOffset,                      
!                               open_addr_t*   neighbor,
!                               slotinfo_element_t* info);
! 
! owerror_t               schedule_removeActiveSlot(slotOffset_t   slotOffset,                      
!                               open_addr_t*   neighbor);
! 
! 
  // from IEEE802154E
  void               schedule_syncSlotOffset(slotOffset_t targetSlotOffset);
! void               schedule_advanceSlot(void);
! slotOffset_t       schedule_getNextActiveSlotOffset(void);
! frameLength_t      schedule_getFrameLength(void);
! cellType_t         schedule_getType(void);
  void               schedule_getNeighbor(open_addr_t* addrToWrite);
! channelOffset_t    schedule_getChannelOffset(void);
! bool               schedule_getOkToSend(void);
! void               schedule_resetBackoff(void);
  void               schedule_indicateRx(asn_t*   asnTimestamp);
  void               schedule_indicateTx(
                          asn_t*    asnTimestamp,
***************
*** 154,158 ****
  \}
  \}
  */
-           
  #endif
--- 185,188 ----
diff -crB stock/openwsn/03a-IPHC/Makefile dev/openwsn/03a-IPHC/Makefile
*** stock/openwsn/03a-IPHC/Makefile	Tue Jan 28 12:35:56 2014
--- dev/openwsn/03a-IPHC/Makefile	Wed Jan 29 10:33:22 2014
***************
*** 0 ****
--- 1,32 ----
+ SUBMOD:=$(shell basename $(CURDIR)).a
+ #BINDIR = $(RIOTBASE)/bin/
+ SRC = $(wildcard *.c)
+ OBJ = $(SRC:%.c=$(BINDIR)%.o)
+ DEP = $(SRC:%.c=$(BINDIR)%.d)
+ 
+ INCLUDES += -I$(RIOTBASE) -I$(RIOTBASE)/sys/include -I$(RIOTBASE)/core/include -I$(RIOTBASE)/drivers/include -I$(RIOTBASE)/drivers/cc110x_ng/include -I$(RIOTBASE)/cpu/arm_common/include -I$(RIOTBASE)/sys/net/include/ 
+ INCLUDES += -I$(CURDIR)/02a-MAClow
+ INCLUDES += -I$(CURDIR)/02b-MAChigh
+ INCLUDES += -I$(CURDIR)/03a-IPHC
+ INCLUDES += -I$(CURDIR)/03b-IPv6
+ INCLUDES += -I$(CURDIR)/04-TRAN
+ INCLUDES += -I$(CURDIR)/cross-layers
+ 
+ .PHONY: $(BINDIR)$(SUBMOD)
+ 
+ $(BINDIR)$(SUBMOD): $(OBJ)
+ 	$(AD)$(AR) rcs $(BINDIR)$(MODULE) $(OBJ)
+ 
+ # pull in dependency info for *existing* .o files
+ -include $(OBJ:.o=.d)
+ 
+ # compile and generate dependency info
+ $(BINDIR)%.o: %.c
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -c $*.c -o $(BINDIR)$*.o
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -MM $*.c > $(BINDIR)$*.d
+ 	@printf "$(BINDIR)" | cat - $(BINDIR)$*.d > /tmp/riot_out && mv /tmp/riot_out $(BINDIR)$*.d
+ 
+ # remove compilation products
+ 
+ clean:
+ 	rm -f $(OBJ) $(DEP)
diff -crB stock/openwsn/03a-IPHC/iphc.c dev/openwsn/03a-IPHC/iphc.c
*** stock/openwsn/03a-IPHC/iphc.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/03a-IPHC/iphc.c	Wed Jan 29 10:33:22 2014
***************
*** 12,18 ****
  
  //=========================== prototypes ======================================
  
! error_t prependIPv6Header(
     OpenQueueEntry_t*    msg,
     uint8_t              tf,
     uint32_t             value_flowLabel,
--- 12,18 ----
  
  //=========================== prototypes ======================================
  
! owerror_t prependIPv6Header(
     OpenQueueEntry_t*    msg,
     uint8_t              tf,
     uint32_t             value_flowLabel,
***************
*** 31,44 ****
     uint8_t              fw_SendOrfw_Rcv
  );
  ipv6_header_iht retrieveIPv6Header(OpenQueueEntry_t* msg);
! 
  //=========================== public ==========================================
  
! void iphc_init() {
  }
  
  //send from upper layer: I need to add 6LoWPAN header
! error_t iphc_sendFromForwarding(OpenQueueEntry_t *msg, ipv6_header_iht ipv6_header, uint8_t fw_SendOrfw_Rcv) {
     open_addr_t  temp_dest_prefix;
     open_addr_t  temp_dest_mac64b;
     open_addr_t* p_dest;
--- 31,46 ----
     uint8_t              fw_SendOrfw_Rcv
  );
  ipv6_header_iht retrieveIPv6Header(OpenQueueEntry_t* msg);
! //hop by hop header
! void prependIPv6HopByHopHeader(OpenQueueEntry_t* msg,uint8_t nextheader, bool nh, rpl_hopoption_ht *hopbyhop_option);
! void retrieveIPv6HopByHopHeader(OpenQueueEntry_t* msg, ipv6_hopbyhop_ht *hopbyhop_header, rpl_hopoption_ht *rpl_option);
  //=========================== public ==========================================
  
! void iphc_init(void) {
  }
  
  //send from upper layer: I need to add 6LoWPAN header
! owerror_t iphc_sendFromForwarding(OpenQueueEntry_t *msg, ipv6_header_iht ipv6_header, rpl_hopoption_ht *hopbyhop_option, uint8_t fw_SendOrfw_Rcv) {
     open_addr_t  temp_dest_prefix;
     open_addr_t  temp_dest_mac64b;
     open_addr_t* p_dest;
***************
*** 48,54 ****
     uint8_t      sam;
     uint8_t      dam;
     uint8_t      nh;
!    
     // take ownership over the packet
     msg->owner = COMPONENT_IPHC;
     
--- 50,58 ----
     uint8_t      sam;
     uint8_t      dam;
     uint8_t      nh;
!    uint8_t      next_header;
!    //option header
!   
     // take ownership over the packet
     msg->owner = COMPONENT_IPHC;
     
***************
*** 85,90 ****
--- 89,95 ----
          if (fw_SendOrfw_Rcv==PCKTFORWARD){
              sam = IPHC_SAM_64B;    //case forwarding a packet
              p_src = &temp_src_mac64b;
+             //poipoi xv forcing elided addresses on src routing, this needs to be fixed so any type of address should be supported supported.
          } else if (fw_SendOrfw_Rcv==PCKTSEND){
              sam = IPHC_SAM_ELIDED;
              p_src = NULL;
***************
*** 92,100 ****
             openserial_printCritical(COMPONENT_IPHC,ERR_INVALID_FWDMODE,
                              (errorparameter_t)0,
                              (errorparameter_t)0);
!         }
!          dam = IPHC_DAM_ELIDED;
!          p_dest = NULL;
        } else {
           //else, not a direct neighbour use 64B address
           sam = IPHC_SAM_64B;
--- 97,105 ----
             openserial_printCritical(COMPONENT_IPHC,ERR_INVALID_FWDMODE,
                              (errorparameter_t)0,
                              (errorparameter_t)0);
!         } 
!         dam = IPHC_DAM_ELIDED;
!         p_dest = NULL;     
        } else {
           //else, not a direct neighbour use 64B address
           sam = IPHC_SAM_64B;
***************
*** 113,119 ****
       }else{
         //source routing
        sam = IPHC_SAM_128B;
!       dam = IPHC_DAM_ELIDED;
        p_dest = NULL;
        p_src = &(msg->l3_sourceAdd);
       }
--- 118,124 ----
       }else{
         //source routing
        sam = IPHC_SAM_128B;
!       dam = IPHC_DAM_ELIDED; //poipoi xv not true, should not be elided.
        p_dest = NULL;
        p_src = &(msg->l3_sourceAdd);
       }
***************
*** 125,135 ****
     // decrement the packet's hop limit
     ipv6_header.hop_limit--;
     
     if (prependIPv6Header(msg,
              IPHC_TF_ELIDED,
              0, // value_flowlabel is not copied
              nh,
!             msg->l4_protocol,
              IPHC_HLIM_INLINE,
              ipv6_header.hop_limit,
              IPHC_CID_NO,
--- 130,149 ----
     // decrement the packet's hop limit
     ipv6_header.hop_limit--;
     
+    //prepend Option hop by hop header except when src routing and dst is not 0xffff -- this is a little trick as src routing is using an option header set to 0x00
+    next_header=msg->l4_protocol;
+    if (hopbyhop_option->optionType==RPL_HOPBYHOP_HEADER_OPTION_TYPE 
+        && packetfunctions_isBroadcastMulticast(&(msg->l3_destinationAdd))==FALSE ){
+       prependIPv6HopByHopHeader(msg, msg->l4_protocol, nh, hopbyhop_option);
+       //change nh to point to the newly added header
+       next_header=IANA_IPv6HOPOPT;// use 0x00 as NH to indicate option header -- see rfc 2460
+    }
+    //then regular header
     if (prependIPv6Header(msg,
              IPHC_TF_ELIDED,
              0, // value_flowlabel is not copied
              nh,
!             next_header, 
              IPHC_HLIM_INLINE,
              ipv6_header.hop_limit,
              IPHC_CID_NO,
***************
*** 144,149 ****
--- 158,164 ----
              )==E_FAIL) {
        return E_FAIL;
     }
+    
     return res_send(msg);
  }
  
***************
*** 147,154 ****
     return res_send(msg);
  }
  
  //send from bridge: 6LoWPAN header already added by OpenLBR, send as is
! error_t iphc_sendFromBridge(OpenQueueEntry_t *msg) {
     msg->owner = COMPONENT_IPHC;
     // error checking
     if (idmanager_getIsBridge()==FALSE) {
--- 162,172 ----
     return res_send(msg);
  }
  
+ 
+ 
+ 
  //send from bridge: 6LoWPAN header already added by OpenLBR, send as is
! owerror_t iphc_sendFromBridge(OpenQueueEntry_t *msg) {
     msg->owner = COMPONENT_IPHC;
     // error checking
     if (idmanager_getIsBridge()==FALSE) {
***************
*** 160,166 ****
     return res_send(msg);
  }
  
! void iphc_sendDone(OpenQueueEntry_t* msg, error_t error) {
     msg->owner = COMPONENT_IPHC;
     if (msg->creator==COMPONENT_OPENBRIDGE) {
        openbridge_sendDone(msg,error);
--- 178,184 ----
     return res_send(msg);
  }
  
! void iphc_sendDone(OpenQueueEntry_t* msg, owerror_t error) {
     msg->owner = COMPONENT_IPHC;
     if (msg->creator==COMPONENT_OPENBRIDGE) {
        openbridge_sendDone(msg,error);
***************
*** 171,182 ****
  
  void iphc_receive(OpenQueueEntry_t* msg) {
     ipv6_header_iht ipv6_header;
     msg->owner  = COMPONENT_IPHC;
     ipv6_header = retrieveIPv6Header(msg);
     if (idmanager_getIsBridge()==FALSE ||
        packetfunctions_isBroadcastMulticast(&(ipv6_header.dest))) {
        packetfunctions_tossHeader(msg,ipv6_header.header_length);
!       forwarding_receive(msg,ipv6_header);       //up the internal stack
     } else {
        openbridge_receive(msg);                   //out to the OpenVisualizer
     }
--- 189,214 ----
  
  void iphc_receive(OpenQueueEntry_t* msg) {
     ipv6_header_iht ipv6_header;
+    ipv6_hopbyhop_ht ipv6_hop_header;
+    rpl_hopoption_ht hop_by_hop_option;
+    
     msg->owner  = COMPONENT_IPHC;
+    
+    //then regular header
     ipv6_header = retrieveIPv6Header(msg);
+    
+   
     if (idmanager_getIsBridge()==FALSE ||
        packetfunctions_isBroadcastMulticast(&(ipv6_header.dest))) {
        packetfunctions_tossHeader(msg,ipv6_header.header_length);
!       
!       if (ipv6_header.next_header==IANA_IPv6HOPOPT){
!           //retrieve hop by hop header
!           retrieveIPv6HopByHopHeader(msg,&ipv6_hop_header,&hop_by_hop_option);
!           //toss the header + option +tlv on it if any
!           packetfunctions_tossHeader(msg,IPv6HOP_HDR_LEN+ipv6_hop_header.HdrExtLen);
!       }
!       forwarding_receive(msg,ipv6_header,ipv6_hop_header,hop_by_hop_option);       //up the internal stack
     } else {
        openbridge_receive(msg);                   //out to the OpenVisualizer
     }
***************
*** 184,190 ****
  
  //=========================== private =========================================
  
! error_t prependIPv6Header(
        OpenQueueEntry_t* msg,
        uint8_t tf,
        uint32_t value_flowLabel,
--- 216,256 ----
  
  //=========================== private =========================================
  
! 
! void prependIPv6HopByHopHeader(OpenQueueEntry_t *msg,uint8_t nextheader, bool nh, rpl_hopoption_ht *hopbyhop_option){
!    
!     //copy them in reverse order, first option later header
!     packetfunctions_reserveHeaderSize(msg,sizeof(rpl_hopoption_ht));
!     memcpy(msg->payload,hopbyhop_option,sizeof(rpl_hopoption_ht));
!     
!     //hdr len as defined by rfc6282 sect 4.2
!     packetfunctions_reserveHeaderSize(msg,sizeof(uint8_t));
!    *((uint8_t*)(msg->payload)) = sizeof(rpl_hopoption_ht);
!     
!     //next header
!     switch (nh) {
!       case IPHC_NH_INLINE:
!         //add the next header inline
!          packetfunctions_reserveHeaderSize(msg,sizeof(uint8_t));
!          *((uint8_t*)(msg->payload)) = nextheader;
!        
!          //append NHC field on the extension header should be 1110 0000 -- see rfc 6282 sect 4.2
!          packetfunctions_reserveHeaderSize(msg,sizeof(uint8_t));
!          *((uint8_t*)(msg->payload)) = NHC_IPv6EXT_ID;
!          break;
!       case IPHC_NH_COMPRESSED:
!          packetfunctions_reserveHeaderSize(msg,sizeof(uint8_t));
!          *((uint8_t*)(msg->payload)) = NHC_IPv6EXT_ID | 0x01; //mark last bit as 1 -- see rfc 6282 sect 4.2
!         break;
!       default:
!          openserial_printCritical(COMPONENT_IPHC,ERR_6LOWPAN_UNSUPPORTED,
!                                (errorparameter_t)3,
!                                (errorparameter_t)nh);
!    }
! 
! }
! 
! owerror_t prependIPv6Header(
        OpenQueueEntry_t* msg,
        uint8_t tf,
        uint32_t value_flowLabel,
***************
*** 216,222 ****
                                    (errorparameter_t)0);
              return E_FAIL;
           };
!          packetfunctions_writeAddress(msg,value_dest,BIG_ENDIAN);
           break;
        case IPHC_DAM_64B:
           if (value_dest->type!=ADDR_64B) {
--- 282,288 ----
                                    (errorparameter_t)0);
              return E_FAIL;
           };
!          packetfunctions_writeAddress(msg,value_dest,OW_BIG_ENDIAN);
           break;
        case IPHC_DAM_64B:
           if (value_dest->type!=ADDR_64B) {
***************
*** 225,231 ****
                                    (errorparameter_t)1);
              return E_FAIL;
           };
!          packetfunctions_writeAddress(msg,value_dest,BIG_ENDIAN);
           break;
        case IPHC_DAM_128B:
           if (value_dest->type!=ADDR_128B) {
--- 291,297 ----
                                    (errorparameter_t)1);
              return E_FAIL;
           };
!          packetfunctions_writeAddress(msg,value_dest,OW_BIG_ENDIAN);
           break;
        case IPHC_DAM_128B:
           if (value_dest->type!=ADDR_128B) {
***************
*** 234,240 ****
                                    (errorparameter_t)2);
              return E_FAIL;
           };
!          packetfunctions_writeAddress(msg,value_dest,BIG_ENDIAN);
           break;
        default:
           openserial_printCritical(COMPONENT_IPHC,ERR_6LOWPAN_UNSUPPORTED,
--- 300,306 ----
                                    (errorparameter_t)2);
              return E_FAIL;
           };
!          packetfunctions_writeAddress(msg,value_dest,OW_BIG_ENDIAN);
           break;
        default:
           openserial_printCritical(COMPONENT_IPHC,ERR_6LOWPAN_UNSUPPORTED,
***************
*** 249,255 ****
        case IPHC_SAM_16B:
          if(fw_SendOrfw_Rcv==PCKTSEND)
          {
!          packetfunctions_writeAddress(msg, (idmanager_getMyID(ADDR_16B)),BIG_ENDIAN);
          }
          if(fw_SendOrfw_Rcv==PCKTFORWARD)
          {
--- 315,321 ----
        case IPHC_SAM_16B:
          if(fw_SendOrfw_Rcv==PCKTSEND)
          {
!          packetfunctions_writeAddress(msg, (idmanager_getMyID(ADDR_16B)),OW_BIG_ENDIAN);
          }
          if(fw_SendOrfw_Rcv==PCKTFORWARD)
          {
***************
*** 259,271 ****
                                        (errorparameter_t)0);
                  return E_FAIL;
              } 
!             packetfunctions_writeAddress(msg,value_src,BIG_ENDIAN);
          }
           break;
        case IPHC_SAM_64B:
          if(fw_SendOrfw_Rcv==PCKTSEND)
          {
!           packetfunctions_writeAddress(msg, (idmanager_getMyID(ADDR_64B)),BIG_ENDIAN);
          }
           if(fw_SendOrfw_Rcv==PCKTFORWARD)
          {
--- 325,337 ----
                                        (errorparameter_t)0);
                  return E_FAIL;
              } 
!             packetfunctions_writeAddress(msg,value_src,OW_BIG_ENDIAN);
          }
           break;
        case IPHC_SAM_64B:
          if(fw_SendOrfw_Rcv==PCKTSEND)
          {
!           packetfunctions_writeAddress(msg, (idmanager_getMyID(ADDR_64B)),OW_BIG_ENDIAN);
          }
           if(fw_SendOrfw_Rcv==PCKTFORWARD)
          {
***************
*** 275,288 ****
                                        (errorparameter_t)1);
                  return E_FAIL;
              }      
!             packetfunctions_writeAddress(msg, value_src,BIG_ENDIAN);
          }
           break;
        case IPHC_SAM_128B:
          if(fw_SendOrfw_Rcv==PCKTSEND)
          {
!          packetfunctions_writeAddress(msg, (idmanager_getMyID(ADDR_64B)),BIG_ENDIAN);
!          packetfunctions_writeAddress(msg, (idmanager_getMyID(ADDR_PREFIX)),BIG_ENDIAN);
          }
          if(fw_SendOrfw_Rcv==PCKTFORWARD)
          {
--- 341,354 ----
                                        (errorparameter_t)1);
                  return E_FAIL;
              }      
!             packetfunctions_writeAddress(msg, value_src,OW_BIG_ENDIAN);
          }
           break;
        case IPHC_SAM_128B:
          if(fw_SendOrfw_Rcv==PCKTSEND)
          {
!          packetfunctions_writeAddress(msg, (idmanager_getMyID(ADDR_64B)),OW_BIG_ENDIAN);
!          packetfunctions_writeAddress(msg, (idmanager_getMyID(ADDR_PREFIX)),OW_BIG_ENDIAN);
          }
          if(fw_SendOrfw_Rcv==PCKTFORWARD)
          {
***************
*** 292,298 ****
                                        (errorparameter_t)2);
                  return E_FAIL;
               }
!            packetfunctions_writeAddress(msg,value_src,BIG_ENDIAN);
          }
           break;
        default:
--- 358,364 ----
                                        (errorparameter_t)2);
                  return E_FAIL;
               }
!            packetfunctions_writeAddress(msg,value_src,OW_BIG_ENDIAN);
          }
           break;
        default:
***************
*** 374,379 ****
--- 440,506 ----
     return E_SUCCESS;
  }
  
+ 
+ 
+ void retrieveIPv6HopByHopHeader(OpenQueueEntry_t *msg,ipv6_hopbyhop_ht *hopbyhop_header, rpl_hopoption_ht *rpl_option){
+   uint8_t temp_8b;
+   
+   hopbyhop_header->headerlen=0;
+    
+   hopbyhop_header->lowpan_nhc = *((uint8_t*)(msg->payload)+ hopbyhop_header->headerlen);
+   hopbyhop_header->headerlen += sizeof(uint8_t);   
+   
+    //next header
+    switch ( hopbyhop_header->lowpan_nhc & NHC_HOP_NH_MASK) {
+       case IPHC_NH_INLINE:
+          // Full 8 bits for Next Header are carried in-line
+          hopbyhop_header->next_header_compressed = FALSE;
+          hopbyhop_header->nextHeader = *((uint8_t*)(msg->payload)+hopbyhop_header->headerlen);
+          hopbyhop_header->headerlen+= sizeof(uint8_t);   
+          break;
+       case IPHC_NH_COMPRESSED:
+          // the Next header field is compressed and the next header is encoded
+          // using LOWPAN_NHC, which is discussed in Section 4.1 of RFC6282
+          // we don't parse anything here, but will look at the (compressed)
+          // next header after having parsed all address fields.
+          hopbyhop_header->next_header_compressed = TRUE;
+          break;
+       default:
+          openserial_printError(COMPONENT_IPHC,ERR_6LOWPAN_UNSUPPORTED,
+                                (errorparameter_t)7,
+                                (errorparameter_t)hopbyhop_header->lowpan_nhc);
+          break;
+    }
+    
+    //len of options
+    hopbyhop_header->HdrExtLen =*((uint8_t*)(msg->payload)+hopbyhop_header->headerlen);
+    hopbyhop_header->headerlen+= sizeof(uint8_t);  
+    //copy the options
+    memcpy(rpl_option,((uint8_t*)(msg->payload)+hopbyhop_header->headerlen),sizeof(rpl_hopoption_ht));
+    hopbyhop_header->headerlen+= sizeof(rpl_hopoption_ht);  
+    
+    //now in case nh compressed:
+     /*
+    During the parsing of the nh field, we found that the next header was
+    compressed. We now identify which next (compressed) header this is, and
+    populate the hopbyhop_header.nextHeader field accordingly. It's the role of the
+    appropriate transport module to decompress the header.
+    */
+    if (hopbyhop_header->next_header_compressed==TRUE) {
+       temp_8b   = *((uint8_t*)(msg->payload)+ hopbyhop_header->headerlen);
+       if    ( (temp_8b & NHC_UDP_MASK) == NHC_UDP_ID) {
+          hopbyhop_header->nextHeader = IANA_UDP;
+       }else {
+          // the next header could be an IPv6 extension header, or misformed
+          hopbyhop_header->nextHeader = IANA_UNDEFINED;
+          openserial_printError(COMPONENT_IPHC,ERR_6LOWPAN_UNSUPPORTED,
+                                (errorparameter_t)14,
+                                (errorparameter_t)hopbyhop_header->nextHeader);
+       }
+    }
+ }
+ 
+ 
  ipv6_header_iht retrieveIPv6Header(OpenQueueEntry_t* msg) {
     uint8_t         temp_8b;
     open_addr_t     temp_addr_16b;
***************
*** 446,451 ****
--- 573,579 ----
           ipv6_header.next_header_compressed = FALSE;
           ipv6_header.next_header = *((uint8_t*)(msg->payload)+ipv6_header.header_length);
           ipv6_header.header_length += sizeof(uint8_t);
+       
           break;
        case IPHC_NH_COMPRESSED:
           // the Next header field is compressed and the next header is encoded
***************
*** 487,504 ****
           packetfunctions_mac64bToIp128b(idmanager_getMyID(ADDR_PREFIX),&(msg->l2_nextORpreviousHop),&ipv6_header.src);
           break;
        case IPHC_SAM_16B:
!          packetfunctions_readAddress(((uint8_t*)(msg->payload+ipv6_header.header_length)),ADDR_16B,&temp_addr_16b,BIG_ENDIAN);
           ipv6_header.header_length += 2*sizeof(uint8_t);
           packetfunctions_mac16bToMac64b(&temp_addr_16b,&temp_addr_64b);
           packetfunctions_mac64bToIp128b(idmanager_getMyID(ADDR_PREFIX),&temp_addr_64b,&ipv6_header.src);
           break;
        case IPHC_SAM_64B:
!          packetfunctions_readAddress(((uint8_t*)(msg->payload+ipv6_header.header_length)),ADDR_64B,&temp_addr_64b,BIG_ENDIAN);
           ipv6_header.header_length += 8*sizeof(uint8_t);
           packetfunctions_mac64bToIp128b(idmanager_getMyID(ADDR_PREFIX),&temp_addr_64b,&ipv6_header.src);
           break;
        case IPHC_SAM_128B:
!          packetfunctions_readAddress(((uint8_t*)(msg->payload+ipv6_header.header_length)),ADDR_128B,&ipv6_header.src,BIG_ENDIAN);
           ipv6_header.header_length += 16*sizeof(uint8_t);
           break;
        default:
--- 615,632 ----
           packetfunctions_mac64bToIp128b(idmanager_getMyID(ADDR_PREFIX),&(msg->l2_nextORpreviousHop),&ipv6_header.src);
           break;
        case IPHC_SAM_16B:
!          packetfunctions_readAddress(((uint8_t*)(msg->payload+ipv6_header.header_length)),ADDR_16B,&temp_addr_16b,OW_BIG_ENDIAN);
           ipv6_header.header_length += 2*sizeof(uint8_t);
           packetfunctions_mac16bToMac64b(&temp_addr_16b,&temp_addr_64b);
           packetfunctions_mac64bToIp128b(idmanager_getMyID(ADDR_PREFIX),&temp_addr_64b,&ipv6_header.src);
           break;
        case IPHC_SAM_64B:
!          packetfunctions_readAddress(((uint8_t*)(msg->payload+ipv6_header.header_length)),ADDR_64B,&temp_addr_64b,OW_BIG_ENDIAN);
           ipv6_header.header_length += 8*sizeof(uint8_t);
           packetfunctions_mac64bToIp128b(idmanager_getMyID(ADDR_PREFIX),&temp_addr_64b,&ipv6_header.src);
           break;
        case IPHC_SAM_128B:
!          packetfunctions_readAddress(((uint8_t*)(msg->payload+ipv6_header.header_length)),ADDR_128B,&ipv6_header.src,OW_BIG_ENDIAN);
           ipv6_header.header_length += 16*sizeof(uint8_t);
           break;
        default:
***************
*** 513,530 ****
           packetfunctions_mac64bToIp128b(idmanager_getMyID(ADDR_PREFIX),idmanager_getMyID(ADDR_64B),&(ipv6_header.dest));
           break;
        case IPHC_DAM_16B:
!          packetfunctions_readAddress(((uint8_t*)(msg->payload+ipv6_header.header_length)),ADDR_16B,&temp_addr_16b,BIG_ENDIAN);
           ipv6_header.header_length += 2*sizeof(uint8_t);
           packetfunctions_mac16bToMac64b(&temp_addr_16b,&temp_addr_64b);
           packetfunctions_mac64bToIp128b(idmanager_getMyID(ADDR_PREFIX),&temp_addr_64b,&ipv6_header.dest);
           break;
        case IPHC_DAM_64B:
!          packetfunctions_readAddress(((uint8_t*)(msg->payload+ipv6_header.header_length)),ADDR_64B,&temp_addr_64b,BIG_ENDIAN);
           ipv6_header.header_length += 8*sizeof(uint8_t);
           packetfunctions_mac64bToIp128b(idmanager_getMyID(ADDR_PREFIX),&temp_addr_64b,&ipv6_header.dest);
           break;
        case IPHC_DAM_128B:
!          packetfunctions_readAddress(((uint8_t*)(msg->payload+ipv6_header.header_length)),ADDR_128B,&ipv6_header.dest,BIG_ENDIAN);
           ipv6_header.header_length += 16*sizeof(uint8_t);
           break;
        default:
--- 641,658 ----
           packetfunctions_mac64bToIp128b(idmanager_getMyID(ADDR_PREFIX),idmanager_getMyID(ADDR_64B),&(ipv6_header.dest));
           break;
        case IPHC_DAM_16B:
!          packetfunctions_readAddress(((uint8_t*)(msg->payload+ipv6_header.header_length)),ADDR_16B,&temp_addr_16b,OW_BIG_ENDIAN);
           ipv6_header.header_length += 2*sizeof(uint8_t);
           packetfunctions_mac16bToMac64b(&temp_addr_16b,&temp_addr_64b);
           packetfunctions_mac64bToIp128b(idmanager_getMyID(ADDR_PREFIX),&temp_addr_64b,&ipv6_header.dest);
           break;
        case IPHC_DAM_64B:
!          packetfunctions_readAddress(((uint8_t*)(msg->payload+ipv6_header.header_length)),ADDR_64B,&temp_addr_64b,OW_BIG_ENDIAN);
           ipv6_header.header_length += 8*sizeof(uint8_t);
           packetfunctions_mac64bToIp128b(idmanager_getMyID(ADDR_PREFIX),&temp_addr_64b,&ipv6_header.dest);
           break;
        case IPHC_DAM_128B:
!          packetfunctions_readAddress(((uint8_t*)(msg->payload+ipv6_header.header_length)),ADDR_128B,&ipv6_header.dest,OW_BIG_ENDIAN);
           ipv6_header.header_length += 16*sizeof(uint8_t);
           break;
        default:
***************
*** 543,560 ****
        temp_8b   = *((uint8_t*)(msg->payload)+ipv6_header.header_length);
        if    ( (temp_8b & NHC_UDP_MASK) == NHC_UDP_ID) {
           ipv6_header.next_header = IANA_UDP;
!       } else {
           // the next header could be an IPv6 extension header, or misformed
           ipv6_header.next_header = IANA_UNDEFINED;
           openserial_printError(COMPONENT_IPHC,ERR_6LOWPAN_UNSUPPORTED,
!                                (errorparameter_t)11,
                                 (errorparameter_t)ipv6_header.next_header);
        }
     }
!    // this is a temporary workaround for allowing multicast RAs to go through
!    //poipoi xv -- TODO -- check if this still needed. NO RAs anymore after RPL implementation.
!    /*if (m==1 && dam==IPHC_DAM_ELIDED) {
!       ipv6_header.header_length += sizeof(uint8_t);
!    }*/
     return ipv6_header;
  }
--- 671,695 ----
        temp_8b   = *((uint8_t*)(msg->payload)+ipv6_header.header_length);
        if    ( (temp_8b & NHC_UDP_MASK) == NHC_UDP_ID) {
           ipv6_header.next_header = IANA_UDP;
!       }else if ( (temp_8b & NHC_IPv6EXT_MASK) == NHC_IPv6EXT_ID){
!         if( (temp_8b & NHC_IPv6HOP_MASK) == NHC_IPv6HOP_VAL){
!           //it is hop by hop header
!           ipv6_header.next_header = IANA_IPv6HOPOPT;
!         }else{
!           // the next header could be another IPv6 extension header
!           ipv6_header.next_header = IANA_UNDEFINED;
!           openserial_printError(COMPONENT_IPHC,ERR_6LOWPAN_UNSUPPORTED,
!                                (errorparameter_t)11,
!                                (errorparameter_t)ipv6_header.next_header);
!         }
!       }else {
           // the next header could be an IPv6 extension header, or misformed
           ipv6_header.next_header = IANA_UNDEFINED;
           openserial_printError(COMPONENT_IPHC,ERR_6LOWPAN_UNSUPPORTED,
!                                (errorparameter_t)12,
                                 (errorparameter_t)ipv6_header.next_header);
        }
     }
!    
     return ipv6_header;
  }
diff -crB stock/openwsn/03a-IPHC/iphc.h dev/openwsn/03a-IPHC/iphc.h
*** stock/openwsn/03a-IPHC/iphc.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/03a-IPHC/iphc.h	Wed Jan 29 10:33:22 2014
***************
*** 8,16 ****
--- 8,18 ----
  \{
  */
  
+ #include "openwsn.h"
  //=========================== define ==========================================
  
  #define IPHC_DEFAULT_HOP_LIMIT 65
+ #define IPv6HOP_HDR_LEN         3
  
  enum IPHC_enums {
     IPHC_DISPATCH             = 5,
***************
*** 50,55 ****
--- 52,64 ----
     NHC_UDP_ID                = 0xf0,          // b1111 0000
  };
  
+ enum NHC_IPv6HOP_enums {
+    NHC_IPv6HOP_MASK        = 0x0e,
+    NHC_IPv6HOP_VAL         = 0x0e,
+    NHC_HOP_NH_MASK         = 0x01,
+ };
+ 
+ 
  enum NHC_UDP_enums {
     NHC_UDP_C_MASK            = 0x40,
     NHC_UDP_PORTS_MASK        = 0x03,
***************
*** 116,130 ****
     uint8_t     header_length;          ///< needed to toss the header
  } ipv6_header_iht; //iht for "internal header type"
  
  //=========================== variables =======================================
  
  //=========================== prototypes ======================================
  
! void    iphc_init();
! error_t iphc_sendFromForwarding(OpenQueueEntry_t *msg, ipv6_header_iht ipv6_header, uint8_t fw_SendOrfw_Rcv);
! error_t iphc_sendFromBridge(OpenQueueEntry_t *msg);
! void    iphc_sendDone(OpenQueueEntry_t* msg, error_t error);
! void    iphc_receive(OpenQueueEntry_t* msg);
  
  /**
  \}
--- 125,180 ----
     uint8_t     header_length;          ///< needed to toss the header
  } ipv6_header_iht; //iht for "internal header type"
  
+ 
+ /*
+  The Hop-by-Hop Options header is used to carry optional information
+    that must be examined by every node along a packet's delivery path.
+    The Hop-by-Hop Options header is identified by a Next Header value of
+    0 in the IPv6 header, and has the following format:
+ */
+ typedef struct {
+   /*see rfc 6282 section 4.2 The first 7 bits serve as an identifier for the IPv6 Extension Header immediately
+    following the LOWPAN_NHC octet.  The remaining bit indicates whether
+    or not the following header utilizes LOWPAN_NHC encoding. */
+    uint8_t    headerlen;// counter for internal use
+    bool       next_header_compressed;
+    uint8_t    lowpan_nhc; 
+    uint8_t    nextHeader;//IPv6 hop by hop header field see rfc 2460 section 4.3 
+    uint8_t    HdrExtLen; //IPv6 hop by hop header field see rfc 6282 section 4.2 
+    /*
+    The Length field contained in a compressed IPv6 Extension Header
+    indicates the number of octets that pertain to the (compressed)
+    extension header following the Length field.  Note that this changes
+    the Length field definition in [RFC2460] from indicating the header
+    size in 8-octet units, not including the first 8 octets.  Changing
+    the Length field to be in units of octets removes wasteful internal
+    fragmentation.*/
+    
+ } ipv6_hopbyhop_ht;
+ 
+ PRAGMA(pack(1));
+ typedef struct {
+    //RPL hop by hop option header as described by RFC 6553 p.3
+    uint8_t    optionType;    ///0x63.
+    uint8_t    optionLen;     /////8-bit field indicating the length of the option, in octets, excluding the Option Type and Opt Data Len fields.
+    uint8_t    flags;         //ORF00000.
+    uint8_t    rplInstanceID;  //instanceid
+    uint16_t   senderRank;    //sender rank
+ } rpl_hopoption_ht;
+ PRAGMA(pack());
  //=========================== variables =======================================
  
  //=========================== prototypes ======================================
  
! void    iphc_init(void);
! owerror_t iphc_sendFromForwarding(OpenQueueEntry_t *msg, 
!                                   ipv6_header_iht ipv6_header, 
!                                   rpl_hopoption_ht *hopbyhop_option, 
!                                   uint8_t fw_SendOrfw_Rcv);
! 
! owerror_t iphc_sendFromBridge(OpenQueueEntry_t *msg);
! void    iphc_sendDone(OpenQueueEntry_t *msg, owerror_t error);
! void    iphc_receive(OpenQueueEntry_t *msg);
  
  /**
  \}
diff -crB stock/openwsn/03a-IPHC/openbridge.c dev/openwsn/03a-IPHC/openbridge.c
*** stock/openwsn/03a-IPHC/openbridge.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/03a-IPHC/openbridge.c	Wed Jan 29 10:33:22 2014
***************
*** 9,41 ****
  //=========================== variables =======================================
  
  //=========================== prototypes ======================================
- 
  //=========================== public ==========================================
  
! void openbridge_init() {
  }
  
! void openbridge_triggerData() {
     uint8_t           input_buffer[136];//worst case: 8B of next hop + 128B of data
     OpenQueueEntry_t* pkt;
     uint8_t           numDataBytes;
!    
     numDataBytes = openserial_getNumDataBytes();
!    openserial_getInputBuffer(&(input_buffer[0]),numDataBytes);
!    
     //poipoi xv
     //this is a temporal workaround as we are never supposed to get chunks of data
     //longer than input buffer size.. I assume that HDLC will solve that.
!    
!    if (numDataBytes>136){
         openserial_printError(COMPONENT_OPENBRIDGE,ERR_INPUTBUFFER_LENGTH,
!                    (errorparameter_t)0,
!                    (errorparameter_t)numDataBytes);
!        //return;
!        //poipoi xv test that..
!        numDataBytes=sizeof(input_buffer);
     }
!    
     if (idmanager_getIsBridge()==TRUE && numDataBytes>0) {
        pkt = openqueue_getFreePacketBuffer(COMPONENT_OPENBRIDGE);
        if (pkt==NULL) {
--- 9,41 ----
  //=========================== variables =======================================
  
  //=========================== prototypes ======================================
  //=========================== public ==========================================
  
! void openbridge_init(void) {
  }
  
! void openbridge_triggerData(void) {
     uint8_t           input_buffer[136];//worst case: 8B of next hop + 128B of data
     OpenQueueEntry_t* pkt;
     uint8_t           numDataBytes;
!   
     numDataBytes = openserial_getNumDataBytes();
!   
     //poipoi xv
     //this is a temporal workaround as we are never supposed to get chunks of data
     //longer than input buffer size.. I assume that HDLC will solve that.
!    // MAC header is 13B + 8 next hop so we cannot accept packets that are longer than 118B
!    if (numDataBytes>(136 - 21) || numDataBytes<8){
!    //to prevent too short or too long serial frames to kill the stack  
         openserial_printError(COMPONENT_OPENBRIDGE,ERR_INPUTBUFFER_LENGTH,
!                    (errorparameter_t)numDataBytes,
!                    (errorparameter_t)0);
!        return;
     }
!   
!    //copying the buffer once we know it is not too big
!    openserial_getInputBuffer(&(input_buffer[0]),numDataBytes);
!   
     if (idmanager_getIsBridge()==TRUE && numDataBytes>0) {
        pkt = openqueue_getFreePacketBuffer(COMPONENT_OPENBRIDGE);
        if (pkt==NULL) {
***************
*** 53,58 ****
--- 53,65 ----
        //payload
        packetfunctions_reserveHeaderSize(pkt,numDataBytes-8);
        memcpy(pkt->payload,&(input_buffer[8]),numDataBytes-8);
+       
+       //this is to catch the too short packet. remove it after fw-103 is solved.
+       if (numDataBytes<16){
+               openserial_printError(COMPONENT_OPENBRIDGE,ERR_INVALIDSERIALFRAME,
+                             (errorparameter_t)0,
+                             (errorparameter_t)0);
+       }        
        //send
        if ((iphc_sendFromBridge(pkt))==E_FAIL) {
           openqueue_freePacketBuffer(pkt);
***************
*** 60,66 ****
     }
  }
  
! void openbridge_sendDone(OpenQueueEntry_t* msg, error_t error) {
     msg->owner = COMPONENT_OPENBRIDGE;
     if (msg->creator!=COMPONENT_OPENBRIDGE) {
        openserial_printError(COMPONENT_OPENBRIDGE,ERR_UNEXPECTED_SENDDONE,
--- 67,73 ----
     }
  }
  
! void openbridge_sendDone(OpenQueueEntry_t* msg, owerror_t error) {
     msg->owner = COMPONENT_OPENBRIDGE;
     if (msg->creator!=COMPONENT_OPENBRIDGE) {
        openserial_printError(COMPONENT_OPENBRIDGE,ERR_UNEXPECTED_SENDDONE,
diff -crB stock/openwsn/03a-IPHC/openbridge.h dev/openwsn/03a-IPHC/openbridge.h
*** stock/openwsn/03a-IPHC/openbridge.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/03a-IPHC/openbridge.h	Wed Jan 29 10:33:22 2014
***************
*** 16,24 ****
  
  //=========================== prototypes ======================================
  
! void openbridge_init();
! void openbridge_triggerData();
! void openbridge_sendDone(OpenQueueEntry_t* msg, error_t error);
  void openbridge_receive(OpenQueueEntry_t* msg);
  
  /**
--- 16,24 ----
  
  //=========================== prototypes ======================================
  
! void openbridge_init(void);
! void openbridge_triggerData(void);
! void openbridge_sendDone(OpenQueueEntry_t* msg, owerror_t error);
  void openbridge_receive(OpenQueueEntry_t* msg);
  
  /**
diff -crB stock/openwsn/03b-IPv6/Makefile dev/openwsn/03b-IPv6/Makefile
*** stock/openwsn/03b-IPv6/Makefile	Tue Jan 28 12:35:56 2014
--- dev/openwsn/03b-IPv6/Makefile	Wed Jan 29 10:33:22 2014
***************
*** 0 ****
--- 1,32 ----
+ SUBMOD:=$(shell basename $(CURDIR)).a
+ #BINDIR = $(RIOTBASE)/bin/
+ SRC = $(wildcard *.c)
+ OBJ = $(SRC:%.c=$(BINDIR)%.o)
+ DEP = $(SRC:%.c=$(BINDIR)%.d)
+ 
+ INCLUDES += -I$(RIOTBASE) -I$(RIOTBASE)/sys/include -I$(RIOTBASE)/core/include -I$(RIOTBASE)/drivers/include -I$(RIOTBASE)/drivers/cc110x_ng/include -I$(RIOTBASE)/cpu/arm_common/include -I$(RIOTBASE)/sys/net/include/ 
+ INCLUDES += -I$(CURDIR)/02a-MAClow
+ INCLUDES += -I$(CURDIR)/02b-MAChigh
+ INCLUDES += -I$(CURDIR)/03a-IPHC
+ INCLUDES += -I$(CURDIR)/03b-IPv6
+ INCLUDES += -I$(CURDIR)/04-TRAN
+ INCLUDES += -I$(CURDIR)/cross-layers
+ 
+ .PHONY: $(BINDIR)$(SUBMOD)
+ 
+ $(BINDIR)$(SUBMOD): $(OBJ)
+ 	$(AD)$(AR) rcs $(BINDIR)$(MODULE) $(OBJ)
+ 
+ # pull in dependency info for *existing* .o files
+ -include $(OBJ:.o=.d)
+ 
+ # compile and generate dependency info
+ $(BINDIR)%.o: %.c
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -c $*.c -o $(BINDIR)$*.o
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -MM $*.c > $(BINDIR)$*.d
+ 	@printf "$(BINDIR)" | cat - $(BINDIR)$*.d > /tmp/riot_out && mv /tmp/riot_out $(BINDIR)$*.d
+ 
+ # remove compilation products
+ 
+ clean:
+ 	rm -f $(OBJ) $(DEP)
diff -crB stock/openwsn/03b-IPv6/forwarding.c dev/openwsn/03b-IPv6/forwarding.c
*** stock/openwsn/03b-IPv6/forwarding.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/03b-IPv6/forwarding.c	Wed Jan 29 10:33:22 2014
***************
*** 7,31 ****
  #include "packetfunctions.h"
  #include "neighbors.h"
  #include "icmpv6.h"
  #include "openudp.h"
  #include "opentcp.h"
  
  //=========================== variables =======================================
  
  //=========================== prototypes ======================================
  
! error_t fowarding_send_internal_RoutingTable(OpenQueueEntry_t *msg,  ipv6_header_iht ipv6_header, uint8_t fw_SendOrfw_Rcv);
  void    forwarding_getNextHop_RoutingTable(open_addr_t* destination, open_addr_t* addressToWrite);
! error_t fowarding_send_internal_SourceRouting(OpenQueueEntry_t *msg, ipv6_header_iht ipv6_header);
  
  //=========================== public ==========================================
  
  /**
  \brief Initialize this module.
  */
! void forwarding_init() {
  }
  
  /**
  \brief Send a packet originating at this mote.
  
--- 7,36 ----
  #include "packetfunctions.h"
  #include "neighbors.h"
  #include "icmpv6.h"
+ #include "icmpv6rpl.h"
  #include "openudp.h"
  #include "opentcp.h"
+ //#include "debugpins.h"
+ #include "scheduler.h"
  
  //=========================== variables =======================================
  
  //=========================== prototypes ======================================
  
! owerror_t forwarding_send_internal_RoutingTable(OpenQueueEntry_t *msg,  ipv6_header_iht ipv6_header, rpl_hopoption_ht hopbyhop_header, uint8_t fw_SendOrfw_Rcv);
  void    forwarding_getNextHop_RoutingTable(open_addr_t* destination, open_addr_t* addressToWrite);
! owerror_t forwarding_send_internal_SourceRouting(OpenQueueEntry_t *msg, ipv6_header_iht ipv6_header);
! void forwarding_createHopByHopOption(rpl_hopoption_ht *hopbyhop_opt, uint8_t flags);
  
  //=========================== public ==========================================
  
  /**
  \brief Initialize this module.
  */
! void forwarding_init(void) {
  }
  
+ 
  /**
  \brief Send a packet originating at this mote.
  
***************
*** 34,41 ****
  
  \param[in,out] msg Packet to send.
  */
! error_t forwarding_send(OpenQueueEntry_t* msg) { 
     ipv6_header_iht ipv6_header;
     open_addr_t*    myprefix;
     open_addr_t*    myadd64;
     
--- 39,48 ----
  
  \param[in,out] msg Packet to send.
  */
! owerror_t forwarding_send(OpenQueueEntry_t* msg) { 
     ipv6_header_iht ipv6_header;
+    rpl_hopoption_ht hopbyhop_opt;
+ 
     open_addr_t*    myprefix;
     open_addr_t*    myadd64;
     
***************
*** 58,65 ****
     //this is done here as send_internal is used by forwarding of packets as well which 
     //carry a hlim. This value is required to be set to a value as the following function can decrement it
     ipv6_header.hop_limit     = IPHC_DEFAULT_HOP_LIMIT;
     
!    return fowarding_send_internal_RoutingTable(msg,ipv6_header,PCKTSEND);
  }
  
  /**
--- 65,74 ----
     //this is done here as send_internal is used by forwarding of packets as well which 
     //carry a hlim. This value is required to be set to a value as the following function can decrement it
     ipv6_header.hop_limit     = IPHC_DEFAULT_HOP_LIMIT;
+     //create hop  by hop option
+    forwarding_createHopByHopOption(&hopbyhop_opt, 0x00); //flags are 0x00 -- TODO check and define macro   
     
!    return forwarding_send_internal_RoutingTable(msg,ipv6_header,hopbyhop_opt,PCKTSEND);
  }
  
  /**
***************
*** 68,74 ****
  \param[in,out] msg   The packet just sent.
  \param[in]     error The outcome of sending it.
  */
! void forwarding_sendDone(OpenQueueEntry_t* msg, error_t error) {
     
     // take ownership
     msg->owner = COMPONENT_FORWARDING;
--- 77,83 ----
  \param[in,out] msg   The packet just sent.
  \param[in]     error The outcome of sending it.
  */
! void forwarding_sendDone(OpenQueueEntry_t* msg, owerror_t error) {
     
     // take ownership
     msg->owner = COMPONENT_FORWARDING;
***************
*** 108,126 ****
  \param[in,out] msg         The packet just sent.
  \param[in]     ipv6_header The information contained in the 6LoWPAN header.
  */
! void forwarding_receive(OpenQueueEntry_t* msg, ipv6_header_iht ipv6_header) {
     
     // take ownership
     msg->owner                  = COMPONENT_FORWARDING;
     
-    // populate packets metadata with l4 information
-    msg->l4_protocol            = ipv6_header.next_header;
-    msg->l4_protocol_compressed = ipv6_header.next_header_compressed;
     
!    // populate packets metadata with l3 information
     memcpy(&(msg->l3_destinationAdd),&ipv6_header.dest,sizeof(open_addr_t));
     memcpy(&(msg->l3_sourceAdd),     &ipv6_header.src, sizeof(open_addr_t));
     
     if (
            (
               idmanager_isMyAddress(&ipv6_header.dest)
--- 117,152 ----
  \param[in,out] msg         The packet just sent.
  \param[in]     ipv6_header The information contained in the 6LoWPAN header.
  */
! void forwarding_receive(OpenQueueEntry_t* msg, 
!                         ipv6_header_iht ipv6_header, 
!                         ipv6_hopbyhop_ht ipv6_hop_header, 
!                         rpl_hopoption_ht hop_by_hop_option) {
!                           
!    uint8_t temp_flags;
     
     // take ownership
     msg->owner                  = COMPONENT_FORWARDING;
     
     
!    //contains a 
!  if (ipv6_header.next_header==IANA_IPv6HOPOPT){
!       // populate packets metadata with l4 information
!       msg->l4_protocol            = ipv6_hop_header.nextHeader;
!       msg->l4_protocol_compressed = ipv6_hop_header.next_header_compressed; // rfc 6282   
!       
!       //process HOP BY HOP header
!       
!       
!    }else{
!       msg->l4_protocol            = ipv6_header.next_header;
!       msg->l4_protocol_compressed = ipv6_header.next_header_compressed; // rfc 6282   
!    }
!    
!      // populate packets metadata with l3 information
     memcpy(&(msg->l3_destinationAdd),&ipv6_header.dest,sizeof(open_addr_t));
     memcpy(&(msg->l3_sourceAdd),     &ipv6_header.src, sizeof(open_addr_t));
     
+    
     if (
            (
               idmanager_isMyAddress(&ipv6_header.dest)
***************
*** 128,136 ****
               packetfunctions_isBroadcastMulticast(&ipv6_header.dest)
            )
            &&
            ipv6_header.next_header!=IANA_IPv6ROUTE
         ) {
!       // this packet is for me, but no routing header.
        
        // indicate received packet to upper layer
        switch(msg->l4_protocol) {
--- 154,163 ----
               packetfunctions_isBroadcastMulticast(&ipv6_header.dest)
            )
            &&
+           //ipv6 header - next header will be IANA_IPv6HOPOPT or IANA_IPv6ROUTE
            ipv6_header.next_header!=IANA_IPv6ROUTE
         ) {
!       // this packet is for me, but no src routing header.
        
        // indicate received packet to upper layer
        switch(msg->l4_protocol) {
***************
*** 151,178 ****
        }
     } else {
        // this packet is not for me: relay
!       
        // change the creator of the packet
        msg->creator = COMPONENT_FORWARDING;
        
        if (ipv6_header.next_header!=IANA_IPv6ROUTE) {
           // no source routing header present
!          
           // resend as if from upper layer 
!          if (fowarding_send_internal_RoutingTable(msg, ipv6_header,PCKTFORWARD)==E_FAIL) {
              openqueue_freePacketBuffer(msg);
           }
        } else {
!          // source routing header present
!          
!          if (fowarding_send_internal_SourceRouting(msg, ipv6_header)==E_FAIL) {
!             openqueue_freePacketBuffer(msg);
           }
        }
     }
  }
  
! //=========================== private =========================================
  
  /**
  \brief Send a packet using the routing table to find the next hop.
--- 178,230 ----
        }
     } else {
        // this packet is not for me: relay
!    
        // change the creator of the packet
        msg->creator = COMPONENT_FORWARDING;
        
        if (ipv6_header.next_header!=IANA_IPv6ROUTE) {
           // no source routing header present
!           
!           //process HOP bY HOP header
!           temp_flags = hop_by_hop_option.flags;
!           if ((temp_flags & O_FLAG)!=0){
!             //error wrong direction
!             //what todo? print the error
!             openserial_printError(COMPONENT_FORWARDING,ERR_WRONG_DIRECTION,
!                                   (errorparameter_t)1,
!                                   (errorparameter_t)1);
!           }
!           if (hop_by_hop_option.senderRank < neighbors_getMyDAGrank()){
!             //wrong rank relation.. loop detected
!             temp_flags |= R_FLAG; //set r flag.
!             openserial_printError(COMPONENT_FORWARDING,ERR_LOOP_DETECTED,
!                                   (errorparameter_t) hop_by_hop_option.senderRank,
!                                   (errorparameter_t) neighbors_getMyDAGrank());
!           }
!             
!           //O flag should always be 0 as this is upstream route.
!           
!           forwarding_createHopByHopOption(&hop_by_hop_option, temp_flags); 
!    
!         
           // resend as if from upper layer 
!          if (forwarding_send_internal_RoutingTable(msg, ipv6_header,hop_by_hop_option,PCKTFORWARD)==E_FAIL) {
              openqueue_freePacketBuffer(msg);
           }
        } else {
!          // source routing header present 
!           if (forwarding_send_internal_SourceRouting(msg, ipv6_header)==E_FAIL) {
!             //already freed by send_internal if it fails
!             //todo change error type to another that says src_route failure.
!            openserial_printError(COMPONENT_FORWARDING,ERR_INVALID_FWDMODE,
!                                   (errorparameter_t)0,
!                                   (errorparameter_t)0);
           }
        }
     }
  }
  
! 
  
  /**
  \brief Send a packet using the routing table to find the next hop.
***************
*** 182,188 ****
  \param[in]     fw_SendOrfw_Rcv The packet is originating from this mote
     (PCKTSEND), or forwarded (PCKTFORWARD).
  */
! error_t fowarding_send_internal_RoutingTable(OpenQueueEntry_t* msg, ipv6_header_iht ipv6_header, uint8_t fw_SendOrfw_Rcv) {
     
     // retrieve the next hop from the routing table
     forwarding_getNextHop_RoutingTable(&(msg->l3_destinationAdd),&(msg->l2_nextORpreviousHop));
--- 234,240 ----
  \param[in]     fw_SendOrfw_Rcv The packet is originating from this mote
     (PCKTSEND), or forwarded (PCKTFORWARD).
  */
! owerror_t forwarding_send_internal_RoutingTable(OpenQueueEntry_t* msg, ipv6_header_iht ipv6_header, rpl_hopoption_ht hopbyhop_opt, uint8_t fw_SendOrfw_Rcv) {
     
     // retrieve the next hop from the routing table
     forwarding_getNextHop_RoutingTable(&(msg->l3_destinationAdd),&(msg->l2_nextORpreviousHop));
***************
*** 194,200 ****
     }
     
     // send to next lower layer
!    return iphc_sendFromForwarding(msg, ipv6_header, fw_SendOrfw_Rcv);
  }
  
  /**
--- 246,252 ----
     }
     
     // send to next lower layer
!    return iphc_sendFromForwarding(msg, ipv6_header, &hopbyhop_opt,fw_SendOrfw_Rcv);
  }
  
  /**
***************
*** 208,214 ****
  \param[in,out] msg             The packet to send.
  \param[in]     ipv6_header     The packet's IPv6 header.
  */
! error_t fowarding_send_internal_SourceRouting(OpenQueueEntry_t *msg, ipv6_header_iht ipv6_header) {
     uint8_t         local_CmprE;
     uint8_t         local_CmprI;
     uint8_t         numAddr;
--- 260,266 ----
  \param[in,out] msg             The packet to send.
  \param[in]     ipv6_header     The packet's IPv6 header.
  */
! owerror_t forwarding_send_internal_SourceRouting(OpenQueueEntry_t *msg, ipv6_header_iht ipv6_header) {
     uint8_t         local_CmprE;
     uint8_t         local_CmprI;
     uint8_t         numAddr;
***************
*** 218,223 ****
--- 270,279 ----
     uint8_t         octetsAddressSize;
     open_addr_t*    prefix;
     rpl_routing_ht* rpl_routing_hdr;
+   
+    rpl_hopoption_ht hopbyhop_opt; 
+    
+    memset(&hopbyhop_opt,0,sizeof(rpl_hopoption_ht));//reset everything
     
     // get my prefix
     prefix               = idmanager_getMyID(ADDR_PREFIX);
***************
*** 270,275 ****
--- 326,332 ----
              openserial_printError(COMPONENT_FORWARDING,ERR_WRONG_TRAN_PROTOCOL,
                                 (errorparameter_t)msg->l4_protocol,
                                 (errorparameter_t)1);
+             //not sure that this is correct as iphc will free it?
              openqueue_freePacketBuffer(msg);
              return E_FAIL;
        }
***************
*** 297,304 ****
           rpl_routing_hdr->SegmentsLeft--;
           
           // find next hop address in source route
!          addressposition    = numAddr-(rpl_routing_hdr->SegmentsLeft);
!          
           // how many octets have the address? 
           if (rpl_routing_hdr->SegmentsLeft > 1){
                octetsAddressSize = LENGTH_ADDR128b - local_CmprI; //max addr length - number of prefix octets that are elided in the internal route elements
--- 354,361 ----
           rpl_routing_hdr->SegmentsLeft--;
           
           // find next hop address in source route
!          //addressposition    = numAddr-(rpl_routing_hdr->SegmentsLeft);
!          addressposition    = rpl_routing_hdr->SegmentsLeft;
           // how many octets have the address? 
           if (rpl_routing_hdr->SegmentsLeft > 1){
                octetsAddressSize = LENGTH_ADDR128b - local_CmprI; //max addr length - number of prefix octets that are elided in the internal route elements
***************
*** 311,324 ****
                 msg->l2_nextORpreviousHop.type    = ADDR_16B;
                 memcpy(
                    &(msg->l2_nextORpreviousHop.addr_16b),
!                   runningPointer+((addressposition-1)*octetsAddressSize),
                    octetsAddressSize
                 );
                 // write next hop
                 msg->l3_destinationAdd.type       = ADDR_16B;
                 memcpy(
                    &(msg->l3_destinationAdd.addr_16b),
!                   runningPointer+((addressposition-1)*octetsAddressSize),
                    octetsAddressSize
                 );
                 break;
--- 368,381 ----
                 msg->l2_nextORpreviousHop.type    = ADDR_16B;
                 memcpy(
                    &(msg->l2_nextORpreviousHop.addr_16b),
!                   runningPointer+((addressposition)*octetsAddressSize),
                    octetsAddressSize
                 );
                 // write next hop
                 msg->l3_destinationAdd.type       = ADDR_16B;
                 memcpy(
                    &(msg->l3_destinationAdd.addr_16b),
!                   runningPointer+((addressposition)*octetsAddressSize),
                    octetsAddressSize
                 );
                 break;
***************
*** 327,333 ****
                 msg->l2_nextORpreviousHop.type    = ADDR_64B;
                 memcpy(
                    &(msg->l2_nextORpreviousHop.addr_64b),
!                   runningPointer+((addressposition-1)*octetsAddressSize),
                    octetsAddressSize
                 );
                 
--- 384,390 ----
                 msg->l2_nextORpreviousHop.type    = ADDR_64B;
                 memcpy(
                    &(msg->l2_nextORpreviousHop.addr_64b),
!                   runningPointer+((addressposition)*octetsAddressSize),
                    octetsAddressSize
                 );
                 
***************
*** 344,350 ****
                 
                 memcpy(
                    &(msg->l3_destinationAdd.addr_128b[8]),
!                   runningPointer+((addressposition-1)*octetsAddressSize),
                    octetsAddressSize
                 );
                 
--- 401,407 ----
                 
                 memcpy(
                    &(msg->l3_destinationAdd.addr_128b[8]),
!                   runningPointer+((addressposition)*octetsAddressSize),
                    octetsAddressSize
                 );
                 
***************
*** 354,367 ****
                 msg->l2_nextORpreviousHop.type    = ADDR_128B;
                 memcpy(
                    &(msg->l2_nextORpreviousHop.addr_128b),
!                   runningPointer+((addressposition-1)*octetsAddressSize),
                    octetsAddressSize
                 );
                 // write next hop
                 msg->l3_destinationAdd.type       = ADDR_128B;
                 memcpy(
                    &(msg->l3_destinationAdd.addr_128b),
!                   runningPointer+((addressposition-1)*octetsAddressSize),
                    octetsAddressSize
                 );
                 break;
--- 411,424 ----
                 msg->l2_nextORpreviousHop.type    = ADDR_128B;
                 memcpy(
                    &(msg->l2_nextORpreviousHop.addr_128b),
!                   runningPointer+((addressposition)*octetsAddressSize),
                    octetsAddressSize
                 );
                 // write next hop
                 msg->l3_destinationAdd.type       = ADDR_128B;
                 memcpy(
                    &(msg->l3_destinationAdd.addr_128b),
!                   runningPointer+((addressposition)*octetsAddressSize),
                    octetsAddressSize
                 );
                 break;
***************
*** 378,391 ****
     }
     
     // send to next lower layer
!    return iphc_sendFromForwarding(msg, ipv6_header, PCKTFORWARD);
  }
  
  /**
  \brief Retrieve the next hop's address from routing table.
  
  \param[in]  destination128b  Final IPv6 destination address.
! \param[out]addressToWrite64b Location to write the EUI64 of next hop to.
  */
  void forwarding_getNextHop_RoutingTable(open_addr_t* destination128b, open_addr_t* addressToWrite64b) {
     uint8_t i;
--- 435,448 ----
     }
     
     // send to next lower layer
!    return iphc_sendFromForwarding(msg, ipv6_header,&hopbyhop_opt, PCKTFORWARD);
  }
  
  /**
  \brief Retrieve the next hop's address from routing table.
  
  \param[in]  destination128b  Final IPv6 destination address.
! \param[out] addressToWrite64b Location to write the EUI64 of next hop to.
  */
  void forwarding_getNextHop_RoutingTable(open_addr_t* destination128b, open_addr_t* addressToWrite64b) {
     uint8_t i;
***************
*** 403,406 ****
        // destination is remote, send to preferred parent
        neighbors_getPreferredParentEui64(addressToWrite64b);
     }
! }
\ No newline at end of file
--- 460,478 ----
        // destination is remote, send to preferred parent
        neighbors_getPreferredParentEui64(addressToWrite64b);
     }
! }
! /*
!  * HOP BY HOP HEADER OPTION
!  */
! 
! 
! void forwarding_createHopByHopOption(rpl_hopoption_ht *hopbyhop_opt, uint8_t flags) {   
!         //set the rpl hop by hop header
! 	hopbyhop_opt->optionType = RPL_HOPBYHOP_HEADER_OPTION_TYPE;
! 	//8-bit field indicating the length of the option, in
! 	//octets, excluding the Option Type and Opt Data Len fields.
! 	hopbyhop_opt->optionLen = 0x04; //4-bytes, flags+instanceID+senderrank - no sub-tlvs
! 	hopbyhop_opt->flags = flags;
! 	hopbyhop_opt->rplInstanceID = icmpv6rpl_getRPLIntanceID(); //getit..
! 	hopbyhop_opt->senderRank = neighbors_getMyDAGrank(); //TODO change to DAGRAnk(rank) instead of rank
! }
diff -crB stock/openwsn/03b-IPv6/forwarding.h dev/openwsn/03b-IPv6/forwarding.h
*** stock/openwsn/03b-IPv6/forwarding.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/03b-IPv6/forwarding.h	Wed Jan 29 10:33:22 2014
***************
*** 10,22 ****
--- 10,32 ----
  
  #include "iphc.h"
  
+ 
  //=========================== define ==========================================
  
+ #define RPL_HOPBYHOP_HEADER_OPTION_TYPE  0x63
+ 
  enum {
     PCKTFORWARD     = 1,          
     PCKTSEND        = 2,
  };
  
+ enum {
+   O_FLAG   = 0x80,
+   R_FLAG   = 0x40,
+   F_FLAG   = 0x20,
+ };
+ 
+ 
  //=========================== typedef =========================================
  
  /**
***************
*** 40,49 ****
  
  //=========================== prototypes ======================================
  
! void    forwarding_init();
! error_t forwarding_send(OpenQueueEntry_t *msg);
! void    forwarding_sendDone(OpenQueueEntry_t* msg, error_t error);
! void    forwarding_receive(OpenQueueEntry_t* msg, ipv6_header_iht ipv6_header);
  
  /**
  \}
--- 50,62 ----
  
  //=========================== prototypes ======================================
  
! void    forwarding_init(void);
! owerror_t forwarding_send(OpenQueueEntry_t *msg);
! void    forwarding_sendDone(OpenQueueEntry_t *msg, owerror_t error);
! void    forwarding_receive(OpenQueueEntry_t *msg, 
!                            ipv6_header_iht ipv6_header, 
!                            ipv6_hopbyhop_ht ipv6_hop_header, 
!                            rpl_hopoption_ht hop_by_hop_option);
  
  /**
  \}
diff -crB stock/openwsn/03b-IPv6/icmpv6.c dev/openwsn/03b-IPv6/icmpv6.c
*** stock/openwsn/03b-IPv6/icmpv6.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/03b-IPv6/icmpv6.c	Wed Jan 29 10:33:22 2014
***************
*** 12,27 ****
  
  //=========================== public ==========================================
  
! void icmpv6_init() {
  }
  
! error_t icmpv6_send(OpenQueueEntry_t* msg) {
     msg->owner       = COMPONENT_ICMPv6;
     msg->l4_protocol = IANA_ICMPv6;
     return forwarding_send(msg);
  }
  
! void icmpv6_sendDone(OpenQueueEntry_t* msg, error_t error) {
     msg->owner = COMPONENT_ICMPv6;
     switch (msg->l4_sourcePortORicmpv6Type) {
        case IANA_ICMPv6_ECHO_REQUEST:
--- 12,27 ----
  
  //=========================== public ==========================================
  
! void icmpv6_init(void) {
  }
  
! owerror_t icmpv6_send(OpenQueueEntry_t* msg) {
     msg->owner       = COMPONENT_ICMPv6;
     msg->l4_protocol = IANA_ICMPv6;
     return forwarding_send(msg);
  }
  
! void icmpv6_sendDone(OpenQueueEntry_t* msg, owerror_t error) {
     msg->owner = COMPONENT_ICMPv6;
     switch (msg->l4_sourcePortORicmpv6Type) {
        case IANA_ICMPv6_ECHO_REQUEST:
diff -crB stock/openwsn/03b-IPv6/icmpv6.h dev/openwsn/03b-IPv6/icmpv6.h
*** stock/openwsn/03b-IPv6/icmpv6.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/03b-IPv6/icmpv6.h	Wed Jan 29 10:33:22 2014
***************
*** 48,56 ****
  
  //=========================== prototypes ======================================
  
! void     icmpv6_init();
! error_t  icmpv6_send(OpenQueueEntry_t* msg);
! void     icmpv6_sendDone(OpenQueueEntry_t* msg, error_t error);
  void     icmpv6_receive(OpenQueueEntry_t* msg);
  
  /**
--- 48,56 ----
  
  //=========================== prototypes ======================================
  
! void     icmpv6_init(void);
! owerror_t  icmpv6_send(OpenQueueEntry_t* msg);
! void     icmpv6_sendDone(OpenQueueEntry_t* msg, owerror_t error);
  void     icmpv6_receive(OpenQueueEntry_t* msg);
  
  /**
diff -crB stock/openwsn/03b-IPv6/icmpv6echo.c dev/openwsn/03b-IPv6/icmpv6echo.c
*** stock/openwsn/03b-IPv6/icmpv6echo.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/03b-IPv6/icmpv6echo.c	Wed Jan 29 10:33:22 2014
***************
*** 4,33 ****
  #include "openserial.h"
  #include "openqueue.h"
  #include "packetfunctions.h"
  
  //=========================== variables =======================================
  
- typedef struct {
-    bool        busySending;
-    open_addr_t hisAddress;
-    uint16_t    seq;
- } icmpv6echo_vars_t;
- 
  icmpv6echo_vars_t icmpv6echo_vars;
  
  //=========================== prototypes ======================================
  
  //=========================== public ==========================================
  
! void icmpv6echo_init() {
     icmpv6echo_vars.busySending = FALSE;
     icmpv6echo_vars.seq         = 0;
  }
  
! void icmpv6echo_trigger() {
     uint8_t number_bytes_from_input_buffer;
     uint8_t input_buffer[16];
     OpenQueueEntry_t* msg;
     
     //get command from OpenSerial (16B IPv6 destination address)
     number_bytes_from_input_buffer = openserial_getInputBuffer(&(input_buffer[0]),sizeof(input_buffer));
--- 4,29 ----
  #include "openserial.h"
  #include "openqueue.h"
  #include "packetfunctions.h"
+ //#include "debugpins.h"
  
  //=========================== variables =======================================
  
  icmpv6echo_vars_t icmpv6echo_vars;
  
  //=========================== prototypes ======================================
  
  //=========================== public ==========================================
  
! void icmpv6echo_init(void) {
     icmpv6echo_vars.busySending = FALSE;
     icmpv6echo_vars.seq         = 0;
  }
  
! void icmpv6echo_trigger(void) {
     uint8_t number_bytes_from_input_buffer;
     uint8_t input_buffer[16];
     OpenQueueEntry_t* msg;
+  
     
     //get command from OpenSerial (16B IPv6 destination address)
     number_bytes_from_input_buffer = openserial_getInputBuffer(&(input_buffer[0]),sizeof(input_buffer));
***************
*** 84,90 ****
     }
  }
  
! void icmpv6echo_sendDone(OpenQueueEntry_t* msg, error_t error) {
     msg->owner = COMPONENT_ICMPv6ECHO;
     if (msg->creator!=COMPONENT_ICMPv6ECHO) {//that was a packet I had not created
        openserial_printError(COMPONENT_ICMPv6ECHO,ERR_UNEXPECTED_SENDDONE,
--- 80,86 ----
     }
  }
  
! void icmpv6echo_sendDone(OpenQueueEntry_t* msg, owerror_t error) {
     msg->owner = COMPONENT_ICMPv6ECHO;
     if (msg->creator!=COMPONENT_ICMPv6ECHO) {//that was a packet I had not created
        openserial_printError(COMPONENT_ICMPv6ECHO,ERR_UNEXPECTED_SENDDONE,
***************
*** 93,99 ****
     }
     openqueue_freePacketBuffer(msg);
     icmpv6echo_vars.busySending = FALSE;
! }
  
  void icmpv6echo_receive(OpenQueueEntry_t* msg) {
     OpenQueueEntry_t* reply;
--- 89,95 ----
     }
     openqueue_freePacketBuffer(msg);
     icmpv6echo_vars.busySending = FALSE;
!  }
  
  void icmpv6echo_receive(OpenQueueEntry_t* msg) {
     OpenQueueEntry_t* reply;
***************
*** 149,152 ****
     }
  }
  
! //=========================== private =========================================
\ No newline at end of file
--- 145,148 ----
     }
  }
  
! //=========================== private =========================================
diff -crB stock/openwsn/03b-IPv6/icmpv6echo.h dev/openwsn/03b-IPv6/icmpv6echo.h
*** stock/openwsn/03b-IPv6/icmpv6echo.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/03b-IPv6/icmpv6echo.h	Wed Jan 29 10:33:22 2014
***************
*** 12,24 ****
  
  //=========================== typedef =========================================
  
! //=========================== variables =======================================
  
  //=========================== prototypes ======================================
  
! void icmpv6echo_init();
! void icmpv6echo_trigger();
! void icmpv6echo_sendDone(OpenQueueEntry_t* msg, error_t error);
  void icmpv6echo_receive(OpenQueueEntry_t* msg);
  
  /**
--- 12,30 ----
  
  //=========================== typedef =========================================
  
! //=========================== module variables ================================
! 
! typedef struct {
!    bool        busySending;
!    open_addr_t hisAddress;
!    uint16_t    seq;
! } icmpv6echo_vars_t;
  
  //=========================== prototypes ======================================
  
! void icmpv6echo_init(void);
! void icmpv6echo_trigger(void);
! void icmpv6echo_sendDone(OpenQueueEntry_t* msg, owerror_t error);
  void icmpv6echo_receive(OpenQueueEntry_t* msg);
  
  /**
diff -crB stock/openwsn/03b-IPv6/icmpv6rpl.c dev/openwsn/03b-IPv6/icmpv6rpl.c
*** stock/openwsn/03b-IPv6/icmpv6rpl.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/03b-IPv6/icmpv6rpl.c	Wed Jan 29 10:33:22 2014
***************
*** 11,56 ****
  #include "opentimers.h"
  #include "IEEE802154E.h"
  
! //=========================== variables =======================================
  
! typedef struct {
!    // admin
!    bool                      busySending;             ///< currently sending DIO/DAO.
!    uint8_t                   DODAGIDFlagSet;          ///< is DODAGID set already?
!    // DIO-related
!    icmpv6rpl_dio_ht          dio;                     ///< pre-populated DIO packet.
!    open_addr_t               dioDestination;          ///< IPv6 destination address for DIOs.
!    uint16_t                  periodDIO;               ///< duration, in ms, of a timerIdDIO timeout.
!    opentimer_id_t            timerIdDIO;              ///< ID of the timer used to send DIOs.
!    uint8_t                   delayDIO;                ///< number of timerIdDIO events before actually sending a DIO.
!    // DAO-related
!    icmpv6rpl_dao_ht          dao;                     ///< pre-populated DAO packet.
!    icmpv6rpl_dao_transit_ht  dao_transit;             ///< pre-populated DAO "Transit Info" option header.
!    icmpv6rpl_dao_target_ht  dao_target;             ///< pre-populated DAO "Transit Info" option header.
!    opentimer_id_t            timerIdDAO;              ///< ID of the timer used to send DAOs.
!    uint16_t                  periodDAO;               ///< duration, in ms, of a timerIdDAO timeout.
!    uint8_t                   delayDAO;                ///< number of timerIdDIO events before actually sending a DAO.
! } icmpv6rpl_vars_t;
  
  icmpv6rpl_vars_t             icmpv6rpl_vars;
  
  //=========================== prototypes ======================================
  
  // DIO-related
! void icmpv6rpl_timer_DIO_cb();
! void icmpv6rpl_timer_DIO_task();
! void sendDIO();
  // DAO-related
! void icmpv6rpl_timer_DAO_cb();
! void icmpv6rpl_timer_DAO_task();
! void sendDAO();
  
  //=========================== public ==========================================
  
  /**
  \brief Initialize this module.
  */
! void icmpv6rpl_init() {
     
     //===== reset local variables
     memset(&icmpv6rpl_vars,0,sizeof(icmpv6rpl_vars_t));
--- 11,41 ----
  #include "opentimers.h"
  #include "IEEE802154E.h"
  
! #include "thread.h"
  
! //=========================== variables =======================================
  
  icmpv6rpl_vars_t             icmpv6rpl_vars;
+ //static char openwsn_icmpv6rpl_DAO_stack[KERNEL_CONF_STACKSIZE_MAIN];
+ //static char openwsn_icmpv6rpl_DIO_stack[KERNEL_CONF_STACKSIZE_MAIN];
  
  //=========================== prototypes ======================================
  
  // DIO-related
! void icmpv6rpl_timer_DIO_cb(void);
! void icmpv6rpl_timer_DIO_task(void);
! void sendDIO(void);
  // DAO-related
! void icmpv6rpl_timer_DAO_cb(void);
! void icmpv6rpl_timer_DAO_task(void);
! void sendDAO(void);
  
  //=========================== public ==========================================
  
  /**
  \brief Initialize this module.
  */
! void icmpv6rpl_init(void) {
     
     //===== reset local variables
     memset(&icmpv6rpl_vars,0,sizeof(icmpv6rpl_vars_t));
***************
*** 101,107 ****
                                                D_DAO        |
                                                K_DAO;
     icmpv6rpl_vars.dao.reserved              = 0x00;
!    icmpv6rpl_vars.dao.DAOSequance           = 0x00;
     // DODAGID: to be populated upon receiving DIO
     
     icmpv6rpl_vars.dao_transit.type          = OPTION_TRANSIT_INFORMATION_TYPE;
--- 86,92 ----
                                                D_DAO        |
                                                K_DAO;
     icmpv6rpl_vars.dao.reserved              = 0x00;
!    icmpv6rpl_vars.dao.DAOSequence           = 0x00;
     // DODAGID: to be populated upon receiving DIO
     
     icmpv6rpl_vars.dao_transit.type          = OPTION_TRANSIT_INFORMATION_TYPE;
***************
*** 133,145 ****
     
  }
  
  /**
  \brief Called when DIO/DAO was sent.
  
  \param[in] msg   Pointer to the message just sent.
  \param[in] error Outcome of the sending.
  */
! void icmpv6rpl_sendDone(OpenQueueEntry_t* msg, error_t error) {
     
     // take ownership over that packet
     msg->owner = COMPONENT_ICMPv6RPL;
--- 118,134 ----
     
  }
  
+ uint8_t icmpv6rpl_getRPLIntanceID(void){
+ 	return icmpv6rpl_vars.dao.rplinstanceId;
+ }
+ 
  /**
  \brief Called when DIO/DAO was sent.
  
  \param[in] msg   Pointer to the message just sent.
  \param[in] error Outcome of the sending.
  */
! void icmpv6rpl_sendDone(OpenQueueEntry_t* msg, owerror_t error) {
     
     // take ownership over that packet
     msg->owner = COMPONENT_ICMPv6RPL;
***************
*** 244,251 ****
  \note This function is executed in interrupt context, and should only push a 
     task.
  */
! void icmpv6rpl_timer_DIO_cb() {
     scheduler_push_task(icmpv6rpl_timer_DIO_task,TASKPRIO_RPL);
  }
  
  /**
--- 233,243 ----
  \note This function is executed in interrupt context, and should only push a 
     task.
  */
! void icmpv6rpl_timer_DIO_cb(void) {
     scheduler_push_task(icmpv6rpl_timer_DIO_task,TASKPRIO_RPL);
+    /*thread_create(openwsn_icmpv6rpl_DIO_stack, KERNEL_CONF_STACKSIZE_MAIN, 
+                   PRIORITY_OPENWSN_ICMPV6RPL, CREATE_STACKTEST, 
+                   icmpv6rpl_timer_DIO_task, "icmpv6rpl_timer_DIO_task");*/
  }
  
  /**
***************
*** 253,259 ****
  
  \note This function is executed in task context, called by the scheduler.
  */
! void icmpv6rpl_timer_DIO_task() {
     
     // update the delayDIO
     icmpv6rpl_vars.delayDIO = (icmpv6rpl_vars.delayDIO+1)%5;
--- 245,251 ----
  
  \note This function is executed in task context, called by the scheduler.
  */
! void icmpv6rpl_timer_DIO_task(void) {
     
     // update the delayDIO
     icmpv6rpl_vars.delayDIO = (icmpv6rpl_vars.delayDIO+1)%5;
***************
*** 279,285 ****
  /**
  \brief Prepare and a send a RPL DIO.
  */
! void sendDIO() {
     OpenQueueEntry_t*    msg;
     
     // stop if I'm not sync'ed
--- 271,277 ----
  /**
  \brief Prepare and a send a RPL DIO.
  */
! void sendDIO(void) {
     OpenQueueEntry_t*    msg;
     
     // stop if I'm not sync'ed
***************
*** 370,377 ****
  \note This function is executed in interrupt context, and should only push a
     task.
  */
! void icmpv6rpl_timer_DAO_cb() {
!    scheduler_push_task(icmpv6rpl_timer_DAO_task,TASKPRIO_RPL);
  }
  
  /**
--- 362,372 ----
  \note This function is executed in interrupt context, and should only push a
     task.
  */
! void icmpv6rpl_timer_DAO_cb(void) {
!     scheduler_push_task(icmpv6rpl_timer_DAO_task,TASKPRIO_RPL);
!     /*thread_create(openwsn_icmpv6rpl_DAO_stack, KERNEL_CONF_STACKSIZE_MAIN, 
!                   PRIORITY_OPENWSN_ICMPV6RPL, CREATE_STACKTEST, 
!                   icmpv6rpl_timer_DAO_task, "icmpv6rpl_timer_DAO_task");*/
  }
  
  /**
***************
*** 379,385 ****
  
  \note This function is executed in task context, called by the scheduler.
  */
! void icmpv6rpl_timer_DAO_task() {
     
     // update the delayDAO
     icmpv6rpl_vars.delayDAO = (icmpv6rpl_vars.delayDAO+1)%5;
--- 374,380 ----
  
  \note This function is executed in task context, called by the scheduler.
  */
! void icmpv6rpl_timer_DAO_task(void) {
     
     // update the delayDAO
     icmpv6rpl_vars.delayDAO = (icmpv6rpl_vars.delayDAO+1)%5;
***************
*** 405,415 ****
  /**
  \brief Prepare and a send a RPL DAO.
  */
! void sendDAO() {
     OpenQueueEntry_t*    msg;                // pointer to DAO messages
     uint8_t              nbrIdx;             // running neighbor index
     uint8_t              numTransitParents,numTargetParents;  // the number of parents indicated in transit option
     open_addr_t         address;
     
     if (ieee154e_isSynch()==FALSE) {
        // I'm not sync'ed 
--- 400,411 ----
  /**
  \brief Prepare and a send a RPL DAO.
  */
! void sendDAO(void) {
     OpenQueueEntry_t*    msg;                // pointer to DAO messages
     uint8_t              nbrIdx;             // running neighbor index
     uint8_t              numTransitParents,numTargetParents;  // the number of parents indicated in transit option
     open_addr_t         address;
+    open_addr_t*        prefix;
     
     if (ieee154e_isSynch()==FALSE) {
        // I'm not sync'ed 
***************
*** 464,499 ****
     
     //===== fill in packet
     
!    //=== transit option -- from RFC 6550, page 55 - 1 transit information header per parent is required.
!    numTransitParents                        = 0;
!    for (nbrIdx=0;nbrIdx<MAXNUMNEIGHBORS;nbrIdx++) {
!       if ((neighbors_isNeighborWithLowerDAGrank(nbrIdx))==TRUE) {
!          // this neighbor is of lower DAGrank as I am
!          
!          // write it's address in DAO
!          //packetfunctions_reserveHeaderSize(msg,LENGTH_ADDR64b);
!          neighbors_getNeighbor(&address,ADDR_64B,nbrIdx);
!          packetfunctions_writeAddress(msg,&address,BIG_ENDIAN);
!         
!         
!          // update transit info fields 
!          //size of the whole option in bytes.
!          icmpv6rpl_vars.dao_transit.optionLength  = LENGTH_ADDR64b + sizeof(icmpv6rpl_dao_transit_ht);
!          icmpv6rpl_vars.dao_transit.PathControl=0; //todo. this is to set the preference of this parent.      
!          icmpv6rpl_vars.dao_transit.type=OPTION_TRANSIT_INFORMATION_TYPE;
             
!          // write transit info in packet
!          packetfunctions_reserveHeaderSize(msg,sizeof(icmpv6rpl_dao_transit_ht));
!          memcpy(
!                ((icmpv6rpl_dao_transit_ht*)(msg->payload)),
!                &(icmpv6rpl_vars.dao_transit),
!                sizeof(icmpv6rpl_dao_transit_ht)
!          );
!          
!          // remember I found it
!          numTransitParents++;
!       }  
!    }
     
     //target information is required. RFC 6550 page 55.
     /*
--- 460,490 ----
     
     //===== fill in packet
     
!    //NOTE: limit to preferrred parent only the number of DAO transit addresses to send
!    
!    //=== transit option -- from RFC 6550, page 55 - 1 transit information header per parent is required. 
!    //getting only preferred parent as transit
!    numTransitParents=0;
!    neighbors_getPreferredParentEui64(&address);
!    packetfunctions_writeAddress(msg,&address,OW_BIG_ENDIAN);
!    prefix=idmanager_getMyID(ADDR_PREFIX);
!    packetfunctions_writeAddress(msg,prefix,OW_BIG_ENDIAN);
!    // update transit info fields
!    // from rfc6550 p.55 -- Variable, depending on whether or not the DODAG ParentAddress subfield is present.
!    // poipoi xv: it is not very clear if this includes all fields in the header. or as target info 2 bytes are removed.
!    // using the same pattern as in target information.
!    icmpv6rpl_vars.dao_transit.optionLength  = LENGTH_ADDR128b + sizeof(icmpv6rpl_dao_transit_ht)-2;
!    icmpv6rpl_vars.dao_transit.PathControl=0; //todo. this is to set the preference of this parent.      
!    icmpv6rpl_vars.dao_transit.type=OPTION_TRANSIT_INFORMATION_TYPE;
             
!    // write transit info in packet
!    packetfunctions_reserveHeaderSize(msg,sizeof(icmpv6rpl_dao_transit_ht));
!    memcpy(
!           ((icmpv6rpl_dao_transit_ht*)(msg->payload)),
!           &(icmpv6rpl_vars.dao_transit),
!           sizeof(icmpv6rpl_dao_transit_ht)
!    );
!    numTransitParents++;
     
     //target information is required. RFC 6550 page 55.
     /*
***************
*** 506,519 ****
           // this neighbor is of higher DAGrank as I am. so it is my child
           
           // write it's address in DAO RFC6550 page 80 check point 1.
!          neighbors_getNeighbor(&address,ADDR_64B,nbrIdx);
!          packetfunctions_writeAddress(msg,&address,BIG_ENDIAN);
          
           // update target info fields 
!          icmpv6rpl_vars.dao_target.optionLength  = LENGTH_ADDR64b + sizeof(icmpv6rpl_dao_target_ht);
           icmpv6rpl_vars.dao_target.type  = OPTION_TARGET_INFORMATION_TYPE;
           icmpv6rpl_vars.dao_target.flags  = 0;       //must be 0
!          icmpv6rpl_vars.dao_target.prefixLength = 0; //no prefix.  
           
           // write transit info in packet
           packetfunctions_reserveHeaderSize(msg,sizeof(icmpv6rpl_dao_target_ht));
--- 497,514 ----
           // this neighbor is of higher DAGrank as I am. so it is my child
           
           // write it's address in DAO RFC6550 page 80 check point 1.
!          neighbors_getNeighbor(&address,ADDR_64B,nbrIdx); 
!          packetfunctions_writeAddress(msg,&address,OW_BIG_ENDIAN);
!          prefix=idmanager_getMyID(ADDR_PREFIX);
!          packetfunctions_writeAddress(msg,prefix,OW_BIG_ENDIAN);
          
           // update target info fields 
!          // from rfc6550 p.55 -- Variable, length of the option in octets excluding the Type and Length fields.
!          // poipoi xv: assuming that type and length fields refer to the 2 first bytes of the header
!          icmpv6rpl_vars.dao_target.optionLength  = LENGTH_ADDR128b +sizeof(icmpv6rpl_dao_target_ht) - 2; //no header type and length
           icmpv6rpl_vars.dao_target.type  = OPTION_TARGET_INFORMATION_TYPE;
           icmpv6rpl_vars.dao_target.flags  = 0;       //must be 0
!          icmpv6rpl_vars.dao_target.prefixLength = 128; //128 leading bits  -- full address.
           
           // write transit info in packet
           packetfunctions_reserveHeaderSize(msg,sizeof(icmpv6rpl_dao_target_ht));
***************
*** 526,531 ****
--- 521,530 ----
           // remember I found it
           numTargetParents++;
        }  
+       //limit to MAX_TARGET_PARENTS the number of DAO target addresses to send
+       //section 8.2.1 pag 67 RFC6550 -- using a subset
+       // poipoi TODO base selection on ETX rather than first X.
+       if (numTargetParents>=MAX_TARGET_PARENTS) break;
     }
     
     
diff -crB stock/openwsn/03b-IPv6/icmpv6rpl.h dev/openwsn/03b-IPv6/icmpv6rpl.h
*** stock/openwsn/03b-IPv6/icmpv6rpl.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/03b-IPv6/icmpv6rpl.h	Wed Jan 29 10:33:22 2014
***************
*** 8,13 ****
--- 8,15 ----
  \{
  */
  
+ #include "opentimers.h"
+ 
  //=========================== define ==========================================
  
  #define TIMER_DIO_TIMEOUT         1700
***************
*** 47,52 ****
--- 49,58 ----
  #define Prf_A_dio_options         0<<4
  #define Prf_B_dio_options         0<<3
  
+ // max number of parents and children to send in DAO
+ //section 8.2.1 pag 67 RFC6550 -- using a subset
+ #define MAX_TARGET_PARENTS        0x01
+ 
  enum{
    OPTION_ROUTE_INFORMATION_TYPE   = 0x03,
    OPTION_DODAG_CONFIGURATION_TYPE = 0x04,
***************
*** 94,100 ****
     uint8_t         rplinstanceId;      ///< set by the DODAG root.
     uint8_t         K_D_flags;
     uint8_t         reserved;
!    uint8_t         DAOSequance;
     uint8_t         DODAGID[16];
  } icmpv6rpl_dao_ht;
  PRAGMA(pack());
--- 100,106 ----
     uint8_t         rplinstanceId;      ///< set by the DODAG root.
     uint8_t         K_D_flags;
     uint8_t         reserved;
!    uint8_t         DAOSequence;
     uint8_t         DODAGID[16];
  } icmpv6rpl_dao_ht;
  PRAGMA(pack());
***************
*** 125,136 ****
  } icmpv6rpl_dao_target_ht;
  PRAGMA(pack());
  
  
  //=========================== prototypes ======================================
  
! void icmpv6rpl_init();
! void icmpv6rpl_sendDone(OpenQueueEntry_t* msg, error_t error);
  void icmpv6rpl_receive(OpenQueueEntry_t* msg);
  
  /**
  \}
--- 131,163 ----
  } icmpv6rpl_dao_target_ht;
  PRAGMA(pack());
  
+ //=========================== module variables ================================
+ 
+ typedef struct {
+    // admin
+    bool                      busySending;             ///< currently sending DIO/DAO.
+    uint8_t                   DODAGIDFlagSet;          ///< is DODAGID set already?
+    // DIO-related
+    icmpv6rpl_dio_ht          dio;                     ///< pre-populated DIO packet.
+    open_addr_t               dioDestination;          ///< IPv6 destination address for DIOs.
+    uint16_t                  periodDIO;               ///< duration, in ms, of a timerIdDIO timeout.
+    opentimer_id_t            timerIdDIO;              ///< ID of the timer used to send DIOs.
+    uint8_t                   delayDIO;                ///< number of timerIdDIO events before actually sending a DIO.
+    // DAO-related
+    icmpv6rpl_dao_ht          dao;                     ///< pre-populated DAO packet.
+    icmpv6rpl_dao_transit_ht  dao_transit;             ///< pre-populated DAO "Transit Info" option header.
+    icmpv6rpl_dao_target_ht  dao_target;             ///< pre-populated DAO "Transit Info" option header.
+    opentimer_id_t            timerIdDAO;              ///< ID of the timer used to send DAOs.
+    uint16_t                  periodDAO;               ///< duration, in ms, of a timerIdDAO timeout.
+    uint8_t                   delayDAO;                ///< number of timerIdDIO events before actually sending a DAO.
+ } icmpv6rpl_vars_t;
  
  //=========================== prototypes ======================================
  
! void icmpv6rpl_init(void);
! void icmpv6rpl_sendDone(OpenQueueEntry_t* msg, owerror_t error);
  void icmpv6rpl_receive(OpenQueueEntry_t* msg);
+ uint8_t icmpv6rpl_getRPLIntanceID(void);
  
  /**
  \}
diff -crB stock/openwsn/04-TRAN/Makefile dev/openwsn/04-TRAN/Makefile
*** stock/openwsn/04-TRAN/Makefile	Tue Jan 28 12:35:56 2014
--- dev/openwsn/04-TRAN/Makefile	Wed Jan 29 10:33:22 2014
***************
*** 0 ****
--- 1,42 ----
+ SUBMOD:=$(shell basename $(CURDIR)).a
+ #BINDIR = $(RIOTBASE)/bin/
+ SRC = $(wildcard *.c)
+ OBJ = $(SRC:%.c=$(BINDIR)%.o)
+ DEP = $(SRC:%.c=$(BINDIR)%.d)
+ 
+ INCLUDES += -I$(RIOTBASE) -I$(RIOTBASE)/sys/include -I$(RIOTBASE)/core/include -I$(RIOTBASE)/drivers/include -I$(RIOTBASE)/drivers/cc110x_ng/include -I$(RIOTBASE)/cpu/arm_common/include -I$(RIOTBASE)/sys/net/include/ 
+ INCLUDES += -I$(CURDIR)/02a-MAClow
+ INCLUDES += -I$(CURDIR)/02b-MAChigh
+ INCLUDES += -I$(CURDIR)/03a-IPHC
+ INCLUDES += -I$(CURDIR)/03b-IPv6
+ INCLUDES += -I$(CURDIR)/04-TRAN
+ INCLUDES += -I$(CURDIR)/07-App/ohlone
+ INCLUDES += -I$(CURDIR)/07-App/tcpecho
+ INCLUDES += -I$(CURDIR)/07-App/tcpinject
+ INCLUDES += -I$(CURDIR)/07-App/tcpprint
+ INCLUDES += -I$(CURDIR)/07-App/udpecho
+ INCLUDES += -I$(CURDIR)/07-App/udpinject
+ INCLUDES += -I$(CURDIR)/07-App/udplatency
+ INCLUDES += -I$(CURDIR)/07-App/udpprint
+ INCLUDES += -I$(CURDIR)/07-App/udprand
+ INCLUDES += -I$(CURDIR)/07-App/udpstorm
+ INCLUDES += -I$(CURDIR)/cross-layers
+ 
+ .PHONY: $(BINDIR)$(SUBMOD)
+ 
+ $(BINDIR)$(SUBMOD): $(OBJ)
+ 	$(AD)$(AR) rcs $(BINDIR)$(MODULE) $(OBJ)
+ 
+ # pull in dependency info for *existing* .o files
+ -include $(OBJ:.o=.d)
+ 
+ # compile and generate dependency info
+ $(BINDIR)%.o: %.c
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -c $*.c -o $(BINDIR)$*.o
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -MM $*.c > $(BINDIR)$*.d
+ 	@printf "$(BINDIR)" | cat - $(BINDIR)$*.d > /tmp/riot_out && mv /tmp/riot_out $(BINDIR)$*.d
+ 
+ # remove compilation products
+ 
+ clean:
+ 	rm -f $(OBJ) $(DEP)
diff -crB stock/openwsn/04-TRAN/opencoap.c dev/openwsn/04-TRAN/opencoap.c
*** stock/openwsn/04-TRAN/opencoap.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/04-TRAN/opencoap.c	Wed Jan 29 10:33:22 2014
***************
*** 9,36 ****
  #include "opentimers.h"
  #include "scheduler.h"
  
! //=========================== variables =======================================
  
! // general variable to the CoAP core
! typedef struct {
!    coap_resource_desc_t* resources;
!    bool                  busySending;
!    uint8_t               delayCounter;
!    uint16_t              messageID;
!    opentimer_id_t        timerId;
! } opencoap_vars_t;
  
  opencoap_vars_t opencoap_vars;
  
  //=========================== prototype =======================================
  
! void icmpv6coap_timer_cb();
  
  //=========================== public ==========================================
  
  //===== from stack
  
! void opencoap_init() {
     // initialize the resource linked list
     opencoap_vars.resources     = NULL;
     
--- 9,30 ----
  #include "opentimers.h"
  #include "scheduler.h"
  
! #include "thread.h"
  
! //=========================== variables =======================================
  
  opencoap_vars_t opencoap_vars;
+ //static char openwsn_coap_stack[KERNEL_CONF_STACKSIZE_MAIN];
  
  //=========================== prototype =======================================
  
! void icmpv6coap_timer_cb(void);
  
  //=========================== public ==========================================
  
  //===== from stack
  
! void opencoap_init(void) {
     // initialize the resource linked list
     opencoap_vars.resources     = NULL;
     
***************
*** 52,58 ****
     coap_option_t             last_option;
     coap_resource_desc_t*     temp_desc;
     bool                      found;
!    error_t                   outcome;
     // local variables passed to the handlers (with msg)
     coap_header_iht           coap_header;
     coap_option_iht           coap_options[MAX_COAP_OPTIONS];
--- 46,52 ----
     coap_option_t             last_option;
     coap_resource_desc_t*     temp_desc;
     bool                      found;
!    owerror_t                 outcome = 0;
     // local variables passed to the handlers (with msg)
     coap_header_iht           coap_header;
     coap_option_iht           coap_options[MAX_COAP_OPTIONS];
***************
*** 66,83 ****
     index = 0;
     coap_header.Ver           = (msg->payload[index] & 0xc0) >> 6;
     coap_header.T             = (coap_type_t)((msg->payload[index] & 0x30) >> 4);
!    coap_header.OC            = (msg->payload[index] & 0x0f);
     index++;
     coap_header.Code          = (coap_code_t)(msg->payload[index]);
     index++;
     coap_header.messageID     = msg->payload[index]*256+msg->payload[index+1];
     index+=2;
     // reject unsupported header
!    if (
!          coap_header.Ver!=COAP_VERSION ||
!          coap_header.OC>MAX_COAP_OPTIONS
!       ) {
!       openserial_printError(COMPONENT_OPENCOAP,ERR_6LOWPAN_UNSUPPORTED,
                              (errorparameter_t)0,
                              (errorparameter_t)coap_header.Ver);
        openqueue_freePacketBuffer(msg);
--- 60,81 ----
     index = 0;
     coap_header.Ver           = (msg->payload[index] & 0xc0) >> 6;
     coap_header.T             = (coap_type_t)((msg->payload[index] & 0x30) >> 4);
!    coap_header.TKL           = (msg->payload[index] & 0x0f);
     index++;
     coap_header.Code          = (coap_code_t)(msg->payload[index]);
     index++;
     coap_header.messageID     = msg->payload[index]*256+msg->payload[index+1];
     index+=2;
+    
+    //poipoi xv. TKL tells us the length of the token. If we want to support tokens longer
+    //than one token needs to be converted to an array and memcopy here for the length of TKL
+    coap_header.token         = (msg->payload[index]);
+    index+=coap_header.TKL;
+    
+    
     // reject unsupported header
!    if (coap_header.Ver!=COAP_VERSION || coap_header.TKL>8) {
!       openserial_printError(COMPONENT_OPENCOAP,ERR_WRONG_TRAN_PROTOCOL,
                              (errorparameter_t)0,
                              (errorparameter_t)coap_header.Ver);
        openqueue_freePacketBuffer(msg);
***************
*** 89,102 ****
     }
     // fill in the coap_options
     last_option = COAP_OPTION_NONE;
!    for (i=0;i<coap_header.OC;i++) {
        coap_options[i].type        = (coap_option_t)((uint8_t)last_option+(uint8_t)((msg->payload[index] & 0xf0) >> 4));
        last_option                 = coap_options[i].type;
        coap_options[i].length      = (msg->payload[index] & 0x0f);
        index++;
        coap_options[i].pValue      = &(msg->payload[index]);
!       index += coap_options[i].length;
     }
     // remove the CoAP header+options
     packetfunctions_tossHeader(msg,index);
     
--- 87,106 ----
     }
     // fill in the coap_options
     last_option = COAP_OPTION_NONE;
!    for (i=0;i<MAX_COAP_OPTIONS;i++) {
!      if (msg->payload[index]==0xFF){
!        //found the payload spacer, options are already parsed.
!        index++; //skip it and break.
!        break;
!      }
        coap_options[i].type        = (coap_option_t)((uint8_t)last_option+(uint8_t)((msg->payload[index] & 0xf0) >> 4));
        last_option                 = coap_options[i].type;
        coap_options[i].length      = (msg->payload[index] & 0x0f);
        index++;
        coap_options[i].pValue      = &(msg->payload[index]);
!       index += coap_options[i].length; //includes length as well
     }
+   
     // remove the CoAP header+options
     packetfunctions_tossHeader(msg,index);
     
***************
*** 112,119 ****
        temp_desc = opencoap_vars.resources;
        while (found==FALSE) {
           if    (
!                 coap_options[0].type==COAP_OPTION_URIPATH &&
!                 coap_options[1].type==COAP_OPTION_URIPATH &&
                  temp_desc->path0len>0                     &&
                  temp_desc->path0val!=NULL                 &&
                  temp_desc->path1len>0                     &&
--- 116,123 ----
        temp_desc = opencoap_vars.resources;
        while (found==FALSE) {
           if    (
!                 coap_options[0].type==COAP_OPTION_NUM_URIPATH &&
!                 coap_options[1].type==COAP_OPTION_NUM_URIPATH &&
                  temp_desc->path0len>0                     &&
                  temp_desc->path0val!=NULL                 &&
                  temp_desc->path1len>0                     &&
***************
*** 130,136 ****
                 found = TRUE;
              };
           } else if (
!                 coap_options[0].type==COAP_OPTION_URIPATH &&
                  temp_desc->path0len>0                     &&
                  temp_desc->path0val!=NULL
              ) {
--- 134,140 ----
                 found = TRUE;
              };
           } else if (
!                 coap_options[0].type==COAP_OPTION_NUM_URIPATH &&
                  temp_desc->path0len>0                     &&
                  temp_desc->path0val!=NULL
              ) {
***************
*** 187,193 ****
        msg->payload                     = &(msg->packet[127]);
        msg->length                      = 0;
        // set the CoAP header
!       coap_header.OC                   = 0;
        coap_header.Code                 = COAP_CODE_RESP_NOTFOUND;
     }
     
--- 191,197 ----
        msg->payload                     = &(msg->packet[127]);
        msg->length                      = 0;
        // set the CoAP header
!       coap_header.TKL                  = 0;
        coap_header.Code                 = COAP_CODE_RESP_NOTFOUND;
     }
     
***************
*** 196,202 ****
        msg->payload                     = &(msg->packet[127]);
        msg->length                      = 0;
        // set the CoAP header
!       coap_header.OC                   = 0;
        coap_header.Code                 = COAP_CODE_RESP_METHODNOTALLOWED;
     }
     
--- 200,206 ----
        msg->payload                     = &(msg->packet[127]);
        msg->length                      = 0;
        // set the CoAP header
!       coap_header.TKL                  = 0;
        coap_header.Code                 = COAP_CODE_RESP_METHODNOTALLOWED;
     }
     
***************
*** 213,233 ****
     msg->l4_destination_port         = msg->l4_sourcePortORicmpv6Type;
     msg->l4_sourcePortORicmpv6Type   = temp_l4_destination_port;
     
     // fill in CoAP header
!    packetfunctions_reserveHeaderSize(msg,4);
     msg->payload[0]                  = (COAP_VERSION   << 6) |
                                        (COAP_TYPE_ACK  << 4) |
!                                       (coap_header.OC << 0);
     msg->payload[1]                  = coap_header.Code;
     msg->payload[2]                  = coap_header.messageID/256;
     msg->payload[3]                  = coap_header.messageID%256;
     
     if ((openudp_send(msg))==E_FAIL) {
        openqueue_freePacketBuffer(msg);
     }
  }
  
! void opencoap_sendDone(OpenQueueEntry_t* msg, error_t error) {
     coap_resource_desc_t* temp_resource;
     
     // take ownership over that packet
--- 217,243 ----
     msg->l4_destination_port         = msg->l4_sourcePortORicmpv6Type;
     msg->l4_sourcePortORicmpv6Type   = temp_l4_destination_port;
     
+    //set destination address as the current source.
+    msg->l3_destinationAdd.type = ADDR_128B;
+    memcpy(&msg->l3_destinationAdd.addr_128b[0],&msg->l3_sourceAdd.addr_128b[0],LENGTH_ADDR128b);
+    
+    
     // fill in CoAP header
!    packetfunctions_reserveHeaderSize(msg,5);
     msg->payload[0]                  = (COAP_VERSION   << 6) |
                                        (COAP_TYPE_ACK  << 4) |
!                                       (coap_header.TKL << 0);
     msg->payload[1]                  = coap_header.Code;
     msg->payload[2]                  = coap_header.messageID/256;
     msg->payload[3]                  = coap_header.messageID%256;
+    msg->payload[4]                  = coap_header.token; //this will be a memcopy for TKL size
     
     if ((openudp_send(msg))==E_FAIL) {
        openqueue_freePacketBuffer(msg);
     }
  }
  
! void opencoap_sendDone(OpenQueueEntry_t* msg, owerror_t error) {
     coap_resource_desc_t* temp_resource;
     
     // take ownership over that packet
***************
*** 256,262 ****
     openqueue_freePacketBuffer(msg);
  }
  
! void timers_coap_fired() {
     //do something here if necessary
  }
  
--- 266,272 ----
     openqueue_freePacketBuffer(msg);
  }
  
! void timers_coap_fired(void) {
     //do something here if necessary
  }
  
***************
*** 288,296 ****
--- 298,316 ----
     }
  }
  
+ /**
+ \brief Register a new CoAP resource.
+ 
+ Registration consists in adding a new resource at the end of the linked list
+ of resources.
+ */
  void opencoap_register(coap_resource_desc_t* desc) {
     coap_resource_desc_t* last_elem;
     
+    // since this CoAP resource will be at the end of the list, its next element
+    // should point to NULL, indicating the end of the linked list.
+    desc->next = NULL;
+    
     if (opencoap_vars.resources==NULL) {
        opencoap_vars.resources = desc;
        return;
***************
*** 304,313 ****
     last_elem->next = desc;
  }
  
! error_t opencoap_send(OpenQueueEntry_t*     msg,
                        coap_type_t           type,
                        coap_code_t           code,
!                       uint8_t               numOptions,
                        coap_resource_desc_t* descSender) {
     // change the global messageID
     opencoap_vars.messageID          = openrandom_get16b();
--- 324,333 ----
     last_elem->next = desc;
  }
  
! owerror_t opencoap_send(OpenQueueEntry_t*     msg,
                        coap_type_t           type,
                        coap_code_t           code,
!                       uint8_t               TKL,
                        coap_resource_desc_t* descSender) {
     // change the global messageID
     opencoap_vars.messageID          = openrandom_get16b();
***************
*** 316,335 ****
     // metadata
     msg->l4_sourcePortORicmpv6Type   = WKP_UDP_COAP;
     // fill in CoAP header
!    packetfunctions_reserveHeaderSize(msg,4);
     msg->payload[0]                  = (COAP_VERSION   << 6) |
                                        (type           << 4) |
!                                       (numOptions     << 0);
     msg->payload[1]                  = code;
     msg->payload[2]                  = (opencoap_vars.messageID>>8) & 0xff;
     msg->payload[3]                  = (opencoap_vars.messageID>>0) & 0xff;
     // record the messageID with this sender
     descSender->messageID            = opencoap_vars.messageID;
     return openudp_send(msg);
  }
  
  //=========================== private =========================================
  
! void icmpv6coap_timer_cb() {
!    scheduler_push_task(timers_coap_fired,TASKPRIO_COAP);
  }
\ No newline at end of file
--- 336,364 ----
     // metadata
     msg->l4_sourcePortORicmpv6Type   = WKP_UDP_COAP;
     // fill in CoAP header
!    packetfunctions_reserveHeaderSize(msg,5);
     msg->payload[0]                  = (COAP_VERSION   << 6) |
                                        (type           << 4) |
!                                       (TKL            << 0);
     msg->payload[1]                  = code;
     msg->payload[2]                  = (opencoap_vars.messageID>>8) & 0xff;
     msg->payload[3]                  = (opencoap_vars.messageID>>0) & 0xff;
+    //poipoi xv token needs to be defined by the app or here
+ #define TOKEN 123
+    msg->payload[4]                  = TOKEN; //this will be a memcopy for TKL size
+   
     // record the messageID with this sender
     descSender->messageID            = opencoap_vars.messageID;
+    descSender->token                = TOKEN;
+    
     return openudp_send(msg);
  }
  
  //=========================== private =========================================
  
! void icmpv6coap_timer_cb(void) {
!     scheduler_push_task(timers_coap_fired,TASKPRIO_COAP);
!    /*thread_create(openwsn_coap_stack, KERNEL_CONF_STACKSIZE_MAIN, 
!                   PRIORITY_OPENWSN_COAP, CREATE_STACKTEST, 
!                   timers_coap_fired, "timers coap fired");*/
  }
\ No newline at end of file
diff -crB stock/openwsn/04-TRAN/opencoap.h dev/openwsn/04-TRAN/opencoap.h
*** stock/openwsn/04-TRAN/opencoap.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/04-TRAN/opencoap.h	Wed Jan 29 10:33:22 2014
***************
*** 8,13 ****
--- 8,15 ----
  \{
  */
  
+ #include "opentimers.h"
+ 
  //=========================== define ==========================================
  
  // IPv6 addresses of servers on the Internet
***************
*** 15,26 ****
                                             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x29};
  static const uint8_t ipAddr_motesEecs[] = {0x20, 0x01, 0x04, 0x70, 0x00, 0x66, 0x00, 0x19, \
                                             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02};
! //static const uint8_t ipAddr_local[]     = {0x20, 0x02, 0x80, 0x20, 0x21, 0x47, 0x00, 0x0c, \
                                             0x10, 0xcb, 0xc6, 0x52, 0x44, 0x17, 0xd4, 0x18};
  // 2607:f140:400:1036:688e:fa3b:444:6211
  //static const uint8_t ipAddr_local[]     = {0x26, 0x07, 0xf1, 0x40, 0x04, 0x00, 0x10, 0x36, \
  //                                           0x68, 0x8e, 0xfa, 0x3b, 0x04, 0x44, 0x62, 0x11};
! 
  static const uint8_t ipAddr_local[]     = {0x26, 0x07, 0xf1, 0x40, 0x04, 0x00, 0x10, 0x36, \
                                             0x4d, 0xcd, 0xab, 0x54, 0x81, 0x99, 0xc1, 0xf7}; 
                                             
--- 17,28 ----
                                             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0e, 0x29};
  static const uint8_t ipAddr_motesEecs[] = {0x20, 0x01, 0x04, 0x70, 0x00, 0x66, 0x00, 0x19, \
                                             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02};
! /*static const uint8_t ipAddr_local[]     = {0x20, 0x02, 0x80, 0x20, 0x21, 0x47, 0x00, 0x0c, \
                                             0x10, 0xcb, 0xc6, 0x52, 0x44, 0x17, 0xd4, 0x18};
  // 2607:f140:400:1036:688e:fa3b:444:6211
  //static const uint8_t ipAddr_local[]     = {0x26, 0x07, 0xf1, 0x40, 0x04, 0x00, 0x10, 0x36, \
  //                                           0x68, 0x8e, 0xfa, 0x3b, 0x04, 0x44, 0x62, 0x11};
! */
  static const uint8_t ipAddr_local[]     = {0x26, 0x07, 0xf1, 0x40, 0x04, 0x00, 0x10, 0x36, \
                                             0x4d, 0xcd, 0xab, 0x54, 0x81, 0x99, 0xc1, 0xf7}; 
                                             
***************
*** 28,34 ****
                                             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02};
  
  /// the maximum number of options in a RX'ed CoAP message
! #define MAX_COAP_OPTIONS               3
  
  #define COAP_VERSION                   1
  
--- 30,36 ----
                                             0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02};
  
  /// the maximum number of options in a RX'ed CoAP message
! #define MAX_COAP_OPTIONS               10 //3 before but we want gets with more options
  
  #define COAP_VERSION                   1
  
***************
*** 73,95 ****
  } coap_code_t;
  
  typedef enum {
!    COAP_OPTION_NONE                    =  0,
!    COAP_OPTION_CONTENTTYPE             =  1,
!    COAP_OPTION_MAXAGE                  =  2,
!    COAP_OPTION_PROXYURI                =  3,
!    COAP_OPTION_ETAG                    =  4,
!    COAP_OPTION_URIHOST                 =  5,
!    COAP_OPTION_LOCATIONPATH            =  6,
!    COAP_OPTION_URIPORT                 =  7,
!    COAP_OPTION_LOCATIONQUERY           =  8,
!    COAP_OPTION_URIPATH                 =  9,
!    COAP_OPTION_TOKEN                   = 11,
!    COAP_OPTION_ACCEPT                  = 12,
!    COAP_OPTION_IFMATCH                 = 13,
!    COAP_OPTION_URIQUERY                = 15,
!    COAP_OPTION_IFNONEMATCH             = 21,
  } coap_option_t;
  
  typedef enum {
     COAP_MEDTYPE_TEXTPLAIN              =  0,
     COAP_MEDTYPE_APPLINKFORMAT          = 40,
--- 75,99 ----
  } coap_code_t;
  
  typedef enum {
!    COAP_OPTION_NONE                            = 0,
!    COAP_OPTION_NUM_IFMATCH                     = 1,
!    COAP_OPTION_NUM_URIHOST                     = 3,
!    COAP_OPTION_NUM_ETAG                        = 4,
!    COAP_OPTION_NUM_IFNONEMATCH                 = 5,
!    COAP_OPTION_NUM_URIPORT                     = 7,
!    COAP_OPTION_NUM_LOCATIONPATH                = 8,
!    COAP_OPTION_NUM_URIPATH                     = 11,
!    COAP_OPTION_NUM_CONTENTFORMAT               = 12,
!    COAP_OPTION_NUM_MAXAGE                      = 14,
!    COAP_OPTION_NUM_URIQUERY                    = 15,
!    COAP_OPTION_NUM_ACCEPT                      = 16,
!    COAP_OPTION_NUM_LOCATIONQUERY               = 20,
!    COAP_OPTION_NUM_PROXYURI                    = 35,
!    COAP_OPTION_NUM_PROXYSCHEME                 = 39,
  } coap_option_t;
  
+ 
+ 
  typedef enum {
     COAP_MEDTYPE_TEXTPLAIN              =  0,
     COAP_MEDTYPE_APPLINKFORMAT          = 40,
***************
*** 104,112 ****
  typedef struct {
     uint8_t       Ver;
     coap_type_t   T;
!    uint8_t       OC;
     coap_code_t   Code;
     uint16_t      messageID;
  } coap_header_iht;
  
  typedef struct {
--- 108,117 ----
  typedef struct {
     uint8_t       Ver;
     coap_type_t   T;
!    uint8_t       TKL;
     coap_code_t   Code;
     uint16_t      messageID;
+    uint8_t       token; //this might be an array of 8 as tkl can be 8
  } coap_header_iht;
  
  typedef struct {
***************
*** 115,125 ****
     uint8_t*      pValue;
  } coap_option_iht;
  
! typedef error_t (*callbackRx_t)(OpenQueueEntry_t* msg,
                                  coap_header_iht*  coap_header,
                                  coap_option_iht*  coap_options);
! typedef void (*callbackTimer_t)(void);
! typedef void (*callbackSendDone_t)(OpenQueueEntry_t* msg, error_t error);
  
  typedef struct coap_resource_desc_t coap_resource_desc_t;
  
--- 120,130 ----
     uint8_t*      pValue;
  } coap_option_iht;
  
! typedef owerror_t (*callbackRx_cbt)(OpenQueueEntry_t* msg,
                                  coap_header_iht*  coap_header,
                                  coap_option_iht*  coap_options);
! typedef void (*callbackSendDone_cbt)(OpenQueueEntry_t* msg,
!                                       owerror_t error);
  
  typedef struct coap_resource_desc_t coap_resource_desc_t;
  
***************
*** 130,153 ****
     uint8_t*              path1val;
     uint8_t               componentID;
     uint16_t              messageID;
!    callbackRx_t          callbackRx;
!    callbackSendDone_t    callbackSendDone;
     coap_resource_desc_t* next;
  };
  
! //=========================== variables =======================================
  
  //=========================== prototypes ======================================
  
  // from stack
! void     opencoap_init();
  void     opencoap_receive(OpenQueueEntry_t* msg);
! void     opencoap_sendDone(OpenQueueEntry_t* msg, error_t error);
  
  // from CoAP resources
  void     opencoap_writeLinks(OpenQueueEntry_t* msg);
  void     opencoap_register(coap_resource_desc_t* desc);
! error_t  opencoap_send(OpenQueueEntry_t*     msg,
                         coap_type_t           type,
                         coap_code_t           code,
                         uint8_t               numOptions,
--- 135,167 ----
     uint8_t*              path1val;
     uint8_t               componentID;
     uint16_t              messageID;
!    uint8_t               token; //should be 8bytes
!    callbackRx_cbt        callbackRx;
!    callbackSendDone_cbt  callbackSendDone;
     coap_resource_desc_t* next;
  };
  
! //=========================== module variables ================================
! 
! typedef struct {
!    coap_resource_desc_t* resources;
!    bool                  busySending;
!    uint8_t               delayCounter;
!    uint16_t              messageID;
!    opentimer_id_t        timerId;
! } opencoap_vars_t;
  
  //=========================== prototypes ======================================
  
  // from stack
! void     opencoap_init(void);
  void     opencoap_receive(OpenQueueEntry_t* msg);
! void     opencoap_sendDone(OpenQueueEntry_t* msg, owerror_t error);
  
  // from CoAP resources
  void     opencoap_writeLinks(OpenQueueEntry_t* msg);
  void     opencoap_register(coap_resource_desc_t* desc);
! owerror_t  opencoap_send(OpenQueueEntry_t*     msg,
                         coap_type_t           type,
                         coap_code_t           code,
                         uint8_t               numOptions,
diff -crB stock/openwsn/04-TRAN/opentcp.c dev/openwsn/04-TRAN/opentcp.c
*** stock/openwsn/04-TRAN/opentcp.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/04-TRAN/opentcp.c	Wed Jan 29 10:33:22 2014
***************
*** 4,10 ****
  #include "openqueue.h"
  #include "forwarding.h"
  #include "packetfunctions.h"
! #include "bsp_timer.h"
  #include "scheduler.h"
  #include "opentimers.h"
  //TCP applications
--- 4,10 ----
  #include "openqueue.h"
  #include "forwarding.h"
  #include "packetfunctions.h"
! //#include "bsp_timer.h"
  #include "scheduler.h"
  #include "opentimers.h"
  //TCP applications
***************
*** 13,53 ****
  #include "tcpinject.h"
  #include "tcpprint.h"
  
! //=========================== variables =======================================
  
! typedef struct {
!    uint8_t              state;
!    uint32_t             mySeqNum;
!    uint16_t             myPort;
!    uint32_t             hisNextSeqNum;
!    uint16_t             hisPort;
!    open_addr_t          hisIPv6Address;
!    OpenQueueEntry_t*    dataToSend;
!    OpenQueueEntry_t*    dataReceived;
!    bool                 timerStarted;
!    opentimer_id_t       timerId;
! } tcp_vars_t;
  
  tcp_vars_t tcp_vars;
  
  //=========================== prototypes ======================================
  
  void prependTCPHeader(OpenQueueEntry_t* msg, bool ack, bool push, bool rst, bool syn, bool fin);
  bool containsControlBits(OpenQueueEntry_t* msg, uint8_t ack, uint8_t rst, uint8_t syn, uint8_t fin);
  void tcp_change_state(uint8_t new_state);
! void reset();
! void opentcp_timer_cb();
  
  //=========================== public ==========================================
  
! void opentcp_init() {
     // reset local variables
     memset(&tcp_vars,0,sizeof(tcp_vars_t));   
     // reset state machine
!    reset();
  }
  
! error_t opentcp_connect(open_addr_t* dest, uint16_t param_tcp_hisPort, uint16_t param_tcp_myPort) {
     //[command] establishment
     OpenQueueEntry_t* tempPkt;
     if (tcp_vars.state!=TCP_STATE_CLOSED) {
--- 13,43 ----
  #include "tcpinject.h"
  #include "tcpprint.h"
  
! #include "thread.h"
  
! //=========================== variables =======================================
  
  tcp_vars_t tcp_vars;
+ //static char openwsn_opentcp_stack[KERNEL_CONF_STACKSIZE_MAIN];
  
  //=========================== prototypes ======================================
  
  void prependTCPHeader(OpenQueueEntry_t* msg, bool ack, bool push, bool rst, bool syn, bool fin);
  bool containsControlBits(OpenQueueEntry_t* msg, uint8_t ack, uint8_t rst, uint8_t syn, uint8_t fin);
  void tcp_change_state(uint8_t new_state);
! void opentcp_reset(void);
! void opentcp_timer_cb(void);
  
  //=========================== public ==========================================
  
! void opentcp_init(void) {
     // reset local variables
     memset(&tcp_vars,0,sizeof(tcp_vars_t));   
     // reset state machine
!    opentcp_reset();
  }
  
! owerror_t opentcp_connect(open_addr_t* dest, uint16_t param_tcp_hisPort, uint16_t param_tcp_myPort) {
     //[command] establishment
     OpenQueueEntry_t* tempPkt;
     if (tcp_vars.state!=TCP_STATE_CLOSED) {
***************
*** 81,87 ****
     return forwarding_send(tempPkt);
  }
  
! error_t opentcp_send(OpenQueueEntry_t* msg) {             //[command] data
     msg->owner = COMPONENT_OPENTCP;
     if (tcp_vars.state!=TCP_STATE_ESTABLISHED) {
        openserial_printError(COMPONENT_OPENTCP,ERR_WRONG_TCP_STATE,
--- 71,77 ----
     return forwarding_send(tempPkt);
  }
  
! owerror_t opentcp_send(OpenQueueEntry_t* msg) {             //[command] data
     msg->owner = COMPONENT_OPENTCP;
     if (tcp_vars.state!=TCP_STATE_ESTABLISHED) {
        openserial_printError(COMPONENT_OPENTCP,ERR_WRONG_TCP_STATE,
***************
*** 114,120 ****
     return forwarding_send(tcp_vars.dataToSend);
  }
  
! void opentcp_sendDone(OpenQueueEntry_t* msg, error_t error) {
     OpenQueueEntry_t* tempPkt;
     msg->owner = COMPONENT_OPENTCP;
     switch (tcp_vars.state) {
--- 104,110 ----
     return forwarding_send(tcp_vars.dataToSend);
  }
  
! void opentcp_sendDone(OpenQueueEntry_t* msg, owerror_t error) {
     OpenQueueEntry_t* tempPkt;
     msg->owner = COMPONENT_OPENTCP;
     switch (tcp_vars.state) {
***************
*** 196,202 ****
           openqueue_freePacketBuffer(msg);
           tcp_change_state(TCP_STATE_TIME_WAIT);
           //TODO implement waiting timer
!          reset();
           break;
  
        case TCP_STATE_ALMOST_CLOSE_WAIT:                           //[sendDone] teardown
--- 186,192 ----
           openqueue_freePacketBuffer(msg);
           tcp_change_state(TCP_STATE_TIME_WAIT);
           //TODO implement waiting timer
!          opentcp_reset();
           break;
  
        case TCP_STATE_ALMOST_CLOSE_WAIT:                           //[sendDone] teardown
***************
*** 259,265 ****
     }
     if (containsControlBits(msg,TCP_ACK_WHATEVER,TCP_RST_YES,TCP_SYN_WHATEVER,TCP_FIN_WHATEVER)) {
        //I receive RST[+*], I reset
!       reset();
        openqueue_freePacketBuffer(msg);
     }
     switch (tcp_vars.state) {
--- 249,255 ----
     }
     if (containsControlBits(msg,TCP_ACK_WHATEVER,TCP_RST_YES,TCP_SYN_WHATEVER,TCP_FIN_WHATEVER)) {
        //I receive RST[+*], I reset
!       opentcp_reset();
        openqueue_freePacketBuffer(msg);
     }
     switch (tcp_vars.state) {
***************
*** 311,317 ****
                    tcp_change_state(TCP_STATE_ALMOST_SYN_RECEIVED);
                    forwarding_send(tempPkt);
                 } else {
!                   reset();
                    openserial_printError(COMPONENT_OPENTCP,ERR_TCP_RESET,
                                          (errorparameter_t)tcp_vars.state,
                                          (errorparameter_t)0);
--- 301,307 ----
                    tcp_change_state(TCP_STATE_ALMOST_SYN_RECEIVED);
                    forwarding_send(tempPkt);
                 } else {
!                   opentcp_reset();
                    openserial_printError(COMPONENT_OPENTCP,ERR_TCP_RESET,
                                          (errorparameter_t)tcp_vars.state,
                                          (errorparameter_t)0);
***************
*** 366,372 ****
              tcp_change_state(TCP_STATE_ALMOST_SYN_RECEIVED);
              forwarding_send(tempPkt);
           } else {
!             reset();
              openserial_printError(COMPONENT_OPENTCP,ERR_TCP_RESET,
                                    (errorparameter_t)tcp_vars.state,
                                    (errorparameter_t)1);
--- 356,362 ----
              tcp_change_state(TCP_STATE_ALMOST_SYN_RECEIVED);
              forwarding_send(tempPkt);
           } else {
!             opentcp_reset();
              openserial_printError(COMPONENT_OPENTCP,ERR_TCP_RESET,
                                    (errorparameter_t)tcp_vars.state,
                                    (errorparameter_t)1);
***************
*** 379,385 ****
              //I receive ACK, the virtual circuit is established
              tcp_change_state(TCP_STATE_ESTABLISHED);
           } else {
!             reset();
              openserial_printError(COMPONENT_OPENTCP,ERR_TCP_RESET,
                                    (errorparameter_t)tcp_vars.state,
                                    (errorparameter_t)2);
--- 369,375 ----
              //I receive ACK, the virtual circuit is established
              tcp_change_state(TCP_STATE_ESTABLISHED);
           } else {
!             opentcp_reset();
              openserial_printError(COMPONENT_OPENTCP,ERR_TCP_RESET,
                                    (errorparameter_t)tcp_vars.state,
                                    (errorparameter_t)2);
***************
*** 435,441 ****
              tcp_vars.dataReceived = msg;
              tcp_change_state(TCP_STATE_ALMOST_DATA_RECEIVED);
           } else {
!             reset();
              openserial_printError(COMPONENT_OPENTCP,ERR_TCP_RESET,
                                    (errorparameter_t)tcp_vars.state,
                                    (errorparameter_t)3);
--- 425,431 ----
              tcp_vars.dataReceived = msg;
              tcp_change_state(TCP_STATE_ALMOST_DATA_RECEIVED);
           } else {
!             opentcp_reset();
              openserial_printError(COMPONENT_OPENTCP,ERR_TCP_RESET,
                                    (errorparameter_t)tcp_vars.state,
                                    (errorparameter_t)3);
***************
*** 510,516 ****
              forwarding_send(tempPkt);
              tcp_change_state(TCP_STATE_ALMOST_CLOSE_WAIT);
           } else {
!             reset();
              openserial_printError(COMPONENT_OPENTCP,ERR_TCP_RESET,
                                    (errorparameter_t)tcp_vars.state,
                                    (errorparameter_t)4);
--- 500,506 ----
              forwarding_send(tempPkt);
              tcp_change_state(TCP_STATE_ALMOST_CLOSE_WAIT);
           } else {
!             opentcp_reset();
              openserial_printError(COMPONENT_OPENTCP,ERR_TCP_RESET,
                                    (errorparameter_t)tcp_vars.state,
                                    (errorparameter_t)4);
***************
*** 567,573 ****
              //I receive ACK, I will receive FIN later
              tcp_change_state(TCP_STATE_FIN_WAIT_2);
           } else {
!             reset();
              openserial_printError(COMPONENT_OPENTCP,ERR_TCP_RESET,
                                    (errorparameter_t)tcp_vars.state,
                                    (errorparameter_t)5);
--- 557,563 ----
              //I receive ACK, I will receive FIN later
              tcp_change_state(TCP_STATE_FIN_WAIT_2);
           } else {
!             opentcp_reset();
              openserial_printError(COMPONENT_OPENTCP,ERR_TCP_RESET,
                                    (errorparameter_t)tcp_vars.state,
                                    (errorparameter_t)5);
***************
*** 607,613 ****
              //I receive ACK, I do nothing
              tcp_change_state(TCP_STATE_TIME_WAIT);
              //TODO implement waiting timer
!             reset();
           }
           openqueue_freePacketBuffer(msg);
           break;
--- 597,603 ----
              //I receive ACK, I do nothing
              tcp_change_state(TCP_STATE_TIME_WAIT);
              //TODO implement waiting timer
!             opentcp_reset();
           }
           openqueue_freePacketBuffer(msg);
           break;
***************
*** 615,621 ****
        case TCP_STATE_LAST_ACK:                                    //[receive] teardown
           if (containsControlBits(msg,TCP_ACK_YES,TCP_RST_NO,TCP_SYN_NO,TCP_FIN_NO)) {
              //I receive ACK, I reset
!             reset();
           }
           openqueue_freePacketBuffer(msg);
           break;
--- 605,611 ----
        case TCP_STATE_LAST_ACK:                                    //[receive] teardown
           if (containsControlBits(msg,TCP_ACK_YES,TCP_RST_NO,TCP_SYN_NO,TCP_FIN_NO)) {
              //I receive ACK, I reset
!             opentcp_reset();
           }
           openqueue_freePacketBuffer(msg);
           break;
***************
*** 628,634 ****
     }
  }
  
! error_t opentcp_close() {    //[command] teardown
     OpenQueueEntry_t* tempPkt;
     if (  tcp_vars.state==TCP_STATE_ALMOST_CLOSE_WAIT ||
           tcp_vars.state==TCP_STATE_CLOSE_WAIT        ||
--- 618,624 ----
     }
  }
  
! owerror_t opentcp_close(void) {    //[command] teardown
     OpenQueueEntry_t* tempPkt;
     if (  tcp_vars.state==TCP_STATE_ALMOST_CLOSE_WAIT ||
           tcp_vars.state==TCP_STATE_CLOSE_WAIT        ||
***************
*** 660,674 ****
     return forwarding_send(tempPkt);
  }
  
! bool tcp_debugPrint() {
     return FALSE;
  }
  
  //======= timer
  
  //timer used to reset state when TCP state machine is stuck
! void timers_tcp_fired() {
!    reset();
  }
  
  //=========================== private =========================================
--- 650,664 ----
     return forwarding_send(tempPkt);
  }
  
! bool tcp_debugPrint(void) {
     return FALSE;
  }
  
  //======= timer
  
  //timer used to reset state when TCP state machine is stuck
! void timers_tcp_fired(void) {
!    opentcp_reset();
  }
  
  //=========================== private =========================================
***************
*** 727,733 ****
     return return_value;
  }
  
! void reset() {
     tcp_change_state(TCP_STATE_CLOSED);
     tcp_vars.mySeqNum            = TCP_INITIAL_SEQNUM; 
     tcp_vars.hisNextSeqNum       = 0;
--- 717,723 ----
     return return_value;
  }
  
! void opentcp_reset(void) {
     tcp_change_state(TCP_STATE_CLOSED);
     tcp_vars.mySeqNum            = TCP_INITIAL_SEQNUM; 
     tcp_vars.hisNextSeqNum       = 0;
***************
*** 755,760 ****
     }
  }
  
! void opentcp_timer_cb() {
!    scheduler_push_task(timers_tcp_fired,TASKPRIO_TCP_TIMEOUT);
  }
\ No newline at end of file
--- 745,753 ----
     }
  }
  
! void opentcp_timer_cb(void) {
!     scheduler_push_task(timers_tcp_fired,TASKPRIO_TCP_TIMEOUT);
!    /*thread_create(openwsn_opentcp_stack, KERNEL_CONF_STACKSIZE_MAIN, 
!                   PRIORITY_OPENWSN_OPENTCP, CREATE_STACKTEST, 
!                   timers_tcp_fired, "timers tcp fired");*/
  }
\ No newline at end of file
diff -crB stock/openwsn/04-TRAN/opentcp.h dev/openwsn/04-TRAN/opentcp.h
*** stock/openwsn/04-TRAN/opentcp.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/04-TRAN/opentcp.h	Wed Jan 29 10:33:22 2014
***************
*** 4,13 ****
  /**
  \addtogroup Transport
  \{
! \addtogroup TCP
  \{
  */
  
  //=========================== define ==========================================
  
  enum {
--- 4,15 ----
  /**
  \addtogroup Transport
  \{
! \addtogroup OpenTcp
  \{
  */
  
+ #include "opentimers.h"
+ 
  //=========================== define ==========================================
  
  enum {
***************
*** 98,114 ****
     uint16_t urgent_pointer;
  } tcp_ht;
  
! //=========================== variables =======================================
  
  //=========================== prototypes ======================================
  
! void     opentcp_init();
! error_t  opentcp_connect(open_addr_t* dest, uint16_t param_hisPort, uint16_t param_myPort);
! error_t  opentcp_send(OpenQueueEntry_t* msg);
! void     opentcp_sendDone(OpenQueueEntry_t* msg, error_t error);
  void     opentcp_receive(OpenQueueEntry_t* msg);
! error_t  opentcp_close();
! bool     opentcp_debugPrint();
  
  /**
  \}
--- 100,129 ----
     uint16_t urgent_pointer;
  } tcp_ht;
  
! //=========================== module variables ================================
! 
! typedef struct {
!    uint8_t              state;
!    uint32_t             mySeqNum;
!    uint16_t             myPort;
!    uint32_t             hisNextSeqNum;
!    uint16_t             hisPort;
!    open_addr_t          hisIPv6Address;
!    OpenQueueEntry_t*    dataToSend;
!    OpenQueueEntry_t*    dataReceived;
!    bool                 timerStarted;
!    opentimer_id_t       timerId;
! } tcp_vars_t;
  
  //=========================== prototypes ======================================
  
! void     opentcp_init(void);
! owerror_t  opentcp_connect(open_addr_t* dest, uint16_t param_hisPort, uint16_t param_myPort);
! owerror_t  opentcp_send(OpenQueueEntry_t* msg);
! void     opentcp_sendDone(OpenQueueEntry_t* msg, owerror_t error);
  void     opentcp_receive(OpenQueueEntry_t* msg);
! owerror_t  opentcp_close(void);
! bool     opentcp_debugPrint(void);
  
  /**
  \}
diff -crB stock/openwsn/04-TRAN/openudp.c dev/openwsn/04-TRAN/openudp.c
*** stock/openwsn/04-TRAN/openudp.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/04-TRAN/openudp.c	Wed Jan 29 10:33:22 2014
***************
*** 21,30 ****
  
  //=========================== public ==========================================
  
! void openudp_init() {
  }
  
! error_t openudp_send(OpenQueueEntry_t* msg) {
     msg->owner       = COMPONENT_OPENUDP;
     msg->l4_protocol = IANA_UDP;
     msg->l4_payload  = msg->payload;
--- 21,30 ----
  
  //=========================== public ==========================================
  
! void openudp_init(void) {
  }
  
! owerror_t openudp_send(OpenQueueEntry_t* msg) {
     msg->owner       = COMPONENT_OPENUDP;
     msg->l4_protocol = IANA_UDP;
     msg->l4_payload  = msg->payload;
***************
*** 37,43 ****
     return forwarding_send(msg);
  }
  
! void openudp_sendDone(OpenQueueEntry_t* msg, error_t error) {
     msg->owner = COMPONENT_OPENUDP;
     switch(msg->l4_sourcePortORicmpv6Type) {
        case WKP_UDP_COAP:
--- 37,43 ----
     return forwarding_send(msg);
  }
  
! void openudp_sendDone(OpenQueueEntry_t* msg, owerror_t error) {
     msg->owner = COMPONENT_OPENUDP;
     switch(msg->l4_sourcePortORicmpv6Type) {
        case WKP_UDP_COAP:
***************
*** 108,115 ****
           case NHC_UDP_PORTS_4S_4D:
              // source port: 0xf0b +  4 bits in-line
              // dest port:   0xf0b +  4 bits in-line
!             msg->l4_sourcePortORicmpv6Type  = 0xf0b0 + (msg->payload[0] >> 4) & 0x0f;
!             msg->l4_destination_port        = 0xf0b0 + (msg->payload[0] >> 0) & 0x0f;
              packetfunctions_tossHeader(msg,1);
              break;
        }
--- 108,115 ----
           case NHC_UDP_PORTS_4S_4D:
              // source port: 0xf0b +  4 bits in-line
              // dest port:   0xf0b +  4 bits in-line
!             msg->l4_sourcePortORicmpv6Type  = 0xf0b0 + ((msg->payload[0] >> 4) & 0x0f);
!             msg->l4_destination_port        = 0xf0b0 + ((msg->payload[0] >> 0) & 0x0f);
              packetfunctions_tossHeader(msg,1);
              break;
        }
***************
*** 151,157 ****
     }
  }
  
! bool openudp_debugPrint() {
     return FALSE;
  }
  
--- 151,157 ----
     }
  }
  
! bool openudp_debugPrint(void) {
     return FALSE;
  }
  
diff -crB stock/openwsn/04-TRAN/openudp.h dev/openwsn/04-TRAN/openudp.h
*** stock/openwsn/04-TRAN/openudp.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/04-TRAN/openudp.h	Wed Jan 29 10:33:22 2014
***************
*** 4,10 ****
  /**
  \addtogroup Transport
  \{
! \addtogroup UDP
  \{
  */
  
--- 4,10 ----
  /**
  \addtogroup Transport
  \{
! \addtogroup OpenUdp
  \{
  */
  
***************
*** 45,55 ****
  
  //=========================== prototypes ======================================
  
! void    openudp_init();
! error_t openudp_send(OpenQueueEntry_t* msg);
! void    openudp_sendDone(OpenQueueEntry_t* msg, error_t error);
  void    openudp_receive(OpenQueueEntry_t* msg);
! bool    openudp_debugPrint();
  
  /**
  \}
--- 45,55 ----
  
  //=========================== prototypes ======================================
  
! void    openudp_init(void);
! owerror_t openudp_send(OpenQueueEntry_t* msg);
! void    openudp_sendDone(OpenQueueEntry_t* msg, owerror_t error);
  void    openudp_receive(OpenQueueEntry_t* msg);
! bool    openudp_debugPrint(void);
  
  /**
  \}
diff -crB stock/openwsn/04-TRAN/rsvp.c dev/openwsn/04-TRAN/rsvp.c
*** stock/openwsn/04-TRAN/rsvp.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/04-TRAN/rsvp.c	Wed Jan 29 10:33:22 2014
***************
*** 17,27 ****
     uint8_t rsvp_timer_id;
  }rsvp_vars_t;
  
! void rsvp_timer_cb();
  
  rsvp_vars_t rsvp_vars;
  
! void rsvp_init(){
     rsvp_vars.rsvp_period    = 0;
     rsvp_vars.rsvp_timer_id  = 0;
  }
--- 17,27 ----
     uint8_t rsvp_timer_id;
  }rsvp_vars_t;
  
! void rsvp_timer_cb(void);
  
  rsvp_vars_t rsvp_vars;
  
! void rsvp_init(void){
     rsvp_vars.rsvp_period    = 0;
     rsvp_vars.rsvp_timer_id  = 0;
  }
***************
*** 35,42 ****
  void rsvp_qos_request(uint8_t bandwith, uint16_t refresh_period, open_addr_t dest){
     
        OpenQueueEntry_t* pkt;
!       error_t           outcome;
        uint8_t           i,j;
       
        pkt = openqueue_getFreePacketBuffer(COMPONENT_RSVP);
        if (pkt==NULL) {
--- 35,46 ----
  void rsvp_qos_request(uint8_t bandwith, uint16_t refresh_period, open_addr_t dest){
     
        OpenQueueEntry_t* pkt;
!       owerror_t           outcome;
        uint8_t           i,j;
+       
+       (void)outcome;
+       (void)i;
+       (void)j;
       
        pkt = openqueue_getFreePacketBuffer(COMPONENT_RSVP);
        if (pkt==NULL) {
diff -crB stock/openwsn/04-TRAN/rsvp.h dev/openwsn/04-TRAN/rsvp.h
*** stock/openwsn/04-TRAN/rsvp.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/04-TRAN/rsvp.h	Wed Jan 29 10:33:22 2014
***************
*** 157,163 ****
  
  
  
! void    rsvp_init();
  void    rsvp_qos_request(uint8_t bandwith, uint16_t refresh_period,open_addr_t dest);
  
  #endif
--- 157,163 ----
  
  
  
! void    rsvp_init(void);
  void    rsvp_qos_request(uint8_t bandwith, uint16_t refresh_period,open_addr_t dest);
  
  #endif
diff -crB stock/openwsn/07-App/Makefile dev/openwsn/07-App/Makefile
*** stock/openwsn/07-App/Makefile	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/Makefile	Wed Jan 29 10:33:22 2014
***************
*** 0 ****
--- 1,49 ----
+ SUBMOD:=$(shell basename $(CURDIR)).a
+ #BINDIR = $(RIOTBASE)/bin/
+ SRC = $(wildcard *.c)
+ OBJ = $(SRC:%.c=$(BINDIR)%.o)
+ DEP = $(SRC:%.c=$(BINDIR)%.d)
+ 
+ INCLUDES += -I$(RIOTBASE) -I$(RIOTBASE)/sys/include -I$(RIOTBASE)/core/include -I$(RIOTBASE)/drivers/include -I$(RIOTBASE)/drivers/cc110x_ng/include -I$(RIOTBASE)/cpu/arm_common/include -I$(RIOTBASE)/sys/net/include/ 
+ INCLUDES += -I$(CURDIR)/02a-MAClow
+ INCLUDES += -I$(CURDIR)/02b-MAChigh
+ INCLUDES += -I$(CURDIR)/03a-IPHC
+ INCLUDES += -I$(CURDIR)/03b-IPv6
+ INCLUDES += -I$(CURDIR)/04-TRAN
+ INCLUDES += -I$(CURDIR)/07-App/ohlone
+ INCLUDES += -I$(CURDIR)/07-App/tcpecho
+ INCLUDES += -I$(CURDIR)/07-App/tcpinject
+ INCLUDES += -I$(CURDIR)/07-App/tcpprint
+ INCLUDES += -I$(CURDIR)/cross-layers
+ 
+ DIRS += rinfo
+ DIRS += rwellknown
+ DIRS += ohlone
+ DIRS += tcpecho
+ DIRS += tcpinject
+ DIRS += tcpprint
+ DIRS += udpecho
+ DIRS += udpinject
+ DIRS += udplatency
+ DIRS += udpprint
+ DIRS += udprand
+ DIRS += udpstorm
+ 
+ all: $(BINDIR)$(SUBMOD)
+ 	@for i in $(DIRS) ; do "$(MAKE)" -C $$i ; done ;
+ 
+ $(BINDIR)$(SUBMOD): $(OBJ)
+ 	$(AD)$(AR) rcs $(BINDIR)$(MODULE) $(OBJ)
+ 
+ # pull in dependency info for *existing* .o files
+ -include $(OBJ:.o=.d)
+ 
+ # compile and generate dependency info
+ $(BINDIR)%.o: %.c
+ 	mkdir -p $(BINDIR)
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -c $*.c -o $(BINDIR)$*.o
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -MM $*.c > $(BINDIR)$*.d
+ 	@printf "$(BINDIR)"|cat - $(BINDIR)$*.d > /tmp/riot_out && mv /tmp/riot_out $(BINDIR)$*.d
+ 
+ clean::
+ 	@for i in $(DIRS) ; do "$(MAKE)" -C $$i clean ; done ;
diff -crB stock/openwsn/07-App/heli/heli.h dev/openwsn/07-App/heli/heli.h
*** stock/openwsn/07-App/heli/heli.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/heli/heli.h	Wed Jan 29 10:33:22 2014
***************
*** 2,13 ****
  #define __HELI_H
  
  /**
! \addtogroup App
  \{
  \addtogroup Heli
  \{
  */
  
  //=========================== define ==========================================
  
  //=========================== typedef =========================================
--- 2,15 ----
  #define __HELI_H
  
  /**
! \addtogroup AppUdp
  \{
  \addtogroup Heli
  \{
  */
  
+ 
+ #include "openwsn.h"
  //=========================== define ==========================================
  
  //=========================== typedef =========================================
***************
*** 18,24 ****
  
  void heli_init();
  void heli_trigger();
! void heli_sendDone(OpenQueueEntry_t* msg, error_t error);
  void heli_receive(OpenQueueEntry_t* msg);
  bool heli_debugPrint();
  
--- 20,26 ----
  
  void heli_init();
  void heli_trigger();
! void heli_sendDone(OpenQueueEntry_t* msg, owerror_t error);
  void heli_receive(OpenQueueEntry_t* msg);
  bool heli_debugPrint();
  
diff -crB stock/openwsn/07-App/imu/imu.c dev/openwsn/07-App/imu/imu.c
*** stock/openwsn/07-App/imu/imu.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/imu/imu.c	Wed Jan 29 10:33:22 2014
***************
*** 54,60 ****
  }
  
  //I just sent a IMU packet, check I need to resend one
! void imu_sendDone(OpenQueueEntry_t* msg, error_t error) {
     msg->owner = COMPONENT_IMU;
     if (msg->creator!=COMPONENT_IMU) {
        openserial_printError(COMPONENT_IMU,ERR_UNEXPECTED_SENDDONE,
--- 54,60 ----
  }
  
  //I just sent a IMU packet, check I need to resend one
! void imu_sendDone(OpenQueueEntry_t* msg, owerror_t error) {
     msg->owner = COMPONENT_IMU;
     if (msg->creator!=COMPONENT_IMU) {
        openserial_printError(COMPONENT_IMU,ERR_UNEXPECTED_SENDDONE,
diff -crB stock/openwsn/07-App/imu/imu.h dev/openwsn/07-App/imu/imu.h
*** stock/openwsn/07-App/imu/imu.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/imu/imu.h	Wed Jan 29 10:33:22 2014
***************
*** 2,8 ****
  #define __IMU_H
  
  /**
! \addtogroup App
  \{
  \addtogroup imu
  \{
--- 2,8 ----
  #define __IMU_H
  
  /**
! \addtogroup AppUdp
  \{
  \addtogroup imu
  \{
***************
*** 18,24 ****
  
  void imu_init();
  void imu_trigger();
! void imu_sendDone(OpenQueueEntry_t* msg, error_t error);
  void imu_receive(OpenQueueEntry_t* msg);
  bool imu_debugPrint();
  
--- 18,24 ----
  
  void imu_init();
  void imu_trigger();
! void imu_sendDone(OpenQueueEntry_t* msg, owerror_t error);
  void imu_receive(OpenQueueEntry_t* msg);
  bool imu_debugPrint();
  
diff -crB stock/openwsn/07-App/layerdebug/layerdebug.c dev/openwsn/07-App/layerdebug/layerdebug.c
*** stock/openwsn/07-App/layerdebug/layerdebug.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/layerdebug/layerdebug.c	Wed Jan 29 10:33:22 2014
***************
*** 7,13 ****
  #include "openserial.h"
  #include "openrandom.h"
  #include "scheduler.h"
! 
  
  // include layer files to debug
  #include "neighbors.h"
--- 7,14 ----
  #include "openserial.h"
  #include "openrandom.h"
  #include "scheduler.h"
! #include "IEEE802154E.h"
! #include "idmanager.h"
  
  // include layer files to debug
  #include "neighbors.h"
***************
*** 34,45 ****
  
  //=========================== prototypes ======================================
  
! error_t layerdebug_schedule_receive(OpenQueueEntry_t* msg,
                      coap_header_iht*  coap_header,
                      coap_option_iht*  coap_options);
  
  
! error_t layerdebug_neighbors_receive(OpenQueueEntry_t* msg,
                      coap_header_iht*  coap_header,
                      coap_option_iht*  coap_options);
  
--- 35,46 ----
  
  //=========================== prototypes ======================================
  
! owerror_t layerdebug_schedule_receive(OpenQueueEntry_t* msg,
                      coap_header_iht*  coap_header,
                      coap_option_iht*  coap_options);
  
  
! owerror_t layerdebug_neighbors_receive(OpenQueueEntry_t* msg,
                      coap_header_iht*  coap_header,
                      coap_option_iht*  coap_options);
  
***************
*** 50,56 ****
  void    layerdebug_task_neighbors_cb();
  
  void    layerdebug_sendDone(OpenQueueEntry_t* msg,
!                        error_t error);
  
  //=========================== public ==========================================
  
--- 51,57 ----
  void    layerdebug_task_neighbors_cb();
  
  void    layerdebug_sendDone(OpenQueueEntry_t* msg,
!                        owerror_t error);
  
  //=========================== public ==========================================
  
***************
*** 100,109 ****
  //schedule stats
  void layerdebug_task_schedule_cb() {
     OpenQueueEntry_t* pkt;
!    error_t           outcome;
     uint8_t           numOptions;
     uint8_t           size;
  
     // create a CoAP RD packet
     pkt = openqueue_getFreePacketBuffer(COMPONENT_LAYERDEBUG);
     if (pkt==NULL) {
--- 101,120 ----
  //schedule stats
  void layerdebug_task_schedule_cb() {
     OpenQueueEntry_t* pkt;
!    owerror_t           outcome;
     uint8_t           numOptions;
     uint8_t           size;
  
+    // don't run if not synch
+    if (ieee154e_isSynch() == FALSE) return;
+    
+     // don't run on dagroot
+    if (idmanager_getIsDAGroot()) {
+        opentimers_stop( layerdebug_vars.schtimerId);
+        opentimers_stop( layerdebug_vars.nbstimerId);
+        return;
+    }
+    
     // create a CoAP RD packet
     pkt = openqueue_getFreePacketBuffer(COMPONENT_LAYERDEBUG);
     if (pkt==NULL) {
***************
*** 131,142 ****
     packetfunctions_reserveHeaderSize(pkt,sizeof(schedule_layerdebug_path0)-1);
     memcpy(&pkt->payload[0],&schedule_layerdebug_path0,sizeof(schedule_layerdebug_path0)-1);
     packetfunctions_reserveHeaderSize(pkt,1);
!    pkt->payload[0]                  = (COAP_OPTION_LOCATIONPATH-COAP_OPTION_CONTENTTYPE) << 4 |
        sizeof(schedule_layerdebug_path0)-1;
     numOptions++;
     // content-type option
     packetfunctions_reserveHeaderSize(pkt,2);
!    pkt->payload[0]                  = COAP_OPTION_CONTENTTYPE << 4 |
        1;
     pkt->payload[1]                  = COAP_MEDTYPE_APPOCTETSTREAM;
     numOptions++;
--- 142,153 ----
     packetfunctions_reserveHeaderSize(pkt,sizeof(schedule_layerdebug_path0)-1);
     memcpy(&pkt->payload[0],&schedule_layerdebug_path0,sizeof(schedule_layerdebug_path0)-1);
     packetfunctions_reserveHeaderSize(pkt,1);
!    pkt->payload[0]                  = (COAP_OPTION_NUM_URIPATH) << 4 |
        sizeof(schedule_layerdebug_path0)-1;
     numOptions++;
     // content-type option
     packetfunctions_reserveHeaderSize(pkt,2);
!    pkt->payload[0]                  = COAP_OPTION_NUM_CONTENTFORMAT << 4 |
        1;
     pkt->payload[1]                  = COAP_MEDTYPE_APPOCTETSTREAM;
     numOptions++;
***************
*** 162,168 ****
  void layerdebug_task_neighbors_cb() {
    
     OpenQueueEntry_t* pkt;
!    error_t           outcome;
     uint8_t           numOptions;
     uint8_t           size;
     
--- 173,179 ----
  void layerdebug_task_neighbors_cb() {
    
     OpenQueueEntry_t* pkt;
!    owerror_t           outcome;
     uint8_t           numOptions;
     uint8_t           size;
     
***************
*** 195,206 ****
     packetfunctions_reserveHeaderSize(pkt,sizeof(neighbors_layerdebug_path0)-1);
     memcpy(&pkt->payload[0],&neighbors_layerdebug_path0,sizeof(neighbors_layerdebug_path0)-1);
     packetfunctions_reserveHeaderSize(pkt,1);
!    pkt->payload[0]                  = (COAP_OPTION_LOCATIONPATH-COAP_OPTION_CONTENTTYPE) << 4 |
        sizeof(neighbors_layerdebug_path0)-1;
     numOptions++;
     // content-type option
     packetfunctions_reserveHeaderSize(pkt,2);
!    pkt->payload[0]                  = COAP_OPTION_CONTENTTYPE << 4 |
        1;
     pkt->payload[1]                  = COAP_MEDTYPE_APPOCTETSTREAM;
     numOptions++;
--- 206,217 ----
     packetfunctions_reserveHeaderSize(pkt,sizeof(neighbors_layerdebug_path0)-1);
     memcpy(&pkt->payload[0],&neighbors_layerdebug_path0,sizeof(neighbors_layerdebug_path0)-1);
     packetfunctions_reserveHeaderSize(pkt,1);
!    pkt->payload[0]                  = (COAP_OPTION_NUM_URIPATH) << 4 |
        sizeof(neighbors_layerdebug_path0)-1;
     numOptions++;
     // content-type option
     packetfunctions_reserveHeaderSize(pkt,2);
!    pkt->payload[0]                  = COAP_OPTION_NUM_CONTENTFORMAT << 4 |
        1;
     pkt->payload[1]                  = COAP_MEDTYPE_APPOCTETSTREAM;
     numOptions++;
***************
*** 222,236 ****
     return;
  }
  
! void layerdebug_sendDone(OpenQueueEntry_t* msg, error_t error) {
     openqueue_freePacketBuffer(msg);
  }
  
  
! error_t layerdebug_schedule_receive(OpenQueueEntry_t* msg,
                        coap_header_iht* coap_header,
                        coap_option_iht* coap_options) {
!    error_t outcome;
     uint8_t size;
    
     
--- 233,247 ----
     return;
  }
  
! void layerdebug_sendDone(OpenQueueEntry_t* msg, owerror_t error) {
     openqueue_freePacketBuffer(msg);
  }
  
  
! owerror_t layerdebug_schedule_receive(OpenQueueEntry_t* msg,
                        coap_header_iht* coap_header,
                        coap_option_iht* coap_options) {
!    owerror_t outcome;
     uint8_t size;
    
     
***************
*** 250,256 ****
        msg->payload[0] = MAXACTIVESLOTS;
             
        // set the CoAP header
-       coap_header->OC                  = 0;
        coap_header->Code                = COAP_CODE_RESP_CONTENT;
        
        outcome                          = E_SUCCESS;
--- 261,266 ----
***************
*** 263,272 ****
     return outcome;
  }
  
! error_t layerdebug_neighbors_receive(OpenQueueEntry_t* msg,
                        coap_header_iht* coap_header,
                        coap_option_iht* coap_options) {
!    error_t outcome;
     uint8_t size;
    
     
--- 273,282 ----
     return outcome;
  }
  
! owerror_t layerdebug_neighbors_receive(OpenQueueEntry_t* msg,
                        coap_header_iht* coap_header,
                        coap_option_iht* coap_options) {
!    owerror_t outcome;
     uint8_t size;
    
     
***************
*** 287,293 ****
        msg->payload[0] = size;
             
        // set the CoAP header
-       coap_header->OC                  = 0;
        coap_header->Code                = COAP_CODE_RESP_CONTENT;
        
        outcome                          = E_SUCCESS;
--- 297,302 ----
diff -crB stock/openwsn/07-App/layerdebug/layerdebug.h dev/openwsn/07-App/layerdebug/layerdebug.h
*** stock/openwsn/07-App/layerdebug/layerdebug.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/layerdebug/layerdebug.h	Wed Jan 29 10:33:22 2014
***************
*** 2,8 ****
  #define __LAYERDEBUG_H
  
  /**
! \addtogroup App
  \{
  \addtogroup rT
  \{
--- 2,8 ----
  #define __LAYERDEBUG_H
  
  /**
! \addtogroup AppCoAP
  \{
  \addtogroup rT
  \{
diff -crB stock/openwsn/07-App/ohlone/Makefile dev/openwsn/07-App/ohlone/Makefile
*** stock/openwsn/07-App/ohlone/Makefile	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/ohlone/Makefile	Wed Jan 29 10:33:22 2014
***************
*** 0 ****
--- 1,32 ----
+ SUBSUBMOD:=$(shell basename $(CURDIR)).a
+ #BINDIR = $(RIOTBASE)/bin/
+ SRC = $(wildcard *.c)
+ OBJ = $(SRC:%.c=$(BINDIR)%.o)
+ DEP = $(SRC:%.c=$(BINDIR)%.d)
+ 
+ INCLUDES += -I$(RIOTBASE) -I$(RIOTBASE)/sys/include -I$(RIOTBASE)/core/include -I$(RIOTBASE)/drivers/include -I$(RIOTBASE)/drivers/cc110x_ng/include -I$(RIOTBASE)/cpu/arm_common/include -I$(RIOTBASE)/sys/net/include/
+ INCLUDES += -I$(CURDIR)/02a-MAClow
+ INCLUDES += -I$(CURDIR)/02b-MAChigh
+ INCLUDES += -I$(CURDIR)/03a-IPHC
+ INCLUDES += -I$(CURDIR)/03b-IPv6
+ INCLUDES += -I$(CURDIR)/04-TRAN
+ INCLUDES += -I$(CURDIR)/cross-layers
+ 
+ .PHONY: $(BINDIR)$(SUBSUBMOD)
+ 
+ $(BINDIR)$(SUBSUBMOD): $(OBJ)
+ 	$(AD)$(AR) rcs $(BINDIR)$(MODULE) $(OBJ)
+ 
+ # pull in dependency info for *existing* .o files
+ -include $(OBJ:.o=.d)
+ 
+ # compile and generate dependency info
+ $(BINDIR)%.o: %.c
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -c $*.c -o $(BINDIR)$*.o
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -MM $*.c > $(BINDIR)$*.d
+ 	@printf "$(BINDIR)" | cat - $(BINDIR)$*.d > /tmp/riot_out && mv /tmp/riot_out $(BINDIR)$*.d
+ 
+ # remove compilation products
+ 
+ clean:
+ 	rm -f $(OBJ) $(DEP)
diff -crB stock/openwsn/07-App/ohlone/ohlone.c dev/openwsn/07-App/ohlone/ohlone.c
*** stock/openwsn/07-App/ohlone/ohlone.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/ohlone/ohlone.c	Wed Jan 29 10:33:22 2014
***************
*** 9,42 ****
  
  //=========================== variables =======================================
  
- typedef struct {
-    OpenQueueEntry_t*    pkt;
-    bool                 sending;
-    uint16_t             httpChunk;
-    uint8_t              getRequest[TCP_DEFAULT_WINDOW_SIZE];
- } ohlone_vars_t;
- 
  ohlone_vars_t ohlone_vars;
  
  //=========================== prototypes ======================================
  
! void ohlone_sendpkt();
  bool ohlone_check4chars(uint8_t c1[4], uint8_t c2[4]);
  
  //=========================== public ==========================================
  
! void ohlone_init() {
     ohlone_vars.httpChunk = 0;
     ohlone_vars.getRequest[0] = '/';
     ohlone_vars.getRequest[1] = ' ';
     ohlone_webpages_init();
  }
  
! bool ohlone_shouldIlisten() {
     return TRUE;
  }
  
! void ohlone_sendpkt() {
     uint8_t buffer[TCP_DEFAULT_WINDOW_SIZE];
     uint8_t buffer_len;
    
--- 9,35 ----
  
  //=========================== variables =======================================
  
  ohlone_vars_t ohlone_vars;
  
  //=========================== prototypes ======================================
  
! void ohlone_sendpkt(void);
  bool ohlone_check4chars(uint8_t c1[4], uint8_t c2[4]);
  
  //=========================== public ==========================================
  
! void ohlone_init(void) {
     ohlone_vars.httpChunk = 0;
     ohlone_vars.getRequest[0] = '/';
     ohlone_vars.getRequest[1] = ' ';
     ohlone_webpages_init();
  }
  
! bool ohlone_shouldIlisten(void) {
     return TRUE;
  }
  
! void ohlone_sendpkt(void) {
     uint8_t buffer[TCP_DEFAULT_WINDOW_SIZE];
     uint8_t buffer_len;
    
***************
*** 98,104 ****
     openqueue_freePacketBuffer(msg);
  }
  
! void ohlone_sendDone(OpenQueueEntry_t* msg, error_t error) {
     msg->owner = COMPONENT_OHLONE;
     if (msg->creator!=COMPONENT_OHLONE) {
        openserial_printError(COMPONENT_OHLONE,ERR_UNEXPECTED_SENDDONE,
--- 91,97 ----
     openqueue_freePacketBuffer(msg);
  }
  
! void ohlone_sendDone(OpenQueueEntry_t* msg, owerror_t error) {
     msg->owner = COMPONENT_OHLONE;
     if (msg->creator!=COMPONENT_OHLONE) {
        openserial_printError(COMPONENT_OHLONE,ERR_UNEXPECTED_SENDDONE,
***************
*** 110,119 ****
     openqueue_freePacketBuffer(msg);
  }
  
! void ohlone_connectDone(error_t error) {
  }
  
! bool ohlone_debugPrint() {
     return FALSE;
  }
  
--- 103,112 ----
     openqueue_freePacketBuffer(msg);
  }
  
! void ohlone_connectDone(owerror_t error) {
  }
  
! bool ohlone_debugPrint(void) {
     return FALSE;
  }
  
diff -crB stock/openwsn/07-App/ohlone/ohlone.h dev/openwsn/07-App/ohlone/ohlone.h
*** stock/openwsn/07-App/ohlone/ohlone.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/ohlone/ohlone.h	Wed Jan 29 10:33:22 2014
***************
*** 2,27 ****
  #define __OHLONE_H
  
  /**
! \addtogroup App
  \{
  \addtogroup ohlone
  \{
  */
  
  //=========================== define ==========================================
  
  //=========================== typedef =========================================
  
! //=========================== variables =======================================
  
  //=========================== prototypes ======================================
  
! void ohlone_init();
! bool ohlone_shouldIlisten();
  void ohlone_receive(OpenQueueEntry_t* msg);
! void ohlone_sendDone(OpenQueueEntry_t* msg, error_t error);
! void ohlone_connectDone(error_t error);
! bool ohlone_debugPrint();
  
  /**
  \}
--- 2,36 ----
  #define __OHLONE_H
  
  /**
! \addtogroup AppTcp
  \{
  \addtogroup ohlone
  \{
  */
  
+ #include "opentcp.h"
+ 
  //=========================== define ==========================================
  
  //=========================== typedef =========================================
  
! //=========================== module variables ================================
! 
! typedef struct {
!    OpenQueueEntry_t*    pkt;
!    bool                 sending;
!    uint16_t             httpChunk;
!    uint8_t              getRequest[TCP_DEFAULT_WINDOW_SIZE];
! } ohlone_vars_t;
  
  //=========================== prototypes ======================================
  
! void ohlone_init(void);
! bool ohlone_shouldIlisten(void);
  void ohlone_receive(OpenQueueEntry_t* msg);
! void ohlone_sendDone(OpenQueueEntry_t* msg, owerror_t error);
! void ohlone_connectDone(owerror_t error);
! bool ohlone_debugPrint(void);
  
  /**
  \}
diff -crB stock/openwsn/07-App/ohlone/ohlone_webpages.c dev/openwsn/07-App/ohlone/ohlone_webpages.c
*** stock/openwsn/07-App/ohlone/ohlone_webpages.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/ohlone/ohlone_webpages.c	Wed Jan 29 10:33:22 2014
***************
*** 25,31 ****
  
  //=========================== public ==========================================
  
! void ohlone_webpages_init() {
     /*
     if (*(&eui64+3)==0x09) {                      // this is a GINA board (not a basestation)
        gyro_init();
--- 25,31 ----
  
  //=========================== public ==========================================
  
! void ohlone_webpages_init(void) {
     /*
     if (*(&eui64+3)==0x09) {                      // this is a GINA board (not a basestation)
        gyro_init();
diff -crB stock/openwsn/07-App/ohlone/ohlone_webpages.h dev/openwsn/07-App/ohlone/ohlone_webpages.h
*** stock/openwsn/07-App/ohlone/ohlone_webpages.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/ohlone/ohlone_webpages.h	Wed Jan 29 10:33:22 2014
***************
*** 27,33 ****
  
  //=========================== prototypes ======================================
  
! void     ohlone_webpages_init();
  uint8_t  ohlone_webpage(uint8_t *getRequest, uint16_t chunk, uint8_t *packet);
  
  #endif
\ No newline at end of file
--- 27,33 ----
  
  //=========================== prototypes ======================================
  
! void     ohlone_webpages_init(void);
  uint8_t  ohlone_webpage(uint8_t *getRequest, uint16_t chunk, uint8_t *packet);
  
  #endif
\ No newline at end of file
diff -crB stock/openwsn/07-App/r6tus/r6tus.c dev/openwsn/07-App/r6tus/r6tus.c
*** stock/openwsn/07-App/r6tus/r6tus.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/r6tus/r6tus.c	Wed Jan 29 10:33:22 2014
***************
*** 0 ****
--- 1,211 ----
+ /**
+ \brief CoAP schedule manager application.
+ 
+ \author Xavi Vilajosana <xvilajosana@eecs.berkeley.edu>, Feb. 2013.
+ 
+ */
+ 
+ #include "openwsn.h"
+ #include "r6tus.h"
+ #include "opentimers.h"
+ #include "openqueue.h"
+ #include "packetfunctions.h"
+ #include "openserial.h"
+ #include "scheduler.h"
+ #include "schedule.h"
+ #include "idmanager.h"
+ 
+ //=========================== defines =========================================
+ 
+ #define TSCH_GET_OPTIONS 4 //how many params in a get request.
+ 
+ const uint8_t r6tus_path0[] = "6tus";
+ 
+ //=========================== variables =======================================
+ 
+ r6tus_vars_t r6tus_vars;
+ 
+ //=========================== prototypes ======================================
+ 
+ owerror_t r6tus_receive(OpenQueueEntry_t* msg,
+                     coap_header_iht*  coap_header,
+                     coap_option_iht*  coap_options);
+ 
+ void    r6tus_sendDone(OpenQueueEntry_t* msg,
+                        owerror_t error);
+ 
+ //=========================== public ==========================================
+ 
+ void r6tus_init() {
+    
+    if(idmanager_getIsDAGroot()==TRUE) return; 
+    // prepare the resource descriptor for the /r6tus path
+    r6tus_vars.desc.path0len            = sizeof(r6tus_path0)-1;
+    r6tus_vars.desc.path0val            = (uint8_t*)(&r6tus_path0);
+    r6tus_vars.desc.path1len            = 0;
+    r6tus_vars.desc.path1val            = NULL;
+    r6tus_vars.desc.componentID         = COMPONENT_R6TUS;
+    r6tus_vars.desc.callbackRx          = &r6tus_receive;
+    r6tus_vars.desc.callbackSendDone    = &r6tus_sendDone;
+    
+    opencoap_register(&r6tus_vars.desc);
+ }
+ 
+ //=========================== private =========================================
+ 
+ /**
+ \brief Receives a command and a list of items to be used by the command.
+ 
+ the coap payload contains, command_type (CREATE,READ,UPDATE,DELETE) number of
+ items to be processed.
+ A tuple including address,slotoffset,choffset,whether is shared or not and link
+ type.
+ 
+ According to the command it returns the list of responses or the required
+ information.
+ */
+ owerror_t r6tus_receive(OpenQueueEntry_t* msg,
+                       coap_header_iht*  coap_header,
+                       coap_option_iht*  coap_options) {
+                         
+    uint8_t              i;
+    owerror_t              outcome;
+    r6tus_command_t*     link_command;
+    r6tus_command_t      getResponse;
+    slotinfo_element_t*  link_element;
+    slotinfo_element_t   getLink_elementResponse;
+    open_addr_t          temp_addr;
+    owerror_t              responses[R6TUS_MAXRESPONSES];
+    //assuming data comes in binary format.
+     
+    if (coap_header->Code==COAP_CODE_REQ_GET) {
+       outcome = E_SUCCESS;    
+       // parsing the options from header
+       // assuming the following header: /6tus/LinkComandType/targetSlot/targetAddress
+       // if (coap_header->OC != TSCH_GET_OPTIONS) {
+          //option[0] is 6tus
+          getResponse.type=(link_command_t)coap_options[1].pValue[0];
+          if (getResponse.type != READ_LINK){
+             //fail if this is not a READ REQUEST
+             outcome                    = E_FAIL;
+             coap_header->Code          = COAP_CODE_RESP_CONTENT;
+             //return as this is not the right request.
+             return outcome;
+          }
+          
+          getResponse.numelem = 1; //get is always for 1 element.
+          getLink_elementResponse.slotOffset=coap_options[2].pValue[0];
+          
+          switch (coap_options[3].length){
+             case ADDR_16B:
+                temp_addr.type=ADDR_16B;
+                memcpy(&(temp_addr.addr_16b[0]), &(coap_options[3].pValue[0]),LENGTH_ADDR16b);
+                schedule_getSlotInfo(getLink_elementResponse.slotOffset, &temp_addr, &getLink_elementResponse);
+                outcome                 = E_SUCCESS;
+                break;
+             case ADDR_64B:
+                temp_addr.type=ADDR_64B;
+                memcpy(&(temp_addr.addr_64b[0]), &(coap_options[3].pValue[0]),LENGTH_ADDR64b);
+                schedule_getSlotInfo(getLink_elementResponse.slotOffset, &temp_addr, &getLink_elementResponse);
+                outcome                 = E_SUCCESS;
+                break;
+             case ADDR_128B:
+                // not supported
+                outcome                 = E_FAIL;
+                break;
+             default:
+                outcome                 = E_FAIL;
+                break;  
+          }
+       
+       coap_header->Code                = COAP_CODE_RESP_CONTENT;
+       // By using the same link_element we don't need to write the packet.
+       // It returns the same payload  but with the correct values.
+       if (outcome==E_SUCCESS) {
+          // write the payload in the response.
+          packetfunctions_reserveHeaderSize(msg,sizeof(slotinfo_element_t));
+          memcpy(&msg->payload[0],&getLink_elementResponse,sizeof(slotinfo_element_t));
+       }
+    } else if (coap_header->Code==COAP_CODE_REQ_PUT) {     
+       link_command = (r6tus_command_t*) msg->payload; 
+       //parsing all cases at post as we want params. once tested we can decide. GET does not accept params
+       //so params should be encoded in the url.
+       switch (link_command->type){
+          case READ_LINK:
+             outcome=E_FAIL; 
+             //cannot put READ operation
+             break;
+          case CREATE_LINK:
+          case UPDATE_LINK: //update should be post according to REST architecture.
+             outcome=E_FAIL; 
+             if (link_command->numelem<R6TUS_MAXRESPONSES) {
+                for (i=0;i<link_command->numelem;i++) {
+                   link_element=(slotinfo_element_t*) &(msg->payload[sizeof(r6tus_command_t)+i*sizeof(slotinfo_element_t)]);
+                   temp_addr.type=ADDR_64B;
+                   memcpy(&(temp_addr.addr_64b[0]), &(link_element->address[0]),LENGTH_ADDR64b);
+                   responses[i]=schedule_addActiveSlot(link_element->slotOffset,link_element->link_type,link_element->shared,link_element->channelOffset,&temp_addr,(link_command->type==UPDATE_LINK));
+                }
+                outcome=E_SUCCESS; 
+             }
+             break;
+          case DELETE_LINK:
+             outcome=E_FAIL; 
+             //cannot delete with PUT/POST
+             break;
+          default:
+             openserial_printError(COMPONENT_R6TUS,ERR_COMMAND_NOT_ALLOWED,
+                (errorparameter_t)0,
+                (errorparameter_t)0
+             );
+             //who clears the packet??
+             //error. Print error and send error msg.
+             outcome                    = E_FAIL;
+             break; 
+       }
+       //response of the post
+       if (outcome==E_SUCCESS){
+          
+          // reset packet payload
+          msg->payload                  = &(msg->packet[127]);
+          msg->length                   = 0;
+          //copy the response.
+          
+          //packetfunctions_reserveHeaderSize(msg,link_command->numelem); 
+          //memcpy(&(msg->payload[0]), &(responses[0]),link_command->numelem);
+          
+          // set the CoAP header
+          coap_header->Code             = COAP_CODE_RESP_CONTENT;
+       }
+    } else if (coap_header->Code==COAP_CODE_REQ_DELETE) {  
+       link_command = (r6tus_command_t*) msg->payload; 
+       switch (link_command->type){
+          case DELETE_LINK:
+             outcome=E_FAIL; 
+             if (link_command->numelem<R6TUS_MAXRESPONSES){    
+                for(i=0;i<link_command->numelem;i++) {
+                   link_element=(slotinfo_element_t*) &(msg->payload[sizeof(r6tus_command_t)+i*sizeof(slotinfo_element_t)]);
+                   temp_addr.type=ADDR_64B;
+                   memcpy(&(temp_addr.addr_64b[0]), &(link_element->address[0]),LENGTH_ADDR64b);
+                   //remove the required links.
+                   responses[i]=schedule_removeActiveSlot(link_element->slotOffset,&temp_addr);
+                }
+                outcome=E_SUCCESS; 
+             }
+             break;
+          default:
+             openserial_printError(COMPONENT_R6TUS,ERR_COMMAND_NOT_ALLOWED,
+                             (errorparameter_t)0,
+                             (errorparameter_t)0);
+             //who clears the packet??
+             //error. Print error and send error msg.        
+             outcome                          = E_FAIL;
+             break;
+       }
+    }
+    return outcome;
+ }
+ 
+ 
+ void r6tus_sendDone(OpenQueueEntry_t* msg, owerror_t error) {
+    openqueue_freePacketBuffer(msg);
+ }
diff -crB stock/openwsn/07-App/r6tus/r6tus.h dev/openwsn/07-App/r6tus/r6tus.h
*** stock/openwsn/07-App/r6tus/r6tus.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/r6tus/r6tus.h	Wed Jan 29 10:33:22 2014
***************
*** 0 ****
--- 1,60 ----
+ /**
+ \brief CoAP schedule manager application.
+ 
+ \author Xavi Vilajosana <xvilajosana@eecs.berkeley.edu>, Feb. 2013.
+ 
+ */
+ 
+ 
+ #ifndef __RSCHED_H
+ #define __RSCHED_H
+ 
+ /**
+ \addtogroup AppCoAP
+ \{
+ \addtogroup rsched
+ \{
+ */
+ 
+ #include "openwsn.h"
+ #include "opencoap.h"
+ #include "schedule.h"
+ 
+ //=========================== define ==========================================
+ 
+ #define R6TUS_MAXRESPONSES 20 //max number of elements to be processed by a command.
+ 
+ //=========================== typedef =========================================
+ 
+ //CRUD OPERATIONS FOR LINKS.
+ typedef enum {
+    CREATE_LINK                           = 0,          
+    READ_LINK                             = 1,
+    UPDATE_LINK                           = 2,
+    DELETE_LINK                           = 3,
+ }link_command_t;
+ 
+ //header
+ PRAGMA(pack(1)); //elements for slot info 
+ typedef struct {
+   link_command_t type; 
+   uint8_t numelem;//number of elements 
+ }r6tus_command_t;
+ PRAGMA(pack());
+ 
+ //=========================== variables =======================================
+ 
+ typedef struct {
+    coap_resource_desc_t desc;
+ } r6tus_vars_t;
+ 
+ //=========================== prototypes ======================================
+ 
+ void r6tus_init();
+ 
+ /**
+ \}
+ \}
+ */
+ 
+ #endif
diff -crB stock/openwsn/07-App/rex/rex.c dev/openwsn/07-App/rex/rex.c
*** stock/openwsn/07-App/rex/rex.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/rex/rex.c	Wed Jan 29 10:33:22 2014
***************
*** 8,13 ****
--- 8,15 ----
  #include "openrandom.h"
  #include "scheduler.h"
  //#include "ADC_Channel.h"
+ #include "idmanager.h"
+ #include "IEEE802154E.h"
  
  //=========================== defines =========================================
  
***************
*** 28,40 ****
  
  //=========================== prototypes ======================================
  
! error_t rex_receive(OpenQueueEntry_t* msg,
                      coap_header_iht*  coap_header,
                      coap_option_iht*  coap_options);
  void    rex_timer_cb();
  void    rex_task_cb();
  void    rex_sendDone(OpenQueueEntry_t* msg,
!                        error_t error);
  
  //=========================== public ==========================================
  
--- 30,42 ----
  
  //=========================== prototypes ======================================
  
! owerror_t rex_receive(OpenQueueEntry_t* msg,
                      coap_header_iht*  coap_header,
                      coap_option_iht*  coap_options);
  void    rex_timer_cb();
  void    rex_task_cb();
  void    rex_sendDone(OpenQueueEntry_t* msg,
!                        owerror_t error);
  
  //=========================== public ==========================================
  
***************
*** 58,64 ****
  
  //=========================== private =========================================
  
! error_t rex_receive(OpenQueueEntry_t* msg,
                        coap_header_iht* coap_header,
                        coap_option_iht* coap_options) {
     return E_FAIL;
--- 60,66 ----
  
  //=========================== private =========================================
  
! owerror_t rex_receive(OpenQueueEntry_t* msg,
                        coap_header_iht* coap_header,
                        coap_option_iht* coap_options) {
     return E_FAIL;
***************
*** 72,78 ****
  
  void rex_task_cb() {
     OpenQueueEntry_t* pkt;
!    error_t           outcome;
     uint8_t           numOptions;
     uint8_t           i;
     
--- 74,80 ----
  
  void rex_task_cb() {
     OpenQueueEntry_t* pkt;
!    owerror_t           outcome;
     uint8_t           numOptions;
     uint8_t           i;
     
***************
*** 82,92 ****
     uint16_t       avg         = 0;
     uint8_t        N_avg       = 10;
     
!    for (int i = 0; i < N_avg; i++)
!    {
!      //ADC_getvoltage(p_x_int);
!       
!      sum += x_int;
     }
     avg = sum/N_avg;
     
--- 84,102 ----
     uint16_t       avg         = 0;
     uint8_t        N_avg       = 10;
     
!    // don't run if not synch
!    if (ieee154e_isSynch() == FALSE) return;
!    
!        // don't run on dagroot
!    if (idmanager_getIsDAGroot()) {
!        opentimers_stop(rex_vars.timerId);
!        return;
!    }
!    
!    
!    for (i = 0; i < N_avg; i++) {
!       //ADC_getvoltage(p_x_int);
!       sum += x_int;
     }
     avg = sum/N_avg;
     
***************
*** 117,128 ****
     packetfunctions_reserveHeaderSize(pkt,sizeof(rex_path0)-1);
     memcpy(&pkt->payload[0],&rex_path0,sizeof(rex_path0)-1);
     packetfunctions_reserveHeaderSize(pkt,1);
!    pkt->payload[0]                  = (COAP_OPTION_LOCATIONPATH-COAP_OPTION_CONTENTTYPE) << 4 |
        sizeof(rex_path0)-1;
     numOptions++;
     // content-type option
     packetfunctions_reserveHeaderSize(pkt,2);
!    pkt->payload[0]                  = COAP_OPTION_CONTENTTYPE << 4 |
        1;
     pkt->payload[1]                  = COAP_MEDTYPE_APPOCTETSTREAM;
     numOptions++;
--- 127,138 ----
     packetfunctions_reserveHeaderSize(pkt,sizeof(rex_path0)-1);
     memcpy(&pkt->payload[0],&rex_path0,sizeof(rex_path0)-1);
     packetfunctions_reserveHeaderSize(pkt,1);
!    pkt->payload[0]                  = (COAP_OPTION_NUM_URIPATH) << 4 |
        sizeof(rex_path0)-1;
     numOptions++;
     // content-type option
     packetfunctions_reserveHeaderSize(pkt,2);
!    pkt->payload[0]                  = COAP_OPTION_NUM_CONTENTFORMAT << 4 |
        1;
     pkt->payload[1]                  = COAP_MEDTYPE_APPOCTETSTREAM;
     numOptions++;
***************
*** 144,149 ****
     return;
  }
  
! void rex_sendDone(OpenQueueEntry_t* msg, error_t error) {
     openqueue_freePacketBuffer(msg);
  }
--- 154,159 ----
     return;
  }
  
! void rex_sendDone(OpenQueueEntry_t* msg, owerror_t error) {
     openqueue_freePacketBuffer(msg);
  }
diff -crB stock/openwsn/07-App/rex/rex.h dev/openwsn/07-App/rex/rex.h
*** stock/openwsn/07-App/rex/rex.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/rex/rex.h	Wed Jan 29 10:33:22 2014
***************
*** 2,8 ****
  #define __REX_H
  
  /**
! \addtogroup App
  \{
  \addtogroup rT
  \{
--- 2,8 ----
  #define __REX_H
  
  /**
! \addtogroup AppUdp
  \{
  \addtogroup rT
  \{
diff -crB stock/openwsn/07-App/rheli/rheli.c dev/openwsn/07-App/rheli/rheli.c
*** stock/openwsn/07-App/rheli/rheli.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/rheli/rheli.c	Wed Jan 29 10:33:22 2014
***************
*** 19,30 ****
  
  //=========================== prototypes ======================================
  
! error_t rheli_receive(OpenQueueEntry_t* msg,
                        coap_header_iht*  coap_header,
                        coap_option_iht*  coap_options);
  void    rheli_timer();
  void    rheli_sendDone(OpenQueueEntry_t* msg,
!                        error_t error);
  
  //=========================== public ==========================================
  
--- 19,30 ----
  
  //=========================== prototypes ======================================
  
! owerror_t rheli_receive(OpenQueueEntry_t* msg,
                        coap_header_iht*  coap_header,
                        coap_option_iht*  coap_options);
  void    rheli_timer();
  void    rheli_sendDone(OpenQueueEntry_t* msg,
!                        owerror_t error);
  
  //=========================== public ==========================================
  
***************
*** 49,58 ****
  
  //=========================== private =========================================
  
! error_t rheli_receive(OpenQueueEntry_t* msg,
                        coap_header_iht*  coap_header,
                        coap_option_iht*  coap_options) {      
!    error_t outcome;
     
     if (coap_header->Code==COAP_CODE_REQ_POST) {
        
--- 49,58 ----
  
  //=========================== private =========================================
  
! owerror_t rheli_receive(OpenQueueEntry_t* msg,
                        coap_header_iht*  coap_header,
                        coap_option_iht*  coap_options) {      
!    owerror_t outcome;
     
     if (coap_header->Code==COAP_CODE_REQ_POST) {
        
***************
*** 64,70 ****
        msg->length                      = 0;
        
        // set the CoAP header
-       coap_header->OC                  = 0;
        coap_header->Code                = COAP_CODE_RESP_CHANGED;
        
        outcome                          = E_SUCCESS;
--- 64,69 ----
***************
*** 79,84 ****
     heli_off();
  }
  
! void rheli_sendDone(OpenQueueEntry_t* msg, error_t error) {
     openqueue_freePacketBuffer(msg);
  }
\ No newline at end of file
--- 78,83 ----
     heli_off();
  }
  
! void rheli_sendDone(OpenQueueEntry_t* msg, owerror_t error) {
     openqueue_freePacketBuffer(msg);
  }
\ No newline at end of file
diff -crB stock/openwsn/07-App/rheli/rheli.h dev/openwsn/07-App/rheli/rheli.h
*** stock/openwsn/07-App/rheli/rheli.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/rheli/rheli.h	Wed Jan 29 10:33:22 2014
***************
*** 2,8 ****
  #define __RHELI_H
  
  /**
! \addtogroup App
  \{
  \addtogroup rHeli
  \{
--- 2,8 ----
  #define __RHELI_H
  
  /**
! \addtogroup AppCoAP
  \{
  \addtogroup rHeli
  \{
diff -crB stock/openwsn/07-App/rinfo/Makefile dev/openwsn/07-App/rinfo/Makefile
*** stock/openwsn/07-App/rinfo/Makefile	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/rinfo/Makefile	Wed Jan 29 10:33:22 2014
***************
*** 0 ****
--- 1,32 ----
+ SUBSUBMOD:=$(shell basename $(CURDIR)).a
+ #BINDIR = $(RIOTBASE)/bin/
+ SRC = $(wildcard *.c)
+ OBJ = $(SRC:%.c=$(BINDIR)%.o)
+ DEP = $(SRC:%.c=$(BINDIR)%.d)
+ 
+ INCLUDES += -I$(RIOTBASE) -I$(RIOTBASE)/sys/include -I$(RIOTBASE)/core/include -I$(RIOTBASE)/drivers/include -I$(RIOTBASE)/drivers/cc110x_ng/include -I$(RIOTBASE)/cpu/arm_common/include -I$(RIOTBASE)/sys/net/include/
+ INCLUDES += -I$(CURDIR)/02a-MAClow
+ INCLUDES += -I$(CURDIR)/02b-MAChigh
+ INCLUDES += -I$(CURDIR)/03a-IPHC
+ INCLUDES += -I$(CURDIR)/03b-IPv6
+ INCLUDES += -I$(CURDIR)/04-TRAN
+ INCLUDES += -I$(CURDIR)/cross-layers
+ 
+ .PHONY: $(BINDIR)$(SUBSUBMOD)
+ 
+ $(BINDIR)$(SUBSUBMOD): $(OBJ)
+ 	$(AD)$(AR) rcs $(BINDIR)$(MODULE) $(OBJ)
+ 
+ # pull in dependency info for *existing* .o files
+ -include $(OBJ:.o=.d)
+ 
+ # compile and generate dependency info
+ $(BINDIR)%.o: %.c
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -c $*.c -o $(BINDIR)$*.o
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -MM $*.c > $(BINDIR)$*.d
+ 	@printf "$(BINDIR)" | cat - $(BINDIR)$*.d > /tmp/riot_out && mv /tmp/riot_out $(BINDIR)$*.d
+ 
+ # remove compilation products
+ 
+ clean:
+ 	rm -f $(OBJ) $(DEP)
diff -crB stock/openwsn/07-App/rinfo/rinfo.c dev/openwsn/07-App/rinfo/rinfo.c
*** stock/openwsn/07-App/rinfo/rinfo.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/rinfo/rinfo.c	Wed Jan 29 10:33:22 2014
***************
*** 6,11 ****
--- 6,12 ----
  #include "openserial.h"
  #include "openrandom.h"
  #include "board.h"
+ #include "idmanager.h"
  
  //=========================== defines =========================================
  
***************
*** 21,35 ****
  
  //=========================== prototypes ======================================
  
! error_t rinfo_receive(OpenQueueEntry_t* msg,
                        coap_header_iht*  coap_header,
                        coap_option_iht*  coap_options);
  void    rinfo_sendDone(OpenQueueEntry_t* msg,
!                        error_t error);
  
  //=========================== public ==========================================
  
! void rinfo_init() {
     // prepare the resource descriptor for the /temp path
     rinfo_vars.desc.path0len             = sizeof(rinfo_path0)-1;
     rinfo_vars.desc.path0val             = (uint8_t*)(&rinfo_path0);
--- 22,39 ----
  
  //=========================== prototypes ======================================
  
! owerror_t rinfo_receive(OpenQueueEntry_t* msg,
                        coap_header_iht*  coap_header,
                        coap_option_iht*  coap_options);
  void    rinfo_sendDone(OpenQueueEntry_t* msg,
!                        owerror_t error);
  
  //=========================== public ==========================================
  
! void rinfo_init(void) {
!   
!   
!    if(idmanager_getIsDAGroot()==TRUE) return; 
     // prepare the resource descriptor for the /temp path
     rinfo_vars.desc.path0len             = sizeof(rinfo_path0)-1;
     rinfo_vars.desc.path0val             = (uint8_t*)(&rinfo_path0);
***************
*** 44,53 ****
  
  //=========================== private =========================================
  
! error_t rinfo_receive(OpenQueueEntry_t* msg,
                        coap_header_iht* coap_header,
                        coap_option_iht* coap_options) {
!    error_t outcome;
     
     if (coap_header->Code==COAP_CODE_REQ_GET) {
        
--- 48,57 ----
  
  //=========================== private =========================================
  
! owerror_t rinfo_receive(OpenQueueEntry_t* msg,
                        coap_header_iht* coap_header,
                        coap_option_iht* coap_options) {
!    owerror_t outcome;
     
     if (coap_header->Code==COAP_CODE_REQ_GET) {
        
***************
*** 81,88 ****
        msg->payload[sizeof(infoStackName)-1+5-1] = '0'+OPENWSN_VERSION_PATCH;
           
        // set the CoAP header
!       coap_header->OC                  = 0;
!       coap_header->Code                = COAP_CODE_RESP_CONTENT;
        
        outcome                          = E_SUCCESS;
     
--- 85,91 ----
        msg->payload[sizeof(infoStackName)-1+5-1] = '0'+OPENWSN_VERSION_PATCH;
           
        // set the CoAP header
!        coap_header->Code                = COAP_CODE_RESP_CONTENT;
        
        outcome                          = E_SUCCESS;
     
***************
*** 94,99 ****
     return outcome;
  }
  
! void rinfo_sendDone(OpenQueueEntry_t* msg, error_t error) {
     openqueue_freePacketBuffer(msg);
  }
\ No newline at end of file
--- 97,102 ----
     return outcome;
  }
  
! void rinfo_sendDone(OpenQueueEntry_t* msg, owerror_t error) {
     openqueue_freePacketBuffer(msg);
  }
\ No newline at end of file
diff -crB stock/openwsn/07-App/rinfo/rinfo.h dev/openwsn/07-App/rinfo/rinfo.h
*** stock/openwsn/07-App/rinfo/rinfo.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/rinfo/rinfo.h	Wed Jan 29 10:33:22 2014
***************
*** 2,8 ****
  #define __RINFO_H
  
  /**
! \addtogroup App
  \{
  \addtogroup rXL1
  \{
--- 2,8 ----
  #define __RINFO_H
  
  /**
! \addtogroup AppCoAP
  \{
  \addtogroup rXL1
  \{
***************
*** 16,22 ****
  
  //=========================== prototypes ======================================
  
! void rinfo_init();
  
  /**
  \}
--- 16,22 ----
  
  //=========================== prototypes ======================================
  
! void rinfo_init(void);
  
  /**
  \}
diff -crB stock/openwsn/07-App/rleds/rleds.c dev/openwsn/07-App/rleds/rleds.c
*** stock/openwsn/07-App/rleds/rleds.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/rleds/rleds.c	Wed Jan 29 10:33:22 2014
***************
*** 17,31 ****
  
  //=========================== prototypes ======================================
  
! error_t rleds_receive(OpenQueueEntry_t* msg,
                        coap_header_iht*  coap_header,
                        coap_option_iht*  coap_options);
  void    rleds_sendDone(OpenQueueEntry_t* msg,
!                        error_t error);
  
  //=========================== public ==========================================
  
! void rleds_init() {
     // prepare the resource descriptor for the /.well-known/core path
     rleds_vars.desc.path0len            = sizeof(rleds_path0)-1;
     rleds_vars.desc.path0val            = (uint8_t*)(&rleds_path0);
--- 17,31 ----
  
  //=========================== prototypes ======================================
  
! owerror_t rleds_receive(OpenQueueEntry_t* msg,
                        coap_header_iht*  coap_header,
                        coap_option_iht*  coap_options);
  void    rleds_sendDone(OpenQueueEntry_t* msg,
!                        owerror_t error);
  
  //=========================== public ==========================================
  
! void rleds__init() {
     // prepare the resource descriptor for the /.well-known/core path
     rleds_vars.desc.path0len            = sizeof(rleds_path0)-1;
     rleds_vars.desc.path0val            = (uint8_t*)(&rleds_path0);
***************
*** 40,49 ****
  
  //=========================== private =========================================
  
! error_t rleds_receive(OpenQueueEntry_t* msg,
                        coap_header_iht*  coap_header,
                        coap_option_iht*  coap_options) {      
!    error_t outcome;
     
     if        (coap_header->Code==COAP_CODE_REQ_GET) {
        // reset packet payload
--- 40,49 ----
  
  //=========================== private =========================================
  
! owerror_t rleds_receive(OpenQueueEntry_t* msg,
                        coap_header_iht*  coap_header,
                        coap_option_iht*  coap_options) {      
!    owerror_t outcome;
     
     if        (coap_header->Code==COAP_CODE_REQ_GET) {
        // reset packet payload
***************
*** 59,65 ****
        }
           
        // set the CoAP header
-       coap_header->OC                  = 0;
        coap_header->Code                = COAP_CODE_RESP_CONTENT;
        
        outcome                          = E_SUCCESS;
--- 59,64 ----
***************
*** 79,85 ****
        msg->length                      = 0;
        
        // set the CoAP header
-       coap_header->OC                  = 0;
        coap_header->Code                = COAP_CODE_RESP_CHANGED;
        
        outcome                          = E_SUCCESS;
--- 78,83 ----
***************
*** 89,94 ****
     return outcome;
  }
  
! void rleds_sendDone(OpenQueueEntry_t* msg, error_t error) {
     openqueue_freePacketBuffer(msg);
  }
\ No newline at end of file
--- 87,92 ----
     return outcome;
  }
  
! void rleds_sendDone(OpenQueueEntry_t* msg, owerror_t error) {
     openqueue_freePacketBuffer(msg);
  }
\ No newline at end of file
diff -crB stock/openwsn/07-App/rleds/rleds.h dev/openwsn/07-App/rleds/rleds.h
*** stock/openwsn/07-App/rleds/rleds.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/rleds/rleds.h	Wed Jan 29 10:33:22 2014
***************
*** 2,8 ****
  #define __RLEDS_H
  
  /**
! \addtogroup App
  \{
  \addtogroup netLeds
  \{
--- 2,8 ----
  #define __RLEDS_H
  
  /**
! \addtogroup AppCoAP
  \{
  \addtogroup netLeds
  \{
***************
*** 16,22 ****
  
  //=========================== prototypes ======================================
  
! void rleds_init();
  
  /**
  \}
--- 16,22 ----
  
  //=========================== prototypes ======================================
  
! void rleds__init();
  
  /**
  \}
diff -crB stock/openwsn/07-App/rreg/rreg.c dev/openwsn/07-App/rreg/rreg.c
*** stock/openwsn/07-App/rreg/rreg.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/rreg/rreg.c	Wed Jan 29 10:33:22 2014
***************
*** 24,41 ****
  
  //=========================== prototypes ======================================
  
! error_t rreg_receive(OpenQueueEntry_t* msg,
                       coap_header_iht*  coap_header,
                       coap_option_iht*  coap_options);
  void    rreg_timer();
  void    rreg_sendDone(OpenQueueEntry_t* msg,
!                       error_t error);
  uint8_t hexToAscii(uint8_t hex);
  
  //=========================== public ==========================================
  
  void rreg_init() {
!    // prepare the resource descriptor for the /.well-known/core path
     rreg_vars.desc.path0len             = sizeof(rreg_path0)-1;
     rreg_vars.desc.path0val             = (uint8_t*)(&rreg_path0);
     rreg_vars.desc.path1len             = 0;
--- 24,44 ----
  
  //=========================== prototypes ======================================
  
! owerror_t rreg_receive(OpenQueueEntry_t* msg,
                       coap_header_iht*  coap_header,
                       coap_option_iht*  coap_options);
  void    rreg_timer();
  void    rreg_sendDone(OpenQueueEntry_t* msg,
!                       owerror_t error);
  uint8_t hexToAscii(uint8_t hex);
  
  //=========================== public ==========================================
  
  void rreg_init() {
!   //dagroot does not run upper layers.
!    if(idmanager_getIsDAGroot()==TRUE) return; 
!  
!   // prepare the resource descriptor for the /.well-known/core path
     rreg_vars.desc.path0len             = sizeof(rreg_path0)-1;
     rreg_vars.desc.path0val             = (uint8_t*)(&rreg_path0);
     rreg_vars.desc.path1len             = 0;
***************
*** 55,65 ****
  
  //=========================== private =========================================
  
! error_t rreg_receive(OpenQueueEntry_t* msg,
                     coap_header_iht* coap_header,
                     coap_option_iht* coap_options) {
                        
!    error_t outcome;
     
     if (coap_header->Code==COAP_CODE_REQ_POST) {
        // request to register received
--- 58,68 ----
  
  //=========================== private =========================================
  
! owerror_t rreg_receive(OpenQueueEntry_t* msg,
                     coap_header_iht* coap_header,
                     coap_option_iht* coap_options) {
                        
!    owerror_t outcome;
     
     if (coap_header->Code==COAP_CODE_REQ_POST) {
        // request to register received
***************
*** 74,81 ****
        msg->length                      = 0;
        
        // set the CoAP header
!       coap_header->OC                  = 0;
!       coap_header->Code                = COAP_CODE_RESP_VALID;
        
        outcome = E_SUCCESS;
     } else if (coap_header->T==COAP_TYPE_ACK) {
--- 77,83 ----
        msg->length                      = 0;
        
        // set the CoAP header
!        coap_header->Code                = COAP_CODE_RESP_VALID;
        
        outcome = E_SUCCESS;
     } else if (coap_header->T==COAP_TYPE_ACK) {
***************
*** 90,96 ****
  void rreg_timer() {
     OpenQueueEntry_t* pkt;
     uint8_t           temp8b;
!    error_t           outcome;
     uint8_t           numOptions;
     
  
--- 92,98 ----
  void rreg_timer() {
     OpenQueueEntry_t* pkt;
     uint8_t           temp8b;
!    owerror_t           outcome;
     uint8_t           numOptions;
     
  
***************
*** 100,106 ****
        openserial_printError(COMPONENT_RREG,ERR_NO_FREE_PACKET_BUFFER,
                              (errorparameter_t)0,
                              (errorparameter_t)0);
!       openqueue_freePacketBuffer(pkt);
        return;
     }
     // take ownership over that packet
--- 102,108 ----
        openserial_printError(COMPONENT_RREG,ERR_NO_FREE_PACKET_BUFFER,
                              (errorparameter_t)0,
                              (errorparameter_t)0);
!       //openqueue_freePacketBuffer(pkt);
        return;
     }
     // take ownership over that packet
***************
*** 116,122 ****
     pkt->payload[sizeof(rreg_uriquery)-1] = hexToAscii((temp8b>>4) & 0x0f);
     pkt->payload[sizeof(rreg_uriquery)-0] = hexToAscii((temp8b>>0) & 0x0f);
     packetfunctions_reserveHeaderSize(pkt,1);
!    pkt->payload[0] = (COAP_OPTION_URIQUERY-COAP_OPTION_URIPATH) << 4 |
        sizeof(rreg_uriquery)-1+2;
     numOptions++;
     // URI-path
--- 118,124 ----
     pkt->payload[sizeof(rreg_uriquery)-1] = hexToAscii((temp8b>>4) & 0x0f);
     pkt->payload[sizeof(rreg_uriquery)-0] = hexToAscii((temp8b>>0) & 0x0f);
     packetfunctions_reserveHeaderSize(pkt,1);
!    pkt->payload[0] = (COAP_OPTION_NUM_URIQUERY-COAP_OPTION_NUM_URIPATH) << 4 |
        sizeof(rreg_uriquery)-1+2;
     numOptions++;
     // URI-path
***************
*** 124,135 ****
     pkt->payload[0] = 'r';
     pkt->payload[1] = 'd';
     packetfunctions_reserveHeaderSize(pkt,1);
!    pkt->payload[0] = (COAP_OPTION_URIPATH-COAP_OPTION_CONTENTTYPE) << 4 |
        2;
     numOptions++;
     // add content-type option
     packetfunctions_reserveHeaderSize(pkt,2);
!    pkt->payload[0]                  = COAP_OPTION_CONTENTTYPE << 4 |
        1;
     pkt->payload[1]                  = COAP_MEDTYPE_APPLINKFORMAT;
     numOptions++;
--- 126,137 ----
     pkt->payload[0] = 'r';
     pkt->payload[1] = 'd';
     packetfunctions_reserveHeaderSize(pkt,1);
!    pkt->payload[0] = (COAP_OPTION_NUM_URIPATH) << 4 |
        2;
     numOptions++;
     // add content-type option
     packetfunctions_reserveHeaderSize(pkt,2);
!    pkt->payload[0]                  = COAP_OPTION_NUM_CONTENTFORMAT << 4 |
        1;
     pkt->payload[1]                  = COAP_MEDTYPE_APPLINKFORMAT;
     numOptions++;
***************
*** 151,157 ****
     return;
  }
  
! void rreg_sendDone(OpenQueueEntry_t* msg, error_t error) {
     openqueue_freePacketBuffer(msg);
  }
  
--- 153,159 ----
     return;
  }
  
! void rreg_sendDone(OpenQueueEntry_t* msg, owerror_t error) {
     openqueue_freePacketBuffer(msg);
  }
  
diff -crB stock/openwsn/07-App/rreg/rreg.h dev/openwsn/07-App/rreg/rreg.h
*** stock/openwsn/07-App/rreg/rreg.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/rreg/rreg.h	Wed Jan 29 10:33:22 2014
***************
*** 2,8 ****
  #define __RREG_H
  
  /**
! \addtogroup App
  \{
  \addtogroup rReg
  \{
--- 2,8 ----
  #define __RREG_H
  
  /**
! \addtogroup AppCoAP
  \{
  \addtogroup rReg
  \{
diff -crB stock/openwsn/07-App/rrube/rrube.c dev/openwsn/07-App/rrube/rrube.c
*** stock/openwsn/07-App/rrube/rrube.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/rrube/rrube.c	Wed Jan 29 10:33:22 2014
***************
*** 37,48 ****
  
  //=========================== prototypes ======================================
  
! error_t rrube_receive(OpenQueueEntry_t* msg,
                       coap_header_iht*  coap_header,
                       coap_option_iht*  coap_options);
  void    rrube_timer();
  void    rrube_sendDone(OpenQueueEntry_t* msg,
!                       error_t error);
  uint8_t hexToAscii(uint8_t hex);
  
  //=========================== public ==========================================
--- 37,48 ----
  
  //=========================== prototypes ======================================
  
! owerror_t rrube_receive(OpenQueueEntry_t* msg,
                       coap_header_iht*  coap_header,
                       coap_option_iht*  coap_options);
  void    rrube_timer();
  void    rrube_sendDone(OpenQueueEntry_t* msg,
!                       owerror_t error);
  uint8_t hexToAscii(uint8_t hex);
  
  //=========================== public ==========================================
***************
*** 70,80 ****
  
  //=========================== private =========================================
  
! error_t rrube_receive(OpenQueueEntry_t* msg,
                     coap_header_iht* coap_header,
                     coap_option_iht* coap_options) {
                        
!    error_t outcome;
     
     if (rrube_vars.rrube_state==RRUBE_ST_IDLE &&
         coap_header->Code==COAP_CODE_REQ_POST) {
--- 70,80 ----
  
  //=========================== private =========================================
  
! owerror_t rrube_receive(OpenQueueEntry_t* msg,
                     coap_header_iht* coap_header,
                     coap_option_iht* coap_options) {
                        
!    owerror_t outcome;
     
     if (rrube_vars.rrube_state==RRUBE_ST_IDLE &&
         coap_header->Code==COAP_CODE_REQ_POST) {
***************
*** 90,96 ****
        msg->length                      = 0;
        
        // set the CoAP header
-       coap_header->OC                  = 0;
        coap_header->Code                = COAP_CODE_RESP_VALID;
        
        // advance state machine
--- 90,95 ----
***************
*** 136,142 ****
  void rrube_timer() {
     OpenQueueEntry_t* pkt;
     uint8_t           numOptions;
!    error_t           outcome;
     
     // turn off heli
     heli_off();
--- 135,141 ----
  void rrube_timer() {
     OpenQueueEntry_t* pkt;
     uint8_t           numOptions;
!    owerror_t           outcome;
     
     // turn off heli
     heli_off();
***************
*** 161,167 ****
        packetfunctions_reserveHeaderSize(pkt,sizeof(rrube_path0)-1);
        memcpy(&pkt->payload[0],&rrube_path0,sizeof(rrube_path0)-1);
        packetfunctions_reserveHeaderSize(pkt,1);
!       pkt->payload[0] = (COAP_OPTION_URIPATH) << 4 |
                          sizeof(rrube_path0)-1;
        numOptions++;
        // metadata
--- 160,166 ----
        packetfunctions_reserveHeaderSize(pkt,sizeof(rrube_path0)-1);
        memcpy(&pkt->payload[0],&rrube_path0,sizeof(rrube_path0)-1);
        packetfunctions_reserveHeaderSize(pkt,1);
!       pkt->payload[0] = (COAP_OPTION_NUM_URIPATH) << 4 |
                          sizeof(rrube_path0)-1;
        numOptions++;
        // metadata
***************
*** 205,211 ****
        packetfunctions_reserveHeaderSize(pkt,sizeof(rrube_path0)-1);
        memcpy(&pkt->payload[0],&rrube_path0,sizeof(rrube_path0)-1);
        packetfunctions_reserveHeaderSize(pkt,1);
!       pkt->payload[0] = (COAP_OPTION_URIPATH) << 4 |
                          sizeof(rrube_path0)-1;
        numOptions++;
        // metadata
--- 204,210 ----
        packetfunctions_reserveHeaderSize(pkt,sizeof(rrube_path0)-1);
        memcpy(&pkt->payload[0],&rrube_path0,sizeof(rrube_path0)-1);
        packetfunctions_reserveHeaderSize(pkt,1);
!       pkt->payload[0] = (COAP_OPTION_NUM_URIPATH) << 4 |
                          sizeof(rrube_path0)-1;
        numOptions++;
        // metadata
***************
*** 238,243 ****
     return;
  }
  
! void rrube_sendDone(OpenQueueEntry_t* msg, error_t error) {
     openqueue_freePacketBuffer(msg);
  }
\ No newline at end of file
--- 237,242 ----
     return;
  }
  
! void rrube_sendDone(OpenQueueEntry_t* msg, owerror_t error) {
     openqueue_freePacketBuffer(msg);
  }
\ No newline at end of file
diff -crB stock/openwsn/07-App/rrube/rrube.h dev/openwsn/07-App/rrube/rrube.h
*** stock/openwsn/07-App/rrube/rrube.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/rrube/rrube.h	Wed Jan 29 10:33:22 2014
***************
*** 2,8 ****
  #define __RRUBE_H
  
  /**
! \addtogroup App
  \{
  \addtogroup rRube
  \{
--- 2,8 ----
  #define __RRUBE_H
  
  /**
! \addtogroup AppCoAP
  \{
  \addtogroup rRube
  \{
diff -crB stock/openwsn/07-App/rt/rt.c dev/openwsn/07-App/rt/rt.c
*** stock/openwsn/07-App/rt/rt.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/rt/rt.c	Wed Jan 29 10:33:22 2014
***************
*** 27,38 ****
  
  //=========================== prototypes ======================================
  
! error_t rt_receive(OpenQueueEntry_t* msg,
                        coap_header_iht*  coap_header,
                        coap_option_iht*  coap_options);
  void    rt_timer();
  void    rt_sendDone(OpenQueueEntry_t* msg,
!                        error_t error);
  
  //=========================== public ==========================================
  
--- 27,38 ----
  
  //=========================== prototypes ======================================
  
! owerror_t rt_receive(OpenQueueEntry_t* msg,
                        coap_header_iht*  coap_header,
                        coap_option_iht*  coap_options);
  void    rt_timer();
  void    rt_sendDone(OpenQueueEntry_t* msg,
!                        owerror_t error);
  
  //=========================== public ==========================================
  
***************
*** 58,67 ****
  
  //=========================== private =========================================
  
! error_t rt_receive(OpenQueueEntry_t* msg,
                        coap_header_iht* coap_header,
                        coap_option_iht* coap_options) {
!    error_t outcome;
     uint8_t rawdata[SENSITIVE_ACCEL_TEMPERATURE_DATALEN];
     
     if (coap_header->Code==COAP_CODE_REQ_POST) {
--- 58,67 ----
  
  //=========================== private =========================================
  
! owerror_t rt_receive(OpenQueueEntry_t* msg,
                        coap_header_iht* coap_header,
                        coap_option_iht* coap_options) {
!    owerror_t outcome;
     uint8_t rawdata[SENSITIVE_ACCEL_TEMPERATURE_DATALEN];
     
     if (coap_header->Code==COAP_CODE_REQ_POST) {
***************
*** 78,84 ****
        msg->length                      = 0;
        
        // CoAP header
-       coap_header->OC                  = 0;
        coap_header->Code                = COAP_CODE_RESP_VALID;
        
        outcome = E_SUCCESS;
--- 78,83 ----
***************
*** 97,104 ****
        msg->payload[1] = rawdata[9];
           
        // set the CoAP header
!       coap_header->OC                  = 0;
!       coap_header->Code                = COAP_CODE_RESP_CONTENT;
        
        outcome                          = E_SUCCESS;
     
--- 96,102 ----
        msg->payload[1] = rawdata[9];
           
        // set the CoAP header
!        coap_header->Code                = COAP_CODE_RESP_CONTENT;
        
        outcome                          = E_SUCCESS;
     
***************
*** 112,118 ****
  
  void rt_timer() {
     OpenQueueEntry_t* pkt;
!    error_t           outcome;
     uint8_t           numOptions;
     uint8_t           rawdata[SENSITIVE_ACCEL_TEMPERATURE_DATALEN];
     
--- 110,116 ----
  
  void rt_timer() {
     OpenQueueEntry_t* pkt;
!    owerror_t           outcome;
     uint8_t           numOptions;
     uint8_t           rawdata[SENSITIVE_ACCEL_TEMPERATURE_DATALEN];
     
***************
*** 139,150 ****
     packetfunctions_reserveHeaderSize(pkt,sizeof(rt_path0)-1);
     memcpy(&pkt->payload[0],&rt_path0,sizeof(rt_path0)-1);
     packetfunctions_reserveHeaderSize(pkt,1);
!    pkt->payload[0]                  = (COAP_OPTION_LOCATIONPATH-COAP_OPTION_CONTENTTYPE) << 4 |
        sizeof(rt_path0)-1;
     numOptions++;
     // content-type option
     packetfunctions_reserveHeaderSize(pkt,2);
!    pkt->payload[0]                  = COAP_OPTION_CONTENTTYPE << 4 |
        1;
     pkt->payload[1]                  = COAP_MEDTYPE_APPOCTETSTREAM;
     numOptions++;
--- 137,148 ----
     packetfunctions_reserveHeaderSize(pkt,sizeof(rt_path0)-1);
     memcpy(&pkt->payload[0],&rt_path0,sizeof(rt_path0)-1);
     packetfunctions_reserveHeaderSize(pkt,1);
!    pkt->payload[0]                  = (COAP_OPTION_NUM_URIPATH) << 4 |
        sizeof(rt_path0)-1;
     numOptions++;
     // content-type option
     packetfunctions_reserveHeaderSize(pkt,2);
!    pkt->payload[0]                  = COAP_OPTION_NUM_CONTENTFORMAT << 4 |
        1;
     pkt->payload[1]                  = COAP_MEDTYPE_APPOCTETSTREAM;
     numOptions++;
***************
*** 166,171 ****
     return;
  }
  
! void rt_sendDone(OpenQueueEntry_t* msg, error_t error) {
     openqueue_freePacketBuffer(msg);
  }
\ No newline at end of file
--- 164,169 ----
     return;
  }
  
! void rt_sendDone(OpenQueueEntry_t* msg, owerror_t error) {
     openqueue_freePacketBuffer(msg);
  }
\ No newline at end of file
diff -crB stock/openwsn/07-App/rt/rt.h dev/openwsn/07-App/rt/rt.h
*** stock/openwsn/07-App/rt/rt.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/rt/rt.h	Wed Jan 29 10:33:22 2014
***************
*** 2,8 ****
  #define __RT_H
  
  /**
! \addtogroup App
  \{
  \addtogroup rT
  \{
--- 2,8 ----
  #define __RT_H
  
  /**
! \addtogroup AppCoAP
  \{
  \addtogroup rT
  \{
diff -crB stock/openwsn/07-App/rwellknown/Makefile dev/openwsn/07-App/rwellknown/Makefile
*** stock/openwsn/07-App/rwellknown/Makefile	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/rwellknown/Makefile	Wed Jan 29 10:33:22 2014
***************
*** 0 ****
--- 1,32 ----
+ SUBSUBMOD:=$(shell basename $(CURDIR)).a
+ #BINDIR = $(RIOTBASE)/bin/
+ SRC = $(wildcard *.c)
+ OBJ = $(SRC:%.c=$(BINDIR)%.o)
+ DEP = $(SRC:%.c=$(BINDIR)%.d)
+ 
+ INCLUDES += -I$(RIOTBASE) -I$(RIOTBASE)/sys/include -I$(RIOTBASE)/core/include -I$(RIOTBASE)/drivers/include -I$(RIOTBASE)/drivers/cc110x_ng/include -I$(RIOTBASE)/cpu/arm_common/include -I$(RIOTBASE)/sys/net/include/
+ INCLUDES += -I$(CURDIR)/02a-MAClow
+ INCLUDES += -I$(CURDIR)/02b-MAChigh
+ INCLUDES += -I$(CURDIR)/03a-IPHC
+ INCLUDES += -I$(CURDIR)/03b-IPv6
+ INCLUDES += -I$(CURDIR)/04-TRAN
+ INCLUDES += -I$(CURDIR)/cross-layers
+ 
+ .PHONY: $(BINDIR)$(SUBSUBMOD)
+ 
+ $(BINDIR)$(SUBSUBMOD): $(OBJ)
+ 	$(AD)$(AR) rcs $(BINDIR)$(MODULE) $(OBJ)
+ 
+ # pull in dependency info for *existing* .o files
+ -include $(OBJ:.o=.d)
+ 
+ # compile and generate dependency info
+ $(BINDIR)%.o: %.c
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -c $*.c -o $(BINDIR)$*.o
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -MM $*.c > $(BINDIR)$*.d
+ 	@printf "$(BINDIR)" | cat - $(BINDIR)$*.d > /tmp/riot_out && mv /tmp/riot_out $(BINDIR)$*.d
+ 
+ # remove compilation products
+ 
+ clean:
+ 	rm -f $(OBJ) $(DEP)
diff -crB stock/openwsn/07-App/rwellknown/rwellknown.c dev/openwsn/07-App/rwellknown/rwellknown.c
*** stock/openwsn/07-App/rwellknown/rwellknown.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/rwellknown/rwellknown.c	Wed Jan 29 10:33:22 2014
***************
*** 4,10 ****
  #include "openqueue.h"
  #include "packetfunctions.h"
  #include "openserial.h"
! 
  //=========================== variables =======================================
  
  typedef struct {
--- 4,10 ----
  #include "openqueue.h"
  #include "packetfunctions.h"
  #include "openserial.h"
! #include "idmanager.h"
  //=========================== variables =======================================
  
  typedef struct {
***************
*** 19,33 ****
  
  //=========================== prototypes ======================================
  
! error_t rwellknown_receive(OpenQueueEntry_t* msg,
                             coap_header_iht*  coap_header,
                             coap_option_iht*  coap_options);
  void    rwellknown_sendDone(OpenQueueEntry_t* msg,
!                             error_t error);
  
  //=========================== public ==========================================
  
! void rwellknown_init() {
     // prepare the resource descriptor for the /.well-known/core path
     rwellknown_vars.desc.path0len            = sizeof(rwellknown_path0)-1;
     rwellknown_vars.desc.path0val            = (uint8_t*)(&rwellknown_path0);
--- 19,37 ----
  
  //=========================== prototypes ======================================
  
! owerror_t rwellknown_receive(OpenQueueEntry_t* msg,
                             coap_header_iht*  coap_header,
                             coap_option_iht*  coap_options);
  void    rwellknown_sendDone(OpenQueueEntry_t* msg,
!                             owerror_t error);
  
  //=========================== public ==========================================
  
! void rwellknown_init(void) {
!   
!   
!    if(idmanager_getIsDAGroot()==TRUE) return; 
!    
     // prepare the resource descriptor for the /.well-known/core path
     rwellknown_vars.desc.path0len            = sizeof(rwellknown_path0)-1;
     rwellknown_vars.desc.path0val            = (uint8_t*)(&rwellknown_path0);
***************
*** 42,51 ****
  
  //=========================== private =========================================
  
! error_t rwellknown_receive(OpenQueueEntry_t* msg,
                             coap_header_iht*  coap_header,
                             coap_option_iht*  coap_options) {
!    error_t outcome;
     
     if (coap_header->Code==COAP_CODE_REQ_GET) {
        // reset packet payload
--- 46,55 ----
  
  //=========================== private =========================================
  
! owerror_t rwellknown_receive(OpenQueueEntry_t* msg,
                             coap_header_iht*  coap_header,
                             coap_option_iht*  coap_options) {
!    owerror_t outcome;
     
     if (coap_header->Code==COAP_CODE_REQ_GET) {
        // reset packet payload
***************
*** 57,69 ****
           
        // add return option
        packetfunctions_reserveHeaderSize(msg,2);
!       msg->payload[0]                  = COAP_OPTION_CONTENTTYPE << 4 |
                                           1;
        msg->payload[1]                  = COAP_MEDTYPE_APPLINKFORMAT;
        
        // set the CoAP header
!       coap_header->OC                  = 1;
!       coap_header->Code                = COAP_CODE_RESP_CONTENT;
        
        outcome                          = E_SUCCESS;
     } else {
--- 61,72 ----
           
        // add return option
        packetfunctions_reserveHeaderSize(msg,2);
!       msg->payload[0]                  = COAP_OPTION_NUM_CONTENTFORMAT << 4 |
                                           1;
        msg->payload[1]                  = COAP_MEDTYPE_APPLINKFORMAT;
        
        // set the CoAP header
!        coap_header->Code                = COAP_CODE_RESP_CONTENT;
        
        outcome                          = E_SUCCESS;
     } else {
***************
*** 72,77 ****
     return outcome;
  }
  
! void rwellknown_sendDone(OpenQueueEntry_t* msg, error_t error) {
     openqueue_freePacketBuffer(msg);
  }
\ No newline at end of file
--- 75,80 ----
     return outcome;
  }
  
! void rwellknown_sendDone(OpenQueueEntry_t* msg, owerror_t error) {
     openqueue_freePacketBuffer(msg);
  }
\ No newline at end of file
diff -crB stock/openwsn/07-App/rwellknown/rwellknown.h dev/openwsn/07-App/rwellknown/rwellknown.h
*** stock/openwsn/07-App/rwellknown/rwellknown.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/rwellknown/rwellknown.h	Wed Jan 29 10:33:22 2014
***************
*** 2,8 ****
  #define __RWELLKNOWN_H
  
  /**
! \addtogroup App
  \{
  \addtogroup rWellKnown
  \{
--- 2,8 ----
  #define __RWELLKNOWN_H
  
  /**
! \addtogroup AppCoAP
  \{
  \addtogroup rWellKnown
  \{
***************
*** 16,22 ****
  
  //=========================== prototypes ======================================
  
! void rwellknown_init();
  
  /**
  \}
--- 16,22 ----
  
  //=========================== prototypes ======================================
  
! void rwellknown_init(void);
  
  /**
  \}
diff -crB stock/openwsn/07-App/rxl1/rxl1.c dev/openwsn/07-App/rxl1/rxl1.c
*** stock/openwsn/07-App/rxl1/rxl1.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/rxl1/rxl1.c	Wed Jan 29 10:33:22 2014
***************
*** 27,38 ****
  
  //=========================== prototypes ======================================
  
! error_t rxl1_receive(OpenQueueEntry_t* msg,
                        coap_header_iht*  coap_header,
                        coap_option_iht*  coap_options);
  void    rxl1_timer();
  void    rxl1_sendDone(OpenQueueEntry_t* msg,
!                        error_t error);
  
  //=========================== public ==========================================
  
--- 27,38 ----
  
  //=========================== prototypes ======================================
  
! owerror_t rxl1_receive(OpenQueueEntry_t* msg,
                        coap_header_iht*  coap_header,
                        coap_option_iht*  coap_options);
  void    rxl1_timer();
  void    rxl1_sendDone(OpenQueueEntry_t* msg,
!                        owerror_t error);
  
  //=========================== public ==========================================
  
***************
*** 60,69 ****
  
  //=========================== private =========================================
  
! error_t rxl1_receive(OpenQueueEntry_t* msg,
                        coap_header_iht* coap_header,
                        coap_option_iht* coap_options) {
!    error_t outcome;
     uint8_t rawdata[SENSITIVE_ACCEL_TEMPERATURE_DATALEN];
     
     if (coap_header->Code==COAP_CODE_REQ_POST) {
--- 60,69 ----
  
  //=========================== private =========================================
  
! owerror_t rxl1_receive(OpenQueueEntry_t* msg,
                        coap_header_iht* coap_header,
                        coap_option_iht* coap_options) {
!    owerror_t outcome;
     uint8_t rawdata[SENSITIVE_ACCEL_TEMPERATURE_DATALEN];
     
     if (coap_header->Code==COAP_CODE_REQ_POST) {
***************
*** 83,89 ****
        msg->length                      = 0;
        
        // CoAP header
-       coap_header->OC                  = 0;
        coap_header->Code                = COAP_CODE_RESP_VALID;
        
        outcome = E_SUCCESS;
--- 83,88 ----
***************
*** 101,107 ****
        memcpy(&msg->payload[0],&rawdata[8],8);
           
        // set the CoAP header
-       coap_header->OC                  = 0;
        coap_header->Code                = COAP_CODE_RESP_CONTENT;
        
        outcome                          = E_SUCCESS;
--- 100,105 ----
***************
*** 116,122 ****
  
  void rxl1_timer() {
     OpenQueueEntry_t* pkt;
!    error_t           outcome;
     uint8_t           numOptions;
     uint8_t           rawdata[SENSITIVE_ACCEL_TEMPERATURE_DATALEN];
     
--- 114,120 ----
  
  void rxl1_timer() {
     OpenQueueEntry_t* pkt;
!    owerror_t           outcome;
     uint8_t           numOptions;
     uint8_t           rawdata[SENSITIVE_ACCEL_TEMPERATURE_DATALEN];
     
***************
*** 143,154 ****
     packetfunctions_reserveHeaderSize(pkt,sizeof(rxl1_path0)-1);
     memcpy(&pkt->payload[0],&rxl1_path0,sizeof(rxl1_path0)-1);
     packetfunctions_reserveHeaderSize(pkt,1);
!    pkt->payload[0]                  = (COAP_OPTION_LOCATIONPATH-COAP_OPTION_CONTENTTYPE) << 4 |
        sizeof(rxl1_path0)-1;
     numOptions++;
     // content-type option
     packetfunctions_reserveHeaderSize(pkt,2);
!    pkt->payload[0]                  = COAP_OPTION_CONTENTTYPE << 4 |
        1;
     pkt->payload[1]                  = COAP_MEDTYPE_APPOCTETSTREAM;
     numOptions++;
--- 141,152 ----
     packetfunctions_reserveHeaderSize(pkt,sizeof(rxl1_path0)-1);
     memcpy(&pkt->payload[0],&rxl1_path0,sizeof(rxl1_path0)-1);
     packetfunctions_reserveHeaderSize(pkt,1);
!    pkt->payload[0]                  = (COAP_OPTION_NUM_URIPATH) << 4 |
        sizeof(rxl1_path0)-1;
     numOptions++;
     // content-type option
     packetfunctions_reserveHeaderSize(pkt,2);
!    pkt->payload[0]                  = COAP_OPTION_NUM_CONTENTFORMAT << 4 |
        1;
     pkt->payload[1]                  = COAP_MEDTYPE_APPOCTETSTREAM;
     numOptions++;
***************
*** 171,176 ****
     return;
  }
  
! void rxl1_sendDone(OpenQueueEntry_t* msg, error_t error) {
     openqueue_freePacketBuffer(msg);
  }
--- 169,174 ----
     return;
  }
  
! void rxl1_sendDone(OpenQueueEntry_t* msg, owerror_t error) {
     openqueue_freePacketBuffer(msg);
  }
diff -crB stock/openwsn/07-App/rxl1/rxl1.h dev/openwsn/07-App/rxl1/rxl1.h
*** stock/openwsn/07-App/rxl1/rxl1.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/rxl1/rxl1.h	Wed Jan 29 10:33:22 2014
***************
*** 2,8 ****
  #define __RXL1_H
  
  /**
! \addtogroup App
  \{
  \addtogroup rXL1
  \{
--- 2,8 ----
  #define __RXL1_H
  
  /**
! \addtogroup AppCoAP
  \{
  \addtogroup rXL1
  \{
diff -crB stock/openwsn/07-App/tcpecho/Makefile dev/openwsn/07-App/tcpecho/Makefile
*** stock/openwsn/07-App/tcpecho/Makefile	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/tcpecho/Makefile	Wed Jan 29 10:33:22 2014
***************
*** 0 ****
--- 1,32 ----
+ SUBSUBMOD:=$(shell basename $(CURDIR)).a
+ #BINDIR = $(RIOTBASE)/bin/
+ SRC = $(wildcard *.c)
+ OBJ = $(SRC:%.c=$(BINDIR)%.o)
+ DEP = $(SRC:%.c=$(BINDIR)%.d)
+ 
+ INCLUDES += -I$(RIOTBASE) -I$(RIOTBASE)/sys/include -I$(RIOTBASE)/core/include -I$(RIOTBASE)/drivers/include -I$(RIOTBASE)/drivers/cc110x_ng/include -I$(RIOTBASE)/cpu/arm_common/include -I$(RIOTBASE)/sys/net/include/
+ INCLUDES += -I$(CURDIR)/02a-MAClow
+ INCLUDES += -I$(CURDIR)/02b-MAChigh
+ INCLUDES += -I$(CURDIR)/03a-IPHC
+ INCLUDES += -I$(CURDIR)/03b-IPv6
+ INCLUDES += -I$(CURDIR)/04-TRAN
+ INCLUDES += -I$(CURDIR)/cross-layers
+ 
+ .PHONY: $(BINDIR)$(SUBSUBMOD)
+ 
+ $(BINDIR)$(SUBSUBMOD): $(OBJ)
+ 	$(AD)$(AR) rcs $(BINDIR)$(MODULE) $(OBJ)
+ 
+ # pull in dependency info for *existing* .o files
+ -include $(OBJ:.o=.d)
+ 
+ # compile and generate dependency info
+ $(BINDIR)%.o: %.c
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -c $*.c -o $(BINDIR)$*.o
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -MM $*.c > $(BINDIR)$*.d
+ 	@printf "$(BINDIR)" | cat - $(BINDIR)$*.d > /tmp/riot_out && mv /tmp/riot_out $(BINDIR)$*.d
+ 
+ # remove compilation products
+ 
+ clean:
+ 	rm -f $(OBJ) $(DEP)
diff -crB stock/openwsn/07-App/tcpecho/tcpecho.c dev/openwsn/07-App/tcpecho/tcpecho.c
*** stock/openwsn/07-App/tcpecho/tcpecho.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/tcpecho/tcpecho.c	Wed Jan 29 10:33:22 2014
***************
*** 10,19 ****
  
  //=========================== public ==========================================
  
! void tcpecho_init() {
  }
  
! bool tcpecho_shouldIlisten() {
     return TRUE;
  }
  
--- 10,19 ----
  
  //=========================== public ==========================================
  
! void tcpecho_init(void) {
  }
  
! bool tcpecho_shouldIlisten(void) {
     return TRUE;
  }
  
***************
*** 31,37 ****
     }
  }
  
! void tcpecho_sendDone(OpenQueueEntry_t* msg, error_t error) {
     msg->owner = COMPONENT_TCPECHO;
     if (msg->creator!=COMPONENT_TCPECHO) {
        openserial_printError(COMPONENT_TCPECHO,ERR_UNEXPECTED_SENDDONE,
--- 31,37 ----
     }
  }
  
! void tcpecho_sendDone(OpenQueueEntry_t* msg, owerror_t error) {
     msg->owner = COMPONENT_TCPECHO;
     if (msg->creator!=COMPONENT_TCPECHO) {
        openserial_printError(COMPONENT_TCPECHO,ERR_UNEXPECTED_SENDDONE,
***************
*** 43,52 ****
     openqueue_freePacketBuffer(msg);
  }
  
! void tcpecho_connectDone() {
  }
  
! bool tcpecho_debugPrint() {
     return FALSE;
  }
  
--- 43,52 ----
     openqueue_freePacketBuffer(msg);
  }
  
! void tcpecho_connectDone(owerror_t error) {
  }
  
! bool tcpecho_debugPrint(void) {
     return FALSE;
  }
  
diff -crB stock/openwsn/07-App/tcpecho/tcpecho.h dev/openwsn/07-App/tcpecho/tcpecho.h
*** stock/openwsn/07-App/tcpecho/tcpecho.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/tcpecho/tcpecho.h	Wed Jan 29 10:33:22 2014
***************
*** 2,8 ****
  #define __TCPECHO_H
  
  /**
! \addtogroup App
  \{
  \addtogroup tcpEcho
  \{
--- 2,8 ----
  #define __TCPECHO_H
  
  /**
! \addtogroup AppTcp
  \{
  \addtogroup tcpEcho
  \{
***************
*** 16,27 ****
  
  //=========================== prototypes ======================================
  
! void tcpecho_init();
! bool tcpecho_shouldIlisten();
  void tcpecho_receive(OpenQueueEntry_t* msg);
! void tcpecho_sendDone(OpenQueueEntry_t* msg, error_t error);
! void tcpecho_connectDone();
! bool tcpecho_debugPrint();
  
  /**
  \}
--- 16,27 ----
  
  //=========================== prototypes ======================================
  
! void tcpecho_init(void);
! bool tcpecho_shouldIlisten(void);
  void tcpecho_receive(OpenQueueEntry_t* msg);
! void tcpecho_sendDone(OpenQueueEntry_t* msg, owerror_t error);
! void tcpecho_connectDone(owerror_t error);
! bool tcpecho_debugPrint(void);
  
  /**
  \}
diff -crB stock/openwsn/07-App/tcpinject/Makefile dev/openwsn/07-App/tcpinject/Makefile
*** stock/openwsn/07-App/tcpinject/Makefile	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/tcpinject/Makefile	Wed Jan 29 10:33:22 2014
***************
*** 0 ****
--- 1,32 ----
+ SUBSUBMOD:=$(shell basename $(CURDIR)).a
+ #BINDIR = $(RIOTBASE)/bin/
+ SRC = $(wildcard *.c)
+ OBJ = $(SRC:%.c=$(BINDIR)%.o)
+ DEP = $(SRC:%.c=$(BINDIR)%.d)
+ 
+ INCLUDES += -I$(RIOTBASE) -I$(RIOTBASE)/sys/include -I$(RIOTBASE)/core/include -I$(RIOTBASE)/drivers/include -I$(RIOTBASE)/drivers/cc110x_ng/include -I$(RIOTBASE)/cpu/arm_common/include -I$(RIOTBASE)/sys/net/include/
+ INCLUDES += -I$(CURDIR)/02a-MAClow
+ INCLUDES += -I$(CURDIR)/02b-MAChigh
+ INCLUDES += -I$(CURDIR)/03a-IPHC
+ INCLUDES += -I$(CURDIR)/03b-IPv6
+ INCLUDES += -I$(CURDIR)/04-TRAN
+ INCLUDES += -I$(CURDIR)/cross-layers
+ 
+ .PHONY: $(BINDIR)$(SUBSUBMOD)
+ 
+ $(BINDIR)$(SUBSUBMOD): $(OBJ)
+ 	$(AD)$(AR) rcs $(BINDIR)$(MODULE) $(OBJ)
+ 
+ # pull in dependency info for *existing* .o files
+ -include $(OBJ:.o=.d)
+ 
+ # compile and generate dependency info
+ $(BINDIR)%.o: %.c
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -c $*.c -o $(BINDIR)$*.o
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -MM $*.c > $(BINDIR)$*.d
+ 	@printf "$(BINDIR)" | cat - $(BINDIR)$*.d > /tmp/riot_out && mv /tmp/riot_out $(BINDIR)$*.d
+ 
+ # remove compilation products
+ 
+ clean:
+ 	rm -f $(OBJ) $(DEP)
diff -crB stock/openwsn/07-App/tcpinject/tcpinject.c dev/openwsn/07-App/tcpinject/tcpinject.c
*** stock/openwsn/07-App/tcpinject/tcpinject.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/tcpinject/tcpinject.c	Wed Jan 29 10:33:22 2014
***************
*** 7,33 ****
  
  //=========================== variables =======================================
  
- typedef struct {
-    OpenQueueEntry_t*    pkt;
-    bool                 sending;
-    open_addr_t          hisAddress;
-    uint16_t             hisPort;
- } tcpinject_vars_t;
- 
  tcpinject_vars_t tcpinject_vars;
  
  //=========================== prototypes ======================================
  
  //=========================== public ==========================================
  
! void tcpinject_init() {
  }
  
! bool tcpinject_shouldIlisten() {
     return FALSE;
  }
  
! void tcpinject_trigger() {
     uint8_t number_bytes_from_input_buffer;
     uint8_t input_buffer[18];
     //get command from OpenSerial (16B IPv6 destination address, 2B destination port)
--- 7,26 ----
  
  //=========================== variables =======================================
  
  tcpinject_vars_t tcpinject_vars;
  
  //=========================== prototypes ======================================
  
  //=========================== public ==========================================
  
! void tcpinject_init(void) {
  }
  
! bool tcpinject_shouldIlisten(void) {
     return FALSE;
  }
  
! void tcpinject_trigger(void) {
     uint8_t number_bytes_from_input_buffer;
     uint8_t input_buffer[18];
     //get command from OpenSerial (16B IPv6 destination address, 2B destination port)
***************
*** 45,51 ****
     opentcp_connect(&tcpinject_vars.hisAddress,tcpinject_vars.hisPort,WKP_TCP_INJECT);
  }
  
! void tcpinject_connectDone(error_t error) {
     if (error==E_SUCCESS) {
        tcpinject_vars.pkt = openqueue_getFreePacketBuffer(COMPONENT_TCPINJECT);
        if (tcpinject_vars.pkt==NULL) {
--- 38,44 ----
     opentcp_connect(&tcpinject_vars.hisAddress,tcpinject_vars.hisPort,WKP_TCP_INJECT);
  }
  
! void tcpinject_connectDone(owerror_t error) {
     if (error==E_SUCCESS) {
        tcpinject_vars.pkt = openqueue_getFreePacketBuffer(COMPONENT_TCPINJECT);
        if (tcpinject_vars.pkt==NULL) {
***************
*** 74,80 ****
     }
  }
  
! void tcpinject_sendDone(OpenQueueEntry_t* msg, error_t error) {
     msg->owner = COMPONENT_TCPINJECT;
     if (msg->creator!=COMPONENT_TCPINJECT) {
        openserial_printError(COMPONENT_TCPINJECT,ERR_UNEXPECTED_SENDDONE,
--- 67,73 ----
     }
  }
  
! void tcpinject_sendDone(OpenQueueEntry_t* msg, owerror_t error) {
     msg->owner = COMPONENT_TCPINJECT;
     if (msg->creator!=COMPONENT_TCPINJECT) {
        openserial_printError(COMPONENT_TCPINJECT,ERR_UNEXPECTED_SENDDONE,
***************
*** 88,94 ****
  void tcpinject_receive(OpenQueueEntry_t* msg) {
  }
  
! bool tcpinject_debugPrint() {
     return FALSE;
  }
  
--- 81,87 ----
  void tcpinject_receive(OpenQueueEntry_t* msg) {
  }
  
! bool tcpinject_debugPrint(void) {
     return FALSE;
  }
  
diff -crB stock/openwsn/07-App/tcpinject/tcpinject.h dev/openwsn/07-App/tcpinject/tcpinject.h
*** stock/openwsn/07-App/tcpinject/tcpinject.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/tcpinject/tcpinject.h	Wed Jan 29 10:33:22 2014
***************
*** 2,8 ****
  #define __TCPINJECT_H
  
  /**
! \addtogroup App
  \{
  \addtogroup tcpInject
  \{
--- 2,8 ----
  #define __TCPINJECT_H
  
  /**
! \addtogroup AppTcp
  \{
  \addtogroup tcpInject
  \{
***************
*** 12,28 ****
  
  //=========================== typedef =========================================
  
! //=========================== variables =======================================
  
  //=========================== prototypes ======================================
  
! void tcpinject_init();
! bool tcpinject_shouldIlisten();
! void tcpinject_trigger();
! void tcpinject_connectDone(error_t error);
! void tcpinject_sendDone(OpenQueueEntry_t* msg, error_t error);
  void tcpinject_receive(OpenQueueEntry_t* msg);
! bool tcpinject_debugPrint();
  
  /**
  \}
--- 12,35 ----
  
  //=========================== typedef =========================================
  
! //=========================== module variables ================================
! 
! typedef struct {
!    OpenQueueEntry_t*    pkt;
!    bool                 sending;
!    open_addr_t          hisAddress;
!    uint16_t             hisPort;
! } tcpinject_vars_t;
  
  //=========================== prototypes ======================================
  
! void tcpinject_init(void);
! bool tcpinject_shouldIlisten(void);
! void tcpinject_trigger(void);
! void tcpinject_connectDone(owerror_t error);
! void tcpinject_sendDone(OpenQueueEntry_t* msg, owerror_t error);
  void tcpinject_receive(OpenQueueEntry_t* msg);
! bool tcpinject_debugPrint(void);
  
  /**
  \}
diff -crB stock/openwsn/07-App/tcpprint/Makefile dev/openwsn/07-App/tcpprint/Makefile
*** stock/openwsn/07-App/tcpprint/Makefile	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/tcpprint/Makefile	Wed Jan 29 10:33:22 2014
***************
*** 0 ****
--- 1,32 ----
+ SUBSUBMOD:=$(shell basename $(CURDIR)).a
+ #BINDIR = $(RIOTBASE)/bin/
+ SRC = $(wildcard *.c)
+ OBJ = $(SRC:%.c=$(BINDIR)%.o)
+ DEP = $(SRC:%.c=$(BINDIR)%.d)
+ 
+ INCLUDES += -I$(RIOTBASE) -I$(RIOTBASE)/sys/include -I$(RIOTBASE)/core/include -I$(RIOTBASE)/drivers/include -I$(RIOTBASE)/drivers/cc110x_ng/include -I$(RIOTBASE)/cpu/arm_common/include -I$(RIOTBASE)/sys/net/include/
+ INCLUDES += -I$(CURDIR)/02a-MAClow
+ INCLUDES += -I$(CURDIR)/02b-MAChigh
+ INCLUDES += -I$(CURDIR)/03a-IPHC
+ INCLUDES += -I$(CURDIR)/03b-IPv6
+ INCLUDES += -I$(CURDIR)/04-TRAN
+ INCLUDES += -I$(CURDIR)/cross-layers
+ 
+ .PHONY: $(BINDIR)$(SUBSUBMOD)
+ 
+ $(BINDIR)$(SUBSUBMOD): $(OBJ)
+ 	$(AD)$(AR) rcs $(BINDIR)$(MODULE) $(OBJ)
+ 
+ # pull in dependency info for *existing* .o files
+ -include $(OBJ:.o=.d)
+ 
+ # compile and generate dependency info
+ $(BINDIR)%.o: %.c
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -c $*.c -o $(BINDIR)$*.o
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -MM $*.c > $(BINDIR)$*.d
+ 	@printf "$(BINDIR)" | cat - $(BINDIR)$*.d > /tmp/riot_out && mv /tmp/riot_out $(BINDIR)$*.d
+ 
+ # remove compilation products
+ 
+ clean:
+ 	rm -f $(OBJ) $(DEP)
diff -crB stock/openwsn/07-App/tcpprint/tcpprint.c dev/openwsn/07-App/tcpprint/tcpprint.c
*** stock/openwsn/07-App/tcpprint/tcpprint.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/tcpprint/tcpprint.c	Wed Jan 29 10:33:22 2014
***************
*** 10,19 ****
  
  //=========================== public ==========================================
  
! void tcpprint_init() {
  }
  
! bool tcpprint_shouldIlisten(){
     return TRUE;
  }
  
--- 10,19 ----
  
  //=========================== public ==========================================
  
! void tcpprint_init(void) {
  }
  
! bool tcpprint_shouldIlisten(void){
     return TRUE;
  }
  
***************
*** 24,36 ****
     openqueue_freePacketBuffer(msg);
  }
  
! void tcpprint_connectDone(error_t error) {
  }
  
! void tcpprint_sendDone(OpenQueueEntry_t* msg, error_t error) {
  }
  
! bool tcpprint_debugPrint() {
     return FALSE;
  }
  
--- 24,36 ----
     openqueue_freePacketBuffer(msg);
  }
  
! void tcpprint_connectDone(owerror_t error) {
  }
  
! void tcpprint_sendDone(OpenQueueEntry_t* msg, owerror_t error) {
  }
  
! bool tcpprint_debugPrint(void) {
     return FALSE;
  }
  
diff -crB stock/openwsn/07-App/tcpprint/tcpprint.h dev/openwsn/07-App/tcpprint/tcpprint.h
*** stock/openwsn/07-App/tcpprint/tcpprint.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/tcpprint/tcpprint.h	Wed Jan 29 10:33:22 2014
***************
*** 2,8 ****
  #define __TCPPRINT_H
  
  /**
! \addtogroup App
  \{
  \addtogroup tcpPrint
  \{
--- 2,8 ----
  #define __TCPPRINT_H
  
  /**
! \addtogroup AppTcp
  \{
  \addtogroup tcpPrint
  \{
***************
*** 16,27 ****
  
  //=========================== prototypes ======================================
  
! void tcpprint_init();
! bool tcpprint_shouldIlisten();
  void tcpprint_receive(OpenQueueEntry_t* msg);
! void tcpprint_connectDone(error_t error);
! void tcpprint_sendDone(OpenQueueEntry_t* msg, error_t error);
! bool tcpprint_debugPrint();
  
  /**
  \}
--- 16,27 ----
  
  //=========================== prototypes ======================================
  
! void tcpprint_init(void);
! bool tcpprint_shouldIlisten(void);
  void tcpprint_receive(OpenQueueEntry_t* msg);
! void tcpprint_connectDone(owerror_t error);
! void tcpprint_sendDone(OpenQueueEntry_t* msg, owerror_t error);
! bool tcpprint_debugPrint(void);
  
  /**
  \}
diff -crB stock/openwsn/07-App/udpecho/Makefile dev/openwsn/07-App/udpecho/Makefile
*** stock/openwsn/07-App/udpecho/Makefile	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/udpecho/Makefile	Wed Jan 29 10:33:22 2014
***************
*** 0 ****
--- 1,32 ----
+ SUBSUBMOD:=$(shell basename $(CURDIR)).a
+ #BINDIR = $(RIOTBASE)/bin/
+ SRC = $(wildcard *.c)
+ OBJ = $(SRC:%.c=$(BINDIR)%.o)
+ DEP = $(SRC:%.c=$(BINDIR)%.d)
+ 
+ INCLUDES += -I$(RIOTBASE) -I$(RIOTBASE)/sys/include -I$(RIOTBASE)/core/include -I$(RIOTBASE)/drivers/include -I$(RIOTBASE)/drivers/cc110x_ng/include -I$(RIOTBASE)/cpu/arm_common/include -I$(RIOTBASE)/sys/net/include/
+ INCLUDES += -I$(CURDIR)/02a-MAClow
+ INCLUDES += -I$(CURDIR)/02b-MAChigh
+ INCLUDES += -I$(CURDIR)/03a-IPHC
+ INCLUDES += -I$(CURDIR)/03b-IPv6
+ INCLUDES += -I$(CURDIR)/04-TRAN
+ INCLUDES += -I$(CURDIR)/cross-layers
+ 
+ .PHONY: $(BINDIR)$(SUBSUBMOD)
+ 
+ $(BINDIR)$(SUBSUBMOD): $(OBJ)
+ 	$(AD)$(AR) rcs $(BINDIR)$(MODULE) $(OBJ)
+ 
+ # pull in dependency info for *existing* .o files
+ -include $(OBJ:.o=.d)
+ 
+ # compile and generate dependency info
+ $(BINDIR)%.o: %.c
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -c $*.c -o $(BINDIR)$*.o
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -MM $*.c > $(BINDIR)$*.d
+ 	@printf "$(BINDIR)" | cat - $(BINDIR)$*.d > /tmp/riot_out && mv /tmp/riot_out $(BINDIR)$*.d
+ 
+ # remove compilation products
+ 
+ clean:
+ 	rm -f $(OBJ) $(DEP)
diff -crB stock/openwsn/07-App/udpecho/udpecho.c dev/openwsn/07-App/udpecho/udpecho.c
*** stock/openwsn/07-App/udpecho/udpecho.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/udpecho/udpecho.c	Wed Jan 29 10:33:22 2014
***************
*** 10,16 ****
  
  //=========================== public ==========================================
  
! void udpecho_init() {
  }
  
  void udpecho_receive(OpenQueueEntry_t* msg) {
--- 10,16 ----
  
  //=========================== public ==========================================
  
! void udpecho_init(void) {
  }
  
  void udpecho_receive(OpenQueueEntry_t* msg) {
***************
*** 44,50 ****
     }
  }
  
! void udpecho_sendDone(OpenQueueEntry_t* msg, error_t error) {
     msg->owner = COMPONENT_UDPECHO;
     if (msg->creator!=COMPONENT_UDPECHO) {
        openserial_printError(COMPONENT_UDPECHO,ERR_UNEXPECTED_SENDDONE,
--- 44,50 ----
     }
  }
  
! void udpecho_sendDone(OpenQueueEntry_t* msg, owerror_t error) {
     msg->owner = COMPONENT_UDPECHO;
     if (msg->creator!=COMPONENT_UDPECHO) {
        openserial_printError(COMPONENT_UDPECHO,ERR_UNEXPECTED_SENDDONE,
***************
*** 54,60 ****
     openqueue_freePacketBuffer(msg);
  }
  
! bool udpecho_debugPrint() {
     return FALSE;
  }
  
--- 54,60 ----
     openqueue_freePacketBuffer(msg);
  }
  
! bool udpecho_debugPrint(void) {
     return FALSE;
  }
  
diff -crB stock/openwsn/07-App/udpecho/udpecho.h dev/openwsn/07-App/udpecho/udpecho.h
*** stock/openwsn/07-App/udpecho/udpecho.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/udpecho/udpecho.h	Wed Jan 29 10:33:22 2014
***************
*** 2,8 ****
  #define __UDPECHO_H
  
  /**
! \addtogroup App
  \{
  \addtogroup udpEcho
  \{
--- 2,8 ----
  #define __UDPECHO_H
  
  /**
! \addtogroup AppUdp
  \{
  \addtogroup udpEcho
  \{
***************
*** 16,25 ****
  
  //=========================== prototypes ======================================
  
! void udpecho_init();
  void udpecho_receive(OpenQueueEntry_t* msg);
! void udpecho_sendDone(OpenQueueEntry_t* msg, error_t error);
! bool udpecho_debugPrint();
  
  /**
  \}
--- 16,25 ----
  
  //=========================== prototypes ======================================
  
! void udpecho_init(void);
  void udpecho_receive(OpenQueueEntry_t* msg);
! void udpecho_sendDone(OpenQueueEntry_t* msg, owerror_t error);
! bool udpecho_debugPrint(void);
  
  /**
  \}
diff -crB stock/openwsn/07-App/udpecho/udpecho.py dev/openwsn/07-App/udpecho/udpecho.py
*** stock/openwsn/07-App/udpecho/udpecho.py	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/udpecho/udpecho.py	Wed Jan 29 10:33:22 2014
***************
*** 3,26 ****
  request    = "poipoipoipoi"
  myAddress  = '' #means 'all'
  myPort     = 21568
! hisAddress = '2001:470:48b8:cfde:1415:9200:12:e63b'
  hisPort    = 7
! 
  print "Testing udpEcho..."
  
! socket_handler = socket.socket(socket.AF_INET6,socket.SOCK_DGRAM)
! socket_handler.settimeout(5)
! socket_handler.bind((myAddress,myPort))
! socket_handler.sendto(request,(hisAddress,hisPort))
! print "\nrequest "+myAddress+"%"+str(myPort)+" -> "+hisAddress+"%"+str(hisPort)
! print request+" ("+str(len(request))+" bytes)"
! try:
!    reply,dist_addr = socket_handler.recvfrom(1024)
! except socket.timeout:
!    print "\nno reply"
! else:
!    print "\nreply "+str(dist_addr[0])+"%"+str(dist_addr[1])+" -> "+myAddress+"%"+str(myPort)
!    print reply+" ("+str(len(reply))+" bytes)"
! socket_handler.close()
  
  raw_input("\nPress return to close this window...")
--- 3,32 ----
  request    = "poipoipoipoi"
  myAddress  = '' #means 'all'
  myPort     = 21568
! hisAddress = 'bbbb::1415:920b:0301:00e9'
  hisPort    = 7
! succ       = 0
! fail       = 0
  print "Testing udpEcho..."
  
! for i in range(10):
!    print "echo " + str(i)
!    socket_handler = socket.socket(socket.AF_INET6,socket.SOCK_DGRAM)
!    socket_handler.settimeout(5)
!    socket_handler.bind((myAddress,myPort))
!    socket_handler.sendto(request,(hisAddress,hisPort))
!    print "\nrequest "+myAddress+"%"+str(myPort)+" -> "+hisAddress+"%"+str(hisPort)
!    print request+" ("+str(len(request))+" bytes)"
!    try:
!       reply,dist_addr = socket_handler.recvfrom(1024)
!    except socket.timeout:
!       print "\nno reply"
!       fail=fail+1
!    else:
!       print "\nreply "+str(dist_addr[0])+"%"+str(dist_addr[1])+" -> "+myAddress+"%"+str(myPort)
!       print reply+" ("+str(len(reply))+" bytes)"
!       succ=succ+1
!    socket_handler.close()
  
+ print "success " + str(succ) + " fail " + str(fail)
  raw_input("\nPress return to close this window...")
diff -crB stock/openwsn/07-App/udpinject/Makefile dev/openwsn/07-App/udpinject/Makefile
*** stock/openwsn/07-App/udpinject/Makefile	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/udpinject/Makefile	Wed Jan 29 10:33:22 2014
***************
*** 0 ****
--- 1,32 ----
+ SUBSUBMOD:=$(shell basename $(CURDIR)).a
+ #BINDIR = $(RIOTBASE)/bin/
+ SRC = $(wildcard *.c)
+ OBJ = $(SRC:%.c=$(BINDIR)%.o)
+ DEP = $(SRC:%.c=$(BINDIR)%.d)
+ 
+ INCLUDES += -I$(RIOTBASE) -I$(RIOTBASE)/sys/include -I$(RIOTBASE)/core/include -I$(RIOTBASE)/drivers/include -I$(RIOTBASE)/drivers/cc110x_ng/include -I$(RIOTBASE)/cpu/arm_common/include -I$(RIOTBASE)/sys/net/include/
+ INCLUDES += -I$(CURDIR)/02a-MAClow
+ INCLUDES += -I$(CURDIR)/02b-MAChigh
+ INCLUDES += -I$(CURDIR)/03a-IPHC
+ INCLUDES += -I$(CURDIR)/03b-IPv6
+ INCLUDES += -I$(CURDIR)/04-TRAN
+ INCLUDES += -I$(CURDIR)/cross-layers
+ 
+ .PHONY: $(BINDIR)$(SUBSUBMOD)
+ 
+ $(BINDIR)$(SUBSUBMOD): $(OBJ)
+ 	$(AD)$(AR) rcs $(BINDIR)$(MODULE) $(OBJ)
+ 
+ # pull in dependency info for *existing* .o files
+ -include $(OBJ:.o=.d)
+ 
+ # compile and generate dependency info
+ $(BINDIR)%.o: %.c
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -c $*.c -o $(BINDIR)$*.o
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -MM $*.c > $(BINDIR)$*.d
+ 	@printf "$(BINDIR)" | cat - $(BINDIR)$*.d > /tmp/riot_out && mv /tmp/riot_out $(BINDIR)$*.d
+ 
+ # remove compilation products
+ 
+ clean:
+ 	rm -f $(OBJ) $(DEP)
diff -crB stock/openwsn/07-App/udpinject/udpinject.c dev/openwsn/07-App/udpinject/udpinject.c
*** stock/openwsn/07-App/udpinject/udpinject.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/udpinject/udpinject.c	Wed Jan 29 10:33:22 2014
***************
*** 11,20 ****
  
  //=========================== public ==========================================
  
! void udpinject_init() {
  }
  
! void udpinject_trigger() {
     OpenQueueEntry_t* pkt;
     uint8_t number_bytes_from_input_buffer;
     uint8_t input_buffer[18];
--- 11,20 ----
  
  //=========================== public ==========================================
  
! void udpinject_init(void) {
  }
  
! void udpinject_trigger(void) {
     OpenQueueEntry_t* pkt;
     uint8_t number_bytes_from_input_buffer;
     uint8_t input_buffer[18];
***************
*** 54,60 ****
     }
  }
  
! void udpinject_sendDone(OpenQueueEntry_t* msg, error_t error) {
     msg->owner = COMPONENT_UDPINJECT;
     if (msg->creator!=COMPONENT_UDPINJECT) {
        openserial_printError(COMPONENT_UDPINJECT,ERR_UNEXPECTED_SENDDONE,
--- 54,60 ----
     }
  }
  
! void udpinject_sendDone(OpenQueueEntry_t* msg, owerror_t error) {
     msg->owner = COMPONENT_UDPINJECT;
     if (msg->creator!=COMPONENT_UDPINJECT) {
        openserial_printError(COMPONENT_UDPINJECT,ERR_UNEXPECTED_SENDDONE,
***************
*** 68,74 ****
     openqueue_freePacketBuffer(msg);
  }
  
! bool udpinject_debugPrint() {
     return FALSE;
  }
  
--- 68,74 ----
     openqueue_freePacketBuffer(msg);
  }
  
! bool udpinject_debugPrint(void) {
     return FALSE;
  }
  
diff -crB stock/openwsn/07-App/udpinject/udpinject.h dev/openwsn/07-App/udpinject/udpinject.h
*** stock/openwsn/07-App/udpinject/udpinject.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/udpinject/udpinject.h	Wed Jan 29 10:33:22 2014
***************
*** 2,8 ****
  #define __UDPINJECT_H
  
  /**
! \addtogroup App
  \{
  \addtogroup udpInject
  \{
--- 2,8 ----
  #define __UDPINJECT_H
  
  /**
! \addtogroup AppUdp
  \{
  \addtogroup udpInject
  \{
***************
*** 16,26 ****
  
  //=========================== prototypes ======================================
  
! void udpinject_init();
! void udpinject_trigger();
! void udpinject_sendDone(OpenQueueEntry_t* msg, error_t error);
  void udpinject_receive(OpenQueueEntry_t* msg);
! bool udpinject_debugPrint();
  
  /**
  \}
--- 16,26 ----
  
  //=========================== prototypes ======================================
  
! void udpinject_init(void);
! void udpinject_trigger(void);
! void udpinject_sendDone(OpenQueueEntry_t* msg, owerror_t error);
  void udpinject_receive(OpenQueueEntry_t* msg);
! bool udpinject_debugPrint(void);
  
  /**
  \}
diff -crB stock/openwsn/07-App/udplatency/Makefile dev/openwsn/07-App/udplatency/Makefile
*** stock/openwsn/07-App/udplatency/Makefile	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/udplatency/Makefile	Wed Jan 29 10:33:22 2014
***************
*** 0 ****
--- 1,32 ----
+ SUBSUBMOD:=$(shell basename $(CURDIR)).a
+ #BINDIR = $(RIOTBASE)/bin/
+ SRC = $(wildcard *.c)
+ OBJ = $(SRC:%.c=$(BINDIR)%.o)
+ DEP = $(SRC:%.c=$(BINDIR)%.d)
+ 
+ INCLUDES += -I$(RIOTBASE) -I$(RIOTBASE)/sys/include -I$(RIOTBASE)/core/include -I$(RIOTBASE)/drivers/include -I$(RIOTBASE)/drivers/cc110x_ng/include -I$(RIOTBASE)/cpu/arm_common/include -I$(RIOTBASE)/sys/net/include/
+ INCLUDES += -I$(CURDIR)/02a-MAClow
+ INCLUDES += -I$(CURDIR)/02b-MAChigh
+ INCLUDES += -I$(CURDIR)/03a-IPHC
+ INCLUDES += -I$(CURDIR)/03b-IPv6
+ INCLUDES += -I$(CURDIR)/04-TRAN
+ INCLUDES += -I$(CURDIR)/cross-layers
+ 
+ .PHONY: $(BINDIR)$(SUBSUBMOD)
+ 
+ $(BINDIR)$(SUBSUBMOD): $(OBJ)
+ 	$(AD)$(AR) rcs $(BINDIR)$(MODULE) $(OBJ)
+ 
+ # pull in dependency info for *existing* .o files
+ -include $(OBJ:.o=.d)
+ 
+ # compile and generate dependency info
+ $(BINDIR)%.o: %.c
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -c $*.c -o $(BINDIR)$*.o
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -MM $*.c > $(BINDIR)$*.d
+ 	@printf "$(BINDIR)" | cat - $(BINDIR)$*.d > /tmp/riot_out && mv /tmp/riot_out $(BINDIR)$*.d
+ 
+ # remove compilation products
+ 
+ clean:
+ 	rm -f $(OBJ) $(DEP)
diff -crB stock/openwsn/07-App/udplatency/udplatency.c dev/openwsn/07-App/udplatency/udplatency.c
*** stock/openwsn/07-App/udplatency/udplatency.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/udplatency/udplatency.c	Wed Jan 29 10:33:22 2014
***************
*** 12,21 ****
  #include "idmanager.h"
  #include "neighbors.h"
  
! //=========================== defines =========================================
  
! /// inter-packet period (in mseconds)
! #define UDPLATENCYPERIOD     30000
  
  //=========================== variables =======================================
  
--- 12,20 ----
  #include "idmanager.h"
  #include "neighbors.h"
  
! #include "thread.h"
  
! //=========================== defines =========================================
  
  //=========================== variables =======================================
  
***************
*** 24,51 ****
  } udplatency_vars_t;
  
  udplatency_vars_t udplatency_vars;
  
  //=========================== prototypes ======================================
  
! void udplatency_timer();
  
  //=========================== public ==========================================
  
! void udplatency_init() {
!  //don't run on dagroot 
!  if (idmanager_getIsDAGroot()) return;
!  
!  udplatency_vars.timerId    = opentimers_start(UDPLATENCYPERIOD,
!                                           TIMER_PERIODIC,TIME_MS,
!                                           udplatency_timer);
  }
  
! void udplatency_task(){
     OpenQueueEntry_t* pkt;
     open_addr_t * p;
     open_addr_t  q;
  
!    //prepare packet
     pkt = openqueue_getFreePacketBuffer(COMPONENT_UDPLATENCY);
     if (pkt==NULL) {
        openserial_printError(COMPONENT_UDPLATENCY,ERR_NO_FREE_PACKET_BUFFER,
--- 23,60 ----
  } udplatency_vars_t;
  
  udplatency_vars_t udplatency_vars;
+ uint16_t          seqNum;
+ 
+ //static char openwsn_udplatency_stack[KERNEL_CONF_STACKSIZE_MAIN];
  
  //=========================== prototypes ======================================
  
! void udplatency_timer(void);
  
  //=========================== public ==========================================
  
! void udplatency_init(void) {
!    seqNum = 0;
!    udplatency_vars.timerId    = opentimers_start(UDPLATENCYPERIOD,
!                                             TIMER_PERIODIC,TIME_MS,
!                                             udplatency_timer);
  }
  
! void udplatency_task(void) {
     OpenQueueEntry_t* pkt;
     open_addr_t * p;
     open_addr_t  q;
  
!    // don't run if not synch
!    if (ieee154e_isSynch() == FALSE) return;
! 
!    // don't run on dagroot
!    if (idmanager_getIsDAGroot()) {
!        opentimers_stop(udplatency_vars.timerId);
!        return;
!    }
! 
!    // prepare packet
     pkt = openqueue_getFreePacketBuffer(COMPONENT_UDPLATENCY);
     if (pkt==NULL) {
        openserial_printError(COMPONENT_UDPLATENCY,ERR_NO_FREE_PACKET_BUFFER,
***************
*** 58,106 ****
     pkt->l4_protocol                 = IANA_UDP;
     pkt->l4_sourcePortORicmpv6Type   = WKP_UDP_LATENCY;
     pkt->l4_destination_port         = WKP_UDP_LATENCY;
!    pkt->l3_destinationAdd.type = ADDR_128B;
     memcpy(&pkt->l3_destinationAdd.addr_128b[0],&ipAddr_motedata,16);
     
! //the payload contains the 64bit address of the sender + the ASN
!    packetfunctions_reserveHeaderSize(pkt,sizeof(asn_t));
!    asnWriteToPkt(pkt);//gets asn from mac layer.
     
     packetfunctions_reserveHeaderSize(pkt,8);
     p=idmanager_getMyID(ADDR_64B);
!    pkt->payload[0]=p->addr_64b[0];
!    pkt->payload[1]=p->addr_64b[1];
!    pkt->payload[2]=p->addr_64b[2];
!    pkt->payload[3]=p->addr_64b[3];
!    pkt->payload[4]=p->addr_64b[4];
!    pkt->payload[5]=p->addr_64b[5];
!    pkt->payload[6]=p->addr_64b[6];
!    pkt->payload[7]=p->addr_64b[7];
     
     neighbors_getPreferredParentEui64(&q);
!    if (q.type==ADDR_64B){
        packetfunctions_reserveHeaderSize(pkt,8);
     
!    //copy my preferred parent so we can build the topology
!       pkt->payload[0]=q.addr_64b[0];
!       pkt->payload[1]=q.addr_64b[1];
!       pkt->payload[2]=q.addr_64b[2];
!       pkt->payload[3]=q.addr_64b[3];
!       pkt->payload[4]=q.addr_64b[4];
!       pkt->payload[5]=q.addr_64b[5];
!       pkt->payload[6]=q.addr_64b[6];
!       pkt->payload[7]=q.addr_64b[7];
     }
!    //send packet
!    if ((openudp_send(pkt))==E_FAIL) {
        openqueue_freePacketBuffer(pkt);
     }
  }
  
! void udplatency_timer() {
!   scheduler_push_task(udplatency_task,TASKPRIO_COAP);
  }
  
! void udplatency_sendDone(OpenQueueEntry_t* msg, error_t error) {
     msg->owner = COMPONENT_UDPLATENCY;
     if (msg->creator!=COMPONENT_UDPLATENCY) {
        openserial_printError(COMPONENT_UDPLATENCY,ERR_UNEXPECTED_SENDDONE,
--- 67,132 ----
     pkt->l4_protocol                 = IANA_UDP;
     pkt->l4_sourcePortORicmpv6Type   = WKP_UDP_LATENCY;
     pkt->l4_destination_port         = WKP_UDP_LATENCY;
!    pkt->l3_destinationAdd.type      = ADDR_128B;
     memcpy(&pkt->l3_destinationAdd.addr_128b[0],&ipAddr_motedata,16);
     
!    // the payload contains the 64bit address of the sender + the ASN
!    packetfunctions_reserveHeaderSize(pkt, sizeof(asn_t));
!    ieee154e_getAsn(pkt->payload);//gets asn from mac layer.
     
     packetfunctions_reserveHeaderSize(pkt,8);
     p=idmanager_getMyID(ADDR_64B);
!    pkt->payload[0]    = p->addr_64b[0];
!    pkt->payload[1]    = p->addr_64b[1];
!    pkt->payload[2]    = p->addr_64b[2];
!    pkt->payload[3]    = p->addr_64b[3];
!    pkt->payload[4]    = p->addr_64b[4];
!    pkt->payload[5]    = p->addr_64b[5];
!    pkt->payload[6]    = p->addr_64b[6];
!    pkt->payload[7]    = p->addr_64b[7];
     
     neighbors_getPreferredParentEui64(&q);
!    if (q.type==ADDR_64B) {
        packetfunctions_reserveHeaderSize(pkt,8);
     
!    // copy my preferred parent so we can build the topology
!       pkt->payload[0] = q.addr_64b[0];
!       pkt->payload[1] = q.addr_64b[1];
!       pkt->payload[2] = q.addr_64b[2];
!       pkt->payload[3] = q.addr_64b[3];
!       pkt->payload[4] = q.addr_64b[4];
!       pkt->payload[5] = q.addr_64b[5];
!       pkt->payload[6] = q.addr_64b[6];
!       pkt->payload[7] = q.addr_64b[7];
     }
! 
!    // insert Sequence Number
!    packetfunctions_reserveHeaderSize(pkt,sizeof(seqNum));
!    pkt->payload[0]    = (seqNum >> 8) & 0xff;
!    pkt->payload[1]    = seqNum & 0xff;
! 
!    // send packet
!    if ((openudp_send(pkt)) == E_FAIL) {
        openqueue_freePacketBuffer(pkt);
     }
+ 
+    // increment seqNum
+    seqNum++;
+ 
+    // close timer when test finish
+    if (seqNum > NUMPKTTEST) {
+        opentimers_stop(udplatency_vars.timerId);
+    }
  }
  
! void udplatency_timer(void) {
!     scheduler_push_task(udplatency_task,TASKPRIO_COAP);
!   /*thread_create(openwsn_udplatency_stack, KERNEL_CONF_STACKSIZE_MAIN, 
!                  PRIORITY_OPENWSN_UDPLATENCY, CREATE_STACKTEST, 
!                  udplatency_task, "udplatency task");*/
  }
  
! void udplatency_sendDone(OpenQueueEntry_t* msg, owerror_t error) {
     msg->owner = COMPONENT_UDPLATENCY;
     if (msg->creator!=COMPONENT_UDPLATENCY) {
        openserial_printError(COMPONENT_UDPLATENCY,ERR_UNEXPECTED_SENDDONE,
***************
*** 114,117 ****
     openqueue_freePacketBuffer(msg);
  }
  
! //=========================== private =========================================
\ No newline at end of file
--- 140,143 ----
     openqueue_freePacketBuffer(msg);
  }
  
! //=========================== private =========================================
diff -crB stock/openwsn/07-App/udplatency/udplatency.h dev/openwsn/07-App/udplatency/udplatency.h
*** stock/openwsn/07-App/udplatency/udplatency.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/udplatency/udplatency.h	Wed Jan 29 10:33:22 2014
***************
*** 2,27 ****
  #define __UDPLATENCY_H
  
  /**
! \addtogroup App
! 
! \addtogroup udpLatency
  \{
  */
  
  //=========================== define ==========================================
  
  //=========================== typedef =========================================
  
  //=========================== variables =======================================
  
  //=========================== prototypes ======================================
  
! void udplatency_init();
! void udplatency_trigger();
! void udplatency_sendDone(OpenQueueEntry_t* msg, error_t error);
  void udplatency_receive(OpenQueueEntry_t* msg);
! bool udplatency_debugPrint();
! void udplatency_task();
  
  /**
  \}
--- 2,31 ----
  #define __UDPLATENCY_H
  
  /**
! \addtogroup AppUdp
! \{
! \addtogroup UdpLatency
  \{
  */
  
  //=========================== define ==========================================
  
+ /// inter-packet period (in mseconds)
+ #define UDPLATENCYPERIOD     3000
+ #define NUMPKTTEST           300
+ 
  //=========================== typedef =========================================
  
  //=========================== variables =======================================
  
  //=========================== prototypes ======================================
  
! void udplatency_init(void);
! void udplatency_trigger(void);
! void udplatency_sendDone(OpenQueueEntry_t* msg, owerror_t error);
  void udplatency_receive(OpenQueueEntry_t* msg);
! bool udplatency_debugPrint(void);
! void udplatency_task(void);
  
  /**
  \}
diff -crB stock/openwsn/07-App/udpprint/Makefile dev/openwsn/07-App/udpprint/Makefile
*** stock/openwsn/07-App/udpprint/Makefile	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/udpprint/Makefile	Wed Jan 29 10:33:22 2014
***************
*** 0 ****
--- 1,32 ----
+ SUBSUBMOD:=$(shell basename $(CURDIR)).a
+ #BINDIR = $(RIOTBASE)/bin/
+ SRC = $(wildcard *.c)
+ OBJ = $(SRC:%.c=$(BINDIR)%.o)
+ DEP = $(SRC:%.c=$(BINDIR)%.d)
+ 
+ INCLUDES += -I$(RIOTBASE) -I$(RIOTBASE)/sys/include -I$(RIOTBASE)/core/include -I$(RIOTBASE)/drivers/include -I$(RIOTBASE)/drivers/cc110x_ng/include -I$(RIOTBASE)/cpu/arm_common/include -I$(RIOTBASE)/sys/net/include/
+ INCLUDES += -I$(CURDIR)/02a-MAClow
+ INCLUDES += -I$(CURDIR)/02b-MAChigh
+ INCLUDES += -I$(CURDIR)/03a-IPHC
+ INCLUDES += -I$(CURDIR)/03b-IPv6
+ INCLUDES += -I$(CURDIR)/04-TRAN
+ INCLUDES += -I$(CURDIR)/cross-layers
+ 
+ .PHONY: $(BINDIR)$(SUBSUBMOD)
+ 
+ $(BINDIR)$(SUBSUBMOD): $(OBJ)
+ 	$(AD)$(AR) rcs $(BINDIR)$(MODULE) $(OBJ)
+ 
+ # pull in dependency info for *existing* .o files
+ -include $(OBJ:.o=.d)
+ 
+ # compile and generate dependency info
+ $(BINDIR)%.o: %.c
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -c $*.c -o $(BINDIR)$*.o
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -MM $*.c > $(BINDIR)$*.d
+ 	@printf "$(BINDIR)" | cat - $(BINDIR)$*.d > /tmp/riot_out && mv /tmp/riot_out $(BINDIR)$*.d
+ 
+ # remove compilation products
+ 
+ clean:
+ 	rm -f $(OBJ) $(DEP)
diff -crB stock/openwsn/07-App/udpprint/udpprint.c dev/openwsn/07-App/udpprint/udpprint.c
*** stock/openwsn/07-App/udpprint/udpprint.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/udpprint/udpprint.c	Wed Jan 29 10:33:22 2014
***************
*** 9,18 ****
  
  //=========================== public ==========================================
  
! void udpprint_init() {
  }
  
! void udpprint_sendDone(OpenQueueEntry_t* msg, error_t error) {
     openserial_printError(COMPONENT_UDPPRINT,ERR_UNEXPECTED_SENDDONE,
                           (errorparameter_t)0,
                           (errorparameter_t)0);
--- 9,18 ----
  
  //=========================== public ==========================================
  
! void udpprint_init(void) {
  }
  
! void udpprint_sendDone(OpenQueueEntry_t* msg, owerror_t error) {
     openserial_printError(COMPONENT_UDPPRINT,ERR_UNEXPECTED_SENDDONE,
                           (errorparameter_t)0,
                           (errorparameter_t)0);
***************
*** 24,30 ****
     openqueue_freePacketBuffer(msg);
  }
  
! bool udpprint_debugPrint() {
     return FALSE;
  }
  
--- 24,30 ----
     openqueue_freePacketBuffer(msg);
  }
  
! bool udpprint_debugPrint(void) {
     return FALSE;
  }
  
diff -crB stock/openwsn/07-App/udpprint/udpprint.h dev/openwsn/07-App/udpprint/udpprint.h
*** stock/openwsn/07-App/udpprint/udpprint.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/udpprint/udpprint.h	Wed Jan 29 10:33:22 2014
***************
*** 2,8 ****
  #define __UDPPRINT_H
  
  /**
! \addtogroup App
  \{
  \addtogroup udpPrint
  \{
--- 2,8 ----
  #define __UDPPRINT_H
  
  /**
! \addtogroup AppUdp
  \{
  \addtogroup udpPrint
  \{
***************
*** 16,25 ****
  
  //=========================== prototypes ======================================
  
! void udpprint_init();
! void udpprint_sendDone(OpenQueueEntry_t* msg, error_t error);
  void udpprint_receive(OpenQueueEntry_t* msg);
! bool udpprint_debugPrint();
  
  /**
  \}
--- 16,25 ----
  
  //=========================== prototypes ======================================
  
! void udpprint_init(void);
! void udpprint_sendDone(OpenQueueEntry_t* msg, owerror_t error);
  void udpprint_receive(OpenQueueEntry_t* msg);
! bool udpprint_debugPrint(void);
  
  /**
  \}
diff -crB stock/openwsn/07-App/udprand/Makefile dev/openwsn/07-App/udprand/Makefile
*** stock/openwsn/07-App/udprand/Makefile	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/udprand/Makefile	Wed Jan 29 10:33:22 2014
***************
*** 0 ****
--- 1,32 ----
+ SUBSUBMOD:=$(shell basename $(CURDIR)).a
+ #BINDIR = $(RIOTBASE)/bin/
+ SRC = $(wildcard *.c)
+ OBJ = $(SRC:%.c=$(BINDIR)%.o)
+ DEP = $(SRC:%.c=$(BINDIR)%.d)
+ 
+ INCLUDES += -I$(RIOTBASE) -I$(RIOTBASE)/sys/include -I$(RIOTBASE)/core/include -I$(RIOTBASE)/drivers/include -I$(RIOTBASE)/drivers/cc110x_ng/include -I$(RIOTBASE)/cpu/arm_common/include -I$(RIOTBASE)/sys/net/include/
+ INCLUDES += -I$(CURDIR)/02a-MAClow
+ INCLUDES += -I$(CURDIR)/02b-MAChigh
+ INCLUDES += -I$(CURDIR)/03a-IPHC
+ INCLUDES += -I$(CURDIR)/03b-IPv6
+ INCLUDES += -I$(CURDIR)/04-TRAN
+ INCLUDES += -I$(CURDIR)/cross-layers
+ 
+ .PHONY: $(BINDIR)$(SUBSUBMOD)
+ 
+ $(BINDIR)$(SUBSUBMOD): $(OBJ)
+ 	$(AD)$(AR) rcs $(BINDIR)$(MODULE) $(OBJ)
+ 
+ # pull in dependency info for *existing* .o files
+ -include $(OBJ:.o=.d)
+ 
+ # compile and generate dependency info
+ $(BINDIR)%.o: %.c
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -c $*.c -o $(BINDIR)$*.o
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -MM $*.c > $(BINDIR)$*.d
+ 	@printf "$(BINDIR)" | cat - $(BINDIR)$*.d > /tmp/riot_out && mv /tmp/riot_out $(BINDIR)$*.d
+ 
+ # remove compilation products
+ 
+ clean:
+ 	rm -f $(OBJ) $(DEP)
diff -crB stock/openwsn/07-App/udprand/udprand.c dev/openwsn/07-App/udprand/udprand.c
*** stock/openwsn/07-App/udprand/udprand.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/udprand/udprand.c	Wed Jan 29 10:33:22 2014
***************
*** 8,13 ****
--- 8,17 ----
  #include "openrandom.h"
  #include "opencoap.h"
  #include "scheduler.h"
+ #include "idmanager.h"
+ #include "IEEE802154E.h"
+ 
+ #include "thread.h"
  
  //=========================== defines =========================================
  
***************
*** 21,41 ****
  } udprand_vars_t;
  
  udprand_vars_t udprand_vars;
! 
  //=========================== prototypes ======================================
  
! void udprand_timer();
  
  //=========================== public ==========================================
  
! void udprand_init() {
     udprand_vars.timerId    = opentimers_start(openrandom_get16b()%UDPRANDPERIOD,
                                            TIMER_PERIODIC,TIME_MS,
                                            udprand_timer);
  }
  
! void udprand_task(){
      OpenQueueEntry_t* pkt;
     //prepare packet
     pkt = openqueue_getFreePacketBuffer(COMPONENT_UDPRAND);
     if (pkt==NULL) {
--- 25,55 ----
  } udprand_vars_t;
  
  udprand_vars_t udprand_vars;
! //static char openwsn_udprand_stack[KERNEL_CONF_STACKSIZE_MAIN];
  //=========================== prototypes ======================================
  
! void udprand_timer(void);
  
  //=========================== public ==========================================
  
! void udprand_init(void) {
     udprand_vars.timerId    = opentimers_start(openrandom_get16b()%UDPRANDPERIOD,
                                            TIMER_PERIODIC,TIME_MS,
                                            udprand_timer);
  }
  
! void udprand_task(void){
      OpenQueueEntry_t* pkt;
+    
+    // don't run if not synch
+    if (ieee154e_isSynch() == FALSE) return;
+     
+     // don't run on dagroot
+    if (idmanager_getIsDAGroot()) {
+       opentimers_stop(udprand_vars.timerId);
+       return;
+    }
+    
     //prepare packet
     pkt = openqueue_getFreePacketBuffer(COMPONENT_UDPRAND);
     if (pkt==NULL) {
***************
*** 60,70 ****
     }
  }
  
! void udprand_timer() {
!   scheduler_push_task(udprand_task,TASKPRIO_COAP);
  }
  
! void udprand_sendDone(OpenQueueEntry_t* msg, error_t error) {
     msg->owner = COMPONENT_UDPRAND;
     if (msg->creator!=COMPONENT_UDPRAND) {
        openserial_printError(COMPONENT_UDPRAND,ERR_UNEXPECTED_SENDDONE,
--- 74,87 ----
     }
  }
  
! void udprand_timer(void) {
!     scheduler_push_task(udprand_task,TASKPRIO_COAP);
!   /*thread_create(openwsn_udprand_stack, KERNEL_CONF_STACKSIZE_MAIN, 
!                  PRIORITY_OPENWSN_UDPRAND, CREATE_STACKTEST, 
!                  udprand_task, "udprand task");*/
  }
  
! void udprand_sendDone(OpenQueueEntry_t* msg, owerror_t error) {
     msg->owner = COMPONENT_UDPRAND;
     if (msg->creator!=COMPONENT_UDPRAND) {
        openserial_printError(COMPONENT_UDPRAND,ERR_UNEXPECTED_SENDDONE,
diff -crB stock/openwsn/07-App/udprand/udprand.h dev/openwsn/07-App/udprand/udprand.h
*** stock/openwsn/07-App/udprand/udprand.h	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/udprand/udprand.h	Wed Jan 29 10:33:22 2014
***************
*** 2,10 ****
  #define __UDPRAND_H
  
  /**
! \addtogroup App
! 
! \addtogroup udpRand
  \{
  */
  
--- 2,10 ----
  #define __UDPRAND_H
  
  /**
! \addtogroup AppUdp
! \{
! \addtogroup UdpRand
  \{
  */
  
***************
*** 16,27 ****
  
  //=========================== prototypes ======================================
  
! void udprand_init();
! void udprand_trigger();
! void udprand_sendDone(OpenQueueEntry_t* msg, error_t error);
  void udprand_receive(OpenQueueEntry_t* msg);
! bool udprand_debugPrint();
! void udprand_task();
  
  /**
  \}
--- 16,27 ----
  
  //=========================== prototypes ======================================
  
! void udprand_init(void);
! void udprand_trigger(void);
! void udprand_sendDone(OpenQueueEntry_t* msg, owerror_t error);
  void udprand_receive(OpenQueueEntry_t* msg);
! bool udprand_debugPrint(void);
! void udprand_task(void);
  
  /**
  \}
diff -crB stock/openwsn/07-App/udpstorm/Makefile dev/openwsn/07-App/udpstorm/Makefile
*** stock/openwsn/07-App/udpstorm/Makefile	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/udpstorm/Makefile	Wed Jan 29 10:33:22 2014
***************
*** 0 ****
--- 1,32 ----
+ SUBSUBMOD:=$(shell basename $(CURDIR)).a
+ #BINDIR = $(RIOTBASE)/bin/
+ SRC = $(wildcard *.c)
+ OBJ = $(SRC:%.c=$(BINDIR)%.o)
+ DEP = $(SRC:%.c=$(BINDIR)%.d)
+ 
+ INCLUDES += -I$(RIOTBASE) -I$(RIOTBASE)/sys/include -I$(RIOTBASE)/core/include -I$(RIOTBASE)/drivers/include -I$(RIOTBASE)/drivers/cc110x_ng/include -I$(RIOTBASE)/cpu/arm_common/include -I$(RIOTBASE)/sys/net/include/
+ INCLUDES += -I$(CURDIR)/02a-MAClow
+ INCLUDES += -I$(CURDIR)/02b-MAChigh
+ INCLUDES += -I$(CURDIR)/03a-IPHC
+ INCLUDES += -I$(CURDIR)/03b-IPv6
+ INCLUDES += -I$(CURDIR)/04-TRAN
+ INCLUDES += -I$(CURDIR)/cross-layers
+ 
+ .PHONY: $(BINDIR)$(SUBSUBMOD)
+ 
+ $(BINDIR)$(SUBSUBMOD): $(OBJ)
+ 	$(AD)$(AR) rcs $(BINDIR)$(MODULE) $(OBJ)
+ 
+ # pull in dependency info for *existing* .o files
+ -include $(OBJ:.o=.d)
+ 
+ # compile and generate dependency info
+ $(BINDIR)%.o: %.c
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -c $*.c -o $(BINDIR)$*.o
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -MM $*.c > $(BINDIR)$*.d
+ 	@printf "$(BINDIR)" | cat - $(BINDIR)$*.d > /tmp/riot_out && mv /tmp/riot_out $(BINDIR)$*.d
+ 
+ # remove compilation products
+ 
+ clean:
+ 	rm -f $(OBJ) $(DEP)
diff -crB stock/openwsn/07-App/udpstorm/udpstorm.c dev/openwsn/07-App/udpstorm/udpstorm.c
*** stock/openwsn/07-App/udpstorm/udpstorm.c	Tue Jan 28 12:35:56 2014
--- dev/openwsn/07-App/udpstorm/udpstorm.c	Wed Jan 29 10:33:22 2014
***************
*** 9,14 ****
--- 9,17 ----
  #include "scheduler.h"
  //#include "ADC_Channel.h"
  #include "IEEE802154E.h"
+ #include "idmanager.h"
+ 
+ #include "thread.h"
  
  //=========================== defines =========================================
  
***************
*** 33,52 ****
  } udpstorm_vars_t;
  
  udpstorm_vars_t udpstorm_vars;
! 
  //=========================== prototypes ======================================
  
! error_t udpstorm_receive(OpenQueueEntry_t* msg,
                           coap_header_iht*  coap_header,
                           coap_option_iht*  coap_options);
! void    udpstorm_timer_cb();
! void    udpstorm_task_cb();
  void    udpstorm_sendDone(OpenQueueEntry_t* msg,
!                           error_t           error);
  
  //=========================== public ==========================================
  
! void udpstorm_init() {
     // prepare the resource descriptor for the path
     udpstorm_vars.desc.path0len             = sizeof(udpstorm_path0)-1;
     udpstorm_vars.desc.path0val             = (uint8_t*)(&udpstorm_path0);
--- 36,55 ----
  } udpstorm_vars_t;
  
  udpstorm_vars_t udpstorm_vars;
! //static char openwsn_udpstorm_stack[KERNEL_CONF_STACKSIZE_MAIN];
  //=========================== prototypes ======================================
  
! owerror_t udpstorm_receive(OpenQueueEntry_t* msg,
                           coap_header_iht*  coap_header,
                           coap_option_iht*  coap_options);
! void    udpstorm_timer_cb(void);
! void    udpstorm_task_cb(void);
  void    udpstorm_sendDone(OpenQueueEntry_t* msg,
!                           owerror_t           error);
  
  //=========================== public ==========================================
  
! void udpstorm_init(void) {
     // prepare the resource descriptor for the path
     udpstorm_vars.desc.path0len             = sizeof(udpstorm_path0)-1;
     udpstorm_vars.desc.path0val             = (uint8_t*)(&udpstorm_path0);
***************
*** 65,71 ****
  
  //=========================== private =========================================
  
! error_t udpstorm_receive(OpenQueueEntry_t* msg,
                           coap_header_iht* coap_header,
                           coap_option_iht* coap_options) {
     return E_FAIL;
--- 68,74 ----
  
  //=========================== private =========================================
  
! owerror_t udpstorm_receive(OpenQueueEntry_t* msg,
                           coap_header_iht* coap_header,
                           coap_option_iht* coap_options) {
     return E_FAIL;
***************
*** 73,87 ****
  
  //timer fired, but we don't want to execute task in ISR mode
  //instead, push task to scheduler with CoAP priority, and let scheduler take care of it
! void udpstorm_timer_cb(){
!    scheduler_push_task(udpstorm_task_cb,TASKPRIO_COAP);
  }
  
! void udpstorm_task_cb() {
     OpenQueueEntry_t* pkt;
!    error_t           outcome;
     uint8_t           numOptions;
     
     if(udpstorm_vars.seqNum>=NUMPACKETS) {
        // we've sent enough packets
        
--- 76,103 ----
  
  //timer fired, but we don't want to execute task in ISR mode
  //instead, push task to scheduler with CoAP priority, and let scheduler take care of it
! void udpstorm_timer_cb(void){
!     scheduler_push_task(udpstorm_task_cb,TASKPRIO_COAP);
!    /*thread_create(openwsn_udpstorm_stack, KERNEL_CONF_STACKSIZE_MAIN, 
!                   PRIORITY_OPENWSN_UDPSTORM, CREATE_STACKTEST, 
!                   udpstorm_task_cb, "udpstorm task cb");*/
  }
  
! void udpstorm_task_cb(void) {
     OpenQueueEntry_t* pkt;
!    owerror_t           outcome;
     uint8_t           numOptions;
     
+    // don't run if not synch
+    if (ieee154e_isSynch() == FALSE) return;
+    
+    // don't run on dagroot
+    if (idmanager_getIsDAGroot()) {
+        opentimers_stop(udpstorm_vars.timerId);
+        return;
+    }
+    
+    
     if(udpstorm_vars.seqNum>=NUMPACKETS) {
        // we've sent enough packets
        
***************
*** 116,127 ****
     packetfunctions_reserveHeaderSize(pkt,sizeof(udpstorm_path0)-1);
     memcpy(&pkt->payload[0],&udpstorm_path0,sizeof(udpstorm_path0)-1);
     packetfunctions_reserveHeaderSize(pkt,1);
!    pkt->payload[0]                = (COAP_OPTION_LOCATIONPATH-COAP_OPTION_CONTENTTYPE) << 4 |
!                                      sizeof(udpstorm_path0)-1;
     numOptions++;
     // content-type option
     packetfunctions_reserveHeaderSize(pkt,2);
!    pkt->payload[0]                = COAP_OPTION_CONTENTTYPE << 4 |
        1;
     pkt->payload[1]                = COAP_MEDTYPE_APPOCTETSTREAM;
     numOptions++;
--- 132,143 ----
     packetfunctions_reserveHeaderSize(pkt,sizeof(udpstorm_path0)-1);
     memcpy(&pkt->payload[0],&udpstorm_path0,sizeof(udpstorm_path0)-1);
     packetfunctions_reserveHeaderSize(pkt,1);
!    pkt->payload[0]                = ((COAP_OPTION_NUM_URIPATH) << 4) |
!                                      (sizeof(udpstorm_path0)-1);
     numOptions++;
     // content-type option
     packetfunctions_reserveHeaderSize(pkt,2);
!    pkt->payload[0]                = COAP_OPTION_NUM_CONTENTFORMAT << 4 |
        1;
     pkt->payload[1]                = COAP_MEDTYPE_APPOCTETSTREAM;
     numOptions++;
***************
*** 147,152 ****
     udpstorm_vars.seqNum++;
  }
  
! void udpstorm_sendDone(OpenQueueEntry_t* msg, error_t error) {
     openqueue_freePacketBuffer(msg);
  }
\ No newline at end of file
--- 163,168 ----
     udpstorm_vars.seqNum++;
  }
  
! void udpstorm_sendDone(OpenQueueEntry_t* msg, owerror_t error) {
     openqueue_freePacketBuffer(msg);
  }
\ No newline at end of file
diff -crB stock/openwsn/07-App/udpstorm/udpstorm.h dev/openwsn/07-App/udpstorm/udpstorm.h
*** stock/openwsn/07-App/udpstorm/udpstorm.h	Tue Jan 28 12:35:57 2014
--- dev/openwsn/07-App/udpstorm/udpstorm.h	Wed Jan 29 10:33:22 2014
***************
*** 2,8 ****
  #define __UDPSTORM_H
  
  /**
! \addtogroup App
  \{
  \addtogroup udpStorm
  \{
--- 2,8 ----
  #define __UDPSTORM_H
  
  /**
! \addtogroup AppUdp
  \{
  \addtogroup udpStorm
  \{
***************
*** 16,22 ****
  
  //=========================== prototypes ======================================
  
! void udpstorm_init();
  
  /**
  \}
--- 16,22 ----
  
  //=========================== prototypes ======================================
  
! void udpstorm_init(void);
  
  /**
  \}
diff -crB stock/openwsn/Makefile dev/openwsn/Makefile
*** stock/openwsn/Makefile	Tue Jan 28 12:35:57 2014
--- dev/openwsn/Makefile	Wed Jan 29 10:33:22 2014
***************
*** 0 ****
--- 1,57 ----
+ export MODULE:=$(shell basename $(CURDIR)).a
+ #BINDIR = $(RIOTBASE)/bin/
+ SRC = $(wildcard *.c)
+ OBJ = $(SRC:%.c=$(BINDIR)%.o)
+ DEP = $(SRC:%.c=$(BINDIR)%.d)
+ 
+ INCLUDES += -I$(RIOTBASE) -I$(RIOTBASE)/sys/include -I$(RIOTBASE)/core/include -I$(RIOTBASE)/drivers/include -I$(RIOTBASE)/drivers/cc110x_ng/include -I$(RIOTBASE)/cpu/arm_common/include -I$(RIOTBASE)/cpu/msp430-common/include -I$(RIOTBASE)/sys/net/include/
+ 
+ INCLUDES += -I$(CURDIR)
+ INCLUDES += -I$(CURDIR)/02a-MAClow
+ INCLUDES += -I$(CURDIR)/02b-MAChigh
+ INCLUDES += -I$(CURDIR)/03a-IPHC
+ INCLUDES += -I$(CURDIR)/03b-IPv6
+ INCLUDES += -I$(CURDIR)/04-TRAN
+ INCLUDES += -I$(CURDIR)/cross-layers
+ INCLUDES += -I$(CURDIR)/07-App/rinfo
+ INCLUDES += -I$(CURDIR)/07-App/rwellknown
+ INCLUDES += -I$(CURDIR)/07-App/ohlone
+ INCLUDES += -I$(CURDIR)/07-App/tcpecho
+ INCLUDES += -I$(CURDIR)/07-App/tcpinject
+ INCLUDES += -I$(CURDIR)/07-App/tcpprint
+ INCLUDES += -I$(CURDIR)/07-App/udpecho
+ INCLUDES += -I$(CURDIR)/07-App/udpinject
+ INCLUDES += -I$(CURDIR)/07-App/udplatency
+ INCLUDES += -I$(CURDIR)/07-App/udpprint
+ INCLUDES += -I$(CURDIR)/07-App/udprand
+ INCLUDES += -I$(CURDIR)/07-App/udpstorm
+ 
+ 
+ DIRS =
+ DIRS += cross-layers
+ DIRS += 02a-MAClow
+ DIRS += 02b-MAChigh
+ DIRS += 03a-IPHC
+ DIRS += 03b-IPv6
+ DIRS += 04-TRAN
+ DIRS += 07-App
+ 
+ all: $(BINDIR)$(MODULE)
+ 	@for i in $(DIRS) ; do "$(MAKE)" -C $$i ; done ;
+ 
+ $(BINDIR)$(MODULE): $(OBJ)
+ 	$(AD)$(AR) rcs $(BINDIR)$(MODULE) $(OBJ)
+ 
+ # pull in dependency info for *existing* .o files
+ -include $(OBJ:.o=.d)
+ 
+ # compile and generate dependency info
+ $(BINDIR)%.o: %.c
+ 	mkdir -p $(BINDIR)
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -c $*.c -o $(BINDIR)$*.o
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -MM $*.c > $(BINDIR)$*.d
+ 	@printf "$(BINDIR)"|cat - $(BINDIR)$*.d > /tmp/riot_out && mv /tmp/riot_out $(BINDIR)$*.d
+ 
+ 
+ # remove compilation products
+ clean::
diff -crB stock/openwsn/board_info.h dev/openwsn/board_info.h
*** stock/openwsn/board_info.h	Tue Jan 28 12:35:57 2014
--- dev/openwsn/board_info.h	Wed Jan 29 10:33:22 2014
***************
*** 23,36 ****
  #define PRAGMA(x)  _Pragma(#x)
  #define PACK(x)     pack(x)
  
  #define INTERRUPT_DECLARATION()   __istate_t s;
  #define DISABLE_INTERRUPTS()      s = __get_interrupt_state(); \
!                                   __disable_interrupt();
  #define ENABLE_INTERRUPTS()       __set_interrupt_state(s);
  
  //===== timer
  
  #define PORT_TIMER_WIDTH                    uint16_t
  #define PORT_SIGNED_INT_WIDTH               int16_t
  #define PORT_TICS_PER_MS                    33
  
--- 23,49 ----
  #define PRAGMA(x)  _Pragma(#x)
  #define PACK(x)     pack(x)
  
+ //===== interrupt state
+ 
+ #if defined(__GNUC__) && (__GNUC__==4)  && (__GNUC_MINOR__<=5) && defined(__MSP430__)
+    // mspgcc <4.5.x
+ #define INTERRUPT_DECLARATION()   unsigned short s;
+ #define DISABLE_INTERRUPTS()      s = READ_SR&0x0008; \
+                                   __disable_interrupt();
+ #define ENABLE_INTERRUPTS()       __asm__("bis %0,r2" : : "ir" ((uint16_t) s));
+ #else
+    // other
  #define INTERRUPT_DECLARATION()   __istate_t s;
  #define DISABLE_INTERRUPTS()      s = __get_interrupt_state(); \
!                                    __disable_interrupt();
  #define ENABLE_INTERRUPTS()       __set_interrupt_state(s);
+ #endif
  
  //===== timer
  
  #define PORT_TIMER_WIDTH                    uint16_t
+ #define PORT_RADIOTIMER_WIDTH               uint16_t
+ 
  #define PORT_SIGNED_INT_WIDTH               int16_t
  #define PORT_TICS_PER_MS                    33
  
diff -crB stock/openwsn/board_ow.c dev/openwsn/board_ow.c
*** stock/openwsn/board_ow.c	Tue Jan 28 12:35:57 2014
--- dev/openwsn/board_ow.c	Wed Jan 29 10:33:22 2014
***************
*** 1,138 ****
- /**
- \brief TelosB-specific definition of the "board" bsp module.
- 
- \author Thomas Watteyne <watteyne@eecs.berkeley.edu>, February 2012.
- */
- 
  #include "msp430f1611.h"
! #include "board.h"
! // bsp modules
! #include "debugpins.h"
  #include "leds.h"
! #include "uart.h"
  #include "spi.h"
! #include "bsp_timer.h"
  #include "radio.h"
  #include "radiotimer.h"
  
! //=========================== variables =======================================
! 
! //=========================== prototypes ======================================
! 
! //=========================== main ============================================
! 
! extern int mote_main(void);
! int main(void) {
!    return mote_main();
! }
! 
! //=========================== public ==========================================
! 
! void board_init() {
!    // disable watchdog timer
     WDTCTL     =  WDTPW + WDTHOLD;
     
!    // setup clock speed
     DCOCTL    |=  DCO0 | DCO1 | DCO2;             // MCLK at ~8MHz
     BCSCTL1   |=  RSEL0 | RSEL1 | RSEL2;          // MCLK at ~8MHz
                                                   // by default, ACLK from 32kHz XTAL which is running
     
     // initialize pins
     P4DIR     |=  0x20;                           // [P4.5] radio VREG:  output
!    P4DIR     |=  0x40;                           // [P4.6] radio reset: output
     
     // initialize bsp modules
!    debugpins_init();
!    leds_init();
!    uart_init();
!    spi_init();
!    bsp_timer_init();
!    radio_init();
!    radiotimer_init();
     
     // enable interrupts
!    __bis_SR_register(GIE);
! }
! 
! void board_sleep() {
!    __bis_SR_register(GIE+LPM0_bits);             // sleep, but leave ACLK on
  }
  
  void board_reset() {
     WDTCTL = (WDTPW+0x1200) + WDTHOLD; // writing a wrong watchdog password to causes handler to reset
  }
  
! //=========================== private =========================================
! 
! //=========================== interrupt handlers ==============================
! 
! // DACDMA_VECTOR
! 
! // PORT2_VECTOR
! 
! #pragma vector = USART1TX_VECTOR
! __interrupt void USART1TX_ISR (void) {
!    debugpins_isr_set();
!    if (uart_tx_isr()==KICK_SCHEDULER) {          // UART; TX
!       __bic_SR_register_on_exit(CPUOFF);
!    }
!    debugpins_isr_clr();
! }
! 
! #pragma vector = USART1RX_VECTOR
! __interrupt void USART1RX_ISR (void) {
!    debugpins_isr_set();
!    if (uart_rx_isr()==KICK_SCHEDULER) {          // UART: RX
!       __bic_SR_register_on_exit(CPUOFF);
!    }
!    debugpins_isr_clr();
! }
! 
! // PORT1_VECTOR
! 
! // TIMERA1_VECTOR
! 
! #pragma vector = TIMERA0_VECTOR
! __interrupt void TIMERA0_ISR (void) {
!    debugpins_isr_set();
!    if (bsp_timer_isr()==KICK_SCHEDULER) {        // timer: 0
!       __bic_SR_register_on_exit(CPUOFF);
!    }
!    debugpins_isr_clr();
! }
! 
! // ADC12_VECTOR
! 
! // USART0TX_VECTOR
! 
! #pragma vector = USART0RX_VECTOR
! __interrupt void USART0RX_ISR (void) {
!    debugpins_isr_set();
!    if (spi_isr()==KICK_SCHEDULER) {              // SPI
!       __bic_SR_register_on_exit(CPUOFF);
!    }
!    debugpins_isr_clr();
! }
! 
! // WDT_VECTOR
! 
! #pragma vector = COMPARATORA_VECTOR
! __interrupt void COMPARATORA_ISR (void) {
!    debugpins_isr_set();
!    __bic_SR_register_on_exit(CPUOFF);            // restart CPU
!    debugpins_isr_clr();
  }
  
! #pragma vector = TIMERB1_VECTOR
! __interrupt void TIMERB1_ISR (void) {
!    debugpins_isr_set();
     if (radiotimer_isr()==KICK_SCHEDULER) {       // radiotimer
        __bic_SR_register_on_exit(CPUOFF);
     }
!    debugpins_isr_clr();
  }
  
! // TIMERB0_VECTOR
! 
! // NMI_VECTOR
! 
--- 1,65 ----
  #include "msp430f1611.h"
! #include "board_ow.h"
! 
  #include "leds.h"
! #include "uart_ow.h"
  #include "spi.h"
! //#include "bsp_timer.h"
  #include "radio.h"
  #include "radiotimer.h"
  
! void board_init_ow() {
!    puts(__PRETTY_FUNCTION__);
!    //disable watchdog timer
     WDTCTL     =  WDTPW + WDTHOLD;
     
!    //setup clock speed
     DCOCTL    |=  DCO0 | DCO1 | DCO2;             // MCLK at ~8MHz
     BCSCTL1   |=  RSEL0 | RSEL1 | RSEL2;          // MCLK at ~8MHz
                                                   // by default, ACLK from 32kHz XTAL which is running
     
     // initialize pins
     P4DIR     |=  0x20;                           // [P4.5] radio VREG:  output
!      P4DIR     |=  0x40;                           // [P4.6] radio reset: output
     
     // initialize bsp modules
!    // debugpins_init();
!     // leds_init();
!    // uart_init_ow();
!    // spi_init();
! //    bsp_timer_init();
! //    radio_init();
! //    radiotimer_init();
     
     // enable interrupts
!     // __bis_SR_register(GIE);
  }
  
  void board_reset() {
     WDTCTL = (WDTPW+0x1200) + WDTHOLD; // writing a wrong watchdog password to causes handler to reset
  }
  
! void board_sleep() {
!    __bis_SR_register(GIE+LPM0_bits);             // sleep, but leave ACLK on
  }
+ // ISR(COMPARATORA) {
+ //    //debugpins_isr_set();
+ //    __bic_SR_register_on_exit(CPUOFF);            // restart CPU
+ //    //debugpins_isr_clr();
+ // }
  
! ISR(TIMERB1) {
!    //debugpins_isr_set();
     if (radiotimer_isr()==KICK_SCHEDULER) {       // radiotimer
        __bic_SR_register_on_exit(CPUOFF);
     }
!    //debugpins_isr_clr();
  }
  
! // ISR(TIMERA0) {
! //    //debugpins_isr_set();
! //    if (bsp_timer_isr()==KICK_SCHEDULER) {        // timer: 0
! //       __bic_SR_register_on_exit(CPUOFF);
! //    }
! //    //debugpins_isr_clr();
! // }
diff -crB stock/openwsn/board_ow.h dev/openwsn/board_ow.h
*** stock/openwsn/board_ow.h	Tue Jan 28 12:35:57 2014
--- dev/openwsn/board_ow.h	Wed Jan 29 10:33:22 2014
***************
*** 1,12 ****
  /**
  \brief Cross-platform declaration "board" bsp module.
  
  \author Thomas Watteyne <watteyne@eecs.berkeley.edu>, February 2012.
  */
  
- #ifndef __BOARD_H
- #define __BOARD_H
- 
  #include "board_info.h"
  
  //=========================== define ==========================================
--- 1,17 ----
+ #ifndef __BOARD_H
+ #define __BOARD_H
+ 
  /**
+ \addtogroup BSP
+ \{
+ \addtogroup board
+ \{
+ 
  \brief Cross-platform declaration "board" bsp module.
  
  \author Thomas Watteyne <watteyne@eecs.berkeley.edu>, February 2012.
  */
  
  #include "board_info.h"
  
  //=========================== define ==========================================
***************
*** 16,29 ****
     KICK_SCHEDULER,
  } kick_scheduler_t;
  
  //=========================== typedef =========================================
  
  //=========================== variables =======================================
  
  //=========================== prototypes ======================================
  
! void board_init();
! void board_sleep();
! void board_reset();
  
  #endif
--- 21,49 ----
     KICK_SCHEDULER,
  } kick_scheduler_t;
  
+ #if defined(__GNUC__) && (__GNUC__==4)  && (__GNUC_MINOR__<=5) && defined(__MSP430__)
+    // mspgcc <4.5.x
+ #include <signal.h>
+ #define ISR(v) interrupt (v ## _VECTOR) v ## _ISR(void)
+ #else
+    // other
+ #define __PRAGMA__(x) _Pragma(#x)
+ #define ISR(v) __PRAGMA__(vector=v ##_VECTOR) __interrupt void v ##_ISR(void)
+ #endif
+ 
  //=========================== typedef =========================================
  
  //=========================== variables =======================================
  
  //=========================== prototypes ======================================
  
! void board_init_ow(void);
! void board_sleep(void);
! void board_reset(void);
! 
! /**
! \}
! \}
! */
  
  #endif
diff -crB stock/openwsn/cc2420.h dev/openwsn/cc2420.h
*** stock/openwsn/cc2420.h	Tue Jan 28 12:35:57 2014
--- dev/openwsn/cc2420.h	Wed Jan 29 10:33:22 2014
***************
*** 213,219 ****
  #define CC2420_MANFIDH_ADDR       0x1f
  typedef struct {
     uint16_t PARTNUM:12;
!    uint16_t VERSION:4;
  } cc2420_MANFIDH_reg_t;
  
  /// [R/W] Finite State Machine Time Constants
--- 213,219 ----
  #define CC2420_MANFIDH_ADDR       0x1f
  typedef struct {
     uint16_t PARTNUM:12;
!    uint16_t AVERSION:4; // collision with -DVERSION=$(GIT_VERSION)
  } cc2420_MANFIDH_reg_t;
  
  /// [R/W] Finite State Machine Time Constants
diff -crB stock/openwsn/cross-layers/Makefile dev/openwsn/cross-layers/Makefile
*** stock/openwsn/cross-layers/Makefile	Tue Jan 28 12:35:57 2014
--- dev/openwsn/cross-layers/Makefile	Wed Jan 29 10:33:22 2014
***************
*** 0 ****
--- 1,32 ----
+ SUBMOD:=$(shell basename $(CURDIR)).a
+ #BINDIR = $(RIOTBASE)/bin/
+ SRC = $(wildcard *.c)
+ OBJ = $(SRC:%.c=$(BINDIR)%.o)
+ DEP = $(SRC:%.c=$(BINDIR)%.d)
+ 
+ INCLUDES += -I$(RIOTBASE) -I$(RIOTBASE)/sys/include -I$(RIOTBASE)/core/include -I$(RIOTBASE)/drivers/include -I$(RIOTBASE)/drivers/cc110x_ng/include -I$(RIOTBASE)/cpu/arm_common/include -I$(RIOTBASE)/sys/net/include/
+ INCLUDES += -I$(CURDIR)/02a-MAClow
+ INCLUDES += -I$(CURDIR)/02b-MAChigh
+ INCLUDES += -I$(CURDIR)/03a-IPHC
+ INCLUDES += -I$(CURDIR)/03b-IPv6
+ INCLUDES += -I$(CURDIR)/04-TRAN
+ INCLUDES += -I$(CURDIR)/cross-layers
+ 
+ .PHONY: $(BINDIR)$(SUBMOD)
+ 
+ $(BINDIR)$(SUBMOD): $(OBJ)
+ 	$(AD)$(AR) rcs $(BINDIR)$(MODULE) $(OBJ)
+ 
+ # pull in dependency info for *existing* .o files
+ -include $(OBJ:.o=.d)
+ 
+ # compile and generate dependency info
+ $(BINDIR)%.o: %.c
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -c $*.c -o $(BINDIR)$*.o
+ 	$(AD)$(CC) $(CFLAGS) $(INCLUDES) $(BOARDINCLUDE) $(PROJECTINCLUDE) $(CPUINCLUDE) -MM $*.c > $(BINDIR)$*.d
+ 	@printf "$(BINDIR)" | cat - $(BINDIR)$*.d > /tmp/riot_out && mv /tmp/riot_out $(BINDIR)$*.d
+ 
+ # remove compilation products
+ 
+ clean:
+ 	rm -f $(OBJ) $(DEP)
diff -crB stock/openwsn/cross-layers/idmanager.c dev/openwsn/cross-layers/idmanager.c
*** stock/openwsn/cross-layers/idmanager.c	Tue Jan 28 12:35:57 2014
--- dev/openwsn/cross-layers/idmanager.c	Wed Jan 29 10:33:22 2014
***************
*** 7,28 ****
  
  //=========================== variables =======================================
  
- typedef struct {
-    bool          isDAGroot;
-    bool          isBridge;
-    open_addr_t   my16bID;
-    open_addr_t   my64bID;
-    open_addr_t   myPANID;
-    open_addr_t   myPrefix;
- } idmanager_vars_t;
- 
  idmanager_vars_t idmanager_vars;
  
  //=========================== prototypes ======================================
  
  //=========================== public ==========================================
  
! void idmanager_init() {
     idmanager_vars.isDAGroot            = FALSE;
     idmanager_vars.isBridge             = FALSE;
     idmanager_vars.myPANID.type         = ADDR_PANID;
--- 7,19 ----
  
  //=========================== variables =======================================
  
  idmanager_vars_t idmanager_vars;
  
  //=========================== prototypes ======================================
  
  //=========================== public ==========================================
  
! void idmanager_init(void) {
     idmanager_vars.isDAGroot            = FALSE;
     idmanager_vars.isBridge             = FALSE;
     idmanager_vars.myPANID.type         = ADDR_PANID;
***************
*** 28,54 ****
     idmanager_vars.myPANID.type         = ADDR_PANID;
     idmanager_vars.myPANID.panid[0]     = 0xca;
     idmanager_vars.myPANID.panid[1]     = 0xfe;
     idmanager_vars.myPrefix.type        = ADDR_PREFIX;
!    idmanager_vars.myPrefix.prefix[0]   = 0x00;
!    idmanager_vars.myPrefix.prefix[1]   = 0x00;
!    idmanager_vars.myPrefix.prefix[2]   = 0x00;
!    idmanager_vars.myPrefix.prefix[3]   = 0x00;
!    idmanager_vars.myPrefix.prefix[4]   = 0x00;
!    idmanager_vars.myPrefix.prefix[5]   = 0x00;
!    idmanager_vars.myPrefix.prefix[6]   = 0x00;
!    idmanager_vars.myPrefix.prefix[7]   = 0x00;
     idmanager_vars.my64bID.type         = ADDR_64B;
     eui64_get(idmanager_vars.my64bID.addr_64b);
     packetfunctions_mac64bToMac16b(&idmanager_vars.my64bID,&idmanager_vars.my16bID);
! 
!    // DEBUG_MOTEID_MASTER is DAGroot and bridge
!    if (idmanager_vars.my16bID.addr_16b[1]==DEBUG_MOTEID_MASTER) {
!       idmanager_vars.isDAGroot         = TRUE;
!       idmanager_vars.isBridge          = TRUE;
!    }
  }
  
! bool idmanager_getIsDAGroot() {
     bool res;
     INTERRUPT_DECLARATION();
     
--- 19,37 ----
     idmanager_vars.myPANID.type         = ADDR_PANID;
     idmanager_vars.myPANID.panid[0]     = 0xca;
     idmanager_vars.myPANID.panid[1]     = 0xfe;
+ 
     idmanager_vars.myPrefix.type        = ADDR_PREFIX;
!    memset(&idmanager_vars.myPrefix.prefix[0], 0x00, sizeof(idmanager_vars.myPrefix.prefix));
     idmanager_vars.my64bID.type         = ADDR_64B;
+ 
     eui64_get(idmanager_vars.my64bID.addr_64b);
     packetfunctions_mac64bToMac16b(&idmanager_vars.my64bID,&idmanager_vars.my16bID);
!    
! //   if(idmanager_vars.my16bID.addr_16b[1] == 0x0B)
! //     idmanager_setIsDAGroot(TRUE);
  }
  
! bool idmanager_getIsDAGroot(void) {
     bool res;
     INTERRUPT_DECLARATION();
     
***************
*** 66,72 ****
     ENABLE_INTERRUPTS();
  }
  
! bool idmanager_getIsBridge() {
     bool res;
     INTERRUPT_DECLARATION();
     DISABLE_INTERRUPTS();
--- 49,55 ----
     ENABLE_INTERRUPTS();
  }
  
! bool idmanager_getIsBridge(void) {
     bool res;
     INTERRUPT_DECLARATION();
     DISABLE_INTERRUPTS();
***************
*** 88,142 ****
     INTERRUPT_DECLARATION();
     DISABLE_INTERRUPTS();
     switch (type) {
!    case ADDR_16B:
!       res= &idmanager_vars.my16bID;
!       break;
!    case ADDR_64B:
!       res= &idmanager_vars.my64bID;
!       break;
!    case ADDR_PANID:
!       res= &idmanager_vars.myPANID;
!       break;
!    case ADDR_PREFIX:
!       res= &idmanager_vars.myPrefix;
!       break;
!    case ADDR_128B:
!       // you don't ask for my full address, rather for prefix, then 64b
!    default:
!       openserial_printCritical(COMPONENT_IDMANAGER,ERR_WRONG_ADDR_TYPE,
!             (errorparameter_t)type,
!             (errorparameter_t)0);
!       res= NULL;
!       break;
     }
     ENABLE_INTERRUPTS();
     return res;
  }
  
! error_t idmanager_setMyID(open_addr_t* newID) {
     INTERRUPT_DECLARATION();
     DISABLE_INTERRUPTS();
     switch (newID->type) {
!    case ADDR_16B:
!       memcpy(&idmanager_vars.my16bID,newID,sizeof(open_addr_t));
!       break;
!    case ADDR_64B:
!       memcpy(&idmanager_vars.my64bID,newID,sizeof(open_addr_t));
!       break;
!    case ADDR_PANID:
!       memcpy(&idmanager_vars.myPANID,newID,sizeof(open_addr_t));
!       break;
!    case ADDR_PREFIX:
!       memcpy(&idmanager_vars.myPrefix,newID,sizeof(open_addr_t));
!       break;
!    case ADDR_128B:
!       //don't set 128b, but rather prefix and 64b
!    default:
!       openserial_printCritical(COMPONENT_IDMANAGER,ERR_WRONG_ADDR_TYPE,
!             (errorparameter_t)newID->type,
!             (errorparameter_t)1);
!       ENABLE_INTERRUPTS();
!       return E_FAIL;
     }
     ENABLE_INTERRUPTS();
     return E_SUCCESS;
--- 71,125 ----
     INTERRUPT_DECLARATION();
     DISABLE_INTERRUPTS();
     switch (type) {
!      case ADDR_16B:
!         res= &idmanager_vars.my16bID;
!         break;
!      case ADDR_64B:
!         res= &idmanager_vars.my64bID;
!         break;
!      case ADDR_PANID:
!         res= &idmanager_vars.myPANID;
!         break;
!      case ADDR_PREFIX:
!         res= &idmanager_vars.myPrefix;
!         break;
!      case ADDR_128B:
!         // you don't ask for my full address, rather for prefix, then 64b
!      default:
!         openserial_printCritical(COMPONENT_IDMANAGER,ERR_WRONG_ADDR_TYPE,
!               (errorparameter_t)type,
!               (errorparameter_t)0);
!         res= NULL;
!         break;
     }
     ENABLE_INTERRUPTS();
     return res;
  }
  
! owerror_t idmanager_setMyID(open_addr_t* newID) {
     INTERRUPT_DECLARATION();
     DISABLE_INTERRUPTS();
     switch (newID->type) {
!      case ADDR_16B:
!         memcpy(&idmanager_vars.my16bID,newID,sizeof(open_addr_t));
!         break;
!      case ADDR_64B:
!         memcpy(&idmanager_vars.my64bID,newID,sizeof(open_addr_t));
!         break;
!      case ADDR_PANID:
!         memcpy(&idmanager_vars.myPANID,newID,sizeof(open_addr_t));
!         break;
!      case ADDR_PREFIX:
!         memcpy(&idmanager_vars.myPrefix,newID,sizeof(open_addr_t));
!         break;
!      case ADDR_128B:
!         //don't set 128b, but rather prefix and 64b
!      default:
!         openserial_printCritical(COMPONENT_IDMANAGER,ERR_WRONG_ADDR_TYPE,
!               (errorparameter_t)newID->type,
!               (errorparameter_t)1);
!         ENABLE_INTERRUPTS();
!         return E_FAIL;
     }
     ENABLE_INTERRUPTS();
     return E_SUCCESS;
***************
*** 149,192 ****
     DISABLE_INTERRUPTS();
  
     switch (addr->type) {
!    case ADDR_16B:
!       res= packetfunctions_sameAddress(addr,&idmanager_vars.my16bID);
!       ENABLE_INTERRUPTS();
!       return res;
!    case ADDR_64B:
!       res= packetfunctions_sameAddress(addr,&idmanager_vars.my64bID);
!       ENABLE_INTERRUPTS();
!       return res;
!    case ADDR_128B:
!       //build temporary my128bID
!       temp_my128bID.type = ADDR_128B;
!       memcpy(&temp_my128bID.addr_128b[0],&idmanager_vars.myPrefix.prefix,8);
!       memcpy(&temp_my128bID.addr_128b[8],&idmanager_vars.my64bID.addr_64b,8);
! 
!       res= packetfunctions_sameAddress(addr,&temp_my128bID);
!       ENABLE_INTERRUPTS();
!       return res;
!    case ADDR_PANID:
!       res= packetfunctions_sameAddress(addr,&idmanager_vars.myPANID);
!       ENABLE_INTERRUPTS();
!       return res;
!    case ADDR_PREFIX:
!       res= packetfunctions_sameAddress(addr,&idmanager_vars.myPrefix);
!       ENABLE_INTERRUPTS();
!       return res;
!    default:
!       openserial_printCritical(COMPONENT_IDMANAGER,ERR_WRONG_ADDR_TYPE,
!             (errorparameter_t)addr->type,
!             (errorparameter_t)2);
!       ENABLE_INTERRUPTS();
!       return FALSE;
     }
  }
  
! void idmanager_triggerAboutRoot() {
     uint8_t number_bytes_from_input_buffer;
     uint8_t input_buffer;
!    //get command from OpenSerial
     number_bytes_from_input_buffer = openserial_getInputBuffer(&input_buffer,sizeof(input_buffer));
     if (number_bytes_from_input_buffer!=sizeof(input_buffer)) {
        openserial_printError(COMPONENT_IDMANAGER,ERR_INPUTBUFFER_LENGTH,
--- 132,175 ----
     DISABLE_INTERRUPTS();
  
     switch (addr->type) {
!      case ADDR_16B:
!         res= packetfunctions_sameAddress(addr,&idmanager_vars.my16bID);
!         ENABLE_INTERRUPTS();
!         return res;
!      case ADDR_64B:
!         res= packetfunctions_sameAddress(addr,&idmanager_vars.my64bID);
!         ENABLE_INTERRUPTS();
!         return res;
!      case ADDR_128B:
!         //build temporary my128bID
!         temp_my128bID.type = ADDR_128B;
!         memcpy(&temp_my128bID.addr_128b[0],&idmanager_vars.myPrefix.prefix,8);
!         memcpy(&temp_my128bID.addr_128b[8],&idmanager_vars.my64bID.addr_64b,8);
! 
!         res= packetfunctions_sameAddress(addr,&temp_my128bID);
!         ENABLE_INTERRUPTS();
!         return res;
!      case ADDR_PANID:
!         res= packetfunctions_sameAddress(addr,&idmanager_vars.myPANID);
!         ENABLE_INTERRUPTS();
!         return res;
!      case ADDR_PREFIX:
!         res= packetfunctions_sameAddress(addr,&idmanager_vars.myPrefix);
!         ENABLE_INTERRUPTS();
!         return res;
!      default:
!         openserial_printCritical(COMPONENT_IDMANAGER,ERR_WRONG_ADDR_TYPE,
!               (errorparameter_t)addr->type,
!               (errorparameter_t)2);
!         ENABLE_INTERRUPTS();
!         return FALSE;
     }
  }
  
! void idmanager_triggerAboutRoot(void) {
     uint8_t number_bytes_from_input_buffer;
     uint8_t input_buffer;
!    // get command from OpenSerial
     number_bytes_from_input_buffer = openserial_getInputBuffer(&input_buffer,sizeof(input_buffer));
     if (number_bytes_from_input_buffer!=sizeof(input_buffer)) {
        openserial_printError(COMPONENT_IDMANAGER,ERR_INPUTBUFFER_LENGTH,
***************
*** 194,246 ****
              (errorparameter_t)0);
        return;
     };
!    //handle command
     switch (input_buffer) {
!    case 'Y':
!       idmanager_setIsDAGroot(TRUE);
!       break;
!    case 'N':
!       idmanager_setIsDAGroot(FALSE);
!       break;
!    case 'T':
!       if (idmanager_getIsDAGroot()) {
!          idmanager_setIsDAGroot(FALSE);
!       } else {
!          idmanager_setIsDAGroot(TRUE);
!       }
!       break;
     }
     return;
  }
  
! void idmanager_triggerAboutBridge() {
     uint8_t number_bytes_from_input_buffer;
!    uint8_t input_buffer[9];
!    //get command from OpenSerial (1B command, 8B prefix)
!    number_bytes_from_input_buffer = openserial_getInputBuffer(&input_buffer[0],sizeof(input_buffer));
     if (number_bytes_from_input_buffer!=sizeof(input_buffer)) {
        openserial_printError(COMPONENT_IDMANAGER,ERR_INPUTBUFFER_LENGTH,
              (errorparameter_t)number_bytes_from_input_buffer,
!             (errorparameter_t)0);
        return;
     };
     //handle command
!    switch (input_buffer[0]) {
!    case 'Y':
!       idmanager_setIsBridge(TRUE);
!       memcpy(&(idmanager_vars.myPrefix.prefix),&(input_buffer[1]),8);
!       break;
!    case 'N':
!       idmanager_setIsBridge(FALSE);
!       break;
!    case 'T':
!       if (idmanager_getIsBridge()) {
!          idmanager_setIsBridge(FALSE);
!       } else {
!          idmanager_setIsBridge(TRUE);
!          memcpy(&(idmanager_vars.myPrefix.prefix),&(input_buffer[1]),8);
!       }
!       break;
     }
     return;
  }
--- 177,227 ----
              (errorparameter_t)0);
        return;
     };
!    // handle command
     switch (input_buffer) {
!      case ACTION_YES:
!         idmanager_setIsDAGroot(TRUE);
!         break;
!      case ACTION_NO:
!         idmanager_setIsDAGroot(FALSE);
!         break;
!      case ACTION_TOGGLE:
!         if (idmanager_getIsDAGroot()) {
!            idmanager_setIsDAGroot(FALSE);
!         } else {
!            idmanager_setIsDAGroot(TRUE);
!         }
!         break;
     }
     return;
  }
  
! void idmanager_triggerAboutBridge(void) {
     uint8_t number_bytes_from_input_buffer;
!    uint8_t input_buffer;
!    //get command from OpenSerial
!    number_bytes_from_input_buffer = openserial_getInputBuffer(&input_buffer,sizeof(input_buffer));
     if (number_bytes_from_input_buffer!=sizeof(input_buffer)) {
        openserial_printError(COMPONENT_IDMANAGER,ERR_INPUTBUFFER_LENGTH,
              (errorparameter_t)number_bytes_from_input_buffer,
!             (errorparameter_t)1);
        return;
     };
     //handle command
!    switch (input_buffer) {
!      case ACTION_YES:
!         idmanager_setIsBridge(TRUE);
!         break;
!      case ACTION_NO:
!         idmanager_setIsBridge(FALSE);
!         break;
!      case ACTION_TOGGLE:
!         if (idmanager_getIsBridge()) {
!            idmanager_setIsBridge(FALSE);
!         } else {
!            idmanager_setIsBridge(TRUE);
!         }
!         break;
     }
     return;
  }
***************
*** 253,259 ****
  
  \returns TRUE if this function printed something, FALSE otherwise.
  */
! bool debugPrint_id() {
     debugIDManagerEntry_t output;
     output.isDAGroot = idmanager_vars.isDAGroot;
     output.isBridge  = idmanager_vars.isBridge;
--- 234,240 ----
  
  \returns TRUE if this function printed something, FALSE otherwise.
  */
! bool debugPrint_id(void) {
     debugIDManagerEntry_t output;
     output.isDAGroot = idmanager_vars.isDAGroot;
     output.isBridge  = idmanager_vars.isBridge;
diff -crB stock/openwsn/cross-layers/idmanager.h dev/openwsn/cross-layers/idmanager.h
*** stock/openwsn/cross-layers/idmanager.h	Tue Jan 28 12:35:57 2014
--- dev/openwsn/cross-layers/idmanager.h	Wed Jan 29 10:33:22 2014
***************
*** 12,17 ****
--- 12,21 ----
  
  //=========================== define ==========================================
  
+ #define ACTION_YES      'Y'
+ #define ACTION_NO       'N'
+ #define ACTION_TOGGLE   'T'
+ 
  //=========================== typedef =========================================
  
  typedef struct {
***************
*** 23,44 ****
     open_addr_t   myPrefix;
  } debugIDManagerEntry_t;
  
! //=========================== variables =======================================
  
  //=========================== prototypes ======================================
  
! void         idmanager_init();
! bool         idmanager_getIsDAGroot();
  void         idmanager_setIsDAGroot(bool newRole);
! bool         idmanager_getIsBridge();
  void         idmanager_setIsBridge(bool newRole);
  open_addr_t* idmanager_getMyID(uint8_t type);
! error_t      idmanager_setMyID(open_addr_t* newID);
  bool         idmanager_isMyAddress(open_addr_t* addr);
! void         idmanager_triggerAboutRoot();
! void         idmanager_triggerAboutBridge();
  
! bool         debugPrint_id();
  
  
  /**
--- 27,57 ----
     open_addr_t   myPrefix;
  } debugIDManagerEntry_t;
  
! //=========================== module variables ================================
! 
! typedef struct {
!    bool          isDAGroot;
!    bool          isBridge;
!    open_addr_t   my16bID;
!    open_addr_t   my64bID;
!    open_addr_t   myPANID;
!    open_addr_t   myPrefix;
! } idmanager_vars_t;
  
  //=========================== prototypes ======================================
  
! void         idmanager_init(void);
! bool         idmanager_getIsDAGroot(void);
  void         idmanager_setIsDAGroot(bool newRole);
! bool         idmanager_getIsBridge(void);
  void         idmanager_setIsBridge(bool newRole);
  open_addr_t* idmanager_getMyID(uint8_t type);
! owerror_t      idmanager_setMyID(open_addr_t* newID);
  bool         idmanager_isMyAddress(open_addr_t* addr);
! void         idmanager_triggerAboutRoot(void);
! void         idmanager_triggerAboutBridge(void);
  
! bool         debugPrint_id(void);
  
  
  /**
diff -crB stock/openwsn/cross-layers/openqueue.c dev/openwsn/cross-layers/openqueue.c
*** stock/openwsn/cross-layers/openqueue.c	Tue Jan 28 12:35:57 2014
--- dev/openwsn/cross-layers/openqueue.c	Wed Jan 29 10:33:22 2014
***************
*** 6,15 ****
  
  //=========================== variables =======================================
  
- typedef struct {
-    OpenQueueEntry_t queue[QUEUELENGTH];
- } openqueue_vars_t;
- 
  openqueue_vars_t openqueue_vars;
  
  //=========================== prototypes ======================================
--- 6,11 ----
***************
*** 23,29 ****
  /**
  \brief Initialize this module.
  */
! void openqueue_init() {
     uint8_t i;
     for (i=0;i<QUEUELENGTH;i++){
        openqueue_reset_entry(&(openqueue_vars.queue[i]));
--- 19,25 ----
  /**
  \brief Initialize this module.
  */
! void openqueue_init(void) {
     uint8_t i;
     for (i=0;i<QUEUELENGTH;i++){
        openqueue_reset_entry(&(openqueue_vars.queue[i]));
***************
*** 38,44 ****
  
  \returns TRUE if this function printed something, FALSE otherwise.
  */
! bool debugPrint_queue() {
     debugOpenQueueEntry_t output[QUEUELENGTH];
     uint8_t i;
     for (i=0;i<QUEUELENGTH;i++) {
--- 34,40 ----
  
  \returns TRUE if this function printed something, FALSE otherwise.
  */
! bool debugPrint_queue(void) {
     debugOpenQueueEntry_t output[QUEUELENGTH];
     uint8_t i;
     for (i=0;i<QUEUELENGTH;i++) {
***************
*** 98,104 ****
  \returns E_SUCCESS when the freeing was succeful.
  \returns E_FAIL when the module could not find the specified packet buffer.
  */
! error_t openqueue_freePacketBuffer(OpenQueueEntry_t* pkt) {
     uint8_t i;
     INTERRUPT_DECLARATION();
     DISABLE_INTERRUPTS();
--- 94,100 ----
  \returns E_SUCCESS when the freeing was succeful.
  \returns E_FAIL when the module could not find the specified packet buffer.
  */
! owerror_t openqueue_freePacketBuffer(OpenQueueEntry_t* pkt) {
     uint8_t i;
     INTERRUPT_DECLARATION();
     DISABLE_INTERRUPTS();
***************
*** 126,132 ****
  /**
  \brief Free all the packet buffers created by a specific module.
  
! \param owner The identifier of the component, taken in COMPONENT_*.
  */
  void openqueue_removeAllCreatedBy(uint8_t creator) {
     uint8_t i;
--- 122,128 ----
  /**
  \brief Free all the packet buffers created by a specific module.
  
! \param creator The identifier of the component, taken in COMPONENT_*.
  */
  void openqueue_removeAllCreatedBy(uint8_t creator) {
     uint8_t i;
***************
*** 159,165 ****
  
  //======= called by RES
  
! OpenQueueEntry_t* openqueue_resGetSentPacket() {
     uint8_t i;
     INTERRUPT_DECLARATION();
     DISABLE_INTERRUPTS();
--- 155,161 ----
  
  //======= called by RES
  
! OpenQueueEntry_t* openqueue_resGetSentPacket(void) {
     uint8_t i;
     INTERRUPT_DECLARATION();
     DISABLE_INTERRUPTS();
***************
*** 174,180 ****
     return NULL;
  }
  
! OpenQueueEntry_t* openqueue_resGetReceivedPacket() {
     uint8_t i;
     INTERRUPT_DECLARATION();
     DISABLE_INTERRUPTS();
--- 170,176 ----
     return NULL;
  }
  
! OpenQueueEntry_t* openqueue_resGetReceivedPacket(void) {
     uint8_t i;
     INTERRUPT_DECLARATION();
     DISABLE_INTERRUPTS();
***************
*** 225,231 ****
     return NULL;
  }
  
! OpenQueueEntry_t* openqueue_macGetAdvPacket() {
     uint8_t i;
     INTERRUPT_DECLARATION();
     DISABLE_INTERRUPTS();
--- 221,227 ----
     return NULL;
  }
  
! OpenQueueEntry_t* openqueue_macGetAdvPacket(void) {
     uint8_t i;
     INTERRUPT_DECLARATION();
     DISABLE_INTERRUPTS();
diff -crB stock/openwsn/cross-layers/openqueue.h dev/openwsn/cross-layers/openqueue.h
*** stock/openwsn/cross-layers/openqueue.h	Tue Jan 28 12:35:57 2014
--- dev/openwsn/cross-layers/openqueue.h	Wed Jan 29 10:33:22 2014
***************
*** 22,45 ****
     uint8_t  owner;
  } debugOpenQueueEntry_t;
  
! //=========================== variables =======================================
  
  //=========================== prototypes ======================================
  
  // admin
! void               openqueue_init();
! bool               debugPrint_queue();
  // called by any component
  OpenQueueEntry_t*  openqueue_getFreePacketBuffer(uint8_t creator);
! error_t            openqueue_freePacketBuffer(OpenQueueEntry_t* pkt);
  void               openqueue_removeAllCreatedBy(uint8_t creator);
  void               openqueue_removeAllOwnedBy(uint8_t owner);
  // called by res
! OpenQueueEntry_t*  openqueue_resGetSentPacket();
! OpenQueueEntry_t*  openqueue_resGetReceivedPacket();
  // called by IEEE80215E
  OpenQueueEntry_t*  openqueue_macGetDataPacket(open_addr_t* toNeighbor);
! OpenQueueEntry_t*  openqueue_macGetAdvPacket();
  
  /**
  \}
--- 22,49 ----
     uint8_t  owner;
  } debugOpenQueueEntry_t;
  
! //=========================== module variables ================================
! 
! typedef struct {
!    OpenQueueEntry_t queue[QUEUELENGTH];
! } openqueue_vars_t;
  
  //=========================== prototypes ======================================
  
  // admin
! void               openqueue_init(void);
! bool               debugPrint_queue(void);
  // called by any component
  OpenQueueEntry_t*  openqueue_getFreePacketBuffer(uint8_t creator);
! owerror_t         openqueue_freePacketBuffer(OpenQueueEntry_t* pkt);
  void               openqueue_removeAllCreatedBy(uint8_t creator);
  void               openqueue_removeAllOwnedBy(uint8_t owner);
  // called by res
! OpenQueueEntry_t*  openqueue_resGetSentPacket(void);
! OpenQueueEntry_t*  openqueue_resGetReceivedPacket(void);
  // called by IEEE80215E
  OpenQueueEntry_t*  openqueue_macGetDataPacket(open_addr_t* toNeighbor);
! OpenQueueEntry_t*  openqueue_macGetAdvPacket(void);
  
  /**
  \}
diff -crB stock/openwsn/cross-layers/openrandom.c dev/openwsn/cross-layers/openrandom.c
*** stock/openwsn/cross-layers/openrandom.c	Tue Jan 28 12:35:57 2014
--- dev/openwsn/cross-layers/openrandom.c	Wed Jan 29 10:33:22 2014
***************
*** 4,27 ****
  
  //=========================== variables =======================================
  
- typedef struct {
-    uint16_t shift_reg;  // Galois shift register used to obtain a pseudo-random number
- } random_vars_t;
- 
  random_vars_t random_vars;
  
  //=========================== prototypes ======================================
  
  //=========================== public ==========================================
  
! void openrandom_init() {
     // seed the random number generator with the last 2 bytes of the MAC address
     random_vars.shift_reg  = 0;
     random_vars.shift_reg += idmanager_getMyID(ADDR_16B)->addr_16b[0]*256;
     random_vars.shift_reg += idmanager_getMyID(ADDR_16B)->addr_16b[1];
  }
  
! uint16_t openrandom_get16b() {
     uint8_t  i;
     uint16_t random_value;
     random_value = 0;
--- 4,23 ----
  
  //=========================== variables =======================================
  
  random_vars_t random_vars;
  
  //=========================== prototypes ======================================
  
  //=========================== public ==========================================
  
! void openrandom_init(void) {
     // seed the random number generator with the last 2 bytes of the MAC address
     random_vars.shift_reg  = 0;
     random_vars.shift_reg += idmanager_getMyID(ADDR_16B)->addr_16b[0]*256;
     random_vars.shift_reg += idmanager_getMyID(ADDR_16B)->addr_16b[1];
  }
  
! uint16_t openrandom_get16b(void) {
     uint8_t  i;
     uint16_t random_value;
     random_value = 0;
diff -crB stock/openwsn/cross-layers/openrandom.h dev/openwsn/cross-layers/openrandom.h
*** stock/openwsn/cross-layers/openrandom.h	Tue Jan 28 12:35:57 2014
--- dev/openwsn/cross-layers/openrandom.h	Wed Jan 29 10:33:22 2014
***************
*** 2,10 ****
  #define __OPENRANDOM_H
  
  /**
! \addtogroup helpers
  \{
! \addtogroup Random
  \{
  */
  
--- 2,10 ----
  #define __OPENRANDOM_H
  
  /**
! \addtogroup cross-layers
  \{
! \addtogroup OpenRandom
  \{
  */
  
***************
*** 14,25 ****
  
  //=========================== typedef =========================================
  
! //=========================== variables =======================================
  
  //=========================== prototypes ======================================
  
! void     openrandom_init();
! uint16_t openrandom_get16b();
  
  /**
  \}
--- 14,29 ----
  
  //=========================== typedef =========================================
  
! //=========================== module variables ================================
! 
! typedef struct {
!    uint16_t shift_reg;  // Galois shift register used to obtain a pseudo-random number
! } random_vars_t;
  
  //=========================== prototypes ======================================
  
! void     openrandom_init(void);
! uint16_t openrandom_get16b(void);
  
  /**
  \}
diff -crB stock/openwsn/cross-layers/packetfunctions.c dev/openwsn/cross-layers/packetfunctions.c
*** stock/openwsn/cross-layers/packetfunctions.c	Tue Jan 28 12:35:57 2014
--- dev/openwsn/cross-layers/packetfunctions.c	Wed Jan 29 10:33:22 2014
***************
*** 178,185 ****
--- 178,187 ----
           address_length = 8;
           break;
        case ADDR_128B:
+       case ADDR_ANYCAST:
           address_length = 16;
           break;
+     
        default:
           openserial_printCritical(COMPONENT_PACKETFUNCTIONS,ERR_WRONG_ADDR_TYPE,
                                 (errorparameter_t)address_1->type,
***************
*** 267,273 ****
     pkt->payload -= header_length;
     pkt->length  += header_length;
     if ( (uint8_t*)(pkt->payload) < (uint8_t*)(pkt->packet) ) {
!       openserial_printError(COMPONENT_PACKETFUNCTIONS,ERR_HEADER_TOO_LONG,
                              (errorparameter_t)0,
                              (errorparameter_t)pkt->length);
     }
--- 269,275 ----
     pkt->payload -= header_length;
     pkt->length  += header_length;
     if ( (uint8_t*)(pkt->payload) < (uint8_t*)(pkt->packet) ) {
!       openserial_printCritical(COMPONENT_PACKETFUNCTIONS,ERR_HEADER_TOO_LONG,
                              (errorparameter_t)0,
                              (errorparameter_t)pkt->length);
     }
***************
*** 352,399 ****
  //see http://www-net.cs.umass.edu/kurose/transport/UDP.html, or http://tools.ietf.org/html/rfc1071
  //see http://en.wikipedia.org/wiki/User_Datagram_Protocol#IPv6_PSEUDO-HEADER
  void packetfunctions_calculateChecksum(OpenQueueEntry_t* msg, uint8_t* checksum_ptr) {
-    open_addr_t  temp_dest_prefix;
-    open_addr_t  temp_dest_mac64b;
     uint8_t temp_checksum[2];
     uint8_t little_helper[2];
!    //initialization
     temp_checksum[0]  = 0;
     temp_checksum[1]  = 0;
!    *checksum_ptr     = 0;
!    *(checksum_ptr+1) = 0;
!    //source/destination address
!    packetfunctions_ip128bToMac64b(&(msg->l3_destinationAdd),&temp_dest_prefix,&temp_dest_mac64b);
!    if (packetfunctions_sameAddress(&temp_dest_prefix,idmanager_getMyID(ADDR_PREFIX))) {
!       little_helper[0] = 0xfe;
!       little_helper[1] = 0x80;
!       //source address prefix
!       onesComplementSum(temp_checksum,little_helper,2);
!       //source address EUI
!       onesComplementSum(temp_checksum,(idmanager_getMyID(ADDR_64B))->addr_64b,8);
!       //destination address prefix (fe:80)
!       onesComplementSum(temp_checksum,little_helper,2);
!       //destination address EUI
!       onesComplementSum(temp_checksum,temp_dest_mac64b.addr_64b,8);
!    } else {
!       //source address prefix
!       onesComplementSum(temp_checksum,(idmanager_getMyID(ADDR_PREFIX))->prefix,8);
!       //source address EUI
!       onesComplementSum(temp_checksum,(idmanager_getMyID(ADDR_64B))->addr_64b,8);
!       //destination address
!       onesComplementSum(temp_checksum,msg->l3_destinationAdd.addr_128b,16);
!    }
!    //length
     little_helper[0] = 0;
     little_helper[1] = msg->length;
     onesComplementSum(temp_checksum,little_helper,2);
!    //next header
     little_helper[0] = 0;
     little_helper[1] = msg->l4_protocol;
     onesComplementSum(temp_checksum,little_helper,2);
!    //ICMPv6 packet
     onesComplementSum(temp_checksum,msg->payload,msg->length);
     temp_checksum[0] ^= 0xFF;
     temp_checksum[1] ^= 0xFF;
     //write in packet
     *checksum_ptr     = temp_checksum[0];
     *(checksum_ptr+1) = temp_checksum[1];
--- 354,395 ----
  //see http://www-net.cs.umass.edu/kurose/transport/UDP.html, or http://tools.ietf.org/html/rfc1071
  //see http://en.wikipedia.org/wiki/User_Datagram_Protocol#IPv6_PSEUDO-HEADER
  void packetfunctions_calculateChecksum(OpenQueueEntry_t* msg, uint8_t* checksum_ptr) {
     uint8_t temp_checksum[2];
     uint8_t little_helper[2];
!    
!    // initialize running checksum
     temp_checksum[0]  = 0;
     temp_checksum[1]  = 0;
!    
!    //===== IPv6 pseudo header
!    
!    // source address (prefix and EUI64)
!    onesComplementSum(temp_checksum,(idmanager_getMyID(ADDR_PREFIX))->prefix,8);
!    onesComplementSum(temp_checksum,(idmanager_getMyID(ADDR_64B))->addr_64b,8);
!    
!    // destination address
!    onesComplementSum(temp_checksum,msg->l3_destinationAdd.addr_128b,16);
!    
!    // length
     little_helper[0] = 0;
     little_helper[1] = msg->length;
     onesComplementSum(temp_checksum,little_helper,2);
!    
!    // next header
     little_helper[0] = 0;
     little_helper[1] = msg->l4_protocol;
     onesComplementSum(temp_checksum,little_helper,2);
!    
!    //===== payload
!    
!    // reset the checksum currently in the payload
!    *checksum_ptr     = 0;
!    *(checksum_ptr+1) = 0;
!    
     onesComplementSum(temp_checksum,msg->payload,msg->length);
     temp_checksum[0] ^= 0xFF;
     temp_checksum[1] ^= 0xFF;
+    
     //write in packet
     *checksum_ptr     = temp_checksum[0];
     *(checksum_ptr+1) = temp_checksum[1];
diff -crB stock/openwsn/cross-layers/packetfunctions.h dev/openwsn/cross-layers/packetfunctions.h
*** stock/openwsn/cross-layers/packetfunctions.h	Tue Jan 28 12:35:57 2014
--- dev/openwsn/cross-layers/packetfunctions.h	Wed Jan 29 10:33:22 2014
***************
*** 2,8 ****
  #define __PACKETFUNCTIONS_H
  
  /**
! \addtogroup helpers
  \{
  \addtogroup PacketFunctions
  \{
--- 2,8 ----
  #define __PACKETFUNCTIONS_H
  
  /**
! \addtogroup cross-layers
  \{
  \addtogroup PacketFunctions
  \{
diff -crB stock/openwsn/debugpins.c dev/openwsn/debugpins.c
*** stock/openwsn/debugpins.c	Tue Jan 28 12:35:57 2014
--- dev/openwsn/debugpins.c	Wed Jan 29 10:33:22 2014
***************
*** 3,9 ****
  
  \author Thomas Watteyne <watteyne@eecs.berkeley.edu>, February 2012.
  */
! 
  #include "msp430f1611.h"
  #include "debugpins.h"
  
--- 3,9 ----
  
  \author Thomas Watteyne <watteyne@eecs.berkeley.edu>, February 2012.
  */
! #include <stdint.h>               // needed for uin8_t, uint16_t
  #include "msp430f1611.h"
  #include "debugpins.h"
  
***************
*** 15,21 ****
  
  //=========================== public ==========================================
  
! void debugpins_init() {
     P6DIR |=  0x40;      // frame [P6.6]
     P6DIR |=  0x80;      // slot  [P6.7]
     P2DIR |=  0x08;      // fsm   [P2.3]
--- 15,21 ----
  
  //=========================== public ==========================================
  
! void debugpins_init(void) {
     P6DIR |=  0x40;      // frame [P6.6]
     P6DIR |=  0x80;      // slot  [P6.7]
     P2DIR |=  0x08;      // fsm   [P2.3]
***************
*** 25,93 ****
  }
  
  // P6.6
! void debugpins_frame_toggle() {
     P6OUT ^=  0x40;
  }
! void debugpins_frame_clr() {
     P6OUT &= ~0x40;
  }
! void debugpins_frame_set() {
     P6OUT |=  0x40;
  }
  
  // P6.7
! void debugpins_slot_toggle() {
     P6OUT ^=  0x80;
  }
! void debugpins_slot_clr() {
     P6OUT &= ~0x80;
  }
! void debugpins_slot_set() {
     P6OUT |=  0x80;
  }
  
  // P2.3
! void debugpins_fsm_toggle() {
     P2OUT ^=  0x08;
  }
! void debugpins_fsm_clr() {
     P2OUT &= ~0x08;
  }
! void debugpins_fsm_set() {
     P2OUT |=  0x08;
  }
  
  // P2.6
! void debugpins_task_toggle() {
     P2OUT ^=  0x40;
  }
! void debugpins_task_clr() {
     P2OUT &= ~0x40;
  }
! void debugpins_task_set() {
     P2OUT |=  0x40;
  }
  
  // P6.0
! void debugpins_isr_toggle() {
     P6OUT ^=  0x01;
  }
! void debugpins_isr_clr() {
     P6OUT &= ~0x01;
  }
! void debugpins_isr_set() {
     P6OUT |=  0x01;
  }
  
  // P6.1
! void debugpins_radio_toggle() {
     P6OUT ^=  0x02;
  }
! void debugpins_radio_clr() {
     P6OUT &= ~0x02;
  }
! void debugpins_radio_set() {
     P6OUT |=  0x02;
  }
  
  //=========================== private =========================================
\ No newline at end of file
--- 25,110 ----
  }
  
  // P6.6
! void debugpins_frame_toggle(void) {
     P6OUT ^=  0x40;
  }
! void debugpins_frame_clr(void) {
     P6OUT &= ~0x40;
  }
! void debugpins_frame_set(void) {
     P6OUT |=  0x40;
  }
  
  // P6.7
! void debugpins_slot_toggle(void) {
     P6OUT ^=  0x80;
  }
! void debugpins_slot_clr(void) {
     P6OUT &= ~0x80;
  }
! void debugpins_slot_set(void) {
     P6OUT |=  0x80;
  }
  
  // P2.3
! void debugpins_fsm_toggle(void) {
     P2OUT ^=  0x08;
  }
! void debugpins_fsm_clr(void) {
     P2OUT &= ~0x08;
  }
! void debugpins_fsm_set(void) {
     P2OUT |=  0x08;
  }
  
  // P2.6
! void debugpins_task_toggle(void) {
     P2OUT ^=  0x40;
  }
! void debugpins_task_clr(void) {
     P2OUT &= ~0x40;
  }
! void debugpins_task_set(void) {
     P2OUT |=  0x40;
  }
  
  // P6.0
! void debugpins_isr_toggle(void) {
     P6OUT ^=  0x01;
  }
! void debugpins_isr_clr(void) {
     P6OUT &= ~0x01;
  }
! void debugpins_isr_set(void) {
     P6OUT |=  0x01;
  }
  
  // P6.1
! void debugpins_radio_toggle(void) {
     P6OUT ^=  0x02;
  }
! void debugpins_radio_clr(void) {
     P6OUT &= ~0x02;
  }
! void debugpins_radio_set(void) {
     P6OUT |=  0x02;
  }
  
+ 
+ void    leds_toggle_2x(void){
+ 
+   uint16_t i;
+   debugpins_task_toggle();
+   for (i=0;i<0xFFFF;i++);
+   for (i=0;i<0xFFFF;i++);
+   debugpins_task_toggle();
+ }  
+ void    leds_toggle_4x(void){
+   uint16_t i;
+   leds_toggle_2x();
+   for (i=0;i<0xFFFF;i++);
+   for (i=0;i<0xFFFF;i++);
+   leds_toggle_2x();
+ }
+ 
  //=========================== private =========================================
\ No newline at end of file
diff -crB stock/openwsn/debugpins.h dev/openwsn/debugpins.h
*** stock/openwsn/debugpins.h	Tue Jan 28 12:35:57 2014
--- dev/openwsn/debugpins.h	Wed Jan 29 10:33:22 2014
***************
*** 1,12 ****
  /**
  \brief Cross-platform declaration "leds" bsp module.
  
  \author Thomas Watteyne <watteyne@eecs.berkeley.edu>, February 2012.
  */
  
- #ifndef __DEBUGPINS_H
- #define __DEBUGPINS_H
- 
  //=========================== define ==========================================
  
  //=========================== typedef =========================================
--- 1,17 ----
+ #ifndef __DEBUGPINS_H
+ #define __DEBUGPINS_H
+ 
  /**
+ \addtogroup BSP
+ \{
+ \addtogroup debugpins
+ \{
+ 
  \brief Cross-platform declaration "leds" bsp module.
  
  \author Thomas Watteyne <watteyne@eecs.berkeley.edu>, February 2012.
  */
  
  //=========================== define ==========================================
  
  //=========================== typedef =========================================
***************
*** 15,44 ****
  
  //=========================== prototypes ======================================
  
! void debugpins_init();
  
! void debugpins_frame_toggle();
! void debugpins_frame_clr();
! void debugpins_frame_set();
! 
! void debugpins_slot_toggle();
! void debugpins_slot_clr();
! void debugpins_slot_set();
! 
! void debugpins_fsm_toggle();
! void debugpins_fsm_clr();
! void debugpins_fsm_set();
! 
! void debugpins_task_toggle();
! void debugpins_task_clr();
! void debugpins_task_set();
! 
! void debugpins_isr_toggle();
! void debugpins_isr_clr();
! void debugpins_isr_set();
! 
! void debugpins_radio_toggle();
! void debugpins_radio_clr();
! void debugpins_radio_set();
  
  #endif
--- 20,54 ----
  
  //=========================== prototypes ======================================
  
! void debugpins_init(void);
! 
! void debugpins_frame_toggle(void);
! void debugpins_frame_clr(void);
! void debugpins_frame_set(void);
! 
! void debugpins_slot_toggle(void);
! void debugpins_slot_clr(void);
! void debugpins_slot_set(void);
! 
! void debugpins_fsm_toggle(void);
! void debugpins_fsm_clr(void);
! void debugpins_fsm_set(void);
! 
! void debugpins_task_toggle(void);
! void debugpins_task_clr(void);
! void debugpins_task_set(void);
! 
! void debugpins_isr_toggle(void);
! void debugpins_isr_clr(void);
! void debugpins_isr_set(void);
! 
! void debugpins_radio_toggle(void);
! void debugpins_radio_clr(void);
! void debugpins_radio_set(void);
  
! /**
! \}
! \}
! */
  
  #endif
diff -crB stock/openwsn/eui64.c dev/openwsn/eui64.c
*** stock/openwsn/eui64.c	Tue Jan 28 12:35:57 2014
--- dev/openwsn/eui64.c	Wed Jan 29 10:33:22 2014
***************
*** 32,55 ****
  //=========================== prototypes ======================================
  
  // 1Wire
! uint8_t ow_reset();
  void    ow_write_byte(uint8_t byte);
! uint8_t ow_read_byte();
  void    ow_write_bit(int is_one);
! uint8_t ow_read_bit();
! void    ow_write_bit_one();
! void    ow_write_bit_zero();
  // CRC
  uint8_t crc8_byte(uint8_t crc, uint8_t byte);
  uint8_t crc8_bytes(uint8_t crc, uint8_t* bytes, uint8_t len);
  // timer
  void    delay_us(uint16_t delay);
  // pin
! void    owpin_init();
! void    owpin_output_low();
! void    owpin_output_high();
! void    owpin_prepare_read();
! uint8_t owpin_read();
  
  //=========================== public ==========================================
  
--- 32,55 ----
  //=========================== prototypes ======================================
  
  // 1Wire
! uint8_t ow_reset(void);
  void    ow_write_byte(uint8_t byte);
! uint8_t ow_read_byte(void);
  void    ow_write_bit(int is_one);
! uint8_t ow_read_bit(void);
! void    ow_write_bit_one(void);
! void    ow_write_bit_zero(void);
  // CRC
  uint8_t crc8_byte(uint8_t crc, uint8_t byte);
  uint8_t crc8_bytes(uint8_t crc, uint8_t* bytes, uint8_t len);
  // timer
  void    delay_us(uint16_t delay);
  // pin
! void    owpin_init(void);
! void    owpin_output_low(void);
! void    owpin_output_high(void);
! void    owpin_prepare_read(void);
! uint8_t owpin_read(void);
  
  //=========================== public ==========================================
  
***************
*** 98,104 ****
  
  // admin
  
! uint8_t ow_reset() {              // >= 960us 
     int present;
     owpin_output_low();
     delay_us(OW_DLY_H);            // t_RSTL
--- 98,104 ----
  
  // admin
  
! uint8_t ow_reset(void) {              // >= 960us 
     int present;
     owpin_output_low();
     delay_us(OW_DLY_H);            // t_RSTL
***************
*** 118,124 ****
     }
  }
  
! uint8_t ow_read_byte() {          // >= 560us
     uint8_t byte = 0;
     uint8_t bit;
     for( bit=0x01; bit!=0; bit<<=1 ) {
--- 118,124 ----
     }
  }
  
! uint8_t ow_read_byte(void) {          // >= 560us
     uint8_t byte = 0;
     uint8_t bit;
     for( bit=0x01; bit!=0; bit<<=1 ) {
***************
*** 139,145 ****
     }
  }
  
! uint8_t ow_read_bit() {           // >= 70us
     int bit;
     owpin_output_low();
     delay_us(OW_DLY_A);            // t_RL
--- 139,145 ----
     }
  }
  
! uint8_t ow_read_bit(void) {           // >= 70us
     int bit;
     owpin_output_low();
     delay_us(OW_DLY_A);            // t_RL
***************
*** 150,163 ****
     return bit;
  }
  
! void ow_write_bit_one() {         // >= 70us
     owpin_output_low();
     delay_us(OW_DLY_A);            // t_W1L
     owpin_output_high();
     delay_us(OW_DLY_B);            // t_SLOT - t_W1L
  }
  
! void ow_write_bit_zero() {        // >= 70us
     owpin_output_low();
     delay_us(OW_DLY_C);            // t_W0L
     owpin_output_high();
--- 150,163 ----
     return bit;
  }
  
! void ow_write_bit_one(void) {         // >= 70us
     owpin_output_low();
     delay_us(OW_DLY_A);            // t_W1L
     owpin_output_high();
     delay_us(OW_DLY_B);            // t_SLOT - t_W1L
  }
  
! void ow_write_bit_zero(void) {        // >= 70us
     owpin_output_low();
     delay_us(OW_DLY_C);            // t_W0L
     owpin_output_high();
***************
*** 196,218 ****
  
  //===== pin
  
! void    owpin_init() {
     P2DIR &= ~PIN_1WIRE;           // set as input
     P2OUT &= ~PIN_1WIRE;           // pull low
  }
  
! void    owpin_output_low() {
     P2DIR |=  PIN_1WIRE;           // set as output
  }
  
! void    owpin_output_high() {
     P2DIR &= ~PIN_1WIRE;           // set as input
  }
  
! void    owpin_prepare_read() {
     P2DIR &= ~PIN_1WIRE;           // set as input
  }
  
! uint8_t owpin_read() {
     return (P2IN & PIN_1WIRE);
  }
\ No newline at end of file
--- 196,218 ----
  
  //===== pin
  
! void    owpin_init(void) {
     P2DIR &= ~PIN_1WIRE;           // set as input
     P2OUT &= ~PIN_1WIRE;           // pull low
  }
  
! void    owpin_output_low(void) {
     P2DIR |=  PIN_1WIRE;           // set as output
  }
  
! void    owpin_output_high(void) {
     P2DIR &= ~PIN_1WIRE;           // set as input
  }
  
! void    owpin_prepare_read(void) {
     P2DIR &= ~PIN_1WIRE;           // set as input
  }
  
! uint8_t owpin_read(void) {
     return (P2IN & PIN_1WIRE);
  }
\ No newline at end of file
diff -crB stock/openwsn/eui64.h dev/openwsn/eui64.h
*** stock/openwsn/eui64.h	Tue Jan 28 12:35:57 2014
--- dev/openwsn/eui64.h	Wed Jan 29 10:33:22 2014
***************
*** 1,12 ****
  /**
  \brief Cross-platform declaration "eui64" bsp module.
  
  \author Thomas Watteyne <watteyne@eecs.berkeley.edu>, March 2012.
  */
  
- #ifndef __EUI64_H
- #define __EUI64_H
- 
  #include <stdint.h>
   
  //=========================== define ==========================================
--- 1,17 ----
+ #ifndef __EUI64_H
+ #define __EUI64_H
+ 
  /**
+ \addtogroup BSP
+ \{
+ \addtogroup eui64
+ \{
+ 
  \brief Cross-platform declaration "eui64" bsp module.
  
  \author Thomas Watteyne <watteyne@eecs.berkeley.edu>, March 2012.
  */
  
  #include <stdint.h>
   
  //=========================== define ==========================================
***************
*** 19,22 ****
--- 24,32 ----
  
  void eui64_get(uint8_t* addressToWrite);
  
+ /**
+ \}
+ \}
+ */
+ 
  #endif
\ No newline at end of file
diff -crB stock/openwsn/leds.c dev/openwsn/leds.c
*** stock/openwsn/leds.c	Tue Jan 28 12:35:57 2014
--- dev/openwsn/leds.c	Wed Jan 29 10:33:22 2014
***************
*** 15,39 ****
  
  //=========================== public ==========================================
  
! void    leds_init() {
     P5DIR     |=  0x70;                           // P5DIR = 0bx111xxxx for LEDs
     P5OUT     |=  0x70;                           // P2OUT = 0bx111xxxx, all LEDs off
  }
  
  // red = LED1 = P5.4
! void    leds_error_on() {
     P5OUT     &= ~0x10;
  }
! void    leds_error_off() {
     P5OUT     |=  0x10;
  }
! void    leds_error_toggle() {
     P5OUT     ^=  0x10;
  }
! uint8_t leds_error_isOn() {
     return (uint8_t)(P5OUT & 0x10)>>4;
  }
! void leds_error_blink() {
     uint8_t i;
     volatile uint16_t delay;
     // turn all LEDs off
--- 15,39 ----
  
  //=========================== public ==========================================
  
! void    leds_init(void) {
     P5DIR     |=  0x70;                           // P5DIR = 0bx111xxxx for LEDs
     P5OUT     |=  0x70;                           // P2OUT = 0bx111xxxx, all LEDs off
  }
  
  // red = LED1 = P5.4
! void    leds_error_on(void) {
     P5OUT     &= ~0x10;
  }
! void    leds_error_off(void) {
     P5OUT     |=  0x10;
  }
! void    leds_error_toggle(void) {
     P5OUT     ^=  0x10;
  }
! uint8_t leds_error_isOn(void) {
     return (uint8_t)(P5OUT & 0x10)>>4;
  }
! void leds_error_blink(void) {
     uint8_t i;
     volatile uint16_t delay;
     // turn all LEDs off
***************
*** 47,104 ****
  }
  
  // green = LED2 = P5.5
! void    leds_radio_on() {
     P5OUT     &= ~0x20;
  }
! void    leds_radio_off() {
     P5OUT     |=  0x20;
  }
! void    leds_radio_toggle() {
     P5OUT     ^=  0x20;
  }
! uint8_t leds_radio_isOn() {
     return (uint8_t)(P5OUT & 0x20)>>5;
  }
  
  // blue = LED3 = P5.6
! void    leds_sync_on() {
     P5OUT     &= ~0x40;
  }
! void    leds_sync_off() {
     P5OUT     |=  0x40;
  }
! void    leds_sync_toggle() {
     P5OUT     ^=  0x40;
  }
! uint8_t leds_sync_isOn() {
     return (uint8_t)(P5OUT & 0x40)>>6;
  }
  
! void    leds_debug_on() {
     // TelosB doesn't have a debug LED :(
  }
! void    leds_debug_off() {
     // TelosB doesn't have a debug LED :(
  }
! void    leds_debug_toggle() {
     // TelosB doesn't have a debug LED :(
  }
! uint8_t leds_debug_isOn() {
     // TelosB doesn't have a debug LED :(
     return 0;
  }
  
! void    leds_all_on() {
     P5OUT     &= ~0x70;
  }
! void    leds_all_off() {
     P5OUT     |=  0x70;
  }
! void    leds_all_toggle() {
     P5OUT     ^=  0x70;
  }
  
! void    leds_circular_shift() {
     uint8_t leds_on;
     // get LED state
     leds_on  = (~P5OUT & 0x70) >> 4;
--- 47,104 ----
  }
  
  // green = LED2 = P5.5
! void    leds_radio_on(void) {
     P5OUT     &= ~0x20;
  }
! void    leds_radio_off(void) {
     P5OUT     |=  0x20;
  }
! void    leds_radio_toggle(void) {
     P5OUT     ^=  0x20;
  }
! uint8_t leds_radio_isOn(void) {
     return (uint8_t)(P5OUT & 0x20)>>5;
  }
  
  // blue = LED3 = P5.6
! void    leds_sync_on(void) {
     P5OUT     &= ~0x40;
  }
! void    leds_sync_off(void) {
     P5OUT     |=  0x40;
  }
! void    leds_sync_toggle(void) {
     P5OUT     ^=  0x40;
  }
! uint8_t leds_sync_isOn(void) {
     return (uint8_t)(P5OUT & 0x40)>>6;
  }
  
! void    leds_debug_on(void) {
     // TelosB doesn't have a debug LED :(
  }
! void    leds_debug_off(void) {
     // TelosB doesn't have a debug LED :(
  }
! void    leds_debug_toggle(void) {
     // TelosB doesn't have a debug LED :(
  }
! uint8_t leds_debug_isOn(void) {
     // TelosB doesn't have a debug LED :(
     return 0;
  }
  
! void    leds_all_on(void) {
     P5OUT     &= ~0x70;
  }
! void    leds_all_off(void) {
     P5OUT     |=  0x70;
  }
! void    leds_all_toggle(void) {
     P5OUT     ^=  0x70;
  }
  
! void    leds_circular_shift(void) {
     uint8_t leds_on;
     // get LED state
     leds_on  = (~P5OUT & 0x70) >> 4;
***************
*** 118,124 ****
     P5OUT &= ~( leds_on & 0x70);                  // switch off the leds marked '0' in leds_on
  }
  
! void    leds_increment() {
     uint8_t leds_on;
     // get LED state
     leds_on  = (~P5OUT & 0x70) >> 4;
--- 118,124 ----
     P5OUT &= ~( leds_on & 0x70);                  // switch off the leds marked '0' in leds_on
  }
  
! void    leds_increment(void) {
     uint8_t leds_on;
     // get LED state
     leds_on  = (~P5OUT & 0x70) >> 4;
diff -crB stock/openwsn/leds.h dev/openwsn/leds.h
*** stock/openwsn/leds.h	Tue Jan 28 12:35:57 2014
--- dev/openwsn/leds.h	Wed Jan 29 10:33:22 2014
***************
*** 1,12 ****
  /**
  \brief Cross-platform declaration "leds" bsp module.
  
  \author Thomas Watteyne <watteyne@eecs.berkeley.edu>, February 2012.
  */
  
- #ifndef __LEDS_H
- #define __LEDS_H
- 
  #include "stdint.h"
   
  //=========================== define ==========================================
--- 1,17 ----
+ #ifndef __LEDS_H
+ #define __LEDS_H
+ 
  /**
+ \addtogroup BSP
+ \{
+ \addtogroup leds
+ \{
+ 
  \brief Cross-platform declaration "leds" bsp module.
  
  \author Thomas Watteyne <watteyne@eecs.berkeley.edu>, February 2012.
  */
  
  #include "stdint.h"
   
  //=========================== define ==========================================
***************
*** 17,50 ****
  
  //=========================== prototypes ======================================
  
! void    leds_init();
  
! void    leds_error_on();
! void    leds_error_off();
! void    leds_error_toggle();
! uint8_t leds_error_isOn();
! void    leds_error_blink();
! 
! void    leds_radio_on();
! void    leds_radio_off();
! void    leds_radio_toggle();
! uint8_t leds_radio_isOn();
! 
! void    leds_sync_on();
! void    leds_sync_off();
! void    leds_sync_toggle();
! uint8_t leds_sync_isOn();
! 
! void    leds_debug_on();
! void    leds_debug_off();
! void    leds_debug_toggle();
! uint8_t leds_debug_isOn();
! 
! void    leds_all_on();
! void    leds_all_off();
! void    leds_all_toggle();
  
! void    leds_circular_shift();
! void    leds_increment();
  
  #endif
--- 22,60 ----
  
  //=========================== prototypes ======================================
  
! void    leds_init(void);
! 
! void    leds_error_on(void);
! void    leds_error_off(void);
! void    leds_error_toggle(void);
! uint8_t leds_error_isOn(void);
! void    leds_error_blink(void);
! 
! void    leds_radio_on(void);
! void    leds_radio_off(void);
! void    leds_radio_toggle(void);
! uint8_t leds_radio_isOn(void);
! 
! void    leds_sync_on(void);
! void    leds_sync_off(void);
! void    leds_sync_toggle(void);
! uint8_t leds_sync_isOn(void);
! 
! void    leds_debug_on(void);
! void    leds_debug_off(void);
! void    leds_debug_toggle(void);
! uint8_t leds_debug_isOn(void);
! 
! void    leds_all_on(void);
! void    leds_all_off(void);
! void    leds_all_toggle(void);
  
! void    leds_circular_shift(void);
! void    leds_increment(void);
  
! /**
! \}
! \}
! */
  
  #endif
diff -crB stock/openwsn/openhdlc.h dev/openwsn/openhdlc.h
*** stock/openwsn/openhdlc.h	Tue Jan 28 12:35:57 2014
--- dev/openwsn/openhdlc.h	Wed Jan 29 10:33:22 2014
***************
*** 11,17 ****
  #include "openwsn.h"
  
  /**
! \addtogroup cross-layers
  \{
  \addtogroup HDLC
  \{
--- 11,17 ----
  #include "openwsn.h"
  
  /**
! \addtogroup drivers
  \{
  \addtogroup HDLC
  \{
diff -crB stock/openwsn/openserial.c dev/openwsn/openserial.c
*** stock/openwsn/openserial.c	Tue Jan 28 12:35:57 2014
--- dev/openwsn/openserial.c	Wed Jan 29 10:58:33 2014
***************
*** 17,54 ****
  #include "openbridge.h"
  #include "leds.h"
  #include "schedule.h"
! #include "uart.h"
  #include "opentimers.h"
  #include "openhdlc.h"
  
  //=========================== variables =======================================
  
- typedef struct {
-    // admin
-    uint8_t    mode;
-    uint8_t    debugPrintCounter;
-    // input
-    uint8_t    reqFrame[1+1+2+1]; // flag (1B), command (2B), CRC (2B), flag (1B)
-    uint8_t    reqFrameIdx;
-    uint8_t    lastRxByte;
-    bool       busyReceiving;
-    bool       inputEscaping;
-    uint16_t   inputCrc;
-    uint8_t    inputBufFill;
-    uint8_t    inputBuf[SERIAL_INPUT_BUFFER_SIZE];
-    // output
-    bool       outputBufFilled;
-    uint16_t   outputCrc;
-    uint8_t    outputBufIdxW;
-    uint8_t    outputBufIdxR;
-    uint8_t    outputBuf[SERIAL_OUTPUT_BUFFER_SIZE];
- } openserial_vars_t;
- 
  openserial_vars_t openserial_vars;
  
  //=========================== prototypes ======================================
  
! error_t openserial_printInfoErrorCritical(
     char             severity,
     uint8_t          calling_component,
     uint8_t          error_code,
--- 17,33 ----
  #include "openbridge.h"
  #include "leds.h"
  #include "schedule.h"
! #include "uart_ow.h"
  #include "opentimers.h"
  #include "openhdlc.h"
  
  //=========================== variables =======================================
  
  openserial_vars_t openserial_vars;
  
  //=========================== prototypes ======================================
  
! owerror_t openserial_printInfoErrorCritical(
     char             severity,
     uint8_t          calling_component,
     uint8_t          error_code,
***************
*** 56,182 ****
     errorparameter_t arg2
  );
  // HDLC output
! void outputHdlcOpen();
  void outputHdlcWrite(uint8_t b);
! void outputHdlcClose();
  // HDLC input
! void inputHdlcOpen();
  void inputHdlcWrite(uint8_t b);
! void inputHdlcClose();
  
  //=========================== public ==========================================
  
! void openserial_init() {
!    uint16_t crc;
!    
!    // reset variable
!    memset(&openserial_vars,0,sizeof(openserial_vars_t));
!    
!    // admin
!    openserial_vars.mode                = MODE_OFF;
!    openserial_vars.debugPrintCounter   = 0;
!    
!    // input
!    openserial_vars.reqFrame[0]         = HDLC_FLAG;
!    openserial_vars.reqFrame[1]         = SERFRAME_MOTE2PC_REQUEST;
!    crc = HDLC_CRCINIT;
!    crc = crcIteration(crc,openserial_vars.reqFrame[1]);
!    crc = ~crc;
!    openserial_vars.reqFrame[2]         = (crc>>0)&0xff;
!    openserial_vars.reqFrame[3]         = (crc>>8)&0xff;
!    openserial_vars.reqFrame[4]         = HDLC_FLAG;
!    openserial_vars.reqFrameIdx         = 0;
!    openserial_vars.lastRxByte          = HDLC_FLAG;
!    openserial_vars.busyReceiving       = FALSE;
!    openserial_vars.inputEscaping       = FALSE;
!    openserial_vars.inputBufFill        = 0;
!    
!    // ouput
!    openserial_vars.outputBufFilled     = FALSE;
!    openserial_vars.outputBufIdxR       = 0;
!    openserial_vars.outputBufIdxW       = 0;
!    
!    // set callbacks
!    uart_setCallbacks(isr_openserial_tx,
!                      isr_openserial_rx);
! }
! 
! error_t openserial_printStatus(uint8_t statusElement,uint8_t* buffer, uint16_t length) {
!    uint8_t i;
!    INTERRUPT_DECLARATION();
!    
!    DISABLE_INTERRUPTS();
!    openserial_vars.outputBufFilled  = TRUE;
!    outputHdlcOpen();
!    outputHdlcWrite(SERFRAME_MOTE2PC_STATUS);
!    outputHdlcWrite(idmanager_getMyID(ADDR_16B)->addr_16b[0]);
!    outputHdlcWrite(idmanager_getMyID(ADDR_16B)->addr_16b[1]);
!    outputHdlcWrite(statusElement);
!    for (i=0;i<length;i++){
!       outputHdlcWrite(buffer[i]);
!    }
!    outputHdlcClose();
!    ENABLE_INTERRUPTS();
     
     return E_SUCCESS;
  }
  
! error_t openserial_printInfoErrorCritical(
        char             severity,
        uint8_t          calling_component,
        uint8_t          error_code,
        errorparameter_t arg1,
        errorparameter_t arg2
     ) {
!    INTERRUPT_DECLARATION();
!    
!    DISABLE_INTERRUPTS();
!    openserial_vars.outputBufFilled  = TRUE;
!    outputHdlcOpen();
!    outputHdlcWrite(severity);
!    outputHdlcWrite(idmanager_getMyID(ADDR_16B)->addr_16b[0]);
!    outputHdlcWrite(idmanager_getMyID(ADDR_16B)->addr_16b[1]);
!    outputHdlcWrite(calling_component);
!    outputHdlcWrite(error_code);
!    outputHdlcWrite((uint8_t)((arg1 & 0xff00)>>8));
!    outputHdlcWrite((uint8_t) (arg1 & 0x00ff));
!    outputHdlcWrite((uint8_t)((arg2 & 0xff00)>>8));
!    outputHdlcWrite((uint8_t) (arg2 & 0x00ff));
!    outputHdlcClose();
!    ENABLE_INTERRUPTS();
     
     return E_SUCCESS;
  }
  
! error_t openserial_printData(uint8_t* buffer, uint8_t length) {
!    uint8_t  i;
!    uint8_t  asn[5];
!    INTERRUPT_DECLARATION();
!    
!    // retrieve ASN
!    asnWriteToSerial(asn);// byte01,byte23,byte4
!    
!    DISABLE_INTERRUPTS();
!    openserial_vars.outputBufFilled  = TRUE;
!    outputHdlcOpen();
!    outputHdlcWrite(SERFRAME_MOTE2PC_DATA);
!    outputHdlcWrite(idmanager_getMyID(ADDR_16B)->addr_16b[1]);
!    outputHdlcWrite(idmanager_getMyID(ADDR_16B)->addr_16b[0]);
!    outputHdlcWrite(asn[0]);
!    outputHdlcWrite(asn[1]);
!    outputHdlcWrite(asn[2]);
!    outputHdlcWrite(asn[3]);
!    outputHdlcWrite(asn[4]);
!    for (i=0;i<length;i++){
!       outputHdlcWrite(buffer[i]);
!    }
!    outputHdlcClose();
!    ENABLE_INTERRUPTS();
     
     return E_SUCCESS;
  }
  
! error_t openserial_printInfo(uint8_t calling_component, uint8_t error_code,
                                errorparameter_t arg1,
                                errorparameter_t arg2) {
     return openserial_printInfoErrorCritical(
--- 35,163 ----
     errorparameter_t arg2
  );
  // HDLC output
! void outputHdlcOpen(void);
  void outputHdlcWrite(uint8_t b);
! void outputHdlcClose(void);
  // HDLC input
! void inputHdlcOpen(void);
  void inputHdlcWrite(uint8_t b);
! void inputHdlcClose(void);
  
  //=========================== public ==========================================
  
! void openserial_init(void) {
!    // uint16_t crc;
! //    
! //    // reset variable
! //    memset(&openserial_vars,0,sizeof(openserial_vars_t));
! //    
! //    // admin
! //    openserial_vars.mode                = MODE_OFF;
! //    openserial_vars.debugPrintCounter   = 0;
! //    
! //    // input
! //    openserial_vars.reqFrame[0]         = HDLC_FLAG;
! //    openserial_vars.reqFrame[1]         = SERFRAME_MOTE2PC_REQUEST;
! //    crc = HDLC_CRCINIT;
! //    crc = crcIteration(crc,openserial_vars.reqFrame[1]);
! //    crc = ~crc;
! //    openserial_vars.reqFrame[2]         = (crc>>0)&0xff;
! //    openserial_vars.reqFrame[3]         = (crc>>8)&0xff;
! //    openserial_vars.reqFrame[4]         = HDLC_FLAG;
! //    openserial_vars.reqFrameIdx         = 0;
! //    openserial_vars.lastRxByte          = HDLC_FLAG;
! //    openserial_vars.busyReceiving       = FALSE;
! //    openserial_vars.inputEscaping       = FALSE;
! //    openserial_vars.inputBufFill        = 0;
! //    
! //    // ouput
! //    openserial_vars.outputBufFilled     = FALSE;
! //    openserial_vars.outputBufIdxR       = 0;
! //    openserial_vars.outputBufIdxW       = 0;
! //    
! //    // set callbacks
! //    uart_setCallbacks(isr_openserial_tx,
! //                      isr_openserial_rx);
! }
! 
! owerror_t openserial_printStatus(uint8_t statusElement,uint8_t* buffer, uint8_t length) {
!    // uint8_t i;
! //    INTERRUPT_DECLARATION();
! //    
! //    DISABLE_INTERRUPTS();
! //    openserial_vars.outputBufFilled  = TRUE;
! //    outputHdlcOpen();
! //    outputHdlcWrite(SERFRAME_MOTE2PC_STATUS);
! //    outputHdlcWrite(idmanager_getMyID(ADDR_16B)->addr_16b[0]);
! //    outputHdlcWrite(idmanager_getMyID(ADDR_16B)->addr_16b[1]);
! //    outputHdlcWrite(statusElement);
! //    for (i=0;i<length;i++){
! //       outputHdlcWrite(buffer[i]);
! //    }
! //    outputHdlcClose();
! //    ENABLE_INTERRUPTS();
     
     return E_SUCCESS;
  }
  
! owerror_t openserial_printInfoErrorCritical(
        char             severity,
        uint8_t          calling_component,
        uint8_t          error_code,
        errorparameter_t arg1,
        errorparameter_t arg2
     ) {
!    // INTERRUPT_DECLARATION();
! //    
! //    DISABLE_INTERRUPTS();
! //    openserial_vars.outputBufFilled  = TRUE;
! //    outputHdlcOpen();
! //    outputHdlcWrite(severity);
! //    outputHdlcWrite(idmanager_getMyID(ADDR_16B)->addr_16b[0]);
! //    outputHdlcWrite(idmanager_getMyID(ADDR_16B)->addr_16b[1]);
! //    outputHdlcWrite(calling_component);
! //    outputHdlcWrite(error_code);
! //    outputHdlcWrite((uint8_t)((arg1 & 0xff00)>>8));
! //    outputHdlcWrite((uint8_t) (arg1 & 0x00ff));
! //    outputHdlcWrite((uint8_t)((arg2 & 0xff00)>>8));
! //    outputHdlcWrite((uint8_t) (arg2 & 0x00ff));
! //    outputHdlcClose();
! //    ENABLE_INTERRUPTS();
     
     return E_SUCCESS;
  }
  
! owerror_t openserial_printData(uint8_t* buffer, uint8_t length) {
!     (void)length;
!     puts((char*)buffer);
!    // uint8_t  i;
! //    uint8_t  asn[5];
! //    INTERRUPT_DECLARATION();
! //    
! //    // retrieve ASN
! //    ieee154e_getAsn(asn);// byte01,byte23,byte4
! //    
! //    DISABLE_INTERRUPTS();
! //    openserial_vars.outputBufFilled  = TRUE;
! //    outputHdlcOpen();
! //    outputHdlcWrite(SERFRAME_MOTE2PC_DATA);
! //    outputHdlcWrite(idmanager_getMyID(ADDR_16B)->addr_16b[1]);
! //    outputHdlcWrite(idmanager_getMyID(ADDR_16B)->addr_16b[0]);
! //    outputHdlcWrite(asn[0]);
! //    outputHdlcWrite(asn[1]);
! //    outputHdlcWrite(asn[2]);
! //    outputHdlcWrite(asn[3]);
! //    outputHdlcWrite(asn[4]);
! //    for (i=0;i<length;i++){
! //       outputHdlcWrite(buffer[i]);
! //    }
! //    outputHdlcClose();
! //    ENABLE_INTERRUPTS();
     
     return E_SUCCESS;
  }
  
! owerror_t openserial_printInfo(uint8_t calling_component, uint8_t error_code,
                                errorparameter_t arg1,
                                errorparameter_t arg2) {
     return openserial_printInfoErrorCritical(
***************
*** 188,194 ****
     );
  }
  
! error_t openserial_printError(uint8_t calling_component, uint8_t error_code,
                                errorparameter_t arg1,
                                errorparameter_t arg2) {
     // blink error LED, this is serious
--- 169,175 ----
     );
  }
  
! owerror_t openserial_printError(uint8_t calling_component, uint8_t error_code,
                                errorparameter_t arg1,
                                errorparameter_t arg2) {
     // blink error LED, this is serious
***************
*** 203,218 ****
     );
  }
  
! error_t openserial_printCritical(uint8_t calling_component, uint8_t error_code,
                                errorparameter_t arg1,
                                errorparameter_t arg2) {
     // blink error LED, this is serious
!    leds_error_blink();
!    
!    // schedule for the mote to reboot in 10s
!    opentimers_start(10000,
!                     TIMER_ONESHOT,TIME_MS,
!                     board_reset);
     
     return openserial_printInfoErrorCritical(
        SERFRAME_MOTE2PC_CRITICAL,
--- 184,199 ----
     );
  }
  
! owerror_t openserial_printCritical(uint8_t calling_component, uint8_t error_code,
                                errorparameter_t arg1,
                                errorparameter_t arg2) {
     // blink error LED, this is serious
!     leds_error_blink();
! //    
! //    // schedule for the mote to reboot in 10s
! //    opentimers_start(10000,
! //                     TIMER_ONESHOT,TIME_MS,
! //                     board_reset);
     
     return openserial_printInfoErrorCritical(
        SERFRAME_MOTE2PC_CRITICAL,
***************
*** 223,412 ****
     );
  }
  
! uint8_t openserial_getNumDataBytes() {
!    uint8_t inputBufFill;
!    INTERRUPT_DECLARATION();
!    
!    DISABLE_INTERRUPTS();
!    inputBufFill = openserial_vars.inputBufFill;
!    ENABLE_INTERRUPTS();
  
     return inputBufFill-1; // removing the command byte
  }
  
  uint8_t openserial_getInputBuffer(uint8_t* bufferToWrite, uint8_t maxNumBytes) {
     uint8_t numBytesWritten;
!    uint8_t inputBufFill;
!    INTERRUPT_DECLARATION();
!    
!    DISABLE_INTERRUPTS();
!    inputBufFill = openserial_vars.inputBufFill;
!    ENABLE_INTERRUPTS();
!    
!    if (maxNumBytes<inputBufFill-1) {
!       openserial_printError(COMPONENT_OPENSERIAL,ERR_GETDATA_ASKS_TOO_FEW_BYTES,
!                             (errorparameter_t)maxNumBytes,
!                             (errorparameter_t)inputBufFill-1);
!       numBytesWritten = 0;
!    } else {
!       numBytesWritten = inputBufFill-1;
!       memcpy(bufferToWrite,&(openserial_vars.inputBuf[1]),numBytesWritten);
!    }
!    DISABLE_INTERRUPTS();
!    openserial_vars.inputBufFill=0;
!    ENABLE_INTERRUPTS();
!    
     return numBytesWritten;
  }
  
  void openserial_startInput() {
!    INTERRUPT_DECLARATION();
!    
!    if (openserial_vars.inputBufFill>0) {
!       openserial_printError(COMPONENT_OPENSERIAL,ERR_INPUTBUFFER_LENGTH,
!                             (errorparameter_t)openserial_vars.inputBufFill,
!                             (errorparameter_t)0);
!       openserial_vars.inputBufFill = 0;
!    }
!    
!    uart_clearTxInterrupts();
!    uart_clearRxInterrupts();      // clear possible pending interrupts
!    uart_enableInterrupts();       // Enable USCI_A1 TX & RX interrupt
!    
!    DISABLE_INTERRUPTS();
!    openserial_vars.mode           = MODE_INPUT;
!    openserial_vars.reqFrameIdx    = 0;
!    uart_writeByte(openserial_vars.reqFrame[openserial_vars.reqFrameIdx]);
!    ENABLE_INTERRUPTS();
! }
! 
! void openserial_startOutput() {
!    //schedule a task to get new status in the output buffer
!    uint8_t debugPrintCounter;
!    
!    INTERRUPT_DECLARATION();
!    DISABLE_INTERRUPTS();
!    openserial_vars.debugPrintCounter = (openserial_vars.debugPrintCounter+1)%STATUS_MAX;
!    debugPrintCounter = openserial_vars.debugPrintCounter;
!    ENABLE_INTERRUPTS();
!    
!    // print debug information
!    switch (debugPrintCounter) {
!       case STATUS_ISSYNC:
!          if (debugPrint_isSync()==TRUE) {
!             break;
!          }
!       case STATUS_ID:
!          if (debugPrint_id()==TRUE) {
!             break;
!          }
!       case STATUS_DAGRANK:
!          if (debugPrint_myDAGrank()==TRUE) {
!             break;
!          }
!       case STATUS_OUTBUFFERINDEXES:
!          if (debugPrint_outBufferIndexes()==TRUE) {
!             break;
!          }
!       case STATUS_ASN:
!          if (debugPrint_asn()==TRUE) {
!             break;
!          }
!       case STATUS_MACSTATS:
!          if (debugPrint_macStats()==TRUE) {
!             break;
!          }
!       case STATUS_SCHEDULE:
!          if(debugPrint_schedule()==TRUE) {
!             break;
!          }
!       case STATUS_BACKOFF:
!          if(debugPrint_backoff()==TRUE) {
!             break;
!          }
!       case STATUS_QUEUE:
!          if(debugPrint_queue()==TRUE) {
!             break;
!          }
!       case STATUS_NEIGHBORS:
!          if (debugPrint_neighbors()==TRUE) {
!             break;
!          }
!       default:
!          DISABLE_INTERRUPTS();
!          openserial_vars.debugPrintCounter=0;
!          ENABLE_INTERRUPTS();
!    }
!    
!    // flush buffer
!    uart_clearTxInterrupts();
!    uart_clearRxInterrupts();          // clear possible pending interrupts
!    uart_enableInterrupts();           // Enable USCI_A1 TX & RX interrupt
!    DISABLE_INTERRUPTS();
!    openserial_vars.mode=MODE_OUTPUT;
!    if (openserial_vars.outputBufFilled) {
!       uart_writeByte(openserial_vars.outputBuf[openserial_vars.outputBufIdxR++]);
!    } else {
!       openserial_stop();
!    }
!    ENABLE_INTERRUPTS();
! }
! 
! void openserial_stop() {
!    uint8_t inputBufFill;
!    uint8_t cmdByte;
!    INTERRUPT_DECLARATION();
!    
!    DISABLE_INTERRUPTS();
!    inputBufFill = openserial_vars.inputBufFill;
!    ENABLE_INTERRUPTS();
!    
!    // disable USCI_A1 TX & RX interrupt
!    uart_disableInterrupts();
!    
!    DISABLE_INTERRUPTS();
!    openserial_vars.mode=MODE_OFF;
!    ENABLE_INTERRUPTS();
!    
!    if (inputBufFill>0) {
!       DISABLE_INTERRUPTS();
!       cmdByte = openserial_vars.inputBuf[0];
!       ENABLE_INTERRUPTS();
!       switch (cmdByte) {
!          case SERFRAME_PC2MOTE_SETROOT:
!             idmanager_triggerAboutRoot();
!             break;
!          case SERFRAME_PC2MOTE_SETBRIDGE:
!             idmanager_triggerAboutBridge();
!             break;
!          case SERFRAME_PC2MOTE_DATA:
!             openbridge_triggerData();
!             break;
!          case SERFRAME_PC2MOTE_TRIGGERTCPINJECT:
!             tcpinject_trigger();
!             break;
!          case SERFRAME_PC2MOTE_TRIGGERUDPINJECT:
!             udpinject_trigger();
!             break;
!          case SERFRAME_PC2MOTE_TRIGGERICMPv6ECHO:
!             icmpv6echo_trigger();
!             break;
!          case SERFRAME_PC2MOTE_TRIGGERSERIALECHO:
!             openserial_echo(&openserial_vars.inputBuf[1],inputBufFill-1);
!             break;   
!          default:
!             openserial_printError(COMPONENT_OPENSERIAL,ERR_UNSUPPORTED_COMMAND,
!                                   (errorparameter_t)cmdByte,
!                                   (errorparameter_t)0);
!             DISABLE_INTERRUPTS();
!             openserial_vars.inputBufFill = 0;
!             ENABLE_INTERRUPTS();
!             break;
!       }
!       DISABLE_INTERRUPTS();
!       openserial_vars.inputBufFill = 0;
!       ENABLE_INTERRUPTS();
!    }
  }
  
  /**
--- 204,422 ----
     );
  }
  
! uint8_t openserial_getNumDataBytes(void) {
!     uint8_t inputBufFill;
!  //   INTERRUPT_DECLARATION();
!  //   
!  //   DISABLE_INTERRUPTS();
!  //   inputBufFill = openserial_vars.inputBufFill;
!  //   ENABLE_INTERRUPTS();
  
     return inputBufFill-1; // removing the command byte
  }
  
  uint8_t openserial_getInputBuffer(uint8_t* bufferToWrite, uint8_t maxNumBytes) {
     uint8_t numBytesWritten;
!    // uint8_t inputBufFill;
! //    INTERRUPT_DECLARATION();
! //    
! //    DISABLE_INTERRUPTS();
! //    inputBufFill = openserial_vars.inputBufFill;
! //    ENABLE_INTERRUPTS();
! //    
! //    if (maxNumBytes<inputBufFill-1) {
! //       openserial_printError(COMPONENT_OPENSERIAL,ERR_GETDATA_ASKS_TOO_FEW_BYTES,
! //                             (errorparameter_t)maxNumBytes,
! //                             (errorparameter_t)inputBufFill-1);
! //       numBytesWritten = 0;
! //    } else {
! //       numBytesWritten = inputBufFill-1;
! //       memcpy(bufferToWrite,&(openserial_vars.inputBuf[1]),numBytesWritten);
! //    }
!     
     return numBytesWritten;
  }
  
  void openserial_startInput() {
!    // INTERRUPT_DECLARATION();
! //    
! //    if (openserial_vars.inputBufFill>0) {
! //       openserial_printError(COMPONENT_OPENSERIAL,ERR_INPUTBUFFER_LENGTH,
! //                             (errorparameter_t)openserial_vars.inputBufFill,
! //                             (errorparameter_t)0);
! //       DISABLE_INTERRUPTS();
! //       openserial_vars.inputBufFill=0;
! //       ENABLE_INTERRUPTS();
! //    }
! //    
! //    uart_clearTxInterrupts();
! //    uart_clearRxInterrupts();      // clear possible pending interrupts
! //    uart_enableInterrupts();       // Enable USCI_A1 TX & RX interrupt
! //    
! //    DISABLE_INTERRUPTS();
! //    openserial_vars.busyReceiving  = FALSE;
! //    openserial_vars.mode           = MODE_INPUT;
! //    openserial_vars.reqFrameIdx    = 0;
! // #ifdef FASTSIM
! //    uart_writeBufferByLen_FASTSIM(
! //       openserial_vars.reqFrame,
! //       sizeof(openserial_vars.reqFrame)
! //    );
! //    openserial_vars.reqFrameIdx = sizeof(openserial_vars.reqFrame);
! // #else
! //    uart_writeByte(openserial_vars.reqFrame[openserial_vars.reqFrameIdx]);
! // #endif
! //    ENABLE_INTERRUPTS();
!  }
!  
! void openserial_startOutput(void) {
! //    //schedule a task to get new status in the output buffer
! //    uint8_t debugPrintCounter;
! //    
! //    INTERRUPT_DECLARATION();
! //    DISABLE_INTERRUPTS();
! //    openserial_vars.debugPrintCounter = (openserial_vars.debugPrintCounter+1)%STATUS_MAX;
! //    debugPrintCounter = openserial_vars.debugPrintCounter;
! //    ENABLE_INTERRUPTS();
! //    
! //    // print debug information
! //    switch (debugPrintCounter) {
! //       case STATUS_ISSYNC:
! //          if (debugPrint_isSync()==TRUE) {
! //             break;
! //          }
! //       case STATUS_ID:
! //          if (debugPrint_id()==TRUE) {
! //             break;
! //          }
! //       case STATUS_DAGRANK:
! //          if (debugPrint_myDAGrank()==TRUE) {
! //             break;
! //          }
! //       case STATUS_OUTBUFFERINDEXES:
! //          if (debugPrint_outBufferIndexes()==TRUE) {
! //             break;
! //          }
! //       case STATUS_ASN:
! //          if (debugPrint_asn()==TRUE) {
! //             break;
! //          }
! //       case STATUS_MACSTATS:
! //          if (debugPrint_macStats()==TRUE) {
! //             break;
! //          }
! //       case STATUS_SCHEDULE:
! //          if(debugPrint_schedule()==TRUE) {
! //             break;
! //          }
! //       case STATUS_BACKOFF:
! //          if(debugPrint_backoff()==TRUE) {
! //             break;
! //          }
! //       case STATUS_QUEUE:
! //          if(debugPrint_queue()==TRUE) {
! //             break;
! //          }
! //       case STATUS_NEIGHBORS:
! //          if (debugPrint_neighbors()==TRUE) {
! //             break;
! //          }
! //       default:
! //          DISABLE_INTERRUPTS();
! //          openserial_vars.debugPrintCounter=0;
! //          ENABLE_INTERRUPTS();
! //    }
! //    
! //    // flush buffer
! //    uart_clearTxInterrupts();
! //    uart_clearRxInterrupts();          // clear possible pending interrupts
! //    uart_enableInterrupts();           // Enable USCI_A1 TX & RX interrupt
! //    DISABLE_INTERRUPTS();
! //    openserial_vars.mode=MODE_OUTPUT;
! //    if (openserial_vars.outputBufFilled) {
! // #ifdef FASTSIM
! //       uart_writeCircularBuffer_FASTSIM(
! //          openserial_vars.outputBuf,
! //          &openserial_vars.outputBufIdxR,
! //          &openserial_vars.outputBufIdxW
! //       );
! // #else
! //       uart_writeByte(openserial_vars.outputBuf[openserial_vars.outputBufIdxR++]);
! // #endif
! //    } else {
! //       openserial_stop();
! //    }
! //    ENABLE_INTERRUPTS();
! }
! 
! void openserial_stop(void) {
!    // uint8_t inputBufFill;
!    // uint8_t cmdByte;
! //    bool busyReceiving;
! //    INTERRUPT_DECLARATION();
! //    
! //    DISABLE_INTERRUPTS();
! //    busyReceiving = openserial_vars.busyReceiving;
! //    inputBufFill = openserial_vars.inputBufFill;
! //    ENABLE_INTERRUPTS();
! //    
! //    // disable USCI_A1 TX & RX interrupt
! //    uart_disableInterrupts();
! //    
! //    DISABLE_INTERRUPTS();
! //    openserial_vars.mode=MODE_OFF;
! //    ENABLE_INTERRUPTS();
! //    //the inputBuffer has to be reset if it is not reset where the data is read.
! //    //or the function openserial_getInputBuffer is called (which resets the buffer)
! //    if (busyReceiving==TRUE){
! //       openserial_printError(COMPONENT_OPENSERIAL,ERR_BUSY_RECEIVING,
! //                                   (errorparameter_t)0,
! //                                   (errorparameter_t)inputBufFill);
! //    }
! //    
! //    if (busyReceiving == FALSE && inputBufFill>0) {
! //       DISABLE_INTERRUPTS();
! //       cmdByte = openserial_vars.inputBuf[0];
! //       ENABLE_INTERRUPTS();
! //       switch (cmdByte) {
! //          case SERFRAME_PC2MOTE_SETROOT:
! //             idmanager_triggerAboutRoot();
! //             break;
! //          case SERFRAME_PC2MOTE_SETBRIDGE:
! //             idmanager_triggerAboutBridge();
! //             break;
! //          case SERFRAME_PC2MOTE_DATA:
! //             openbridge_triggerData();
! //             break;
! //          case SERFRAME_PC2MOTE_TRIGGERTCPINJECT:
! //             tcpinject_trigger();
! //             break;
! //          case SERFRAME_PC2MOTE_TRIGGERUDPINJECT:
! //             udpinject_trigger();
! //             break;
! //          case SERFRAME_PC2MOTE_TRIGGERICMPv6ECHO:
! //             icmpv6echo_trigger();
! //             break;
! //          case SERFRAME_PC2MOTE_TRIGGERSERIALECHO:
! //             //echo function must reset input buffer after reading the data.
! //             openserial_echo(&openserial_vars.inputBuf[1],inputBufFill-1);
! //             break;   
! //          default:
! //             openserial_printError(COMPONENT_OPENSERIAL,ERR_UNSUPPORTED_COMMAND,
! //                                   (errorparameter_t)cmdByte,
! //                                   (errorparameter_t)0);
! //             //reset here as it is not being reset in any other callback
! //             DISABLE_INTERRUPTS();
! //             openserial_vars.inputBufFill = 0;
! //             ENABLE_INTERRUPTS();
! //             break;
! //       }
! //    }
! //    
! //    DISABLE_INTERRUPTS();
! //    openserial_vars.inputBufFill  = 0;
! //    openserial_vars.busyReceiving = FALSE;
! //    ENABLE_INTERRUPTS();
  }
  
  /**
***************
*** 417,430 ****
  
  \returns TRUE if this function printed something, FALSE otherwise.
  */
! bool debugPrint_outBufferIndexes() {
!    uint16_t temp_buffer[2];
!    INTERRUPT_DECLARATION();
!    DISABLE_INTERRUPTS();
!    temp_buffer[0] = openserial_vars.outputBufIdxW;
!    temp_buffer[1] = openserial_vars.outputBufIdxR;
!    ENABLE_INTERRUPTS();
!    openserial_printStatus(STATUS_OUTBUFFERINDEXES,(uint8_t*)temp_buffer,sizeof(temp_buffer));
     return TRUE;
  }
  
--- 427,440 ----
  
  \returns TRUE if this function printed something, FALSE otherwise.
  */
! bool debugPrint_outBufferIndexes(void) {
!    // uint16_t temp_buffer[2];
! //    INTERRUPT_DECLARATION();
! //    DISABLE_INTERRUPTS();
! //    temp_buffer[0] = openserial_vars.outputBufIdxW;
! //    temp_buffer[1] = openserial_vars.outputBufIdxR;
! //    ENABLE_INTERRUPTS();
! //    openserial_printStatus(STATUS_OUTBUFFERINDEXES,(uint8_t*)temp_buffer,sizeof(temp_buffer));
     return TRUE;
  }
  
***************
*** 435,633 ****
  /**
  \brief Start an HDLC frame in the output buffer.
  */
! inline void outputHdlcOpen() {
!    // initialize the value of the CRC
!    openserial_vars.outputCrc                          = HDLC_CRCINIT;
!    
!    // write the opening HDLC flag
!    openserial_vars.outputBuf[openserial_vars.outputBufIdxW++]     = HDLC_FLAG;
! }
  /**
  \brief Add a byte to the outgoing HDLC frame being built.
- 
- \todo escape 0x7e and 0x7d.
  */
! inline void outputHdlcWrite(uint8_t b) {
!    
!    // iterate through CRC calculator
!    openserial_vars.outputCrc = crcIteration(openserial_vars.outputCrc,b);
!    
!    // add byte to buffer
!    if (b==HDLC_FLAG || b==HDLC_ESCAPE) {
!       openserial_vars.outputBuf[openserial_vars.outputBufIdxW++]  = HDLC_ESCAPE;
!       b                                               = b^HDLC_ESCAPE_MASK;
!    }
!    openserial_vars.outputBuf[openserial_vars.outputBufIdxW++]     = b;
!    
! }
  /**
  \brief Finalize the outgoing HDLC frame.
  */
! inline void outputHdlcClose() {
!    // finalize the calculation of the CRC
!    openserial_vars.outputCrc                          = ~openserial_vars.outputCrc;
!    
!    // write the CRC value
!    openserial_vars.outputBuf[openserial_vars.outputBufIdxW++]     = (openserial_vars.outputCrc>>0)&0xff;
!    openserial_vars.outputBuf[openserial_vars.outputBufIdxW++]     = (openserial_vars.outputCrc>>8)&0xff;
!    
!    // write the closing HDLC flag
!    openserial_vars.outputBuf[openserial_vars.outputBufIdxW++]     = HDLC_FLAG;
! }
  
  //===== hdlc (input)
  
  /**
  \brief Start an HDLC frame in the input buffer.
  */
! inline void inputHdlcOpen() {
!    // reset the input buffer index
!    openserial_vars.inputBufFill                       = 0;
!    
!    // initialize the value of the CRC
!    openserial_vars.inputCrc                           = HDLC_CRCINIT;
! }
  /**
  \brief Add a byte to the incoming HDLC frame.
- 
- \todo escape 0x7e and 0x7d.
  */
! inline void inputHdlcWrite(uint8_t b) {
!    if (b==HDLC_ESCAPE) {
!       openserial_vars.inputEscaping = TRUE;
!    } else {
!       if (openserial_vars.inputEscaping==TRUE) {
!          b                             = b^HDLC_ESCAPE_MASK;
!          openserial_vars.inputEscaping = FALSE;
!       }
!       
!       // add byte to input buffer
!       openserial_vars.inputBuf[openserial_vars.inputBufFill] = b;
!       openserial_vars.inputBufFill++;
!       
!       // iterate through CRC calculator
!       openserial_vars.inputCrc = crcIteration(openserial_vars.inputCrc,b);
!    }
! }
  /**
  \brief Finalize the incoming HDLC frame.
  */
! inline void inputHdlcClose() {
!    
!    // verify the validity of the frame
!    if (openserial_vars.inputCrc==HDLC_CRCGOOD) {
!       // the CRC is correct
!       
!       // remove the CRC from the input buffer
!       openserial_vars.inputBufFill    -= 2;
!    } else {
!       // the CRC is incorrect
!       
!       // drop the incoming fram
!       openserial_vars.inputBufFill     = 0;
!    }
! }
  
  //=========================== interrupt handlers ==============================
  
- //executed in ISR, called from scheduler.c
- void isr_openserial_tx() {
-    switch (openserial_vars.mode) {
-       case MODE_INPUT:
-          openserial_vars.reqFrameIdx++;
-          if (openserial_vars.reqFrameIdx<sizeof(openserial_vars.reqFrame)) {
-             uart_writeByte(openserial_vars.reqFrame[openserial_vars.reqFrameIdx]);
-          }
-          break;
-       case MODE_OUTPUT:
-          if (openserial_vars.outputBufIdxW==openserial_vars.outputBufIdxR) {
-             openserial_vars.outputBufFilled = FALSE;
-          }
-          if (openserial_vars.outputBufFilled) {
-             uart_writeByte(openserial_vars.outputBuf[openserial_vars.outputBufIdxR++]);
-          }
-          break;
-       case MODE_OFF:
-       default:
-          break;
-    }
- }
- 
  // executed in ISR, called from scheduler.c
! void isr_openserial_rx() {
!    uint8_t rxbyte;
!    
!    // stop if I'm not in input mode
!    if (openserial_vars.mode!=MODE_INPUT) {
!       return;
!    }
!    
!    // read byte just received
!    rxbyte = uart_readByte();
!    
!    if        (
!                 openserial_vars.busyReceiving==FALSE  &&
!                 openserial_vars.lastRxByte==HDLC_FLAG &&
!                 rxbyte!=HDLC_FLAG
!               ) {
!       // start of frame
!       
!       // I'm now receiving
!       openserial_vars.busyReceiving         = TRUE;
!       
!       // create the HDLC frame
!       inputHdlcOpen();
!       
!       // add the byte just received
!       inputHdlcWrite(rxbyte);
!    } else if (
!                 openserial_vars.busyReceiving==TRUE   &&
!                 rxbyte!=HDLC_FLAG
!              ) {
!       // middle of frame
!       
!       // add the byte just received
!       inputHdlcWrite(rxbyte);
!       if (openserial_vars.inputBufFill+1>SERIAL_INPUT_BUFFER_SIZE){
!          // input buffer overflow
!          openserial_printError(COMPONENT_OPENSERIAL,ERR_INPUT_BUFFER_OVERFLOW,
!                                (errorparameter_t)0,
!                                (errorparameter_t)0);
!          openserial_vars.inputBufFill       = 0;
!          openserial_vars.busyReceiving      = FALSE;
!          openserial_stop();
!       }
!    } else if (
!                 openserial_vars.busyReceiving==TRUE   &&
!                 rxbyte==HDLC_FLAG
!               ) {
!          // end of frame
!          
!          // finalize the HDLC frame
!          inputHdlcClose();
!          
!          if (openserial_vars.inputBufFill==0){
!             // invalid HDLC frame
!             openserial_printError(COMPONENT_OPENSERIAL,ERR_INVALIDSERIALFRAME,
!                                   (errorparameter_t)0,
!                                   (errorparameter_t)0);
!          
!          }
!          
!          openserial_vars.busyReceiving      = FALSE;
!          openserial_stop();
!    }
!    
!    openserial_vars.lastRxByte = rxbyte;
! }
  
  
  //======== SERIAL ECHO =============
  
  void openserial_echo(uint8_t* buf, uint8_t bufLen){
     // echo back what you received
     openserial_printData(
        buf,
        bufLen
     );
  }
--- 445,648 ----
  /**
  \brief Start an HDLC frame in the output buffer.
  */
! // inline void outputHdlcOpen(void) {
! //    // initialize the value of the CRC
! //    openserial_vars.outputCrc                          = HDLC_CRCINIT;
! //    
! //    // write the opening HDLC flag
! //    openserial_vars.outputBuf[openserial_vars.outputBufIdxW++]     = HDLC_FLAG;
! // }
  /**
  \brief Add a byte to the outgoing HDLC frame being built.
  */
! // inline void outputHdlcWrite(uint8_t b) {
! //    
! //    // iterate through CRC calculator
! //    openserial_vars.outputCrc = crcIteration(openserial_vars.outputCrc,b);
! //    
! //    // add byte to buffer
! //    if (b==HDLC_FLAG || b==HDLC_ESCAPE) {
! //       openserial_vars.outputBuf[openserial_vars.outputBufIdxW++]  = HDLC_ESCAPE;
! //       b                                               = b^HDLC_ESCAPE_MASK;
! //    }
! //    openserial_vars.outputBuf[openserial_vars.outputBufIdxW++]     = b;
! //    
! // }
  /**
  \brief Finalize the outgoing HDLC frame.
  */
! // inline void outputHdlcClose(void) {
! //    uint16_t   finalCrc;
! //     
! //    // finalize the calculation of the CRC
! //    finalCrc   = ~openserial_vars.outputCrc;
! //    
! //    // write the CRC value
! //    outputHdlcWrite((finalCrc>>0)&0xff);
! //    outputHdlcWrite((finalCrc>>8)&0xff);
! //    
! //    // write the closing HDLC flag
! //    openserial_vars.outputBuf[openserial_vars.outputBufIdxW++]   = HDLC_FLAG;
! // }
  
  //===== hdlc (input)
  
  /**
  \brief Start an HDLC frame in the input buffer.
  */
! // inline void inputHdlcOpen(void) {
! //    // reset the input buffer index
! //    openserial_vars.inputBufFill                       = 0;
! //    
! //    // initialize the value of the CRC
! //    openserial_vars.inputCrc                           = HDLC_CRCINIT;
! // }
  /**
  \brief Add a byte to the incoming HDLC frame.
  */
! // inline void inputHdlcWrite(uint8_t b) {
! //    if (b==HDLC_ESCAPE) {
! //       openserial_vars.inputEscaping = TRUE;
! //    } else {
! //       if (openserial_vars.inputEscaping==TRUE) {
! //          b                             = b^HDLC_ESCAPE_MASK;
! //          openserial_vars.inputEscaping = FALSE;
! //       }
! //       
! //       // add byte to input buffer
! //       openserial_vars.inputBuf[openserial_vars.inputBufFill] = b;
! //       openserial_vars.inputBufFill++;
! //       
! //       // iterate through CRC calculator
! //       openserial_vars.inputCrc = crcIteration(openserial_vars.inputCrc,b);
! //    }
! // }
  /**
  \brief Finalize the incoming HDLC frame.
  */
! // inline void inputHdlcClose(void) {
! //       
! //    // verify the validity of the frame
! //    if (openserial_vars.inputCrc==HDLC_CRCGOOD) {
! //       // the CRC is correct
! //       
! //       // remove the CRC from the input buffer
! //       openserial_vars.inputBufFill    -= 2;
! //    } else {
! //       // the CRC is incorrect
! //       
! //       // drop the incoming fram
! //       openserial_vars.inputBufFill     = 0;
! //     }
! // }
  
  //=========================== interrupt handlers ==============================
  
  // executed in ISR, called from scheduler.c
! // void isr_openserial_tx(void) {
! //    switch (openserial_vars.mode) {
! //       case MODE_INPUT:
! //          openserial_vars.reqFrameIdx++;
! //          if (openserial_vars.reqFrameIdx<sizeof(openserial_vars.reqFrame)) {
! //             uart_writeByte(openserial_vars.reqFrame[openserial_vars.reqFrameIdx]);
! //          }
! //          break;
! //       case MODE_OUTPUT:
! //          if (openserial_vars.outputBufIdxW==openserial_vars.outputBufIdxR) {
! //             openserial_vars.outputBufFilled = FALSE;
! //          }
! //          if (openserial_vars.outputBufFilled) {
! //             uart_writeByte(openserial_vars.outputBuf[openserial_vars.outputBufIdxR++]);
! //          }
! //          break;
! //       case MODE_OFF:
! //       default:
! //          break;
! //    }
! // }
  
+ // executed in ISR, called from scheduler.c
+ // void isr_openserial_rx(void) {
+ //    uint8_t rxbyte;
+ //    uint8_t inputBufFill;
+ //    
+ //    // stop if I'm not in input mode
+ //    if (openserial_vars.mode!=MODE_INPUT) {
+ //       return;
+ //    }
+ //    
+ //    // read byte just received
+ //    rxbyte = uart_readByte();
+ //    //keep lenght
+ //    inputBufFill=openserial_vars.inputBufFill;
+ //    
+ //    if        (
+ //                 openserial_vars.busyReceiving==FALSE  &&
+ //                 openserial_vars.lastRxByte==HDLC_FLAG &&
+ //                 rxbyte!=HDLC_FLAG
+ //               ) {
+ //       // start of frame
+ //       
+ //       // I'm now receiving
+ //       openserial_vars.busyReceiving         = TRUE;
+ //       
+ //       // create the HDLC frame
+ //       inputHdlcOpen();
+ //       
+ //       // add the byte just received
+ //       inputHdlcWrite(rxbyte);
+ //    } else if (
+ //                 openserial_vars.busyReceiving==TRUE   &&
+ //                 rxbyte!=HDLC_FLAG
+ //              ) {
+ //       // middle of frame
+ //       
+ //       // add the byte just received
+ //       inputHdlcWrite(rxbyte);
+ //       if (openserial_vars.inputBufFill+1>SERIAL_INPUT_BUFFER_SIZE){
+ //          // input buffer overflow
+ //          openserial_printError(COMPONENT_OPENSERIAL,ERR_INPUT_BUFFER_OVERFLOW,
+ //                                (errorparameter_t)0,
+ //                                (errorparameter_t)0);
+ //          openserial_vars.inputBufFill       = 0;
+ //          openserial_vars.busyReceiving      = FALSE;
+ //          openserial_stop();
+ //       }
+ //    } else if (
+ //                 openserial_vars.busyReceiving==TRUE   &&
+ //                 rxbyte==HDLC_FLAG
+ //               ) {
+ //          // end of frame
+ //          
+ //          // finalize the HDLC frame
+ //          inputHdlcClose();
+ //          
+ //          if (openserial_vars.inputBufFill==0){
+ //             // invalid HDLC frame
+ //             openserial_printError(COMPONENT_OPENSERIAL,ERR_WRONG_CRC_INPUT,
+ //                                   (errorparameter_t)inputBufFill,
+ //                                   (errorparameter_t)0);
+ //          
+ //          }
+ //          
+ //          openserial_vars.busyReceiving      = FALSE;
+ //          openserial_stop();
+ //    }
+ //    
+ //    openserial_vars.lastRxByte = rxbyte;
+ //  }
  
  //======== SERIAL ECHO =============
  
  void openserial_echo(uint8_t* buf, uint8_t bufLen){
+    INTERRUPT_DECLARATION();
     // echo back what you received
     openserial_printData(
        buf,
        bufLen
     );
+    
+     DISABLE_INTERRUPTS();
+     openserial_vars.inputBufFill = 0;
+     ENABLE_INTERRUPTS();
  }
diff -crB stock/openwsn/openserial.h dev/openwsn/openserial.h
*** stock/openwsn/openserial.h	Tue Jan 28 12:35:57 2014
--- dev/openwsn/openserial.h	Wed Jan 29 10:33:22 2014
***************
*** 10,16 ****
  #include "openwsn.h"
  
  /**
! \addtogroup cross-layers
  \{
  \addtogroup OpenSerial
  \{
--- 10,16 ----
  #include "openwsn.h"
  
  /**
! \addtogroup drivers
  \{
  \addtogroup OpenSerial
  \{
***************
*** 60,90 ****
  
  //=========================== typedef =========================================
  
  //=========================== prototypes ======================================
  
! void    openserial_init();
! error_t openserial_printStatus(uint8_t statusElement, uint8_t* buffer, uint16_t length);
! error_t openserial_printInfo(uint8_t calling_component, uint8_t error_code,
                                errorparameter_t arg1,
                                errorparameter_t arg2);
! error_t openserial_printError(uint8_t calling_component, uint8_t error_code,
                                errorparameter_t arg1,
                                errorparameter_t arg2);
! error_t openserial_printCritical(uint8_t calling_component, uint8_t error_code,
                                errorparameter_t arg1,
                                errorparameter_t arg2);
! error_t openserial_printData(uint8_t* buffer, uint8_t length);
! uint8_t openserial_getNumDataBytes();
  uint8_t openserial_getInputBuffer(uint8_t* bufferToWrite, uint8_t maxNumBytes);
! void    openserial_startInput();
! void    openserial_startOutput();
! void    openserial_stop();
! bool    debugPrint_outBufferIndexes();
  void    openserial_echo(uint8_t* but, uint8_t bufLen);
  
  // interrupt handlers
! void    isr_openserial_rx();
! void    isr_openserial_tx();
  
  /**
  \}
--- 60,113 ----
  
  //=========================== typedef =========================================
  
+ //=========================== module variables ================================
+ 
+ typedef struct {
+    // admin
+    uint8_t    mode;
+    uint8_t    debugPrintCounter;
+    // input
+    uint8_t    reqFrame[1+1+2+1]; // flag (1B), command (2B), CRC (2B), flag (1B)
+    uint8_t    reqFrameIdx;
+    uint8_t    lastRxByte;
+    bool       busyReceiving;
+    bool       inputEscaping;
+    uint16_t   inputCrc;
+    uint8_t    inputBufFill;
+    uint8_t    inputBuf[SERIAL_INPUT_BUFFER_SIZE];
+    // output
+    bool       outputBufFilled;
+    uint16_t   outputCrc;
+    uint8_t    outputBufIdxW;
+    uint8_t    outputBufIdxR;
+    uint8_t    outputBuf[SERIAL_OUTPUT_BUFFER_SIZE];
+ } openserial_vars_t;
+ 
  //=========================== prototypes ======================================
  
! void    openserial_init(void);
! owerror_t openserial_printStatus(uint8_t statusElement, uint8_t* buffer, uint8_t length);
! owerror_t openserial_printInfo(uint8_t calling_component, uint8_t error_code,
                                errorparameter_t arg1,
                                errorparameter_t arg2);
! owerror_t openserial_printError(uint8_t calling_component, uint8_t error_code,
                                errorparameter_t arg1,
                                errorparameter_t arg2);
! owerror_t openserial_printCritical(uint8_t calling_component, uint8_t error_code,
                                errorparameter_t arg1,
                                errorparameter_t arg2);
! owerror_t openserial_printData(uint8_t* buffer, uint8_t length);
! uint8_t openserial_getNumDataBytes(void);
  uint8_t openserial_getInputBuffer(uint8_t* bufferToWrite, uint8_t maxNumBytes);
! void    openserial_startInput(void);
! void    openserial_startOutput(void);
! void    openserial_stop(void);
! bool    debugPrint_outBufferIndexes(void);
  void    openserial_echo(uint8_t* but, uint8_t bufLen);
  
  // interrupt handlers
! void    isr_openserial_rx(void);
! void    isr_openserial_tx(void);
  
  /**
  \}
diff -crB stock/openwsn/opentimers.c dev/openwsn/opentimers.c
*** stock/openwsn/opentimers.c	Tue Jan 28 12:35:57 2014
--- dev/openwsn/opentimers.c	Wed Jan 29 10:33:22 2014
***************
*** 9,33 ****
  
  #include "openwsn.h"
  #include "opentimers.h"
! #include "bsp_timer.h"
  #include "leds.h"
  
  //=========================== define ==========================================
  
  //=========================== variables =======================================
  
- typedef struct {
-    opentimers_t         timersBuf[MAX_NUM_TIMERS];
-    bool                 running;
-    PORT_TIMER_WIDTH     currentTimeout; // current timeout, in ticks
- } opentimers_vars_t;
- 
  opentimers_vars_t opentimers_vars;
  //uint32_t counter; //counts the elapsed time.
  
  //=========================== prototypes ======================================
  
! void opentimers_timer_callback();
  
  //=========================== public ==========================================
  
--- 9,31 ----
  
  #include "openwsn.h"
  #include "opentimers.h"
! //#include "bsp_timer.h"
  #include "leds.h"
  
+ #include "hwtimer_arch.h"
+ #include "hwtimer_cpu.h"
+ 
  //=========================== define ==========================================
  
  //=========================== variables =======================================
  
  opentimers_vars_t opentimers_vars;
  //uint32_t counter; //counts the elapsed time.
  
  //=========================== prototypes ======================================
  
! void opentimers_int_handler(int);
! void opentimers_timer_callback(void);
  
  //=========================== public ==========================================
  
***************
*** 36,42 ****
  
  Initializes data structures and hardware timer.
   */
! void opentimers_init(){
     uint8_t i;
  
     // initialize local variables
--- 34,40 ----
  
  Initializes data structures and hardware timer.
   */
! void opentimers_init(void){
     uint8_t i;
  
     // initialize local variables
***************
*** 51,57 ****
     }
  
     // set callback for bsp_timers module
!    bsp_timer_set_callback(opentimers_timer_callback);
  }
  
  /**
--- 49,66 ----
     }
  
     // set callback for bsp_timers module
!    // bsp_timer_set_callback(opentimers_timer_callback);
!    hwtimer_arch_init(opentimers_int_handler, F_CPU); 
! }
! 
! /** 
! \brief opentimers interrupt handler
! 
! This is a wrapper to fit the hwtimer_arch API
!  */
! void opentimers_int_handler(int t) {
!     (void)t; 
!     opentimers_timer_callback();
  }
  
  /**
***************
*** 64,70 ****
  - if not, insert it in the list
  
  \param duration Number milli-seconds after which the timer will fire.
! \param type     The type of timer, indicating whether it's a one-shot or a period timer.
  \param callback The function to call when the timer fires.
  
  \returns The id of the timer (which serves as a handler to stop it) if the
--- 73,84 ----
  - if not, insert it in the list
  
  \param duration Number milli-seconds after which the timer will fire.
! \param type     Type of timer:
!    - #TIMER_PERIODIC for a periodic timer.
!    - #TIMER_ONESHOT for a on-shot timer.
! \param timetype Units of the <tt>duration</tt>:
!    - #TIME_MS when <tt>duration</tt> is in ms.
!    - #TIME_TICS when <tt>duration</tt> is in clock ticks.
  \param callback The function to call when the timer fires.
  
  \returns The id of the timer (which serves as a handler to stop it) if the
***************
*** 122,130 ****
        ) {  
           opentimers_vars.currentTimeout            = opentimers_vars.timersBuf[id].ticks_remaining;
           if (opentimers_vars.running==FALSE) {
!             bsp_timer_reset();
           }
!          bsp_timer_scheduleIn(opentimers_vars.timersBuf[id].ticks_remaining);
        }
  
        opentimers_vars.running                         = TRUE;
--- 136,146 ----
        ) {  
           opentimers_vars.currentTimeout            = opentimers_vars.timersBuf[id].ticks_remaining;
           if (opentimers_vars.running==FALSE) {
!             //bsp_timer_reset();
!             hwtimer_arch_unset(OPENTIMERS_HWTIMER_ID); 
           }
!          // bsp_timer_scheduleIn(opentimers_vars.timersBuf[id].ticks_remaining);
!          hwtimer_arch_set(opentimers_vars.timersBuf[id].ticks_remaining, OPENTIMERS_HWTIMER_ID);
        }
  
        opentimers_vars.running                         = TRUE;
***************
*** 197,203 ****
  corresponding callback(s), and restarts the hardware timer with the next timer
  to expire.
   */
! void opentimers_timer_callback() {
     
     opentimer_id_t   id;
     PORT_TIMER_WIDTH min_timeout;
--- 213,219 ----
  corresponding callback(s), and restarts the hardware timer with the next timer
  to expire.
   */
! void opentimers_timer_callback(void) {
     
     opentimer_id_t   id;
     PORT_TIMER_WIDTH min_timeout;
***************
*** 275,284 ****
     if (found==TRUE) {
        // at least one timer pending
        opentimers_vars.currentTimeout = min_timeout;
!       bsp_timer_scheduleIn(opentimers_vars.currentTimeout);
     } else {
        // no more timers pending
        opentimers_vars.running = FALSE;
     }
  }
  
--- 291,382 ----
     if (found==TRUE) {
        // at least one timer pending
        opentimers_vars.currentTimeout = min_timeout;
!       // bsp_timer_scheduleIn(opentimers_vars.currentTimeout);
!       hwtimer_arch_set(opentimers_vars.currentTimeout, OPENTIMERS_HWTIMER_ID);
     } else {
        // no more timers pending
        opentimers_vars.running = FALSE;
     }
  }
  
+ void opentimers_sleepTimeCompesation(uint16_t sleepTime)
+ {
+    opentimer_id_t   id;
+    PORT_TIMER_WIDTH min_timeout;
+    bool             found;
+    
+    //step 1. reCount the ticks_remain after waking up from sleep
+    for(id=0; id<MAX_NUM_TIMERS; id++)
+    {
+      if (opentimers_vars.timersBuf[id].isrunning==TRUE) 
+      {
+        if(opentimers_vars.timersBuf[id].ticks_remaining > sleepTime)
+        {
+          opentimers_vars.timersBuf[id].ticks_remaining -= sleepTime;
+        }
+        else
+        {
+          if(opentimers_vars.timersBuf[id].wraps_remaining > 0)
+          {
+            opentimers_vars.timersBuf[id].wraps_remaining--;
+            opentimers_vars.timersBuf[id].ticks_remaining += (MAX_TICKS_IN_SINGLE_CLOCK - sleepTime);
+          }
+          else
+          {
+            opentimers_vars.timersBuf[id].hasExpired  = TRUE;
+          }
+        }
+      }
+    }
+    
+    // step 2. call callbacks of expired timers
+    for(id=0; id<MAX_NUM_TIMERS; id++) {
+       if (opentimers_vars.timersBuf[id].hasExpired==TRUE){
+ 
+          // call the callback
+          opentimers_vars.timersBuf[id].callback();
+          opentimers_vars.timersBuf[id].hasExpired     = FALSE;
+ 
+          // reload the timer, if applicable
+          if (opentimers_vars.timersBuf[id].type==TIMER_PERIODIC) {
+             opentimers_vars.timersBuf[id].wraps_remaining   = (opentimers_vars.timersBuf[id].period_ticks/MAX_TICKS_IN_SINGLE_CLOCK);//65535=maxValue of uint16_t
+             //if the number of ticks falls below a 16bit value, use it, otherwise set to max 16bit value
+             if(opentimers_vars.timersBuf[id].wraps_remaining==0)                                                
+                opentimers_vars.timersBuf[id].ticks_remaining   = opentimers_vars.timersBuf[id].period_ticks;
+             else
+                opentimers_vars.timersBuf[id].ticks_remaining = MAX_TICKS_IN_SINGLE_CLOCK;
+ 
+          } else {
+             opentimers_vars.timersBuf[id].isrunning   = FALSE;
+          }
+       }
+ 
+    }
+    
+    // step 3. find the minimum remaining timeout among running timers
+    found = FALSE;
+    for(id=0;id<MAX_NUM_TIMERS;id++) {
+       if (
+             opentimers_vars.timersBuf[id].isrunning==TRUE &&
+             (
+                   found==FALSE
+                   ||
+                   opentimers_vars.timersBuf[id].ticks_remaining < min_timeout
+             )
+       ) {
+          min_timeout    = opentimers_vars.timersBuf[id].ticks_remaining;
+          found          = TRUE;
+       }
+    }
+ 
+    // step 4. schedule next timeout
+    if (found==TRUE) {
+       // at least one timer pending
+       opentimers_vars.currentTimeout = min_timeout;
+       // bsp_timer_scheduleIn(opentimers_vars.currentTimeout);
+       hwtimer_arch_set(opentimers_vars.currentTimeout, OPENTIMERS_HWTIMER_ID);
+    } else {
+       // no more timers pending
+       opentimers_vars.running = FALSE;
+    }
+ }
diff -crB stock/openwsn/opentimers.h dev/openwsn/opentimers.h
*** stock/openwsn/opentimers.h	Tue Jan 28 12:35:57 2014
--- dev/openwsn/opentimers.h	Wed Jan 29 10:33:22 2014
***************
*** 9,14 ****
--- 9,23 ----
  
  #include "openwsn.h"
  
+ #include "hwtimer_cpu.h"
+ 
+ /**
+ \addtogroup drivers
+ \{
+ \addtogroup OpenTimers
+ \{
+ */
+ 
  //=========================== define ==========================================
  
  /// Maximum number of timers that can run concurrently
***************
*** 22,27 ****
--- 31,38 ----
  
  typedef void (*opentimers_cbt)(void);
  
+ #define OPENTIMERS_HWTIMER_ID (ARCH_MAXTIMERS - 1)
+ 
  //=========================== typedef =========================================
  
  typedef enum {
***************
*** 46,54 ****
     bool                 hasExpired;         // whether the callback has to be called
  } opentimers_t;
  
  //=========================== prototypes ======================================
  
! void           opentimers_init();
  opentimer_id_t opentimers_start(uint32_t       duration,
                                  timer_type_t   type,
                                  time_type_t timetype,
--- 57,73 ----
     bool                 hasExpired;         // whether the callback has to be called
  } opentimers_t;
  
+ //=========================== module variables ================================
+ 
+ typedef struct {
+    opentimers_t         timersBuf[MAX_NUM_TIMERS];
+    bool                 running;
+    PORT_TIMER_WIDTH     currentTimeout; // current timeout, in ticks
+ } opentimers_vars_t;
+ 
  //=========================== prototypes ======================================
  
! void           opentimers_init(void);
  opentimer_id_t opentimers_start(uint32_t       duration,
                                  timer_type_t   type,
                                  time_type_t timetype,
***************
*** 57,60 ****
--- 76,86 ----
  void           opentimers_stop(opentimer_id_t id);
  void           opentimers_restart(opentimer_id_t id);
  
+ void           opentimers_sleepTimeCompesation(uint16_t sleepTime);
+ 
+ /**
+ \}
+ \}
+ */
+ 
  #endif
diff -crB stock/openwsn/openwsn.c dev/openwsn/openwsn.c
*** stock/openwsn/openwsn.c	Tue Jan 28 12:35:57 2014
--- dev/openwsn/openwsn.c	Wed Jan 29 11:56:02 2014
***************
*** 5,10 ****
--- 5,13 ----
  */
  
  #include "openwsn.h"
+ #include "scheduler.h"
+ #include "thread.h"
+ #include "board_ow.h"
  //===== drivers
  #include "openserial.h"
  //===== stack
***************
*** 33,45 ****
  #include "opencoap.h"
  //-- app (common)
  //#include "rreg.h"
! //#include "rwellknown.h"
! //#include "rinfo.h"
  //===== applications
  //-- TCP
! #include "tcpecho.h"
! #include "tcpinject.h"
! #include "tcpprint.h"
  #include "ohlone.h"
  //-- UDP
  #include "udpecho.h"
--- 36,48 ----
  #include "opencoap.h"
  //-- app (common)
  //#include "rreg.h"
! #include "rwellknown.h"
! #include "rinfo.h"
  //===== applications
  //-- TCP
! //#include "tcpecho.h"
! //#include "tcpinject.h"
! //#include "tcpprint.h"
  #include "ohlone.h"
  //-- UDP
  #include "udpecho.h"
***************
*** 56,76 ****
  //#include "rrube.h"
  //#include "rxl1.h"
  //#include "layerdebug.h"
  //-- misc
  //#include "heli.h"
  //#include "imu.h"
  
  //=========================== variables =======================================
  
  //=========================== prototypes ======================================
  
! void openwsn_init();
  
  //=========================== public ==========================================
  
  //=========================== private =========================================
  
! void openwsn_init() {
     //===== drivers
     openserial_init();
     
--- 59,103 ----
  //#include "rrube.h"
  //#include "rxl1.h"
  //#include "layerdebug.h"
+ //#include "r6tus.h"
  //-- misc
  //#include "heli.h"
  //#include "imu.h"
  
+ #define ENABLE_DEBUG (0)
+ #include "debug.h"
+ 
  //=========================== variables =======================================
  
+ static char openwsn_stack[KERNEL_CONF_STACKSIZE_MAIN];
+ 
  //=========================== prototypes ======================================
  
! void openwsn_init(void);
! void openwsn_start(void);
  
  //=========================== public ==========================================
  
+ void openwsn_start_thread(void) {
+     DEBUG(__PRETTY_FUNCTION__);
+     thread_create(openwsn_stack, KERNEL_CONF_STACKSIZE_MAIN, 
+                    PRIORITY_OPENWSN, CREATE_STACKTEST, 
+                    openwsn_start, "openwsn thread");
+ }
+ 
+ void openwsn_start(void) {
+     DEBUG(__PRETTY_FUNCTION__);
+     //board_init_ow();
+     scheduler_init();
+     openwsn_init();
+     puts("OpenWSN thread started.");
+     scheduler_start();
+ }
+ 
  //=========================== private =========================================
  
! void openwsn_init(void) {
!     DEBUG(__PRETTY_FUNCTION__);
     //===== drivers
     openserial_init();
     
***************
*** 100,114 ****
     opencoap_init();    // initialize before any of the CoAP applications
     //-- app (common)
     //rreg_init();
!    //rwellknown_init();
!    //rinfo_init();
     
     //===== applications
     //-- TCP
!    tcpecho_init();
!    tcpinject_init();
!    tcpprint_init();
!    ohlone_init();
     //-- UDP
     udpecho_init();
     udpinject_init();
--- 127,141 ----
     opencoap_init();    // initialize before any of the CoAP applications
     //-- app (common)
     //rreg_init();
!    rwellknown_init();
!    rinfo_init();
     
     //===== applications
     //-- TCP
!    //tcpecho_init();
!    //tcpinject_init();
!    //tcpprint_init();
!    //ohlone_init();
     //-- UDP
     udpecho_init();
     udpinject_init();
***************
*** 124,129 ****
--- 151,157 ----
     //rrube_init();
     //rxl1_init();
     //layerdebug_init();
+    //r6tus_init();
     //-- misc
     //heli_init();
     //imu_init();
diff -crB stock/openwsn/openwsn.h dev/openwsn/openwsn.h
*** stock/openwsn/openwsn.h	Tue Jan 28 12:35:57 2014
--- dev/openwsn/openwsn.h	Wed Jan 29 10:33:22 2014
***************
*** 12,27 ****
  #include <stdint.h>               // needed for uin8_t, uint16_t
  #include "board_info.h"
  
  //=========================== define ==========================================
  
  static const uint8_t infoStackName[] = "OpenWSN ";
  #define OPENWSN_VERSION_MAJOR     1
! #define OPENWSN_VERSION_MINOR     2
  #define OPENWSN_VERSION_PATCH     1
  
- // enter the last byte of your mote's address if you want it to be an LBR
- #define DEBUG_MOTEID_MASTER       0xe8
- 
  #ifndef TRUE
  #define TRUE 1
  #endif
--- 12,31 ----
  #include <stdint.h>               // needed for uin8_t, uint16_t
  #include "board_info.h"
  
+ #include <stdbool.h>
+ #include "kernel.h"
+ //========================= prototypes ========================================
+ void openwsn_start_thread(void);
+ 
  //=========================== define ==========================================
  
+ #define PRIORITY_OPENWSN            PRIORITY_MAIN-1
+ 
  static const uint8_t infoStackName[] = "OpenWSN ";
  #define OPENWSN_VERSION_MAJOR     1
! #define OPENWSN_VERSION_MINOR     4
  #define OPENWSN_VERSION_PATCH     1
  
  #ifndef TRUE
  #define TRUE 1
  #endif
***************
*** 51,66 ****
  };
  
  enum {
!    LITTLE_ENDIAN                       = TRUE,
!    BIG_ENDIAN                          = FALSE,
  };
  
  // protocol numbers, as defined by the IANA
  enum {
!    IANA_UNDEFINED                      = 0x00,
     IANA_TCP                            = 0x06,
     IANA_UDP                            = 0x11,
!    IANA_IPv6ROUTE                      =   43,
     IANA_ICMPv6                         = 0x3a,
     IANA_ICMPv6_ECHO_REQUEST            =  128,
     IANA_ICMPv6_ECHO_REPLY              =  129,
--- 55,70 ----
  };
  
  enum {
!    OW_LITTLE_ENDIAN                       = TRUE,
!    OW_BIG_ENDIAN                          = FALSE,
  };
  
  // protocol numbers, as defined by the IANA
  enum {
!    IANA_IPv6HOPOPT                     = 0x00,
     IANA_TCP                            = 0x06,
     IANA_UDP                            = 0x11,
!    IANA_IPv6ROUTE                      = 0x2b,
     IANA_ICMPv6                         = 0x3a,
     IANA_ICMPv6_ECHO_REQUEST            =  128,
     IANA_ICMPv6_ECHO_REPLY              =  129,
***************
*** 69,79 ****
     IANA_ICMPv6_RA_PREFIX_INFORMATION   =    3,
     IANA_ICMPv6_RPL                     =  155,
     IANA_ICMPv6_RPL_DIO                 = 0x01,
!    IANA_ICMPv6_RPL_DAO                 = 0x04,
     IANA_RSVP                           =   46,
  };
  
  // well known ports (which we define)
  enum {
     //TCP
     WKP_TCP_HTTP                        =    80,
--- 73,85 ----
     IANA_ICMPv6_RA_PREFIX_INFORMATION   =    3,
     IANA_ICMPv6_RPL                     =  155,
     IANA_ICMPv6_RPL_DIO                 = 0x01,
!    IANA_ICMPv6_RPL_DAO                 = 0x02,
     IANA_RSVP                           =   46,
+    IANA_UNDEFINED                      =  250, //use an unassigned
  };
  
  // well known ports (which we define)
+ // warning: first 4 MSB of 2Â° octect may coincide with previous protocol number
  enum {
     //TCP
     WKP_TCP_HTTP                        =    80,
***************
*** 144,150 ****
     COMPONENT_ICMPv6ROUTER              = 0x14,
     COMPONENT_ICMPv6RPL                 = 0x15,
     //TRAN
!    COMPONENT_OPENTCP                   = 0x16,             
     COMPONENT_OPENUDP                   = 0x17,
     COMPONENT_OPENCOAP                  = 0x18,
     //App test
--- 150,156 ----
     COMPONENT_ICMPv6ROUTER              = 0x14,
     COMPONENT_ICMPv6RPL                 = 0x15,
     //TRAN
!    COMPONENT_OPENTCP                   = 0x16,
     COMPONENT_OPENUDP                   = 0x17,
     COMPONENT_OPENCOAP                  = 0x18,
     //App test
***************
*** 173,178 ****
--- 179,185 ----
     COMPONENT_UDPSTORM                  = 0x2e,
     COMPONENT_UDPLATENCY                = 0x2f,
     COMPONENT_TEST                      = 0x30,
+    COMPONENT_R6TUS                    = 0x31,
  };
  
  /**
***************
*** 188,246 ****
     ERR_RCVD_ECHO_REPLY                 = 0x02, // received an echo reply
     ERR_GETDATA_ASKS_TOO_FEW_BYTES      = 0x03, // getData asks for too few bytes, maxNumBytes={0}, fill level={1}
     ERR_INPUT_BUFFER_OVERFLOW           = 0x04, // the input buffer has overflown
     // l4
!    ERR_WRONG_TRAN_PROTOCOL             = 0x05, // unknown transport protocol {0} (code location {1})
!    ERR_WRONG_TCP_STATE                 = 0x06, // wrong TCP state {0} (code location {1})
!    ERR_TCP_RESET                       = 0x07, // TCP reset while in state {0} (code location {1})
!    ERR_UNSUPPORTED_PORT_NUMBER         = 0x08, // unsupported port number {0} (code location {1})
     // l3
!    ERR_UNEXPECTED_DAO                  = 0x09, // unexpected DAO (code location {0})
!    ERR_UNSUPPORTED_ICMPV6_TYPE         = 0x0a, // unsupported ICMPv6 type {0} (code location {1})
!    ERR_6LOWPAN_UNSUPPORTED             = 0x0b, // unsupported 6LoWPAN parameter {1} at location {0}
!    ERR_NO_NEXTHOP                      = 0x0c, // no next hop
!    ERR_INVALID_PARAM                   = 0x0d, // invalid parameter
!    ERR_INVALID_FWDMODE                 = 0x0e, // invalid forward mode
!    ERR_LARGE_DAGRANK                   = 0x0f, // large DAGrank {0}, set to {1}
!    ERR_HOP_LIMIT_REACHED               = 0x10, // packet discarded hop limit reached
     // l2b
!    ERR_NEIGHBORS_FULL                  = 0x11, // neighbors table is full (max number of neighbor is {0})
!    ERR_NO_SENT_PACKET                  = 0x12, // there is no sent packet in queue
!    ERR_NO_RECEIVED_PACKET              = 0x13, // there is no received packet in queue
!    ERR_SCHEDULE_OVERFLOWN              = 0x14, // schedule overflown
     // l2a
!    ERR_WRONG_CELLTYPE                  = 0x15, // wrong celltype {0} at slotOffset {1}
!    ERR_IEEE154_UNSUPPORTED             = 0x16, // unsupported IEEE802.15.4 parameter {1} at location {0}
!    ERR_DESYNCHRONIZED                  = 0x17, // got desynchronized at slotOffset {0}
!    ERR_SYNCHRONIZED                    = 0x18, // synchronized at slotOffset {0}
!    ERR_LARGE_TIMECORRECTION            = 0x19, // large timeCorr.: {0} ticks (code loc. {1})
!    ERR_WRONG_STATE_IN_ENDFRAME_SYNC    = 0x1a, // wrong state {0} in end of frame+sync
!    ERR_WRONG_STATE_IN_STARTSLOT        = 0x1b, // wrong state {0} in startSlot, at slotOffset {1}
!    ERR_WRONG_STATE_IN_TIMERFIRES       = 0x1c, // wrong state {0} in timer fires, at slotOffset {1}
!    ERR_WRONG_STATE_IN_NEWSLOT          = 0x1d, // wrong state {0} in start of frame, at slotOffset {1}
!    ERR_WRONG_STATE_IN_ENDOFFRAME       = 0x1e, // wrong state {0} in end of frame, at slotOffset {1}
!    ERR_MAXTXDATAPREPARE_OVERFLOW       = 0x1f, // maxTxDataPrepare overflows while at state {0} in slotOffset {1}
!    ERR_MAXRXACKPREPARE_OVERFLOWS       = 0x20, // maxRxAckPrepapare overflows while at state {0} in slotOffset {1}
!    ERR_MAXRXDATAPREPARE_OVERFLOWS      = 0x21, // maxRxDataPrepapre overflows while at state {0} in slotOffset {1}
!    ERR_MAXTXACKPREPARE_OVERFLOWS       = 0x22, // maxTxAckPrepapre overflows while at state {0} in slotOffset {1}
!    ERR_WDDATADURATION_OVERFLOWS        = 0x23, // wdDataDuration overflows while at state {0} in slotOffset {1}
!    ERR_WDRADIO_OVERFLOWS               = 0x24, // wdRadio overflows while at state {0} in slotOffset {1}
!    ERR_WDRADIOTX_OVERFLOWS             = 0x25, // wdRadioTx overflows while at state {0} in slotOffset {1}
!    ERR_WDACKDURATION_OVERFLOWS         = 0x26, // wdAckDuration overflows while at state {0} in slotOffset {1}
     // general
!    ERR_BUSY_SENDING                    = 0x27, // busy sending
!    ERR_UNEXPECTED_SENDDONE             = 0x28, // sendDone for packet I didn't send
!    ERR_NO_FREE_PACKET_BUFFER           = 0x29, // no free packet buffer (code location {0})
!    ERR_FREEING_UNUSED                  = 0x2a, // freeing unused memory
!    ERR_FREEING_ERROR                   = 0x2b, // freeing memory unsupported memory
!    ERR_UNSUPPORTED_COMMAND             = 0x2c, // unsupported command {0}
!    ERR_MSG_UNKNOWN_TYPE                = 0x2d, // unknown message type {0}
!    ERR_WRONG_ADDR_TYPE                 = 0x2e, // wrong address type {0} (code location {1})
!    ERR_BRIDGE_MISMATCH                 = 0x2f, // isBridge mismatch (code location {0})
!    ERR_HEADER_TOO_LONG                 = 0x30, // header too long, length {1} (code location {0})
!    ERR_INPUTBUFFER_LENGTH              = 0x31, // input length problem, length={0}
!    ERR_BOOTED                          = 0x32, // booted
!    ERR_INVALIDSERIALFRAME              = 0x33, // invalid serial frame
!    ERR_INVALIDPACKETFROMRADIO          = 0x34, // invalid packet from radio, length {1} (code location {0})
  };
  
  //=========================== typedef =========================================
--- 195,258 ----
     ERR_RCVD_ECHO_REPLY                 = 0x02, // received an echo reply
     ERR_GETDATA_ASKS_TOO_FEW_BYTES      = 0x03, // getData asks for too few bytes, maxNumBytes={0}, fill level={1}
     ERR_INPUT_BUFFER_OVERFLOW           = 0x04, // the input buffer has overflown
+    ERR_COMMAND_NOT_ALLOWED             = 0x05, // the command is not allowerd, command = {0} 
     // l4
!    ERR_WRONG_TRAN_PROTOCOL             = 0x06, // unknown transport protocol {0} (code location {1})
!    ERR_WRONG_TCP_STATE                 = 0x07, // wrong TCP state {0} (code location {1})
!    ERR_TCP_RESET                       = 0x08, // TCP reset while in state {0} (code location {1})
!    ERR_UNSUPPORTED_PORT_NUMBER         = 0x09, // unsupported port number {0} (code location {1})
     // l3
!    ERR_UNEXPECTED_DAO                  = 0x0a, // unexpected DAO (code location {0})
!    ERR_UNSUPPORTED_ICMPV6_TYPE         = 0x0b, // unsupported ICMPv6 type {0} (code location {1})
!    ERR_6LOWPAN_UNSUPPORTED             = 0x0c, // unsupported 6LoWPAN parameter {1} at location {0}
!    ERR_NO_NEXTHOP                      = 0x0d, // no next hop
!    ERR_INVALID_PARAM                   = 0x0e, // invalid parameter
!    ERR_INVALID_FWDMODE                 = 0x0f, // invalid forward mode
!    ERR_LARGE_DAGRANK                   = 0x10, // large DAGrank {0}, set to {1}
!    ERR_HOP_LIMIT_REACHED               = 0x11, // packet discarded hop limit reached
!    ERR_LOOP_DETECTED                   = 0x12, // loop detected due to previous rank {0} lower than current node rank {1}
!    ERR_WRONG_DIRECTION                 = 0x13, // upstream packet set to be downstream, possible loop.
     // l2b
!    ERR_NEIGHBORS_FULL                  = 0x14, // neighbors table is full (max number of neighbor is {0})
!    ERR_NO_SENT_PACKET                  = 0x15, // there is no sent packet in queue
!    ERR_NO_RECEIVED_PACKET              = 0x16, // there is no received packet in queue
!    ERR_SCHEDULE_OVERFLOWN              = 0x17, // schedule overflown
     // l2a
!    ERR_WRONG_CELLTYPE                  = 0x18, // wrong celltype {0} at slotOffset {1}
!    ERR_IEEE154_UNSUPPORTED             = 0x19, // unsupported IEEE802.15.4 parameter {1} at location {0}
!    ERR_DESYNCHRONIZED                  = 0x1a, // got desynchronized at slotOffset {0}
!    ERR_SYNCHRONIZED                    = 0x1b, // synchronized at slotOffset {0}
!    ERR_LARGE_TIMECORRECTION            = 0x1c, // large timeCorr.: {0} ticks (code loc. {1})
!    ERR_WRONG_STATE_IN_ENDFRAME_SYNC    = 0x1d, // wrong state {0} in end of frame+sync
!    ERR_WRONG_STATE_IN_STARTSLOT        = 0x1e, // wrong state {0} in startSlot, at slotOffset {1}
!    ERR_WRONG_STATE_IN_TIMERFIRES       = 0x1f, // wrong state {0} in timer fires, at slotOffset {1}
!    ERR_WRONG_STATE_IN_NEWSLOT          = 0x20, // wrong state {0} in start of frame, at slotOffset {1}
!    ERR_WRONG_STATE_IN_ENDOFFRAME       = 0x21, // wrong state {0} in end of frame, at slotOffset {1}
!    ERR_MAXTXDATAPREPARE_OVERFLOW       = 0x22, // maxTxDataPrepare overflows while at state {0} in slotOffset {1}
!    ERR_MAXRXACKPREPARE_OVERFLOWS       = 0x23, // maxRxAckPrepapare overflows while at state {0} in slotOffset {1}
!    ERR_MAXRXDATAPREPARE_OVERFLOWS      = 0x24, // maxRxDataPrepapre overflows while at state {0} in slotOffset {1}
!    ERR_MAXTXACKPREPARE_OVERFLOWS       = 0x25, // maxTxAckPrepapre overflows while at state {0} in slotOffset {1}
!    ERR_WDDATADURATION_OVERFLOWS        = 0x26, // wdDataDuration overflows while at state {0} in slotOffset {1}
!    ERR_WDRADIO_OVERFLOWS               = 0x27, // wdRadio overflows while at state {0} in slotOffset {1}
!    ERR_WDRADIOTX_OVERFLOWS             = 0x28, // wdRadioTx overflows while at state {0} in slotOffset {1}
!    ERR_WDACKDURATION_OVERFLOWS         = 0x29, // wdAckDuration overflows while at state {0} in slotOffset {1}
     // general
!    ERR_BUSY_SENDING                    = 0x2a, // busy sending
!    ERR_UNEXPECTED_SENDDONE             = 0x2b, // sendDone for packet I didn't send
!    ERR_NO_FREE_PACKET_BUFFER           = 0x2c, // no free packet buffer (code location {0})
!    ERR_FREEING_UNUSED                  = 0x2d, // freeing unused memory
!    ERR_FREEING_ERROR                   = 0x2e, // freeing memory unsupported memory
!    ERR_UNSUPPORTED_COMMAND             = 0x2f, // unsupported command {0}
!    ERR_MSG_UNKNOWN_TYPE                = 0x30, // unknown message type {0}
!    ERR_WRONG_ADDR_TYPE                 = 0x31, // wrong address type {0} (code location {1})
!    ERR_BRIDGE_MISMATCH                 = 0x32, // isBridge mismatch (code location {0})
!    ERR_HEADER_TOO_LONG                 = 0x33, // header too long, length {1} (code location {0})
!    ERR_INPUTBUFFER_LENGTH              = 0x34, // input length problem, length={0}
!    ERR_BOOTED                          = 0x35, // booted
!    ERR_INVALIDSERIALFRAME              = 0x36, // invalid serial frame
!    ERR_INVALIDPACKETFROMRADIO          = 0x37, // invalid packet frome radio, length {1} (code location {0})
!    ERR_BUSY_RECEIVING                  = 0x38, // busy receiving when stop of serial activity, buffer input length {1} (code location {0})
!    ERR_WRONG_CRC_INPUT                 = 0x39, // wrong CRC in input Buffer (input length {0})
  };
  
  //=========================== typedef =========================================
***************
*** 245,254 ****
  
  //=========================== typedef =========================================
  
  typedef uint16_t  errorparameter_t;
  typedef uint16_t  dagrank_t;
! typedef uint8_t   error_t;
! #define bool uint8_t
  
  PRAGMA(pack(1));
  typedef struct {
--- 257,267 ----
  
  //=========================== typedef =========================================
  
+ 
  typedef uint16_t  errorparameter_t;
  typedef uint16_t  dagrank_t;
! typedef uint8_t   owerror_t;
! //#define bool uint8_t
  
  PRAGMA(pack(1));
  typedef struct {
***************
*** 288,294 ****
     open_addr_t   l3_destinationAdd;              // 128b IPv6 destination (down stack) 
     open_addr_t   l3_sourceAdd;                   // 128b IPv6 source address 
     //l2
!    error_t       l2_sendDoneError;               // outcome of trying to send this packet
     open_addr_t   l2_nextORpreviousHop;           // 64b IEEE802.15.4 next (down stack) or previous (up) hop address
     uint8_t       l2_frameType;                   // beacon, data, ack, cmd
     uint8_t       l2_dsn;                         // sequence number of the received frame
--- 301,307 ----
     open_addr_t   l3_destinationAdd;              // 128b IPv6 destination (down stack) 
     open_addr_t   l3_sourceAdd;                   // 128b IPv6 source address 
     //l2
!    owerror_t     l2_sendDoneError;               // outcome of trying to send this packet
     open_addr_t   l2_nextORpreviousHop;           // 64b IEEE802.15.4 next (down stack) or previous (up) hop address
     uint8_t       l2_frameType;                   // beacon, data, ack, cmd
     uint8_t       l2_dsn;                         // sequence number of the received frame
***************
*** 296,301 ****
--- 309,317 ----
     uint8_t       l2_numTxAttempts;               // number Tx attempts
     asn_t         l2_asn;                         // at what ASN the packet was Tx'ed or Rx'ed
     uint8_t*      l2_payload;                     // pointer to the start of the payload of l2 (used for MAC to fill in ASN in ADV)
+    uint8_t*      l2_ASNpayload;                  // pointer to the ASN in EB
+    uint8_t       l2_joinPriority;                // the join priority received in EB
+    bool          l2_joinPriorityPresent;
     //l1 (drivers)
     uint8_t       l1_txPower;                     // power for packet to Tx at
     int8_t        l1_rssi;                        // RSSI of received packet
***************
*** 309,314 ****
  
  //=========================== prototypes ======================================
  
! void openwsn_init();
  
  #endif
--- 325,330 ----
  
  //=========================== prototypes ======================================
  
! extern void openwsn_init(void);
  
  #endif
diff -crB stock/openwsn/radio.c dev/openwsn/radio.c
*** stock/openwsn/radio.c	Tue Jan 28 12:35:57 2014
--- dev/openwsn/radio.c	Wed Jan 29 10:33:22 2014
***************
*** 34,40 ****
  
  //===== admin
  
! void radio_init() {
     // clear variables
     memset(&radio_vars,0,sizeof(radio_vars_t));
     
--- 34,40 ----
  
  //===== admin
  
! void radio_init(void) {
     // clear variables
     memset(&radio_vars,0,sizeof(radio_vars_t));
     
***************
*** 69,75 ****
  
  //===== reset
  
! void radio_reset() {
     volatile uint16_t     delay;
     cc2420_MDMCTRL0_reg_t cc2420_MDMCTRL0_reg;
     cc2420_TXCTRL_reg_t   cc2420_TXCTRL_reg;
--- 69,75 ----
  
  //===== reset
  
! void radio_reset(void) {
     volatile uint16_t     delay;
     cc2420_MDMCTRL0_reg_t cc2420_MDMCTRL0_reg;
     cc2420_TXCTRL_reg_t   cc2420_TXCTRL_reg;
***************
*** 136,142 ****
     radiotimer_start(period);
  }
  
! uint16_t radio_getTimerValue() {
     return radiotimer_getValue();
  }
  
--- 136,142 ----
     radiotimer_start(period);
  }
  
! uint16_t radio_getTimerValue(void) {
     return radiotimer_getValue();
  }
  
***************
*** 144,150 ****
     radiotimer_setPeriod(period);
  }
  
! uint16_t radio_getTimerPeriod() {
     return radiotimer_getPeriod();
  }
  
--- 144,150 ----
     radiotimer_setPeriod(period);
  }
  
! uint16_t radio_getTimerPeriod(void) {
     return radiotimer_getPeriod();
  }
  
***************
*** 173,186 ****
     radio_vars.state = RADIOSTATE_FREQUENCY_SET;
  }
  
! void radio_rfOn() {   
     radio_spiStrobe(CC2420_SXOSCON, &radio_vars.radioStatusByte);
     while (radio_vars.radioStatusByte.xosc16m_stable==0) {
        radio_spiStrobe(CC2420_SNOP, &radio_vars.radioStatusByte);
     }
  }
  
! void radio_rfOff() {
     
     // change state
     radio_vars.state = RADIOSTATE_TURNING_OFF;
--- 173,186 ----
     radio_vars.state = RADIOSTATE_FREQUENCY_SET;
  }
  
! void radio_rfOn(void) {   
     radio_spiStrobe(CC2420_SXOSCON, &radio_vars.radioStatusByte);
     while (radio_vars.radioStatusByte.xosc16m_stable==0) {
        radio_spiStrobe(CC2420_SNOP, &radio_vars.radioStatusByte);
     }
  }
  
! void radio_rfOff(void) {
     
     // change state
     radio_vars.state = RADIOSTATE_TURNING_OFF;
***************
*** 209,215 ****
     radio_vars.state = RADIOSTATE_PACKET_LOADED;
  }
  
! void radio_txEnable() {
     // change state
     radio_vars.state = RADIOSTATE_ENABLING_TX;
     
--- 209,215 ----
     radio_vars.state = RADIOSTATE_PACKET_LOADED;
  }
  
! void radio_txEnable(void) {
     // change state
     radio_vars.state = RADIOSTATE_ENABLING_TX;
     
***************
*** 223,229 ****
     radio_vars.state = RADIOSTATE_TX_ENABLED;
  }
  
! void radio_txNow() {
     // change state
     radio_vars.state = RADIOSTATE_TRANSMITTING;
     
--- 223,229 ----
     radio_vars.state = RADIOSTATE_TX_ENABLED;
  }
  
! void radio_txNow(void) {
     // change state
     radio_vars.state = RADIOSTATE_TRANSMITTING;
     
***************
*** 232,238 ****
  
  //===== RX
  
! void radio_rxEnable() {
     // change state
     radio_vars.state = RADIOSTATE_ENABLING_RX;
     
--- 232,238 ----
  
  //===== RX
  
! void radio_rxEnable(void) {
     // change state
     radio_vars.state = RADIOSTATE_ENABLING_RX;
     
***************
*** 253,259 ****
     radio_vars.state = RADIOSTATE_LISTENING;
  }
  
! void radio_rxNow() {
     // nothing to do, the radio is already listening.
  }
  
--- 253,259 ----
     radio_vars.state = RADIOSTATE_LISTENING;
  }
  
! void radio_rxNow(void) {
     // nothing to do, the radio is already listening.
  }
  
diff -crB stock/openwsn/radio.h dev/openwsn/radio.h
*** stock/openwsn/radio.h	Tue Jan 28 12:35:57 2014
--- dev/openwsn/radio.h	Wed Jan 29 10:33:22 2014
***************
*** 1,12 ****
  /**
  \brief Cross-platform declaration "radio" bsp module.
  
  \author Thomas Watteyne <watteyne@eecs.berkeley.edu>, February 2012.
  */
  
- #ifndef __RADIO_H
- #define __RADIO_H
- 
  #include "radiotimer.h"
  
  //=========================== define ==========================================
--- 1,17 ----
+ #ifndef __RADIO_H
+ #define __RADIO_H
+ 
  /**
+ \addtogroup BSP
+ \{
+ \addtogroup radio
+ \{
+ 
  \brief Cross-platform declaration "radio" bsp module.
  
  \author Thomas Watteyne <watteyne@eecs.berkeley.edu>, February 2012.
  */
  
  #include "radiotimer.h"
  
  //=========================== define ==========================================
***************
*** 44,72 ****
  //=========================== prototypes ======================================
  
  // admin
! void     radio_init();
  void     radio_setOverflowCb(radiotimer_compare_cbt cb);
  void     radio_setCompareCb(radiotimer_compare_cbt cb);
  void     radio_setStartFrameCb(radiotimer_capture_cbt cb);
  void     radio_setEndFrameCb(radiotimer_capture_cbt cb);
  // reset
! void     radio_reset();
  // timer
  void     radio_startTimer(PORT_TIMER_WIDTH period);
! PORT_TIMER_WIDTH radio_getTimerValue();
  void     radio_setTimerPeriod(PORT_TIMER_WIDTH period);
! PORT_TIMER_WIDTH radio_getTimerPeriod();
  // RF admin
  void     radio_setFrequency(uint8_t frequency);
! void     radio_rfOn();
! void     radio_rfOff();
  // TX
  void     radio_loadPacket(uint8_t* packet, uint8_t len);
! void     radio_txEnable();
! void     radio_txNow();
  // RX
! void     radio_rxEnable();
! void     radio_rxNow();
  void     radio_getReceivedFrame(uint8_t* bufRead,
                                  uint8_t* lenRead,
                                  uint8_t  maxBufLen,
--- 49,77 ----
  //=========================== prototypes ======================================
  
  // admin
! void     radio_init(void);
  void     radio_setOverflowCb(radiotimer_compare_cbt cb);
  void     radio_setCompareCb(radiotimer_compare_cbt cb);
  void     radio_setStartFrameCb(radiotimer_capture_cbt cb);
  void     radio_setEndFrameCb(radiotimer_capture_cbt cb);
  // reset
! void     radio_reset(void);
  // timer
  void     radio_startTimer(PORT_TIMER_WIDTH period);
! PORT_TIMER_WIDTH radio_getTimerValue(void);
  void     radio_setTimerPeriod(PORT_TIMER_WIDTH period);
! PORT_TIMER_WIDTH radio_getTimerPeriod(void);
  // RF admin
  void     radio_setFrequency(uint8_t frequency);
! void     radio_rfOn(void);
! void     radio_rfOff(void);
  // TX
  void     radio_loadPacket(uint8_t* packet, uint8_t len);
! void     radio_txEnable(void);
! void     radio_txNow(void);
  // RX
! void     radio_rxEnable(void);
! void     radio_rxNow(void);
  void     radio_getReceivedFrame(uint8_t* bufRead,
                                  uint8_t* lenRead,
                                  uint8_t  maxBufLen,
***************
*** 75,80 ****
                                  uint8_t* crc);
  
  // interrupt handlers
! kick_scheduler_t   radio_isr();
  
  #endif
--- 80,90 ----
                                  uint8_t* crc);
  
  // interrupt handlers
! kick_scheduler_t   radio_isr(void);
! 
! /**
! \}
! \}
! */
  
  #endif
diff -crB stock/openwsn/radiotimer.c dev/openwsn/radiotimer.c
*** stock/openwsn/radiotimer.c	Tue Jan 28 12:35:57 2014
--- dev/openwsn/radiotimer.c	Wed Jan 29 10:33:22 2014
***************
*** 25,31 ****
  
  //===== admin
  
! void radiotimer_init() {
     // clear local variables
     memset(&radiotimer_vars,0,sizeof(radiotimer_vars_t));
  }
--- 25,31 ----
  
  //===== admin
  
! void radiotimer_init(void) {
     // clear local variables
     memset(&radiotimer_vars,0,sizeof(radiotimer_vars_t));
  }
***************
*** 46,52 ****
     radiotimer_vars.endFrameCb     = cb;
  }
  
! void radiotimer_start(uint16_t period) {
     // radio's SFD pin connected to P4.1
     P4DIR   &= ~0x02; // input
     P4SEL   |=  0x02; // in CCI1a/B mode
--- 46,52 ----
     radiotimer_vars.endFrameCb     = cb;
  }
  
! void radiotimer_start(PORT_RADIOTIMER_WIDTH period) {
     // radio's SFD pin connected to P4.1
     P4DIR   &= ~0x02; // input
     P4SEL   |=  0x02; // in CCI1a/B mode
***************
*** 70,90 ****
  
  //===== direct access
  
! uint16_t radiotimer_getValue() {
     return TBR;
  }
  
! void radiotimer_setPeriod(uint16_t period) {
     TBCCR0   =  period;
  }
  
! uint16_t radiotimer_getPeriod() {
     return TBCCR0;
  }
  
  //===== compare
  
! void radiotimer_schedule(uint16_t offset) {
     // offset when to fire
     TBCCR2   =  offset;
     
--- 70,90 ----
  
  //===== direct access
  
! PORT_RADIOTIMER_WIDTH radiotimer_getValue(void) {
     return TBR;
  }
  
! void radiotimer_setPeriod(PORT_RADIOTIMER_WIDTH period) {
     TBCCR0   =  period;
  }
  
! PORT_RADIOTIMER_WIDTH radiotimer_getPeriod(void) {
     return TBCCR0;
  }
  
  //===== compare
  
! void radiotimer_schedule(PORT_RADIOTIMER_WIDTH offset) {
     // offset when to fire
     TBCCR2   =  offset;
     
***************
*** 92,98 ****
     TBCCTL2  =  CCIE;
  }
  
! void radiotimer_cancel() {
     // reset compare value (also resets interrupt flag)
     TBCCR2   =  0;
     
--- 92,98 ----
     TBCCTL2  =  CCIE;
  }
  
! void radiotimer_cancel(void) {
     // reset compare value (also resets interrupt flag)
     TBCCR2   =  0;
     
***************
*** 102,108 ****
  
  //===== capture
  
! inline uint16_t radiotimer_getCapturedTime() {
     // this should never happpen!
     
     // we can not print from within the BSP. Instead:
--- 102,108 ----
  
  //===== capture
  
! inline PORT_RADIOTIMER_WIDTH radiotimer_getCapturedTime(void) {
     // this should never happpen!
     
     // we can not print from within the BSP. Instead:
***************
*** 121,128 ****
  /**
  \brief TimerB CCR1-6 interrupt service routine
  */
! kick_scheduler_t radiotimer_isr() {
!    uint16_t tbiv_local;
     
     // reading TBIV returns the value of the highest pending interrupt flag
     // and automatically resets that flag. We therefore copy its value to the
--- 121,128 ----
  /**
  \brief TimerB CCR1-6 interrupt service routine
  */
! kick_scheduler_t radiotimer_isr(void) {
!    PORT_RADIOTIMER_WIDTH tbiv_local;
     
     // reading TBIV returns the value of the highest pending interrupt flag
     // and automatically resets that flag. We therefore copy its value to the
diff -crB stock/openwsn/radiotimer.h dev/openwsn/radiotimer.h
*** stock/openwsn/radiotimer.h	Tue Jan 28 12:35:57 2014
--- dev/openwsn/radiotimer.h	Wed Jan 29 10:33:22 2014
***************
*** 1,20 ****
  /**
  \brief Cross-platform declaration "radiotimer" bsp module.
  
  \author Thomas Watteyne <watteyne@eecs.berkeley.edu>, February 2012.
  */
  
- #ifndef __RADIOTIMER_H
- #define __RADIOTIMER_H
- 
  #include "stdint.h"
! #include "board.h"
  
  //=========================== define ==========================================
  
  //=========================== typedef =========================================
  
! typedef void (*radiotimer_compare_cbt)();
  typedef void (*radiotimer_capture_cbt)(PORT_TIMER_WIDTH timestamp);
  
  //=========================== variables =======================================
--- 1,25 ----
+ #ifndef __RADIOTIMER_H
+ #define __RADIOTIMER_H
+ 
  /**
+ \addtogroup BSP
+ \{
+ \addtogroup radiotimer
+ \{
+ 
  \brief Cross-platform declaration "radiotimer" bsp module.
  
  \author Thomas Watteyne <watteyne@eecs.berkeley.edu>, February 2012.
  */
  
  #include "stdint.h"
! #include "board_ow.h"
  
  //=========================== define ==========================================
  
  //=========================== typedef =========================================
  
! typedef void (*radiotimer_compare_cbt)(void);
  typedef void (*radiotimer_capture_cbt)(PORT_TIMER_WIDTH timestamp);
  
  //=========================== variables =======================================
***************
*** 22,44 ****
  //=========================== prototypes ======================================
  
  // admin
! void     radiotimer_init();
  void     radiotimer_setOverflowCb(radiotimer_compare_cbt cb);
  void     radiotimer_setCompareCb(radiotimer_compare_cbt cb);
  void     radiotimer_setStartFrameCb(radiotimer_capture_cbt cb);
  void     radiotimer_setEndFrameCb(radiotimer_capture_cbt cb);
! void     radiotimer_start(PORT_TIMER_WIDTH period);
  // direct access
! PORT_TIMER_WIDTH radiotimer_getValue();
! void     radiotimer_setPeriod(PORT_TIMER_WIDTH period);
! PORT_TIMER_WIDTH radiotimer_getPeriod();
  // compare
! void     radiotimer_schedule(PORT_TIMER_WIDTH offset);
! void     radiotimer_cancel();
  // capture
! PORT_TIMER_WIDTH radiotimer_getCapturedTime();
  
  // interrupt handlers
! kick_scheduler_t   radiotimer_isr();
  
  #endif
--- 27,54 ----
  //=========================== prototypes ======================================
  
  // admin
! void     radiotimer_init(void);
  void     radiotimer_setOverflowCb(radiotimer_compare_cbt cb);
  void     radiotimer_setCompareCb(radiotimer_compare_cbt cb);
  void     radiotimer_setStartFrameCb(radiotimer_capture_cbt cb);
  void     radiotimer_setEndFrameCb(radiotimer_capture_cbt cb);
! void     radiotimer_start(PORT_RADIOTIMER_WIDTH period);
  // direct access
! PORT_RADIOTIMER_WIDTH radiotimer_getValue(void);
! void     radiotimer_setPeriod(PORT_RADIOTIMER_WIDTH period);
! PORT_RADIOTIMER_WIDTH radiotimer_getPeriod(void);
  // compare
! void     radiotimer_schedule(PORT_RADIOTIMER_WIDTH offset);
! void     radiotimer_cancel(void);
  // capture
! PORT_RADIOTIMER_WIDTH radiotimer_getCapturedTime(void);
  
  // interrupt handlers
! kick_scheduler_t   radiotimer_isr(void);
! 
! /**
! \}
! \}
! */
  
  #endif
diff -crB stock/openwsn/scheduler.c dev/openwsn/scheduler.c
*** stock/openwsn/scheduler.c	Tue Jan 28 12:35:57 2014
--- dev/openwsn/scheduler.c	Wed Jan 29 11:05:28 2014
***************
*** 6,38 ****
  
  #include "openwsn.h"
  #include "scheduler.h"
! #include "board.h"
  #include "debugpins.h"
  #include "leds.h"
  
! //=========================== variables =======================================
  
! typedef struct task_llist_t {
!    task_cbt             cb;
!    task_prio_t          prio;
!    void*                next;
! } taskList_item_t;
! 
! typedef struct {
!    taskList_item_t      taskBuf[TASK_LIST_DEPTH];
!    taskList_item_t*     task_list;
!    uint8_t              numTasksCur;
!    uint8_t              numTasksMax;
! } scheduler_vars_t;
  
  scheduler_vars_t scheduler_vars;
! 
! typedef struct {
!    uint8_t              numTasksCur;
!    uint8_t              numTasksMax;
! } scheduler_dbg_t;
! 
! scheduler_dbg_t scheduler_dbg;
  
  //=========================== prototypes ======================================
  
--- 6,22 ----
  
  #include "openwsn.h"
  #include "scheduler.h"
! #include "board_ow.h"
  #include "debugpins.h"
  #include "leds.h"
  
! #define ENABLE_DEBUG (0)
! #include "debug.h"
  
! //=========================== variables =======================================
  
  scheduler_vars_t scheduler_vars;
! scheduler_dbg_t  scheduler_dbg;
  
  //=========================== prototypes ======================================
  
***************
*** 41,56 ****
  //=========================== public ==========================================
  
  void scheduler_init() {   
-    
     // initialization module variables
     memset(&scheduler_vars,0,sizeof(scheduler_vars_t));
     memset(&scheduler_dbg,0,sizeof(scheduler_dbg_t));
     
     // enable the scheduler's interrupt so SW can wake up the scheduler
!    SCHEDULER_ENABLE_INTERRUPT();
  }
  
  void scheduler_start() {
     taskList_item_t* pThisTask;
     while (1) {
        while(scheduler_vars.task_list!=NULL) {
--- 25,41 ----
  //=========================== public ==========================================
  
  void scheduler_init() {   
     // initialization module variables
     memset(&scheduler_vars,0,sizeof(scheduler_vars_t));
     memset(&scheduler_dbg,0,sizeof(scheduler_dbg_t));
     
     // enable the scheduler's interrupt so SW can wake up the scheduler
!    //SCHEDULER_ENABLE_INTERRUPT();
!    DEBUG(__PRETTY_FUNCTION__);
  }
  
  void scheduler_start() {
+     DEBUG(__PRETTY_FUNCTION__);
     taskList_item_t* pThisTask;
     while (1) {
        while(scheduler_vars.task_list!=NULL) {
***************
*** 58,64 ****
           
           // the task to execute is the one at the head of the queue
           pThisTask                = scheduler_vars.task_list;
!          
           // shift the queue by one task
           scheduler_vars.task_list = pThisTask->next;
           
--- 43,49 ----
           
           // the task to execute is the one at the head of the queue
           pThisTask                = scheduler_vars.task_list;
!          DEBUG("run task %p with prio %d\n", pThisTask->cb, pThisTask->prio);
           // shift the queue by one task
           scheduler_vars.task_list = pThisTask->next;
           
***************
*** 71,83 ****
           pThisTask->next          = NULL;
           scheduler_dbg.numTasksCur--;
        }
!       debugpins_task_clr();
        board_sleep();
!       debugpins_task_set();                      // IAR should halt here if nothing to do
     }
  }
  
   void scheduler_push_task(task_cbt cb, task_prio_t prio) {
     taskList_item_t*  taskContainer;
     taskList_item_t** taskListWalker;
     INTERRUPT_DECLARATION();
--- 56,70 ----
           pThisTask->next          = NULL;
           scheduler_dbg.numTasksCur--;
        }
!       //debugpins_task_clr();
        board_sleep();
!       //debugpins_task_set();                      // IAR should halt here if nothing to do
     }
+    DEBUG("leaving... WTF?!");
  }
  
   void scheduler_push_task(task_cbt cb, task_prio_t prio) {
+      DEBUG(__PRETTY_FUNCTION__);
     taskList_item_t*  taskContainer;
     taskList_item_t** taskListWalker;
     INTERRUPT_DECLARATION();
***************
*** 117,124 ****
     if (scheduler_dbg.numTasksCur>scheduler_dbg.numTasksMax) {
        scheduler_dbg.numTasksMax   = scheduler_dbg.numTasksCur;
     }
-    
     ENABLE_INTERRUPTS();
! }
! 
! //=========================== private =========================================
--- 104,108 ----
     if (scheduler_dbg.numTasksCur>scheduler_dbg.numTasksMax) {
        scheduler_dbg.numTasksMax   = scheduler_dbg.numTasksCur;
     }
     ENABLE_INTERRUPTS();
!  }
diff -crB stock/openwsn/scheduler.h dev/openwsn/scheduler.h
*** stock/openwsn/scheduler.h	Tue Jan 28 12:35:57 2014
--- dev/openwsn/scheduler.h	Wed Jan 29 10:33:22 2014
***************
*** 2,8 ****
  #define __SCHEDULER_H
  
  /**
! \addtogroup drivers
  \{
  \addtogroup Scheduler
  \{
--- 2,8 ----
  #define __SCHEDULER_H
  
  /**
! \addtogroup kernel
  \{
  \addtogroup Scheduler
  \{
***************
*** 33,51 ****
  
  typedef void (*task_cbt)(void);
  
! //=========================== variables =======================================
  
  //=========================== prototypes ======================================
  
  // public functions
! void scheduler_init();
! void scheduler_start();
  void scheduler_push_task(task_cbt task_cb, task_prio_t prio);
  
  // interrupt handlers
! void isr_ieee154e_newSlot();
! void isr_ieee154e_timer();
! void isr_adc();
  #ifdef ISR_GYRO
  void isr_gyro();
  #endif
--- 33,69 ----
  
  typedef void (*task_cbt)(void);
  
! typedef struct task_llist_t {
!    task_cbt             cb;
!    task_prio_t          prio;
!    void*                next;
! } taskList_item_t;
! 
! //=========================== module variables ================================
! 
! typedef struct {
!    taskList_item_t      taskBuf[TASK_LIST_DEPTH];
!    taskList_item_t*     task_list;
!    uint8_t              numTasksCur;
!    uint8_t              numTasksMax;
! } scheduler_vars_t;
! 
! typedef struct {
!    uint8_t              numTasksCur;
!    uint8_t              numTasksMax;
! } scheduler_dbg_t;
  
  //=========================== prototypes ======================================
  
  // public functions
! void scheduler_init(void);
! void scheduler_start(void);
  void scheduler_push_task(task_cbt task_cb, task_prio_t prio);
  
  // interrupt handlers
! void isr_ieee154e_newSlot(void);
! void isr_ieee154e_timer(void);
! void isr_adc(void);
  #ifdef ISR_GYRO
  void isr_gyro();
  #endif
diff -crB stock/openwsn/spi.c dev/openwsn/spi.c
*** stock/openwsn/spi.c	Tue Jan 28 12:35:57 2014
--- dev/openwsn/spi.c	Wed Jan 29 11:52:32 2014
***************
*** 8,13 ****
--- 8,16 ----
  #include "spi.h"
  #include "leds.h"
  
+ #define ENABLE_DEBUG (0)
+ #include "debug.h"
+ 
  //=========================== defines =========================================
  
  //=========================== variables =======================================
***************
*** 26,32 ****
     uint8_t         busy;
  #ifdef SPI_IN_INTERRUPT_MODE
     // callback when module done
!    spi_cbt         callback;
  #endif
  } spi_vars_t;
  
--- 29,35 ----
     uint8_t         busy;
  #ifdef SPI_IN_INTERRUPT_MODE
     // callback when module done
!    spi_cbt         spi_cb;
  #endif
  } spi_vars_t;
  
***************
*** 36,42 ****
  
  //=========================== public ==========================================
  
! void spi_init() {
     // clear variables
     memset(&spi_vars,0,sizeof(spi_vars_t));
     
--- 39,45 ----
  
  //=========================== public ==========================================
  
! void spi_init(void) {
     // clear variables
     memset(&spi_vars,0,sizeof(spi_vars_t));
     
***************
*** 134,140 ****
     if (spi_vars.isFirst==SPI_FIRST) {
        P4OUT                 &= ~0x04;
     }
!    
  #ifdef SPI_IN_INTERRUPT_MODE
     // implementation 1. use a callback function when transaction finishes
     
--- 137,143 ----
     if (spi_vars.isFirst==SPI_FIRST) {
        P4OUT                 &= ~0x04;
     }
! 
  #ifdef SPI_IN_INTERRUPT_MODE
     // implementation 1. use a callback function when transaction finishes
     
***************
*** 145,157 ****
     __enable_interrupt();
  #else
     // implementation 2. busy wait for each byte to be sent
!    
     // send all bytes
     while (spi_vars.txBytesLeft>0) {
        // write next byte to TX buffer
        U0TXBUF                = *spi_vars.pNextTxByte;
        // busy wait on the interrupt flag
!       while ((IFG1 & URXIFG0)==0);
        // clear the interrupt flag
        IFG1                  &= ~URXIFG0;
        // save the byte just received in the RX buffer
--- 148,165 ----
     __enable_interrupt();
  #else
     // implementation 2. busy wait for each byte to be sent
! 
     // send all bytes
     while (spi_vars.txBytesLeft>0) {
        // write next byte to TX buffer
        U0TXBUF                = *spi_vars.pNextTxByte;
        // busy wait on the interrupt flag
!       uint32_t c = 0;
!       while ((IFG1 & URXIFG0)==0) 
!           if (c++ == 1000) {
!               DEBUG("spi_txrx timeout"); 
!               break;
!           }
        // clear the interrupt flag
        IFG1                  &= ~URXIFG0;
        // save the byte just received in the RX buffer
***************
*** 174,180 ****
        spi_vars.numTxedBytes++;
        spi_vars.txBytesLeft--;
     }
!    
     // put CS signal high to signal end of transmission to slave
     if (spi_vars.isLast==SPI_LAST) {
        P4OUT                 |=  0x04;
--- 182,188 ----
        spi_vars.numTxedBytes++;
        spi_vars.txBytesLeft--;
     }
! 
     // put CS signal high to signal end of transmission to slave
     if (spi_vars.isLast==SPI_LAST) {
        P4OUT                 |=  0x04;
***************
*** 189,195 ****
  
  //=========================== interrupt handlers ==============================
  
! kick_scheduler_t spi_isr() {
  #ifdef SPI_IN_INTERRUPT_MODE   
     // save the byte just received in the RX buffer
     switch (spi_vars.returnType) {
--- 197,203 ----
  
  //=========================== interrupt handlers ==============================
  
! kick_scheduler_t spi_isr(void) {
  #ifdef SPI_IN_INTERRUPT_MODE   
     // save the byte just received in the RX buffer
     switch (spi_vars.returnType) {
***************
*** 224,230 ****
        spi_vars.busy             =  0;
        
        // SPI is done!
!       if (spi_vars.callback!=NULL) {
           // call the callback
           spi_vars.spi_cb();
           // kick the OS
--- 232,238 ----
        spi_vars.busy             =  0;
        
        // SPI is done!
!       if (spi_vars.spi_cb!=NULL) {
           // call the callback
           spi_vars.spi_cb();
           // kick the OS
diff -crB stock/openwsn/spi.h dev/openwsn/spi.h
*** stock/openwsn/spi.h	Tue Jan 28 12:35:57 2014
--- dev/openwsn/spi.h	Wed Jan 29 10:33:22 2014
***************
*** 8,14 ****
  #define __SPI_H
  
  #include "stdint.h"
! #include "board.h"
  
  //=========================== define ==========================================
  
--- 8,14 ----
  #define __SPI_H
  
  #include "stdint.h"
! #include "board_ow.h"
  
  //=========================== define ==========================================
  
***************
*** 49,55 ****
  
  //=========================== prototypes ======================================
  
! void    spi_init();
  #ifdef SPI_IN_INTERRUPT_MODE
  void    spi_setCb(spi_cbt cb);
  #endif
--- 49,55 ----
  
  //=========================== prototypes ======================================
  
! void    spi_init(void);
  #ifdef SPI_IN_INTERRUPT_MODE
  void    spi_setCb(spi_cbt cb);
  #endif
***************
*** 62,67 ****
                   spi_last_t   isLast);
  
  // interrupt handlers
! kick_scheduler_t spi_isr();
  
  #endif
--- 62,67 ----
                   spi_last_t   isLast);
  
  // interrupt handlers
! kick_scheduler_t spi_isr(void);
  
  #endif
diff -crB stock/openwsn/uart_ow.c dev/openwsn/uart_ow.c
*** stock/openwsn/uart_ow.c	Tue Jan 28 12:35:57 2014
--- dev/openwsn/uart_ow.c	Wed Jan 29 10:33:22 2014
***************
*** 5,12 ****
  */
  
  #include "msp430f1611.h"
! #include "uart.h"
! #include "board.h"
  
  //=========================== defines =========================================
  
--- 5,12 ----
  */
  
  #include "msp430f1611.h"
! #include "uart_ow.h"
! #include "board_ow.h"
  
  //=========================== defines =========================================
  
***************
*** 23,29 ****
  
  //=========================== public ==========================================
  
! void uart_init() {
     P3SEL                    |=  0xc0;            // P3.6,7 = UART1TX/RX
     
     UCTL1                     =  SWRST;           // hold UART1 module in reset
--- 23,29 ----
  
  //=========================== public ==========================================
  
! void uart_init_ow(void) {
     P3SEL                    |=  0xc0;            // P3.6,7 = UART1TX/RX
     
     UCTL1                     =  SWRST;           // hold UART1 module in reset
***************
*** 53,71 ****
     uart_vars.rxCb = rxCb;
  }
  
! void    uart_enableInterrupts(){
    IE2 |=  (URXIE1 | UTXIE1);  
  }
  
! void    uart_disableInterrupts(){
    IE2 &= ~(URXIE1 | UTXIE1);
  }
  
! void    uart_clearRxInterrupts(){
    IFG2   &= ~URXIFG1;
  }
  
! void    uart_clearTxInterrupts(){
    IFG2   &= ~UTXIFG1;
  }
  
--- 53,71 ----
     uart_vars.rxCb = rxCb;
  }
  
! void    uart_enableInterrupts(void){
    IE2 |=  (URXIE1 | UTXIE1);  
  }
  
! void    uart_disableInterrupts(void){
    IE2 &= ~(URXIE1 | UTXIE1);
  }
  
! void    uart_clearRxInterrupts(void){
    IFG2   &= ~URXIFG1;
  }
  
! void    uart_clearTxInterrupts(void){
    IFG2   &= ~UTXIFG1;
  }
  
***************
*** 73,79 ****
    U1TXBUF = byteToWrite;
  }
  
! uint8_t uart_readByte(){
    return U1RXBUF;
  }
  
--- 73,79 ----
    U1TXBUF = byteToWrite;
  }
  
! uint8_t uart_readByte_ow(void){
    return U1RXBUF;
  }
  
***************
*** 81,93 ****
  
  //=========================== interrupt handlers ==============================
  
! kick_scheduler_t uart_tx_isr() {
     uart_clearTxInterrupts(); // TODO: do not clear, but disable when done
     uart_vars.txCb();
     return DO_NOT_KICK_SCHEDULER;
  }
  
! kick_scheduler_t uart_rx_isr() {
     uart_clearRxInterrupts(); // TODO: do not clear, but disable when done
     uart_vars.rxCb();
     return DO_NOT_KICK_SCHEDULER;
--- 81,93 ----
  
  //=========================== interrupt handlers ==============================
  
! kick_scheduler_t uart_tx_isr(void) {
     uart_clearTxInterrupts(); // TODO: do not clear, but disable when done
     uart_vars.txCb();
     return DO_NOT_KICK_SCHEDULER;
  }
  
! kick_scheduler_t uart_rx_isr(void) {
     uart_clearRxInterrupts(); // TODO: do not clear, but disable when done
     uart_vars.rxCb();
     return DO_NOT_KICK_SCHEDULER;
diff -crB stock/openwsn/uart_ow.h dev/openwsn/uart_ow.h
*** stock/openwsn/uart_ow.h	Tue Jan 28 12:35:57 2014
--- dev/openwsn/uart_ow.h	Wed Jan 29 10:33:22 2014
***************
*** 1,14 ****
  /**
  \brief Cross-platform declaration "uart" bsp module.
  
  \author Thomas Watteyne <watteyne@eecs.berkeley.edu>, February 2012.
  */
  
- #ifndef __UART_H
- #define __UART_H
- 
  #include "stdint.h"
! #include "board.h"
   
  //=========================== define ==========================================
  
--- 1,19 ----
+ #ifndef __UART_H
+ #define __UART_H
+ 
  /**
+ \addtogroup BSP
+ \{
+ \addtogroup uart
+ \{
+ 
  \brief Cross-platform declaration "uart" bsp module.
  
  \author Thomas Watteyne <watteyne@eecs.berkeley.edu>, February 2012.
  */
  
  #include "stdint.h"
! #include "board_ow.h"
   
  //=========================== define ==========================================
  
***************
*** 19,42 ****
     UART_EVENT_OVERFLOW,
  } uart_event_t;
  
! typedef void (*uart_tx_cbt)();
! typedef void (*uart_rx_cbt)();
  
  //=========================== variables =======================================
  
  //=========================== prototypes ======================================
  
! void    uart_init();
  void    uart_setCallbacks(uart_tx_cbt txCb, uart_rx_cbt rxCb);
! void    uart_enableInterrupts();
! void    uart_disableInterrupts();
! void    uart_clearRxInterrupts();
! void    uart_clearTxInterrupts();
  void    uart_writeByte(uint8_t byteToWrite);
! uint8_t uart_readByte();
  
  // interrupt handlers
! kick_scheduler_t uart_tx_isr();
! kick_scheduler_t uart_rx_isr();
  
! #endif
\ No newline at end of file
--- 24,52 ----
     UART_EVENT_OVERFLOW,
  } uart_event_t;
  
! typedef void (*uart_tx_cbt)(void);
! typedef void (*uart_rx_cbt)(void);
  
  //=========================== variables =======================================
  
  //=========================== prototypes ======================================
  
! void    uart_init_ow(void);
  void    uart_setCallbacks(uart_tx_cbt txCb, uart_rx_cbt rxCb);
! void    uart_enableInterrupts(void);
! void    uart_disableInterrupts(void);
! void    uart_clearRxInterrupts(void);
! void    uart_clearTxInterrupts(void);
  void    uart_writeByte(uint8_t byteToWrite);
! uint8_t uart_readByte_ow(void);
  
  // interrupt handlers
! kick_scheduler_t uart_tx_isr(void);
! kick_scheduler_t uart_rx_isr(void);
! 
! /**
! \}
! \}
! */
  
! #endif
