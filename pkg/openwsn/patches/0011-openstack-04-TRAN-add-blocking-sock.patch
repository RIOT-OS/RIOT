From 3e7c8eb5af1121e19ab80768a7483f50f6658bc7 Mon Sep 17 00:00:00 2001
From: Francisco Molina <femolina@uc.cl>
Date: Fri, 21 Aug 2020 09:11:48 +0200
Subject: [PATCH 11/11] openstack/04-TRAN: add blocking sock

---
 inc/opendefs.h                                |   3 +-
 openapps/uecho/uecho.c                        |   9 +-
 .../uexpiration_monitor/uexpiration_monitor.c |   9 +-
 openapps/uinject/uinject.c                    |   9 +-
 openstack/04-TRAN/sock.c                      | 194 ++++++++++++++----
 openstack/04-TRAN/sock.h                      |   3 +
 openstack/04-TRAN/sock_types.h                |  31 ++-
 openstack/openstack.c                         |   6 +-
 openweb/opencoap/coap.h                       |  10 +-
 9 files changed, 219 insertions(+), 55 deletions(-)

diff --git a/inc/opendefs.h b/inc/opendefs.h
index 29076b5c..6a263ca0 100644
--- a/inc/opendefs.h
+++ b/inc/opendefs.h
@@ -17,7 +17,8 @@
 #include "config.h"
 #include "toolchain_defs.h"
 #include "board_info.h"
-#include "af.h"
+#include "net/af.h"
+// #include "af.h"
 
 
 //=========================== define ==========================================
diff --git a/openapps/uecho/uecho.c b/openapps/uecho/uecho.c
index 4c4a6ec8..036ccfa3 100644
--- a/openapps/uecho/uecho.c
+++ b/openapps/uecho/uecho.c
@@ -4,12 +4,17 @@
 
 #include "opendefs.h"
 #include "uecho.h"
-#include "sock.h"
-#include "async.h"
+// #include "sock.h"
+// #include "async.h"
 #include "openqueue.h"
 #include "openserial.h"
 #include "packetfunctions.h"
 
+#ifdef SOCK_HAS_ASYNC
+#include "net/sock/async.h"
+#endif
+#include "net/sock/udp.h"
+
 //=========================== variables =======================================
 
 sock_udp_t uecho_sock;
diff --git a/openapps/uexpiration_monitor/uexpiration_monitor.c b/openapps/uexpiration_monitor/uexpiration_monitor.c
index 37155c25..c67e31dd 100644
--- a/openapps/uexpiration_monitor/uexpiration_monitor.c
+++ b/openapps/uexpiration_monitor/uexpiration_monitor.c
@@ -4,8 +4,8 @@
 
 #include "opendefs.h"
 #include "uexpiration_monitor.h"
-#include "sock.h"
-#include "async.h"
+// #include "sock.h"
+// #include "async.h"
 #include "openserial.h"
 #include "packetfunctions.h"
 
@@ -13,6 +13,11 @@
 #include "iphc.h"
 #endif
 
+#ifdef SOCK_HAS_ASYNC
+#include "net/sock/async.h"
+#endif
+#include "net/sock/udp.h"
+
 //=========================== variables =======================================
 
 static sock_udp_t _sock;
diff --git a/openapps/uinject/uinject.c b/openapps/uinject/uinject.c
index 499d6633..08d9bbe6 100644
--- a/openapps/uinject/uinject.c
+++ b/openapps/uinject/uinject.c
@@ -4,8 +4,8 @@
 
 #include "opendefs.h"
 #include "uinject.h"
-#include "sock.h"
-#include "async.h"
+// #include "sock.h"
+// #include "async.h"
 #include "openserial.h"
 #include "packetfunctions.h"
 #include "scheduler.h"
@@ -15,6 +15,11 @@
 #include "idmanager.h"
 #include "openrandom.h"
 
+#ifdef SOCK_HAS_ASYNC
+#include "net/sock/async.h"
+#endif
+#include "net/sock/udp.h"
+
 #include "msf.h"
 
 //=========================== defines =========================================
diff --git a/openstack/04-TRAN/sock.c b/openstack/04-TRAN/sock.c
index 689a4cb2..0f0d39c2 100644
--- a/openstack/04-TRAN/sock.c
+++ b/openstack/04-TRAN/sock.c
@@ -3,8 +3,8 @@
 #if defined(OPENWSN_UDP_C)
 
 #include "opendefs.h"
-#include "sock.h"
-#include "af.h"
+#include "opentimers.h"
+// #include "sock.h"
 #include "errno.h"
 #include "packetfunctions.h"
 #include "openqueue.h"
@@ -14,12 +14,30 @@
 #include "scheduler.h"
 #include "openserial.h"
 
-// ============================ defines ========================================
+#ifdef SOCK_HAS_ASYNC
+#include "net/sock/async.h"
+#endif
+#include "net/sock/udp.h"
+#include "openwsn_log.h"
+#ifdef MODULE_ZTIMER
+#include "ztimer.h"
+#endif /* MODULE_ZTIMER */
+
+//============================ defines ========================================
+
+#ifdef MODULE_OPENWSN
+#define _MSG_TYPE_RECV_PKT (0x1601)
+#ifdef MODULE_ZTIMER
+#define _TIMEOUT_MAGIC     (0xF38A0B63U)
+#define _TIMEOUT_MSG_TYPE  (0x8474)
+#endif /* MODULE_ZTIMER */
+#endif /* MODULE_OPENWSN */
 
-sock_udp_t* udp_socket_list;
+//=========================== variables =======================================
 
-// =========================== variables =======================================
-// =========================== prototypes ======================================
+static sock_udp_t *_udp_socket_list;
+
+//=========================== prototypes ======================================
 
 static bool _sock_valid_af(uint8_t af);
 
@@ -29,10 +47,14 @@ static void _sock_get_local_addr(open_addr_t* local);
 
 static void _sock_transmit_internal(void);
 
+#ifdef MODULE_ZTIMER
+static void _timeout_cb(void *arg);
+#endif
+
 // ============================= public ========================================
 
 void sock_udp_init(void) {
-    udp_socket_list = NULL;
+    _udp_socket_list = NULL;
 }
 
 int sock_udp_create(sock_udp_t* sock, const sock_udp_ep_t* local, const sock_udp_ep_t* remote, uint16_t flags) {
@@ -42,10 +64,14 @@ int sock_udp_create(sock_udp_t* sock, const sock_udp_ep_t* local, const sock_udp
         return -EINVAL;
     }
 
+#ifdef MODULE_OPENWSN
+    mbox_init(&sock->mbox, sock->mbox_queue, OPENWSN_SOCK_MBOX_SIZE);
+#endif
+
     memset(&sock->gen_sock.local, 0, sizeof(sock_udp_ep_t));
 
     if (local != NULL) {
-        current = udp_socket_list;
+        current = _udp_socket_list;
 
         while (current != NULL) {
             if (current->gen_sock.local.port == local->port) {
@@ -73,10 +99,13 @@ int sock_udp_create(sock_udp_t* sock, const sock_udp_ep_t* local, const sock_udp
     }
 
     sock->gen_sock.flags = flags;
+
+#ifdef SOCK_HAS_ASYNC
     sock->async_cb = NULL;
+#endif
 
-    sock->next = udp_socket_list;
-    udp_socket_list = sock;
+    sock->next = _udp_socket_list;
+    _udp_socket_list = sock;
 
     return 0;
 }
@@ -144,21 +173,21 @@ int sock_udp_send(sock_udp_t* sock, const void* data, size_t len, const sock_udp
 
     memcpy(pkt->payload, data, len);
 
-    scheduler_push_task(_sock_transmit_internal, TASKPRIO_UDP);
-
     pkt->l4_payload = pkt->payload;
     pkt->l4_length = pkt->length;
 
+    scheduler_push_task(_sock_transmit_internal, TASKPRIO_UDP);
+
     return len;
 }
 
 void sock_udp_close(sock_udp_t* sock) {
-    sock_udp_t* temp = udp_socket_list;
-    sock_udp_t* prev = udp_socket_list;
+    sock_udp_t* temp = _udp_socket_list;
+    sock_udp_t* prev = _udp_socket_list;
 
     /* check if head is the socket to be closed */
     if (temp != NULL && temp == sock) {
-        udp_socket_list = temp->next;
+        _udp_socket_list = temp->next;
 
         return;
     }
@@ -201,28 +230,69 @@ int sock_udp_get_remote(sock_udp_t* sock, sock_udp_ep_t* ep) {
 int sock_udp_recv(sock_udp_t* sock, void* data, size_t max_len, uint32_t timeout, sock_udp_ep_t* remote) {
     uint16_t bytes_to_copy;
     sock_udp_ep_t ep;
+    OpenQueueEntry_t *pkt = NULL;
+
+#ifdef MODULE_OPENWSN
+    msg_t msg;
+#ifdef MODULE_ZTIMER
+    ztimer_t timer;
+
+    if ((timeout != SOCK_NO_TIMEOUT) && (timeout != 0)) {
+        timer.callback = _timeout_cb;
+        timer.arg = &sock->mbox;
+        ztimer_set(ZTIMER_USEC, &timer, timeout);
+    }
+#endif /* MODULE_ZTIMER */
+    if (timeout != 0) {
+        mbox_get(&sock->mbox, &msg);
+    }
+    else {
+        if (!mbox_try_get(&sock->mbox, &msg)) {
+            return -EAGAIN;
+        }
+    }
+#ifdef MODULE_ZTIMER
+    ztimer_remove(ZTIMER_USEC, &timer);
+#endif /* MODULE_ZTIMER */
+    switch (msg.type) {
+        case _MSG_TYPE_RECV_PKT:
+            pkt = msg.content.ptr;
+            break;
+#ifdef MODULE_ZTIMER
+        case _TIMEOUT_MSG_TYPE:
+            if (msg.content.value == _TIMEOUT_MAGIC) {
+                return -ETIMEDOUT;
+            }
+#endif /* MODULE_ZTIMER */
+            /* Falls Through. */
+        default:
+            return -EINVAL;
+    }
+#else /* MODULE_OPENWSN */
+    pkt = sock->txrx;
+#endif /* MODULE_OPENWSN */
 
-    if (sock->txrx == NULL) {
+    if (pkt == NULL) {
         return -EINVAL;
     }
 
-    if (max_len >= sock->txrx->l4_length) {
-        bytes_to_copy = sock->txrx->l4_length;
+    if (max_len >= pkt->l4_length) {
+        bytes_to_copy = pkt->l4_length;
     } else {
         bytes_to_copy = max_len;
     }
 
     if (remote != NULL) {
         ep.family = AF_INET6;
-        ep.port = sock->txrx->l4_sourcePortORicmpv6Type;
-        memcpy(&ep.addr, sock->txrx->l3_sourceAdd.addr_128b, LENGTH_ADDR128b);
+        ep.port = pkt->l4_sourcePortORicmpv6Type;
+        memcpy(&ep.addr, pkt->l3_sourceAdd.addr_128b, LENGTH_ADDR128b);
         memcpy(remote, &ep, sizeof(sock_udp_ep_t));
     }
 
     memset(data, 0, max_len);
-    memcpy(data, sock->txrx->l4_payload, bytes_to_copy);
+    memcpy(data, pkt->l4_payload, bytes_to_copy);
 
-    openqueue_freePacketBuffer(sock->txrx);
+    openqueue_freePacketBuffer(pkt);
 
     return bytes_to_copy;
 }
@@ -239,16 +309,26 @@ void sock_receive_internal(void) {
         return;
     }
 
-    current = udp_socket_list;
-
+    current = _udp_socket_list;
     while (current != NULL) {
         if (current->gen_sock.local.port == pkt->l4_destination_port &&
-            current->async_cb != NULL &&
-            idmanager_isMyAddress(&pkt->l3_destinationAdd))
-        {
-
+            idmanager_isMyAddress(&pkt->l3_destinationAdd)) {
+#ifdef MODULE_OPENWSN
+            msg_t msg;
+            msg.type = _MSG_TYPE_RECV_PKT;
+            msg.content.ptr = pkt;
+            int ret = mbox_try_put(&current->mbox, &msg);
+            if (ret < 1) {
+                LOG_RIOT_DEBUG("openwsn_sock: dropped message to %p (was full)\n", (void*) &current->mbox);
+            }
+#else /* MODULE_OPENWSN */
             current->txrx = pkt;
-            current->async_cb(current, SOCK_ASYNC_MSG_RECV, NULL);
+#endif /* MODULE_OPENWSN */
+#ifdef SOCK_HAS_ASYNC
+            if (current->async_cb != NULL) {
+                current->async_cb(current, SOCK_ASYNC_MSG_RECV, NULL);
+            }
+#endif /* SOCK_HAS_ASYNC */
             break;
         }
 
@@ -262,8 +342,9 @@ void sock_receive_internal(void) {
 }
 
 void sock_senddone_internal(OpenQueueEntry_t* msg, owerror_t error) {
-    OpenQueueEntry_t* pkt;
-    sock_udp_t* current;
+#ifdef SOCK_HAS_ASYNC
+    OpenQueueEntry_t *pkt;
+    sock_udp_t *current;
 
     pkt = openqueue_getPacketByComponent(COMPONENT_UDP);
 
@@ -273,30 +354,46 @@ void sock_senddone_internal(OpenQueueEntry_t* msg, owerror_t error) {
         return;
     }
 
-    current = udp_socket_list;
+    current = _udp_socket_list;
 
     while (current != NULL) {
         if (current->gen_sock.local.port == pkt->l4_sourcePortORicmpv6Type &&
-            current->async_cb != NULL)
-        {
+            current->async_cb != NULL ) {
+#ifdef MODULE_OPENWSN
+        /* In RIOT we can't know what message was sent... */
+#else
             current->txrx = pkt;
+#endif /* MODULE_OPENWSN */
             current->async_cb(current, SOCK_ASYNC_MSG_SENT, &error);
             break;
         }
 
         current = current->next;
     }
-}
-
-void sock_udp_set_cb(sock_udp_t* sock, sock_udp_cb_t cb, void* cb_arg) {
-    sock->async_cb = cb;
-    sock->async_cb_arg = cb_arg;
+#else /* SOCK_HAS_ASYNC */
+    (void) msg;
+    (void) error;
+#endif /*SOCK_HAS_ASYNC */
 }
 
 // ============================= private =======================================
 
-void _sock_transmit_internal(void) {
-    OpenQueueEntry_t* pkt;
+#ifdef MODULE_ZTIMER
+static void _timeout_cb(void *arg)
+{
+    msg_t timeout_msg = { .sender_pid = KERNEL_PID_UNDEF,
+                          .type = _TIMEOUT_MSG_TYPE,
+                          .content = { .value = _TIMEOUT_MAGIC } };
+    mbox_t *mbox = arg;
+
+    /* should be safe, because otherwise if mbox were filled this callback is
+     * senseless */
+    mbox_try_put(mbox, &timeout_msg);
+}
+#endif /* MODULE_ZTIMER */
+
+static void _sock_transmit_internal(void) {
+    OpenQueueEntry_t *pkt;
 
     pkt = openqueue_getPacketByComponent(COMPONENT_SOCK_TO_UDP);
 
@@ -347,4 +444,19 @@ static bool _sock_valid_addr(sock_udp_ep_t* ep) {
     return TRUE;
 }
 
+#ifdef SOCK_HAS_ASYNC
+void sock_udp_set_cb(sock_udp_t *sock, sock_udp_cb_t cb, void *cb_arg)
+{
+    sock->async_cb = cb;
+    sock->async_cb_arg = cb_arg;
+}
+
+#ifdef SOCK_HAS_ASYNC_CTX
+sock_async_ctx_t *sock_udp_get_async_ctx(sock_udp_t *sock)
+{
+    return &sock->async_ctx;
+}
+#endif /* SOCK_HAS_ASYNC_CTX*/
+#endif /* SOCK_HAS_ASYNC */
+
 #endif
diff --git a/openstack/04-TRAN/sock.h b/openstack/04-TRAN/sock.h
index 8eb6a79d..f8fbdf6d 100644
--- a/openstack/04-TRAN/sock.h
+++ b/openstack/04-TRAN/sock.h
@@ -2,7 +2,10 @@
 #define OPENWSN_SOCK_H
 
 #include "opendefs.h"
+
+#ifdef SOCK_HAS_ASYNC
 #include "async_types.h"
+#endif
 
 /**
  * @brief   A Common IP-based transport layer endpoint
diff --git a/openstack/04-TRAN/sock_types.h b/openstack/04-TRAN/sock_types.h
index 9d6bb0ef..9d7d79f1 100644
--- a/openstack/04-TRAN/sock_types.h
+++ b/openstack/04-TRAN/sock_types.h
@@ -1,7 +1,22 @@
 #ifndef OPENWSN_SOCK_TYPES_H
 #define OPENWSN_SOCK_TYPES_H
 
-#include "sock.h"
+// #include "sock.h"
+
+#ifdef SOCK_HAS_ASYNC
+#include "net/sock/async.h"
+#endif
+#include "net/sock/udp.h"
+#include "opendefs.h"
+#include "mbox.h"
+
+#ifndef CONFIG_OPENWSN_SOCK_MBOX_SIZE_EXP
+#define CONFIG_OPENWSN_SOCK_MBOX_SIZE_EXP      (3)
+#endif
+
+#ifndef OPENWSN_SOCK_MBOX_SIZE
+#define OPENWSN_SOCK_MBOX_SIZE  (1 << CONFIG_OPENWSN_SOCK_MBOX_SIZE_EXP)
+#endif
 
 struct _socket {
     sock_udp_ep_t local;         /**< local end-point */
@@ -12,10 +27,20 @@ struct _socket {
 typedef struct _socket socket_t;
 
 struct sock_udp {
-    socket_t gen_sock;                /**< Generic socket */
+#ifdef MODULE_SOCK_ASYNC_EVENT
+    sock_async_ctx_t async_ctx;       /**< asynchronous event context */
+#endif
+#ifdef SOCK_HAS_ASYNC
     sock_udp_cb_t async_cb;           /**< asynchronous callback */
-    OpenQueueEntry_t* txrx;
     void* async_cb_arg;
+#endif
+#ifdef MODULE_OPENWSN
+    mbox_t mbox;                           /**< @ref core_mbox target for the sock */
+    msg_t mbox_queue[OPENWSN_SOCK_MBOX_SIZE]; /**< queue for gnrc_sock_reg_t::mbox */
+#else /* MODULE_OPENWSN */
+    OpenQueueEntry_t* txrx;
+#endif /* MODULE_OPENWSN */
+    socket_t gen_sock;                /**< Generic socket */
     struct sock_udp *next;
 };
 
diff --git a/openstack/openstack.c b/openstack/openstack.c
index c220b8ff..6223ee52 100644
--- a/openstack/openstack.c
+++ b/openstack/openstack.c
@@ -34,7 +34,11 @@
 #include "icmpv6echo.h"
 #include "icmpv6rpl.h"
 //-- 04-TRAN
-#include "sock.h"
+// #include "sock.h"
+#ifdef SOCK_HAS_ASYNC
+#include "net/sock/async.h"
+#endif
+#include "net/sock/udp.h"
 
 //===== application-layer
 #include "openweb.h"
diff --git a/openweb/opencoap/coap.h b/openweb/opencoap/coap.h
index c7305a4e..924d4814 100644
--- a/openweb/opencoap/coap.h
+++ b/openweb/opencoap/coap.h
@@ -9,9 +9,13 @@
 */
 
 #include "config.h"
-#include "sock.h"
-#include "async.h"
+// #include "sock.h"
+// #include "async.h"
 
+#ifdef SOCK_HAS_ASYNC
+#include "net/sock/async.h"
+#endif
+#include "net/sock/udp.h"
 //=========================== define ==========================================
 
 // IPv6 addresses of servers on the Internet
@@ -166,7 +170,7 @@ typedef struct {
     uint8_t commonIV[AES_CCM_16_64_128_IV_LEN];
     uint8_t idContext[OSCOAP_MAX_ID_LEN];
     uint8_t idContextLen;
-    // sender context 
+    // sender context
     uint8_t senderID[OSCOAP_MAX_ID_LEN];
     uint8_t senderIDLen;
     uint8_t senderKey[AES_CCM_16_64_128_KEY_LEN];
-- 
2.28.0

