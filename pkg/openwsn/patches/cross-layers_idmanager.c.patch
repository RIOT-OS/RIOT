*** stock_iot-lab_M3/openwsn/cross-layers/idmanager.c	Thu Apr 24 11:01:37 2014
--- riot-openwsn-wip/openwsn/cross-layers/idmanager.c	Thu Apr 24 16:55:54 2014
***************
*** 7,28 ****

  //=========================== variables =======================================

- typedef struct {
-    bool          isDAGroot;
-    bool          isBridge;
-    open_addr_t   my16bID;
-    open_addr_t   my64bID;
-    open_addr_t   myPANID;
-    open_addr_t   myPrefix;
- } idmanager_vars_t;
-
  idmanager_vars_t idmanager_vars;

  //=========================== prototypes ======================================

  //=========================== public ==========================================

! void idmanager_init() {
     idmanager_vars.isDAGroot            = FALSE;
     idmanager_vars.isBridge             = FALSE;
     idmanager_vars.myPANID.type         = ADDR_PANID;
--- 7,19 ----

  //=========================== variables =======================================

  idmanager_vars_t idmanager_vars;

  //=========================== prototypes ======================================

  //=========================== public ==========================================

! void idmanager_init(void) {
     idmanager_vars.isDAGroot            = FALSE;
     idmanager_vars.isBridge             = FALSE;
     idmanager_vars.myPANID.type         = ADDR_PANID;
***************
*** 28,54 ****
     idmanager_vars.myPANID.type         = ADDR_PANID;
     idmanager_vars.myPANID.panid[0]     = 0xca;
     idmanager_vars.myPANID.panid[1]     = 0xfe;
     idmanager_vars.myPrefix.type        = ADDR_PREFIX;
!    idmanager_vars.myPrefix.prefix[0]   = 0x00;
!    idmanager_vars.myPrefix.prefix[1]   = 0x00;
!    idmanager_vars.myPrefix.prefix[2]   = 0x00;
!    idmanager_vars.myPrefix.prefix[3]   = 0x00;
!    idmanager_vars.myPrefix.prefix[4]   = 0x00;
!    idmanager_vars.myPrefix.prefix[5]   = 0x00;
!    idmanager_vars.myPrefix.prefix[6]   = 0x00;
!    idmanager_vars.myPrefix.prefix[7]   = 0x00;
     idmanager_vars.my64bID.type         = ADDR_64B;
     eui64_get(idmanager_vars.my64bID.addr_64b);
     packetfunctions_mac64bToMac16b(&idmanager_vars.my64bID,&idmanager_vars.my16bID);
!
!    // DEBUG_MOTEID_MASTER is DAGroot and bridge
!    if (idmanager_vars.my16bID.addr_16b[1]==DEBUG_MOTEID_MASTER) {
!       idmanager_vars.isDAGroot         = TRUE;
!       idmanager_vars.isBridge          = TRUE;
!    }
  }

! bool idmanager_getIsDAGroot() {
     bool res;
     INTERRUPT_DECLARATION();

--- 19,37 ----
     idmanager_vars.myPANID.type         = ADDR_PANID;
     idmanager_vars.myPANID.panid[0]     = 0xca;
     idmanager_vars.myPANID.panid[1]     = 0xfe;
+
     idmanager_vars.myPrefix.type        = ADDR_PREFIX;
!    memset(&idmanager_vars.myPrefix.prefix[0], 0x00, sizeof(idmanager_vars.myPrefix.prefix));
     idmanager_vars.my64bID.type         = ADDR_64B;
+
     eui64_get(idmanager_vars.my64bID.addr_64b);
     packetfunctions_mac64bToMac16b(&idmanager_vars.my64bID,&idmanager_vars.my16bID);
!
! //   if(idmanager_vars.my16bID.addr_16b[1] == 0x0B)
! //     idmanager_setIsDAGroot(TRUE);
  }

! bool idmanager_getIsDAGroot(void) {
     bool res;
     INTERRUPT_DECLARATION();

***************
*** 66,72 ****
     ENABLE_INTERRUPTS();
  }

! bool idmanager_getIsBridge() {
     bool res;
     INTERRUPT_DECLARATION();
     DISABLE_INTERRUPTS();
--- 49,55 ----
     ENABLE_INTERRUPTS();
  }

! bool idmanager_getIsBridge(void) {
     bool res;
     INTERRUPT_DECLARATION();
     DISABLE_INTERRUPTS();
***************
*** 88,142 ****
     INTERRUPT_DECLARATION();
     DISABLE_INTERRUPTS();
     switch (type) {
!    case ADDR_16B:
!       res= &idmanager_vars.my16bID;
!       break;
!    case ADDR_64B:
!       res= &idmanager_vars.my64bID;
!       break;
!    case ADDR_PANID:
!       res= &idmanager_vars.myPANID;
!       break;
!    case ADDR_PREFIX:
!       res= &idmanager_vars.myPrefix;
!       break;
!    case ADDR_128B:
!       // you don't ask for my full address, rather for prefix, then 64b
!    default:
!       openserial_printCritical(COMPONENT_IDMANAGER,ERR_WRONG_ADDR_TYPE,
!             (errorparameter_t)type,
!             (errorparameter_t)0);
!       res= NULL;
!       break;
     }
     ENABLE_INTERRUPTS();
     return res;
  }

! error_t idmanager_setMyID(open_addr_t* newID) {
     INTERRUPT_DECLARATION();
     DISABLE_INTERRUPTS();
     switch (newID->type) {
!    case ADDR_16B:
!       memcpy(&idmanager_vars.my16bID,newID,sizeof(open_addr_t));
!       break;
!    case ADDR_64B:
!       memcpy(&idmanager_vars.my64bID,newID,sizeof(open_addr_t));
!       break;
!    case ADDR_PANID:
!       memcpy(&idmanager_vars.myPANID,newID,sizeof(open_addr_t));
!       break;
!    case ADDR_PREFIX:
!       memcpy(&idmanager_vars.myPrefix,newID,sizeof(open_addr_t));
!       break;
!    case ADDR_128B:
!       //don't set 128b, but rather prefix and 64b
!    default:
!       openserial_printCritical(COMPONENT_IDMANAGER,ERR_WRONG_ADDR_TYPE,
!             (errorparameter_t)newID->type,
!             (errorparameter_t)1);
!       ENABLE_INTERRUPTS();
!       return E_FAIL;
     }
     ENABLE_INTERRUPTS();
     return E_SUCCESS;
--- 71,125 ----
     INTERRUPT_DECLARATION();
     DISABLE_INTERRUPTS();
     switch (type) {
!      case ADDR_16B:
!         res= &idmanager_vars.my16bID;
!         break;
!      case ADDR_64B:
!         res= &idmanager_vars.my64bID;
!         break;
!      case ADDR_PANID:
!         res= &idmanager_vars.myPANID;
!         break;
!      case ADDR_PREFIX:
!         res= &idmanager_vars.myPrefix;
!         break;
!      case ADDR_128B:
!         // you don't ask for my full address, rather for prefix, then 64b
!      default:
!         openserial_printCritical(COMPONENT_IDMANAGER,ERR_WRONG_ADDR_TYPE,
!               (errorparameter_t)type,
!               (errorparameter_t)0);
!         res= NULL;
!         break;
     }
     ENABLE_INTERRUPTS();
     return res;
  }

! owerror_t idmanager_setMyID(open_addr_t* newID) {
     INTERRUPT_DECLARATION();
     DISABLE_INTERRUPTS();
     switch (newID->type) {
!      case ADDR_16B:
!         memcpy(&idmanager_vars.my16bID,newID,sizeof(open_addr_t));
!         break;
!      case ADDR_64B:
!         memcpy(&idmanager_vars.my64bID,newID,sizeof(open_addr_t));
!         break;
!      case ADDR_PANID:
!         memcpy(&idmanager_vars.myPANID,newID,sizeof(open_addr_t));
!         break;
!      case ADDR_PREFIX:
!         memcpy(&idmanager_vars.myPrefix,newID,sizeof(open_addr_t));
!         break;
!      case ADDR_128B:
!         //don't set 128b, but rather prefix and 64b
!      default:
!         openserial_printCritical(COMPONENT_IDMANAGER,ERR_WRONG_ADDR_TYPE,
!               (errorparameter_t)newID->type,
!               (errorparameter_t)1);
!         ENABLE_INTERRUPTS();
!         return E_FAIL;
     }
     ENABLE_INTERRUPTS();
     return E_SUCCESS;
***************
*** 149,192 ****
     DISABLE_INTERRUPTS();

     switch (addr->type) {
!    case ADDR_16B:
!       res= packetfunctions_sameAddress(addr,&idmanager_vars.my16bID);
!       ENABLE_INTERRUPTS();
!       return res;
!    case ADDR_64B:
!       res= packetfunctions_sameAddress(addr,&idmanager_vars.my64bID);
!       ENABLE_INTERRUPTS();
!       return res;
!    case ADDR_128B:
!       //build temporary my128bID
!       temp_my128bID.type = ADDR_128B;
!       memcpy(&temp_my128bID.addr_128b[0],&idmanager_vars.myPrefix.prefix,8);
!       memcpy(&temp_my128bID.addr_128b[8],&idmanager_vars.my64bID.addr_64b,8);
!
!       res= packetfunctions_sameAddress(addr,&temp_my128bID);
!       ENABLE_INTERRUPTS();
!       return res;
!    case ADDR_PANID:
!       res= packetfunctions_sameAddress(addr,&idmanager_vars.myPANID);
!       ENABLE_INTERRUPTS();
!       return res;
!    case ADDR_PREFIX:
!       res= packetfunctions_sameAddress(addr,&idmanager_vars.myPrefix);
!       ENABLE_INTERRUPTS();
!       return res;
!    default:
!       openserial_printCritical(COMPONENT_IDMANAGER,ERR_WRONG_ADDR_TYPE,
!             (errorparameter_t)addr->type,
!             (errorparameter_t)2);
!       ENABLE_INTERRUPTS();
!       return FALSE;
     }
  }

! void idmanager_triggerAboutRoot() {
     uint8_t number_bytes_from_input_buffer;
     uint8_t input_buffer;
!    //get command from OpenSerial
     number_bytes_from_input_buffer = openserial_getInputBuffer(&input_buffer,sizeof(input_buffer));
     if (number_bytes_from_input_buffer!=sizeof(input_buffer)) {
        openserial_printError(COMPONENT_IDMANAGER,ERR_INPUTBUFFER_LENGTH,
--- 132,175 ----
     DISABLE_INTERRUPTS();

     switch (addr->type) {
!      case ADDR_16B:
!         res= packetfunctions_sameAddress(addr,&idmanager_vars.my16bID);
!         ENABLE_INTERRUPTS();
!         return res;
!      case ADDR_64B:
!         res= packetfunctions_sameAddress(addr,&idmanager_vars.my64bID);
!         ENABLE_INTERRUPTS();
!         return res;
!      case ADDR_128B:
!         //build temporary my128bID
!         temp_my128bID.type = ADDR_128B;
!         memcpy(&temp_my128bID.addr_128b[0],&idmanager_vars.myPrefix.prefix,8);
!         memcpy(&temp_my128bID.addr_128b[8],&idmanager_vars.my64bID.addr_64b,8);
!
!         res= packetfunctions_sameAddress(addr,&temp_my128bID);
!         ENABLE_INTERRUPTS();
!         return res;
!      case ADDR_PANID:
!         res= packetfunctions_sameAddress(addr,&idmanager_vars.myPANID);
!         ENABLE_INTERRUPTS();
!         return res;
!      case ADDR_PREFIX:
!         res= packetfunctions_sameAddress(addr,&idmanager_vars.myPrefix);
!         ENABLE_INTERRUPTS();
!         return res;
!      default:
!         openserial_printCritical(COMPONENT_IDMANAGER,ERR_WRONG_ADDR_TYPE,
!               (errorparameter_t)addr->type,
!               (errorparameter_t)2);
!         ENABLE_INTERRUPTS();
!         return FALSE;
     }
  }

! void idmanager_triggerAboutRoot(void) {
     uint8_t number_bytes_from_input_buffer;
     uint8_t input_buffer;
!    // get command from OpenSerial
     number_bytes_from_input_buffer = openserial_getInputBuffer(&input_buffer,sizeof(input_buffer));
     if (number_bytes_from_input_buffer!=sizeof(input_buffer)) {
        openserial_printError(COMPONENT_IDMANAGER,ERR_INPUTBUFFER_LENGTH,
***************
*** 194,246 ****
              (errorparameter_t)0);
        return;
     };
!    //handle command
     switch (input_buffer) {
!    case 'Y':
!       idmanager_setIsDAGroot(TRUE);
!       break;
!    case 'N':
!       idmanager_setIsDAGroot(FALSE);
!       break;
!    case 'T':
!       if (idmanager_getIsDAGroot()) {
!          idmanager_setIsDAGroot(FALSE);
!       } else {
!          idmanager_setIsDAGroot(TRUE);
!       }
!       break;
     }
     return;
  }

! void idmanager_triggerAboutBridge() {
     uint8_t number_bytes_from_input_buffer;
!    uint8_t input_buffer[9];
!    //get command from OpenSerial (1B command, 8B prefix)
!    number_bytes_from_input_buffer = openserial_getInputBuffer(&input_buffer[0],sizeof(input_buffer));
     if (number_bytes_from_input_buffer!=sizeof(input_buffer)) {
        openserial_printError(COMPONENT_IDMANAGER,ERR_INPUTBUFFER_LENGTH,
              (errorparameter_t)number_bytes_from_input_buffer,
!             (errorparameter_t)0);
        return;
     };
     //handle command
!    switch (input_buffer[0]) {
!    case 'Y':
!       idmanager_setIsBridge(TRUE);
!       memcpy(&(idmanager_vars.myPrefix.prefix),&(input_buffer[1]),8);
!       break;
!    case 'N':
!       idmanager_setIsBridge(FALSE);
!       break;
!    case 'T':
!       if (idmanager_getIsBridge()) {
!          idmanager_setIsBridge(FALSE);
!       } else {
!          idmanager_setIsBridge(TRUE);
!          memcpy(&(idmanager_vars.myPrefix.prefix),&(input_buffer[1]),8);
!       }
!       break;
     }
     return;
  }
--- 177,227 ----
              (errorparameter_t)0);
        return;
     };
!    // handle command
     switch (input_buffer) {
!      case ACTION_YES:
!         idmanager_setIsDAGroot(TRUE);
!         break;
!      case ACTION_NO:
!         idmanager_setIsDAGroot(FALSE);
!         break;
!      case ACTION_TOGGLE:
!         if (idmanager_getIsDAGroot()) {
!            idmanager_setIsDAGroot(FALSE);
!         } else {
!            idmanager_setIsDAGroot(TRUE);
!         }
!         break;
     }
     return;
  }

! void idmanager_triggerAboutBridge(void) {
     uint8_t number_bytes_from_input_buffer;
!    uint8_t input_buffer;
!    //get command from OpenSerial
!    number_bytes_from_input_buffer = openserial_getInputBuffer(&input_buffer,sizeof(input_buffer));
     if (number_bytes_from_input_buffer!=sizeof(input_buffer)) {
        openserial_printError(COMPONENT_IDMANAGER,ERR_INPUTBUFFER_LENGTH,
              (errorparameter_t)number_bytes_from_input_buffer,
!             (errorparameter_t)1);
        return;
     };
     //handle command
!    switch (input_buffer) {
!      case ACTION_YES:
!         idmanager_setIsBridge(TRUE);
!         break;
!      case ACTION_NO:
!         idmanager_setIsBridge(FALSE);
!         break;
!      case ACTION_TOGGLE:
!         if (idmanager_getIsBridge()) {
!            idmanager_setIsBridge(FALSE);
!         } else {
!            idmanager_setIsBridge(TRUE);
!         }
!         break;
     }
     return;
  }
***************
*** 253,259 ****

  \returns TRUE if this function printed something, FALSE otherwise.
  */
! bool debugPrint_id() {
     debugIDManagerEntry_t output;
     output.isDAGroot = idmanager_vars.isDAGroot;
     output.isBridge  = idmanager_vars.isBridge;
--- 234,240 ----

  \returns TRUE if this function printed something, FALSE otherwise.
  */
! bool debugPrint_id(void) {
     debugIDManagerEntry_t output;
     output.isDAGroot = idmanager_vars.isDAGroot;
     output.isBridge  = idmanager_vars.isBridge;
