From 49fa857a8548b297381f823bf0979732fe18b7dd Mon Sep 17 00:00:00 2001
From: Thomas Eichinger <thomas.eichinger1@gmail.com>
Date: Tue, 2 Dec 2014 14:48:17 +0100
Subject: [PATCH 5/5] fixes to RIOT adaption

---
 Makefile                                      |   3 +-
 bsp/boards/radiotimer.h                       |   2 +-
 bsp/boards/riot-adaption/board_info.h         |  51 +--
 bsp/boards/riot-adaption/board_ow.c           |   8 +-
 bsp/boards/riot-adaption/leds_ow.c            |  63 +--
 bsp/boards/riot-adaption/radio.c              | 615 ++++++++++++++------------
 bsp/boards/riot-adaption/radiotimer.c         |  58 +--
 bsp/boards/riot-adaption/riot.h               |  36 ++
 bsp/boards/riot-adaption/spi_ow.c             | 321 --------------
 bsp/boards/riot-adaption/uart_ow.c            |   8 +-
 bsp/boards/uart.h                             |   2 +-
 drivers/common/Makefile                       |   6 +
 drivers/common/openserial.c                   | 412 ++++++++---------
 drivers/common/opentimers.c                   |  32 +-
 kernel/openos/scheduler.c                     |  22 +-
 openapps/Makefile                             |   6 +-
 openapps/cstorm/cstorm.c                      |   2 +-
 openapps/uecho/uecho.c                        |  98 ++--
 openstack/02a-MAClow/IEEE802154E.c            |   5 +
 openstack/02a-MAClow/IEEE802154E.h            |  14 +-
 openstack/02b-MAChigh/schedule.c              |  30 +-
 openstack/Makefile                            |   2 +
 openstack/cross-layers/idmanager.c            |  37 +-
 openstack/cross-layers/idmanager.h            |   2 +-
 openstack/openstack.c                         |   8 +-
 openstack/openstack.h                         |   2 +-
 projects/common/03oos_openwsn/03oos_openwsn.c |  72 +--
 projects/common/03oos_openwsn/03oos_openwsn.h |   8 +-
 projects/common/03oos_openwsn/Makefile        |   2 +
 29 files changed, 875 insertions(+), 1052 deletions(-)
 create mode 100644 bsp/boards/riot-adaption/riot.h
 delete mode 100644 bsp/boards/riot-adaption/spi_ow.c

diff --git a/Makefile b/Makefile
index f1917fa..41ca883 100644
--- a/Makefile
+++ b/Makefile
@@ -5,7 +5,8 @@ DIRS += $(OPENWSN_ROOT)/projects/common/03oos_openwsn \
 		$(OPENWSN_ROOT)/openstack \
 		$(OPENWSN_ROOT)/openapps \
 		$(OPENWSN_ROOT)/kernel/openos \
-		$(OPENWSN_ROOT)/drivers/common
+		$(OPENWSN_ROOT)/drivers/common \
+		$(OPENWSN_ROOT)/bsp/boards/riot-adaption
 
 INCLUDES += -I$(OPENWSN_ROOT)/kernel \
 			-I$(OPENWSN_ROOT)/inc \
diff --git a/bsp/boards/radiotimer.h b/bsp/boards/radiotimer.h
index 6b6b27c..fc2e639 100644
--- a/bsp/boards/radiotimer.h
+++ b/bsp/boards/radiotimer.h
@@ -44,7 +44,7 @@ void     radiotimer_cancel(void);
 PORT_RADIOTIMER_WIDTH radiotimer_getCapturedTime(void);
 
 // interrupt handlers
-kick_scheduler_t   radiotimer_isr(void);
+void   radiotimer_isr(void);
 
 /**
 \}
diff --git a/bsp/boards/riot-adaption/board_info.h b/bsp/boards/riot-adaption/board_info.h
index 85f2eb1..fd46c20 100644
--- a/bsp/boards/riot-adaption/board_info.h
+++ b/bsp/boards/riot-adaption/board_info.h
@@ -1,12 +1,10 @@
 /**
-\brief agilefox board information bsp module (based on openmoteSTM32 code).
+\brief RIOT adaption information bsp module.
 
 This module simply defines some strings describing the board, which CoAP uses
 to return the board's description.
 
-\author Thomas Watteyne <watteyne@eecs.berkeley.edu>, February 2012.
-\author Tengfei Chang <tengfei.chang@gmail.com>,  July 2012.
-\author Alaeddine Weslati <alaeddine.weslati@inria.fr>,  August 2013.
+\author Thomas Eichinger <thomas.eichinger@fu-berlin.de>
 */
 
 #ifndef __BOARD_INFO_H
@@ -29,44 +27,21 @@ to return the board's description.
 #define PORT_RADIOTIMER_WIDTH               uint32_t
 
 #define PORT_SIGNED_INT_WIDTH               int32_t
-#define PORT_TICS_PER_MS                    32
-#define SCHEDULER_WAKEUP()                  //EXTI->SWIER |= EXTI_Line1;
-#define SCHEDULER_ENABLE_INTERRUPT()        //enable in board use EXTI_Line1
-
-//===== pinout
-
-// [P4.7] radio SLP_TR_CNTL
-#define PORT_PIN_RADIO_SLP_TR_CNTL_HIGH()     //GPIOA->ODR |= (1<<0);
-#define PORT_PIN_RADIO_SLP_TR_CNTL_LOW()      //GPIOA->ODR &= ~(1<<0);
-// radio reset line
-// radio /RST
-#define PORT_PIN_RADIO_RESET_HIGH()       //GPIOC->ODR |= 0X0040;// nothing
-#define PORT_PIN_RADIO_RESET_LOW()        //GPIOC->ODR &= ~0X0040;// nothing
+#define PORT_TICS_PER_MS                    1000
+#define SCHEDULER_WAKEUP()
+#define SCHEDULER_ENABLE_INTERRUPT()
 
 //===== IEEE802154E timing
-
-//// time-slot related
-//#define PORT_TsSlotDuration                 491   // counter counts one extra count, see datasheet
-//// execution speed related
-//#define PORT_maxTxDataPrepare               66    // 2014us (measured 746us)
-//#define PORT_maxRxAckPrepare                10    //  305us (measured  83us)
-//#define PORT_maxRxDataPrepare               33    // 1007us (measured  84us)
-//#define PORT_maxTxAckPrepare                10    //  305us (measured 219us)
-//// radio speed related
-//#define PORT_delayTx                        9     //  214us (measured 219us)
-//#define PORT_delayRx                        0     //    0us (can not measure)
-//// radio watchdog
-
 // time-slot related
-#define PORT_TsSlotDuration                 245   // counter counts one extra count, see datasheet
-// execution speed related   (rcc configure need 235us)
-#define PORT_maxTxDataPrepare               33    // 2014us (measured 812us+235) stm32
-#define PORT_maxRxAckPrepare                10    //  900us (measured 171us+235) stm32
-#define PORT_maxRxDataPrepare               16    //  976us (measured 170us+235) stm32
-#define PORT_maxTxAckPrepare                10    //  900us (measured 323us+235) stm32
+#define PORT_TsSlotDuration                 15000
+
+#define PORT_maxTxDataPrepare               2014
+#define PORT_maxRxAckPrepare                900
+#define PORT_maxRxDataPrepare               976
+#define PORT_maxTxAckPrepare                900
 // radio speed related
-#define PORT_delayTx                        10     //  549us (measured 315us+235) .....
-#define PORT_delayRx                        0     //    0us (can not measure)
+#define PORT_delayTx                        549
+#define PORT_delayRx                        0
 
 //===== adaptive_sync accuracy
 
diff --git a/bsp/boards/riot-adaption/board_ow.c b/bsp/boards/riot-adaption/board_ow.c
index 95f29b1..6c79b33 100644
--- a/bsp/boards/riot-adaption/board_ow.c
+++ b/bsp/boards/riot-adaption/board_ow.c
@@ -2,21 +2,15 @@
 #include "radiotimer.h"
 #include "radio.h"
 #include "debugpins.h"
-#include "spi_ow.h"
 
-#define ENABLE_DEBUG (1)
+#define ENABLE_DEBUG (0)
 #include "debug.h"
 
 void board_init_ow(void)
 {
-    DEBUG("%s\n",__PRETTY_FUNCTION__);
-    spi_init_ow();
     radio_init();
-    DEBUG("%s\n",__PRETTY_FUNCTION__);
     radiotimer_init();
-    DEBUG("%s\n",__PRETTY_FUNCTION__);
     debugpins_init();
-    DEBUG("%s\n",__PRETTY_FUNCTION__);
 }
 
 void board_sleep(void)
diff --git a/bsp/boards/riot-adaption/leds_ow.c b/bsp/boards/riot-adaption/leds_ow.c
index cd892e1..0fd260e 100644
--- a/bsp/boards/riot-adaption/leds_ow.c
+++ b/bsp/boards/riot-adaption/leds_ow.c
@@ -24,16 +24,17 @@ void leds_error_toggle(void)
 }
 uint8_t leds_error_isOn(void)
 {
-  uint8_t bitstatus = 0x00;
-  if ((LED_RED_PORT->ODR & LED_RED_PIN) != (uint32_t)0)
-  {
-    bitstatus = 0x00;
-  }
-  else
-  {
-    bitstatus = 0x01;
-  }
-  return bitstatus;
+  // uint8_t bitstatus = 0x00;
+  // if ((LED_RED_PORT->ODR & LED_RED_PIN) != (uint32_t)0)
+  // {
+  //   bitstatus = 0x00;
+  // }
+  // else
+  // {
+  //   bitstatus = 0x01;
+  // }
+  // return bitstatus;
+  return true;
 }
 void leds_error_blink(void) {}
 
@@ -52,16 +53,17 @@ void leds_sync_toggle(void)
 }
 uint8_t leds_sync_isOn(void)
 {
-  uint8_t bitstatus = 0x00;
-  if ((LED_GREEN_PORT->ODR & LED_GREEN_PIN) != (uint32_t)0)
-  {
-    bitstatus = 0x00;
-  }
-  else
-  {
-    bitstatus = 0x01;
-  }
-  return bitstatus;
+  // uint8_t bitstatus = 0x00;
+  // if ((LED_GREEN_PORT->ODR & LED_GREEN_PIN) != (uint32_t)0)
+  // {
+  //   bitstatus = 0x00;
+  // }
+  // else
+  // {
+  //   bitstatus = 0x01;
+  // }
+  // return bitstatus;
+  return true;
 }
 
 /* orange */
@@ -79,16 +81,17 @@ void leds_radio_toggle(void)
 }
 uint8_t leds_radio_isOn(void)
 {
-  uint8_t bitstatus = 0x00;
-  if ((LED_ORANGE_PORT->ODR & LED_ORANGE_PIN) != (uint32_t)0)
-  {
-    bitstatus = 0x00;
-  }
-  else
-  {
-    bitstatus = 0x01;
-  }
-  return bitstatus;
+  // uint8_t bitstatus = 0x00;
+  // if ((LED_ORANGE_PORT->ODR & LED_ORANGE_PIN) != (uint32_t)0)
+  // {
+  //   bitstatus = 0x00;
+  // }
+  // else
+  // {
+  //   bitstatus = 0x01;
+  // }
+  // return bitstatus;
+  return true;
 }
 
 /* yellow */
diff --git a/bsp/boards/riot-adaption/radio.c b/bsp/boards/riot-adaption/radio.c
index 203550c..76fd0ba 100644
--- a/bsp/boards/riot-adaption/radio.c
+++ b/bsp/boards/riot-adaption/radio.c
@@ -1,12 +1,11 @@
 #include "board_ow.h"
 #include "radio.h"
-#include "at86rf231_ow.h"
-#include "spi_ow.h"
+#include "board.h"
+#include "at86rf231.h"
+#include "at86rf231_spi.h"
 #include "radiotimer.h"
 #include "debugpins.h"
 #include "leds.h"
-#include "board.h"
-#include "spi.h"
 #include "periph_conf.h"
 
 #define ENABLE_DEBUG (0)
@@ -27,46 +26,49 @@ radio_vars_t radio_vars;
 
 //=========================== prototypes ======================================
 
-void    radio_spiWriteReg(uint8_t reg_addr, uint8_t reg_setting);
-uint8_t radio_spiReadReg(uint8_t reg_addr);
-void    radio_spiWriteTxFifo(uint8_t* bufToWrite, uint8_t lenToWrite);
-void    radio_spiReadRxFifo(uint8_t* pBufRead,
-                            uint8_t* pLenRead,
-                            uint8_t  maxBufLen,
-                            uint8_t* pLqi);
-uint8_t radio_spiReadRadioInfo(void);
+// void    radio_spiWriteReg(uint8_t reg_addr, uint8_t reg_setting);
+// uint8_t radio_spiReadReg(uint8_t reg_addr);
+// void    radio_spiWriteTxFifo(uint8_t* bufToWrite, uint8_t lenToWrite);
+// void    radio_spiReadRxFifo(uint8_t* pBufRead,
+//                             uint8_t* pLenRead,
+//                             uint8_t  maxBufLen,
+//                             uint8_t* pLqi);
+// uint8_t radio_spiReadRadioInfo(void);
 
 //=========================== public ==========================================
 
 //===== admin
 
 void radio_init(void) {
-
-   // clear variables
-   memset(&radio_vars,0,sizeof(radio_vars_t));
-
-   // change state
-   radio_vars.state          = RADIOSTATE_STOPPED;
-   DEBUG("%s\n",__PRETTY_FUNCTION__);
-   // configure the radio
-   radio_spiWriteReg(RG_TRX_STATE, CMD_FORCE_TRX_OFF);    // turn radio off
-
-   radio_spiWriteReg(RG_IRQ_MASK,
-                     (AT_IRQ_RX_START| AT_IRQ_TRX_END));  // tell radio to fire interrupt on TRX_END and RX_START
-   radio_spiReadReg(RG_IRQ_STATUS);                       // deassert the interrupt pin in case is high
-   radio_spiWriteReg(RG_ANT_DIV, RADIO_CHIP_ANTENNA);     // use chip antenna
-#define RG_TRX_CTRL_1 0x04
-   radio_spiWriteReg(RG_TRX_CTRL_1, 0x20);                // have the radio calculate CRC
-   //busy wait until radio status is TRX_OFF
-   uint16_t c = 0;
-   while((radio_spiReadReg(RG_TRX_STATUS) & 0x1F) != TRX_OFF)
-       if (c++ == 10000) {
-           DEBUG("radio_spiReadReg timeout\n");
-           break;
-       }
-   DEBUG("%s\n",__PRETTY_FUNCTION__);
-   // change state
-   radio_vars.state          = RADIOSTATE_RFOFF;
+   DEBUG("%s\n", __PRETTY_FUNCTION__);
+   at86rf231_initialize(&at86rf231_netdev);
+   at86rf231_set_monitor(1);
+
+//    // clear variables
+//    memset(&radio_vars,0,sizeof(radio_vars_t));
+
+//    // change state
+//    radio_vars.state          = RADIOSTATE_STOPPED;
+//    DEBUG("%s\n",__PRETTY_FUNCTION__);
+//    // configure the radio
+//    radio_spiWriteReg(RG_TRX_STATE, CMD_FORCE_TRX_OFF);    // turn radio off
+
+//    radio_spiWriteReg(RG_IRQ_MASK,
+//                      (AT_IRQ_RX_START| AT_IRQ_TRX_END));  // tell radio to fire interrupt on TRX_END and RX_START
+//    radio_spiReadReg(RG_IRQ_STATUS);                       // deassert the interrupt pin in case is high
+//    radio_spiWriteReg(RG_ANT_DIV, RADIO_CHIP_ANTENNA);     // use chip antenna
+// #define RG_TRX_CTRL_1 0x04
+//    radio_spiWriteReg(RG_TRX_CTRL_1, 0x20);                // have the radio calculate CRC
+//    //busy wait until radio status is TRX_OFF
+//    uint16_t c = 0;
+//    while((radio_spiReadReg(RG_TRX_STATUS) & 0x1F) != TRX_OFF)
+//        if (c++ == 10000) {
+//            DEBUG("radio_spiReadReg timeout\n");
+//            break;
+//        }
+//    DEBUG("%s\n",__PRETTY_FUNCTION__);
+//    // change state
+//    radio_vars.state          = RADIOSTATE_RFOFF;
 }
 
 void radio_setOverflowCb(radiotimer_compare_cbt cb) {
@@ -88,7 +90,8 @@ void radio_setEndFrameCb(radiotimer_capture_cbt cb) {
 //===== reset
 
 void radio_reset(void) {
-   PORT_PIN_RADIO_RESET_LOW();
+   at86rf231_off();
+   at86rf231_on();
 }
 
 //===== timer
@@ -116,53 +119,54 @@ void radio_setFrequency(uint8_t frequency) {
    radio_vars.state = RADIOSTATE_SETTING_FREQUENCY;
 
    // configure the radio to the right frequecy
-   radio_spiWriteReg(RG_PHY_CC_CCA,0x20+frequency);
+   at86rf231_set_channel(frequency);
 
    // change state
    radio_vars.state = RADIOSTATE_FREQUENCY_SET;
 }
 
 void radio_rfOn(void) {
-   PORT_PIN_RADIO_RESET_LOW();
+   at86rf231_on();
 }
 
 void radio_rfOff(void) {
-    DEBUG("%s\n",__PRETTY_FUNCTION__);
-   // change state
-   radio_vars.state = RADIOSTATE_TURNING_OFF;
-   radio_spiReadReg(RG_TRX_STATUS);
-   DEBUG("step 1\n");
-   // turn radio off
-   radio_spiWriteReg(RG_TRX_STATE, CMD_FORCE_TRX_OFF);
-   DEBUG("step 2\n");
-   radio_spiWriteReg(RG_TRX_STATE, CMD_TRX_OFF);
-
-   // busy wait until done
-   uint16_t c = 0;
-   while((radio_spiReadReg(RG_TRX_STATUS) & 0x1F) != TRX_OFF)
-       ;// if (c++ == 100000) {
-//            DEBUG("%s: radio_spiReadReg timeout\n", __PRETTY_FUNCTION__);
-//            break;
-//        }
-
-   DEBUG("step 3\n");
-   // wiggle debug pin
-   debugpins_radio_clr();
+    // DEBUG("%s\n",__PRETTY_FUNCTION__);
+//    // change state
+//    radio_vars.state = RADIOSTATE_TURNING_OFF;
+//    radio_spiReadReg(RG_TRX_STATUS);
+//    DEBUG("step 1\n");
+//    // turn radio off
+//    radio_spiWriteReg(RG_TRX_STATE, CMD_FORCE_TRX_OFF);
+//    DEBUG("step 2\n");
+//    radio_spiWriteReg(RG_TRX_STATE, CMD_TRX_OFF);
+
+//    // busy wait until done
+//    uint16_t c = 0;
+//    while((radio_spiReadReg(RG_TRX_STATUS) & 0x1F) != TRX_OFF)
+//        ;// if (c++ == 100000) {
+// //            DEBUG("%s: radio_spiReadReg timeout\n", __PRETTY_FUNCTION__);
+// //            break;
+// //        }
+
+//    DEBUG("step 3\n");
+//    // wiggle debug pin
+//    debugpins_radio_clr();
    leds_radio_off();
-   DEBUG("step 4\n");
-   // change state
-   radio_vars.state = RADIOSTATE_RFOFF;
-   DEBUG("step 5\n");
+//    DEBUG("step 4\n");
+//    // change state
+//    radio_vars.state = RADIOSTATE_RFOFF;
+//    DEBUG("step 5\n");
 }
 
 //===== TX
 
 void radio_loadPacket(uint8_t* packet, uint8_t len) {
+   DEBUG("rf load\n");
    // change state
    radio_vars.state = RADIOSTATE_LOADING_PACKET;
 
    // load packet in TXFIFO
-   radio_spiWriteTxFifo(packet,len);
+   at86rf231_write_fifo(packet, len);
 
    // change state
    radio_vars.state = RADIOSTATE_PACKET_LOADED;
@@ -171,19 +175,43 @@ void radio_loadPacket(uint8_t* packet, uint8_t len) {
 void radio_txEnable(void) {
    // change state
    radio_vars.state = RADIOSTATE_ENABLING_TX;
-
-   // wiggle debug pin
-   debugpins_radio_set();
+   DEBUG("rf tx en\n");
+//    // wiggle debug pin
+//    debugpins_radio_set();
    leds_radio_on();
 
-   // turn on radio's PLL
-   radio_spiWriteReg(RG_TRX_STATE, CMD_PLL_ON);
-   uint16_t c = 0;
-   while((radio_spiReadReg(RG_TRX_STATUS) & 0x1F) != PLL_ON) // busy wait until done
-       ;// if (c++ == 100000) {
-//            DEBUG("%s: radio_spiReadReg timeout\n", __PRETTY_FUNCTION__);
-//            break;
-//        }
+   /* Go to state PLL_ON */
+    at86rf231_reg_write(AT86RF231_REG__TRX_STATE, AT86RF231_TRX_STATE__PLL_ON);
+
+    /* wait until it is on PLL_ON state */
+    do {
+        int max_wait = 100;
+        if (!--max_wait) {
+            DEBUG("at86rf231 : ERROR : could not enter PLL_ON mode\n");
+            break;
+        }
+    } while ((at86rf231_get_status() & AT86RF231_TRX_STATUS_MASK__TRX_STATUS)
+             != AT86RF231_TRX_STATUS__PLL_ON);
+
+    /* change into TX_ARET_ON state */
+    at86rf231_reg_write(AT86RF231_REG__TRX_STATE, AT86RF231_TRX_STATE__TX_ARET_ON);
+
+    do {
+        int max_wait = 100;
+        if (!--max_wait) {
+            DEBUG("at86rf231 : ERROR : could not enter TX_ARET_ON mode\n");
+            break;
+        }
+    } while (at86rf231_get_status() != AT86RF231_TRX_STATUS__TX_ARET_ON);
+
+//    // turn on radio's PLL
+//    radio_spiWriteReg(RG_TRX_STATE, CMD_PLL_ON);
+//    uint16_t c = 0;
+//    while((radio_spiReadReg(RG_TRX_STATUS) & 0x1F) != PLL_ON) // busy wait until done
+//        ;// if (c++ == 100000) {
+// //            DEBUG("%s: radio_spiReadReg timeout\n", __PRETTY_FUNCTION__);
+// //            break;
+// //        }
 
    // change state
    radio_vars.state = RADIOSTATE_TX_ENABLED;
@@ -195,8 +223,11 @@ void radio_txNow(void) {
    radio_vars.state = RADIOSTATE_TRANSMITTING;
    leds_radio_toggle();
    // send packet by pulsing the SLP_TR_CNTL pin
-   PORT_PIN_RADIO_SLP_TR_CNTL_HIGH();
-   PORT_PIN_RADIO_SLP_TR_CNTL_LOW();
+   // PORT_PIN_RADIO_SLP_TR_CNTL_HIGH();
+   // PORT_PIN_RADIO_SLP_TR_CNTL_LOW();
+
+   at86rf231_transmit_tx_buf(&at86rf231_netdev);
+
    leds_radio_toggle();
    // The AT86RF231 does not generate an interrupt when the radio transmits the
    // SFD, which messes up the MAC state machine. The danger is that, if we leave
@@ -220,19 +251,21 @@ void radio_rxEnable(void) {
    radio_vars.state = RADIOSTATE_ENABLING_RX;
 
    // put radio in reception mode
-   radio_spiWriteReg(RG_TRX_STATE, CMD_RX_ON);
+   // radio_spiWriteReg(RG_TRX_STATE, CMD_RX_ON);
 
-   // wiggle debug pin
-   debugpins_radio_set();
+   at86rf231_switch_to_rx();
+
+//    // wiggle debug pin
+//    debugpins_radio_set();
    leds_radio_on();
 
-   // busy wait until radio really listening
-   uint16_t c = 0;
-   while((radio_spiReadReg(RG_TRX_STATUS) & 0x1F) != RX_ON)
-       ;// if (c++ == 100000) {
-//            DEBUG("%s: radio_spiReadReg timeout\n",__PRETTY_FUNCTION__);
-//            break;
-//        }
+//    // busy wait until radio really listening
+//    uint16_t c = 0;
+//    while((radio_spiReadReg(RG_TRX_STATUS) & 0x1F) != RX_ON)
+//        ;// if (c++ == 100000) {
+// //            DEBUG("%s: radio_spiReadReg timeout\n",__PRETTY_FUNCTION__);
+// //            break;
+// //        }
 
    // change state
    radio_vars.state = RADIOSTATE_LISTENING;
@@ -248,212 +281,216 @@ void radio_getReceivedFrame(uint8_t* pBufRead,
                             uint8_t  maxBufLen,
                              int8_t* pRssi,
                             uint8_t* pLqi,
-                            uint8_t* pCrc) {
+                               bool* pCrc) {
    uint8_t temp_reg_value;
 
    //===== crc
-   temp_reg_value  = radio_spiReadReg(RG_PHY_RSSI);
+   temp_reg_value  = at86rf231_reg_read(AT86RF231_REG__PHY_RSSI);
    *pCrc           = (temp_reg_value & 0x80)>>7;  // msb is whether packet passed CRC
-
-   //===== rssi
-   // as per section 8.4.3 of the AT86RF231, the RSSI is calculate as:
-   // -91 + ED [dBm]
-   temp_reg_value  = radio_spiReadReg(RG_PHY_ED_LEVEL);
-   *pRssi          = -91 + temp_reg_value;
-
-   //===== packet
-   radio_spiReadRxFifo(pBufRead,
-                       pLenRead,
-                       maxBufLen,
-                       pLqi);
+   *pRssi          = (temp_reg_value & 0x0f);
+
+   // //===== rssi
+   // // as per section 8.4.3 of the AT86RF231, the RSSI is calculate as:
+   // // -91 + ED [dBm]
+   // temp_reg_value  = radio_spiReadReg(RG_PHY_ED_LEVEL);
+   // *pRssi          = -91 + temp_reg_value;
+
+   // //===== packet
+   // radio_spiReadRxFifo(pBufRead,
+   //                     pLenRead,
+   //                     maxBufLen,
+   //                     pLqi);
+   at86rf231_read_fifo(pLenRead, 1);
+   at86rf231_read_fifo(pBufRead, *pLenRead);
+   *pLqi = pBufRead[(*pLenRead)-1];
 }
 
 //=========================== private =========================================
 
-static inline void CSn_SET(void)
-{
-    SPI_0_CS_PORT->BSRR = (1 << SPI_0_CS_PIN);
-}
-static inline void CSn_CLR(void)
-{
-    SPI_0_CS_PORT->BRR = (1 << SPI_0_CS_PIN);
-}
-
-uint8_t radio_spiReadRadioInfo(void){
-   uint8_t              spi_tx_buffer[3];
-   uint8_t              spi_rx_buffer[3];
-   DEBUG("%s\n",__PRETTY_FUNCTION__);
-   // prepare buffer to send over SPI
-   spi_tx_buffer[0]     =  (0x80 | 0x1E);        // [b7]    Read/Write:    1    (read)
-   // [b6]    RAM/Register : 1    (register)
-   // [b5-0]  address:       0x1E (Manufacturer ID, Lower 16 Bit)
-   spi_tx_buffer[1]     =  0x00;                 // send a SNOP strobe just to get the reg value
-   spi_tx_buffer[2]     =  0x00;                 // send a SNOP strobe just to get the reg value
-
-   // retrieve radio manufacturer ID over SPI
-   // spi_txrx(spi_tx_buffer,
-   //       sizeof(spi_tx_buffer),
-   //       SPI_BUFFER,
-   //       spi_rx_buffer,
-   //       sizeof(spi_rx_buffer),
-   //       SPI_FIRST,
-   //       SPI_LAST);
-   CSn_CLR();
-   spi_transfer_bytes(SPI_0, spi_tx_buffer, spi_rx_buffer, 3);
-   CSn_SET();
-   return spi_rx_buffer[2];
-}
-
-void radio_spiWriteReg(uint8_t reg_addr, uint8_t reg_setting) {
-   uint8_t spi_tx_buffer[2];
-   uint8_t spi_rx_buffer[2];
-   spi_tx_buffer[0] = (0xC0 | reg_addr);        // turn addess in a 'reg write' address
-   spi_tx_buffer[1] = reg_setting;
-
-   // spi_txrx(spi_tx_buffer,
-   //          sizeof(spi_tx_buffer),
-   //          SPI_BUFFER,
-   //          (uint8_t*)spi_rx_buffer,
-   //          sizeof(spi_rx_buffer),
-   //          SPI_FIRST,
-   //          SPI_LAST);
-   CSn_CLR();
-   spi_transfer_byte(SPI_0, spi_tx_buffer[0], NULL);
-   spi_transfer_byte(SPI_0, spi_tx_buffer[1], NULL);
-   CSn_SET();
-}
-
-uint8_t radio_spiReadReg(uint8_t reg_addr) {
-   uint8_t spi_tx_buffer[2];
-   uint8_t spi_rx_buffer[2];
-   spi_tx_buffer[0] = (0x80 | reg_addr);        // turn addess in a 'reg read' address
-   spi_tx_buffer[1] = 0x00;                     // send a no_operation command just to get the reg value
-
-   // spi_txrx(spi_tx_buffer,
-   //          sizeof(spi_tx_buffer),
-   //          SPI_BUFFER,
-   //          (uint8_t*)spi_rx_buffer,
-   //          sizeof(spi_rx_buffer),
-   //          SPI_FIRST,
-   //          SPI_LAST);
-   CSn_CLR();
-   spi_transfer_byte(SPI_0, spi_tx_buffer[0], NULL);
-   spi_transfer_byte(SPI_0, 0, spi_rx_buffer);
-   CSn_SET();
-
-  return spi_rx_buffer[0];
-}
-
-/** for testing purposes, remove if not needed anymore**/
-
-void radio_spiWriteTxFifo(uint8_t* bufToWrite, uint8_t  lenToWrite) {
-   uint8_t spi_tx_buffer[2];
-   uint8_t spi_rx_buffer[1+1+127];               // 1B SPI address, 1B length, max. 127B data
-   DEBUG("%s\n",__PRETTY_FUNCTION__);
-   spi_tx_buffer[0] = 0x60;                      // SPI destination address for TXFIFO
-   spi_tx_buffer[1] = lenToWrite;                // length byte
-
-   CSn_CLR();
-   spi_transfer_byte(SPI_0, spi_tx_buffer[0], NULL);
-   spi_transfer_byte(SPI_0, spi_tx_buffer[1], NULL);
-   spi_transfer_bytes(SPI_0, bufToWrite, NULL, lenToWrite);
-   CSn_SET();
-
-   // spi_txrx(spi_tx_buffer,
-   //          sizeof(spi_tx_buffer),
-   //          SPI_BUFFER,
-   //          spi_rx_buffer,
-   //          sizeof(spi_rx_buffer),
-   //          SPI_FIRST,
-   //          SPI_NOTLAST);
-
-   // spi_txrx(bufToWrite,
-   //          lenToWrite,
-   //          SPI_BUFFER,
-   //          spi_rx_buffer,
-   //          sizeof(spi_rx_buffer),
-   //          SPI_NOTFIRST,
-   //          SPI_LAST);
-}
-
-
-
-void radio_spiReadRxFifo(uint8_t* pBufRead,
-                         uint8_t* pLenRead,
-                         uint8_t  maxBufLen,
-                         uint8_t* pLqi) {
-   // when reading the packet over SPI from the RX buffer, you get the following:
-   // - *[1B]     dummy byte because of SPI
-   // - *[1B]     length byte
-   // -  [0-125B] packet (excluding CRC)
-   // - *[2B]     CRC
-   // - *[1B]     LQI
-   uint8_t spi_tx_buffer[125];
-   uint8_t spi_rx_buffer[3];
-   DEBUG("%s\n",__PRETTY_FUNCTION__);
-   spi_tx_buffer[0] = 0x20;
-
-   CSn_CLR();
-   spi_transfer_byte(SPI_0, spi_tx_buffer[0], NULL);
-   spi_transfer_byte(SPI_0, 0, spi_rx_buffer);
-   // 2 first bytes
-   // spi_txrx(spi_tx_buffer,
-   //          2,
-   //          SPI_BUFFER,
-   //          spi_rx_buffer,
-   //          sizeof(spi_rx_buffer),
-   //          SPI_FIRST,
-   //          SPI_NOTLAST);
-
-   *pLenRead  = spi_rx_buffer[0];
-
-   if (*pLenRead>2 && *pLenRead<=127) {
-      // valid length
-      spi_transfer_byte(SPI_0, spi_tx_buffer[0], NULL);
-      spi_transfer_bytes(SPI_0, NULL, pBufRead, *pLenRead);
-
-      // //read packet
-      // spi_txrx(spi_tx_buffer,
-      //          *pLenRead,
-      //          SPI_BUFFER,
-      //          pBufRead,
-      //          125,
-      //          SPI_NOTFIRST,
-      //          SPI_NOTLAST);
-      spi_transfer_byte(SPI_0, 0, 0);
-      spi_transfer_byte(SPI_0, 0, 0);
-      spi_transfer_byte(SPI_0, 0, pLqi);
-      // CRC (2B) and LQI (1B)
-      // spi_txrx(spi_tx_buffer,
-      //          2+1,
-      //          SPI_BUFFER,
-      //          spi_rx_buffer,
-      //          3,
-      //          SPI_NOTFIRST,
-      //          SPI_LAST);
-
-      // *pLqi   = spi_rx_buffer[2];
-
-   } else {
-      // invalid length
-      spi_transfer_byte(SPI_0, 0, 0);
-      // read a just byte to close spi
-      // spi_txrx(spi_tx_buffer,
-      //          1,
-      //          SPI_BUFFER,
-      //          spi_rx_buffer,
-      //          sizeof(spi_rx_buffer),
-      //          SPI_NOTFIRST,
-      //          SPI_LAST);
-   }
-   CSn_SET();
-}
+// static inline void CSn_SET(void)
+// {
+//     SPI_0_CS_PORT->BSRR = (1 << SPI_0_CS_PIN);
+// }
+// static inline void CSn_CLR(void)
+// {
+//     SPI_0_CS_PORT->BRR = (1 << SPI_0_CS_PIN);
+// }
+
+// uint8_t radio_spiReadRadioInfo(void){
+//    uint8_t              spi_tx_buffer[3];
+//    uint8_t              spi_rx_buffer[3];
+//    DEBUG("%s\n",__PRETTY_FUNCTION__);
+//    // prepare buffer to send over SPI
+//    spi_tx_buffer[0]     =  (0x80 | 0x1E);        // [b7]    Read/Write:    1    (read)
+//    // [b6]    RAM/Register : 1    (register)
+//    // [b5-0]  address:       0x1E (Manufacturer ID, Lower 16 Bit)
+//    spi_tx_buffer[1]     =  0x00;                 // send a SNOP strobe just to get the reg value
+//    spi_tx_buffer[2]     =  0x00;                 // send a SNOP strobe just to get the reg value
+
+//    // retrieve radio manufacturer ID over SPI
+//    // spi_txrx(spi_tx_buffer,
+//    //       sizeof(spi_tx_buffer),
+//    //       SPI_BUFFER,
+//    //       spi_rx_buffer,
+//    //       sizeof(spi_rx_buffer),
+//    //       SPI_FIRST,
+//    //       SPI_LAST);
+//    CSn_CLR();
+//    spi_transfer_bytes(SPI_0, spi_tx_buffer, spi_rx_buffer, 3);
+//    CSn_SET();
+//    return spi_rx_buffer[2];
+// }
+
+// void radio_spiWriteReg(uint8_t reg_addr, uint8_t reg_setting) {
+//    uint8_t spi_tx_buffer[2];
+//    uint8_t spi_rx_buffer[2];
+//    spi_tx_buffer[0] = (0xC0 | reg_addr);        // turn addess in a 'reg write' address
+//    spi_tx_buffer[1] = reg_setting;
+
+//    // spi_txrx(spi_tx_buffer,
+//    //          sizeof(spi_tx_buffer),
+//    //          SPI_BUFFER,
+//    //          (uint8_t*)spi_rx_buffer,
+//    //          sizeof(spi_rx_buffer),
+//    //          SPI_FIRST,
+//    //          SPI_LAST);
+//    CSn_CLR();
+//    spi_transfer_byte(SPI_0, spi_tx_buffer[0], NULL);
+//    spi_transfer_byte(SPI_0, spi_tx_buffer[1], NULL);
+//    CSn_SET();
+// }
+
+// uint8_t radio_spiReadReg(uint8_t reg_addr) {
+//    uint8_t spi_tx_buffer[2];
+//    uint8_t spi_rx_buffer[2];
+//    spi_tx_buffer[0] = (0x80 | reg_addr);        // turn addess in a 'reg read' address
+//    spi_tx_buffer[1] = 0x00;                     // send a no_operation command just to get the reg value
+
+//    // spi_txrx(spi_tx_buffer,
+//    //          sizeof(spi_tx_buffer),
+//    //          SPI_BUFFER,
+//    //          (uint8_t*)spi_rx_buffer,
+//    //          sizeof(spi_rx_buffer),
+//    //          SPI_FIRST,
+//    //          SPI_LAST);
+//    CSn_CLR();
+//    spi_transfer_byte(SPI_0, spi_tx_buffer[0], NULL);
+//    spi_transfer_byte(SPI_0, 0, spi_rx_buffer);
+//    CSn_SET();
+
+//   return spi_rx_buffer[0];
+// }
+
+// /** for testing purposes, remove if not needed anymore**/
+
+// void radio_spiWriteTxFifo(uint8_t* bufToWrite, uint8_t  lenToWrite) {
+//    uint8_t spi_tx_buffer[2];
+//    uint8_t spi_rx_buffer[1+1+127];               // 1B SPI address, 1B length, max. 127B data
+//    DEBUG("%s\n",__PRETTY_FUNCTION__);
+//    spi_tx_buffer[0] = 0x60;                      // SPI destination address for TXFIFO
+//    spi_tx_buffer[1] = lenToWrite;                // length byte
+
+//    CSn_CLR();
+//    spi_transfer_byte(SPI_0, spi_tx_buffer[0], NULL);
+//    spi_transfer_byte(SPI_0, spi_tx_buffer[1], NULL);
+//    spi_transfer_bytes(SPI_0, bufToWrite, NULL, lenToWrite);
+//    CSn_SET();
+
+//    // spi_txrx(spi_tx_buffer,
+//    //          sizeof(spi_tx_buffer),
+//    //          SPI_BUFFER,
+//    //          spi_rx_buffer,
+//    //          sizeof(spi_rx_buffer),
+//    //          SPI_FIRST,
+//    //          SPI_NOTLAST);
+
+//    // spi_txrx(bufToWrite,
+//    //          lenToWrite,
+//    //          SPI_BUFFER,
+//    //          spi_rx_buffer,
+//    //          sizeof(spi_rx_buffer),
+//    //          SPI_NOTFIRST,
+//    //          SPI_LAST);
+// }
+
+
+
+// void radio_spiReadRxFifo(uint8_t* pBufRead,
+//                          uint8_t* pLenRead,
+//                          uint8_t  maxBufLen,
+//                          uint8_t* pLqi) {
+//    // when reading the packet over SPI from the RX buffer, you get the following:
+//    // - *[1B]     dummy byte because of SPI
+//    // - *[1B]     length byte
+//    // -  [0-125B] packet (excluding CRC)
+//    // - *[2B]     CRC
+//    // - *[1B]     LQI
+//    uint8_t spi_tx_buffer[125];
+//    uint8_t spi_rx_buffer[3];
+//    DEBUG("%s\n",__PRETTY_FUNCTION__);
+//    spi_tx_buffer[0] = 0x20;
+
+//    CSn_CLR();
+//    spi_transfer_byte(SPI_0, spi_tx_buffer[0], NULL);
+//    spi_transfer_byte(SPI_0, 0, spi_rx_buffer);
+//    // 2 first bytes
+//    // spi_txrx(spi_tx_buffer,
+//    //          2,
+//    //          SPI_BUFFER,
+//    //          spi_rx_buffer,
+//    //          sizeof(spi_rx_buffer),
+//    //          SPI_FIRST,
+//    //          SPI_NOTLAST);
+
+//    *pLenRead  = spi_rx_buffer[0];
+
+//    if (*pLenRead>2 && *pLenRead<=127) {
+//       // valid length
+//       spi_transfer_byte(SPI_0, spi_tx_buffer[0], NULL);
+//       spi_transfer_bytes(SPI_0, NULL, pBufRead, *pLenRead);
+
+//       // //read packet
+//       // spi_txrx(spi_tx_buffer,
+//       //          *pLenRead,
+//       //          SPI_BUFFER,
+//       //          pBufRead,
+//       //          125,
+//       //          SPI_NOTFIRST,
+//       //          SPI_NOTLAST);
+//       spi_transfer_byte(SPI_0, 0, 0);
+//       spi_transfer_byte(SPI_0, 0, 0);
+//       spi_transfer_byte(SPI_0, 0, pLqi);
+//       // CRC (2B) and LQI (1B)
+//       // spi_txrx(spi_tx_buffer,
+//       //          2+1,
+//       //          SPI_BUFFER,
+//       //          spi_rx_buffer,
+//       //          3,
+//       //          SPI_NOTFIRST,
+//       //          SPI_LAST);
+
+//       // *pLqi   = spi_rx_buffer[2];
+
+//    } else {
+//       // invalid length
+//       spi_transfer_byte(SPI_0, 0, 0);
+//       // read a just byte to close spi
+//       // spi_txrx(spi_tx_buffer,
+//       //          1,
+//       //          SPI_BUFFER,
+//       //          spi_rx_buffer,
+//       //          sizeof(spi_rx_buffer),
+//       //          SPI_NOTFIRST,
+//       //          SPI_LAST);
+//    }
+//    CSn_SET();
+// }
 
 //=========================== callbacks =======================================
 
 //=========================== interrupt handlers ==============================
 
-kick_scheduler_t radio_isr(void) {
+void at86rf231_rx_irq(void) {
    PORT_TIMER_WIDTH capturedTime;
    uint8_t  irq_status;
 
@@ -461,10 +498,10 @@ kick_scheduler_t radio_isr(void) {
    capturedTime = radiotimer_getCapturedTime();
 
    // reading IRQ_STATUS causes radio's IRQ pin to go low
-   irq_status = radio_spiReadReg(RG_IRQ_STATUS);
+   irq_status = at86rf231_reg_read(AT86RF231_REG__IRQ_STATUS);
 
    // start of frame event
-   if (irq_status & AT_IRQ_RX_START) {
+   if (irq_status & AT86RF231_IRQ_STATUS_MASK__RX_START) {
        DEBUG("Start of frame.\n");
       // change state
       radio_vars.state = RADIOSTATE_RECEIVING;
@@ -472,13 +509,13 @@ kick_scheduler_t radio_isr(void) {
          // call the callback
          radio_vars.startFrame_cb(capturedTime);
          // kick the OS
-         return KICK_SCHEDULER;
+         return;
       } else {
          while(1);
       }
    }
    // end of frame event
-   if (irq_status & AT_IRQ_TRX_END) {
+   if (irq_status & AT86RF231_IRQ_STATUS_MASK__TRX_END) {
        DEBUG("End of Frame.\n");
       // change state
       radio_vars.state = RADIOSTATE_TXRX_DONE;
@@ -486,11 +523,9 @@ kick_scheduler_t radio_isr(void) {
          // call the callback
          radio_vars.endFrame_cb(capturedTime);
          // kick the OS
-         return KICK_SCHEDULER;
+         return;
       } else {
          while(1);
       }
    }
-
-   return DO_NOT_KICK_SCHEDULER;
 }
\ No newline at end of file
diff --git a/bsp/boards/riot-adaption/radiotimer.c b/bsp/boards/riot-adaption/radiotimer.c
index e9c0b54..47fa2d2 100644
--- a/bsp/boards/riot-adaption/radiotimer.c
+++ b/bsp/boards/riot-adaption/radiotimer.c
@@ -8,11 +8,14 @@ On openmoteSTM32, we use RTC for the radiotimer module.
 #include "stdint.h"
 
 #include "periph/timer.h"
+#include "hwtimer.h"
 
 #include "leds.h"
 #include "radiotimer.h"
 #include "board_info.h"
 
+#include "riot.h"
+
 #define ENABLE_DEBUG (0)
 #include "debug.h"
 
@@ -36,14 +39,14 @@ volatile radiotimer_vars_t radiotimer_vars;
 uint16_t current_period;
 
 //=========================== prototypes ======================================
-
+extern int timer_set_relative(tim_t, int channel, unsigned int rel_value);
 //=========================== public ==========================================
 
 //===== admin
 
 void radiotimer_init(void) {
    // clear local variables
-   memset(&radiotimer_vars,0,sizeof(radiotimer_vars_t));
+   memset((void*)&radiotimer_vars,0,sizeof(radiotimer_vars_t));
    current_period = 0;
 }
 
@@ -63,10 +66,10 @@ void radiotimer_setEndFrameCb(radiotimer_capture_cbt cb) {
    while(1);
 }
 
-void radiotimer_start(uint16_t period) {
+void radiotimer_start(PORT_RADIOTIMER_WIDTH period) {
     DEBUG("%s\n", __PRETTY_FUNCTION__);
-    timer_init(TIMER_1, 1, &radiotimer_isr);
-    timer_set(TIMER_1, 1, (0xffff)&((unsigned int)period));
+    // timer_init(OWSN_TIMER, 1, &radiotimer_isr);
+    timer_set(OWSN_TIMER, 1, ((unsigned int)HWTIMER_TICKS(period)*10));
     current_period = period;
    radiotimer_vars.currentSlotPeriod = period;
    radiotimer_vars.overflowORcompare = RADIOTIMER_OVERFLOW;
@@ -74,12 +77,13 @@ void radiotimer_start(uint16_t period) {
 
 //===== direct access
 
-uint16_t radiotimer_getValue(void) {
-    return (uint16_t)((0xffff)&timer_read(TIMER_1));
+PORT_RADIOTIMER_WIDTH radiotimer_getValue(void) {
+    return (PORT_RADIOTIMER_WIDTH)(HWTIMER_TICKS_TO_US(timer_read(OWSN_TIMER)));
 }
 
-void radiotimer_setPeriod(uint16_t period) {
-    timer_set(TIMER_1, 1, (0xffff)&((unsigned int)period));
+void radiotimer_setPeriod(PORT_RADIOTIMER_WIDTH period) {
+    DEBUG("%s\n", __PRETTY_FUNCTION__);
+    timer_set(OWSN_TIMER, 1, ((unsigned int)HWTIMER_TICKS(period)*10));
     current_period = period;
     radiotimer_vars.currentSlotPeriod = period;
 
@@ -87,26 +91,27 @@ void radiotimer_setPeriod(uint16_t period) {
     radiotimer_vars.overflowORcompare = RADIOTIMER_OVERFLOW;
 }
 
-uint16_t radiotimer_getPeriod(void) {
+PORT_RADIOTIMER_WIDTH radiotimer_getPeriod(void) {
     return current_period;
 }
 
 //===== compare
 
-void radiotimer_schedule(uint16_t offset) {
-    timer_irq_disable(TIMER_1);
-    timer_set(TIMER_1, 1, offset);
-    current_period = offset;
-    timer_irq_enable(TIMER_1);
+void radiotimer_schedule(PORT_RADIOTIMER_WIDTH offset) {
+    DEBUG("%s\n", __PRETTY_FUNCTION__);
+    timer_irq_disable(OWSN_TIMER);
+    timer_set(OWSN_TIMER, 1, HWTIMER_TICKS(offset)*10);
+    timer_irq_enable(OWSN_TIMER);
     //set radiotimer irpstatus
     radiotimer_vars.overflowORcompare = RADIOTIMER_COMPARE;
 }
 
 void radiotimer_cancel(void) {
-    timer_irq_disable(TIMER_1);
-    timer_clear(TIMER_1, 1);
-    current_period = 0;
-    timer_irq_enable(TIMER_1);
+    DEBUG("%s\n", __PRETTY_FUNCTION__);
+    timer_irq_disable(OWSN_TIMER);
+    // timer_clear(OWSN_TIMER, 1);
+    timer_set(OWSN_TIMER, 1, HWTIMER_TICKS(current_period)*10);
+    timer_irq_enable(OWSN_TIMER);
 
     //set radiotimer irpstatus
     radiotimer_vars.overflowORcompare = RADIOTIMER_OVERFLOW;
@@ -114,15 +119,14 @@ void radiotimer_cancel(void) {
 
 //===== capture
 
-inline uint16_t radiotimer_getCapturedTime(void) {
-    return (uint16_t)((0xffff)&timer_read(TIMER_1));
+inline PORT_RADIOTIMER_WIDTH radiotimer_getCapturedTime(void) {
+    return (PORT_RADIOTIMER_WIDTH)(timer_read(OWSN_TIMER));
 }
 
 //=========================== private =========================================
 
 //=========================== interrupt handlers ==============================
-
-kick_scheduler_t radiotimer_isr(void) {
+void radiotimer_isr(void) {
     uint8_t taiv_temp = radiotimer_vars.overflowORcompare;
     switch (taiv_temp) {
         case RADIOTIMER_COMPARE:
@@ -130,19 +134,19 @@ kick_scheduler_t radiotimer_isr(void) {
             if (radiotimer_vars.compare_cb!=NULL) {
                 radiotimer_vars.compare_cb();
                 // kick the OS
-                return KICK_SCHEDULER;
+                // return KICK_SCHEDULER;
             }
             break;
         case RADIOTIMER_OVERFLOW: // timer overflows
             DEBUG("%s of\n", __PRETTY_FUNCTION__);
             if (radiotimer_vars.overflow_cb!=NULL) {
                 //Wait until last write operation on RTC registers has finished
-                timer_reset(TIMER_1);
+                timer_set(OWSN_TIMER, 1, HWTIMER_TICKS(current_period)*10);
                 // call the callback
                 radiotimer_vars.overflow_cb();
                 DEBUG("returned...\n");
                 // kick the OS
-                return KICK_SCHEDULER;
+                // return KICK_SCHEDULER;
             }
             break;
       case RADIOTIMER_NONE:                     // this should not happen
@@ -151,5 +155,5 @@ kick_scheduler_t radiotimer_isr(void) {
             DEBUG("%s default\n", __PRETTY_FUNCTION__);
             // while(1);                               // this should not happen
     }
-    return DO_NOT_KICK_SCHEDULER;
+    // return DO_NOT_KICK_SCHEDULER;
 }
\ No newline at end of file
diff --git a/bsp/boards/riot-adaption/riot.h b/bsp/boards/riot-adaption/riot.h
new file mode 100644
index 0000000..982241c
--- /dev/null
+++ b/bsp/boards/riot-adaption/riot.h
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2014 Freie Universität Berlin
+ *
+ * This file is subject to the terms and conditions of the GNU Lesser
+ * General Public License v2.1. See the file LICENSE in the top level
+ * directory for more details.
+ */
+
+/**
+ * @{
+ *
+ * @file
+ * @brief           RIOT specific definitions for OpenWSN
+ *
+ * @author          Thomas Eichinger <thomas.eichinger@fu-berlin.de>
+ */
+
+#ifndef __RIOT_H
+#define __RIOT_H
+
+#include "thread.h"
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/**
+ * @brief The peripheral timer to use with OpenWSN
+ */
+#define OWSN_TIMER  TIMER_1
+
+#ifdef __cplusplus
+}
+#endif
+#endif /* __RIOT_H */
+/** @} */
\ No newline at end of file
diff --git a/bsp/boards/riot-adaption/spi_ow.c b/bsp/boards/riot-adaption/spi_ow.c
deleted file mode 100644
index 56193f6..0000000
--- a/bsp/boards/riot-adaption/spi_ow.c
+++ /dev/null
@@ -1,321 +0,0 @@
-#include "stdio.h"
-#include "stdint.h"
-#include "string.h"
-#include "spi_ow.h"
-#include "spi.h"
-#include "leds.h"
-#include "board.h"
-#include "radio.h"
-#include "periph/gpio.h"
-#include "periph_conf.h"
-#include "at86rf231.h"
-
-#define ENABLE_DEBUG (0)
-#include "debug.h"
-
-//=========================== defines =========================================
-
-//=========================== variables =======================================
-
-typedef struct {
-   // information about the current transaction
-   uint8_t*        pNextTxByte;
-   uint8_t         numTxedBytes;
-   uint8_t         txBytesLeft;
-   spi_return_t    returnType;
-   uint8_t*        pNextRxByte;
-   uint8_t         maxRxBytes;
-   spi_first_t     isFirst;
-   spi_last_t      isLast;
-   // state of the module
-   uint8_t         busy;
-#ifdef SPI_IN_INTERRUPT_MODE
-   // callback when module done
-   spi_cbt         callback;
-#endif
-} spi_vars_t;
-
-volatile spi_vars_t spi_vars;
-
-//=========================== prototypes ======================================
-// inline static void RESET_CLR(void) { GPIOC->BRR = 1<<1; }
-// inline static void RESET_SET(void) { GPIOC->BSRR = 1<<1; }
-// inline static void CSn_SET(void) { GPIOA->BSRR = 1<<4; }
-// inline static void CSn_CLR(void) { GPIOA->BRR = 1<<4; }
-// inline static void SLEEP_CLR(void) { GPIOA->BRR = 1<<2; }
-static inline void RESET_CLR(void)
-{
-    SPI_0_RESET_PORT->BRR = (1 << SPI_0_RESET_PIN);
-}
-static inline void RESET_SET(void)
-{
-    SPI_0_RESET_PORT->BSRR = (1 << SPI_0_RESET_PIN);
-}
-static inline void CSn_SET(void)
-{
-    SPI_0_CS_PORT->BSRR = (1 << SPI_0_CS_PIN);
-}
-static inline void CSn_CLR(void)
-{
-    SPI_0_CS_PORT->BRR = (1 << SPI_0_CS_PIN);
-}
-static inline void SLEEP_CLR(void)
-{
-    SPI_0_SLEEP_PORT->BRR = (1 << SPI_0_SLEEP_PIN);
-}
-
-//=========================== public ==========================================
-
-void spi_init_ow(void) {
-   // clear variables
-    memset(&spi_vars,0,sizeof(spi_vars_t));
-
-    /* set up GPIO pins */
-    /* SCLK and MOSI*/
-    GPIOA->CRL &= ~(0xf << (5 * 4));
-    GPIOA->CRL |= (0xb << (5 * 4));
-    GPIOA->CRL &= ~(0xf << (7 * 4));
-    GPIOA->CRL |= (0xb << (7 * 4));
-    /* MISO */
-    gpio_init_in(SPI_0_MISO_GPIO, GPIO_NOPULL);
-
-    /* SPI init */
-    spi_init_master(SPI_0, SPI_CONF_FIRST_RISING, 4500000);
-
-    spi_poweron(SPI_0);
-
-    /* IRQ0 */
-    gpio_init_in(SPI_0_IRQ0_GPIO, GPIO_NOPULL);
-    gpio_init_int(SPI_0_IRQ0_GPIO, GPIO_NOPULL, GPIO_RISING, radio_isr);
-
-    /* Connect EXTI4 Line to PC4 pin */
-    gpio_irq_enable(SPI_0_IRQ0_GPIO);
-
-    /* CS */
-    gpio_init_out(SPI_0_CS_GPIO, GPIO_NOPULL);
-    /* SLEEP */
-    gpio_init_out(SPI_0_SLEEP_GPIO, GPIO_NOPULL);
-    /* RESET */
-    gpio_init_out(SPI_0_RESET_GPIO, GPIO_NOPULL);
-
-    // force reset
-    RESET_CLR();
-    CSn_SET();
-    SLEEP_CLR();
-
-    for (uint16_t j=0;j<0xFFFF;j++); //small wait
-
-    RESET_SET();
-    // /* set up GPIO pins */
-    // /* SCLK and MOSI*/
-    // GPIOA->CRL &= ~(0xf << (5 * 4));
-    // GPIOA->CRL |= (0xb << (5 * 4));
-    // GPIOA->CRL &= ~(0xf << (7 * 4));
-    // GPIOA->CRL |= (0xb << (7 * 4));
-    // /* MISO */
-    // gpio_init_in(SPI_0_MISO_GPIO, GPIO_NOPULL);
-
-    // /* SPI init */
-    // spi_init_master(SPI_0, SPI_CONF_FIRST_RISING, 4500000);
-
-    // spi_poweron(SPI_0);
-
-    // /* IRQ0 */
-    // gpio_init_in(SPI_0_IRQ0_GPIO, GPIO_NOPULL);
-    // gpio_init_int(SPI_0_IRQ0_GPIO, GPIO_NOPULL, GPIO_RISING, radio_isr);
-
-    // /* Connect EXTI4 Line to PC4 pin */
-    // gpio_irq_enable(SPI_0_IRQ0_GPIO);
-
-    // /* CS */
-    // gpio_init_out(SPI_0_CS_GPIO, GPIO_NOPULL);
-    // /* SLEEP */
-    // gpio_init_out(SPI_0_SLEEP_GPIO, GPIO_NOPULL);
-    // /* RESET */
-    // gpio_init_out(SPI_0_RESET_GPIO, GPIO_NOPULL);
-
-    // /* force reset */
-    // RESET_CLR();
-    // CSn_SET();
-    // SLEEP_CLR();
-
-    // vtimer_usleep(AT86RF231_TIMING__RESET);
-
-    // RESET_SET();
-
-    // /* Wait until TRX_OFF is entered */
-    // vtimer_usleep(AT86RF231_TIMING__RESET_TO_TRX_OFF);
-
-    // /* Send a FORCE TRX OFF command */
-    // at86rf231_reg_write(AT86RF231_REG__TRX_STATE, AT86RF231_TRX_STATE__FORCE_TRX_OFF);
-
-    // /* Wait until TRX_OFF state is entered from P_ON */
-    // vtimer_usleep(AT86RF231_TIMING__SLEEP_TO_TRX_OFF);
-
-    // /* busy wait for TRX_OFF state */
-    // uint8_t status;
-    // uint8_t max_wait = 100;   // TODO : move elsewhere, this is in 10us
-
-    // do {
-    //     status = at86rf231_get_status();
-
-    //     vtimer_usleep(10);
-
-    //     if (!--max_wait) {
-    //         printf("at86rf231 : ERROR : could not enter TRX_OFF mode\n");
-    //         break;
-    //     }
-    // } while ((status & AT86RF231_TRX_STATUS_MASK__TRX_STATUS)
-    //          != AT86RF231_TRX_STATUS__TRX_OFF);
-
-}
-
-#ifdef SPI_IN_INTERRUPT_MODE
-void spi_setCallback(spi_cbt cb) {
-   spi_vars.callback = cb;
-}
-#endif
-
-void spi_txrx(uint8_t*     bufTx,
-              uint8_t      lenbufTx,
-              spi_return_t returnType,
-              uint8_t*     bufRx,
-              uint8_t      maxLenBufRx,
-              spi_first_t  isFirst,
-              spi_last_t   isLast) {
-
-#ifdef SPI_IN_INTERRUPT_MODE
-   // disable interrupts
-   NVIC_RESETPRIMASK();
-#endif
-
-   // register spi frame to send
-   spi_vars.pNextTxByte      =  bufTx;
-   spi_vars.numTxedBytes     =  0;
-   spi_vars.txBytesLeft      =  lenbufTx;
-   spi_vars.returnType       =  returnType;
-   spi_vars.pNextRxByte      =  bufRx;
-   spi_vars.maxRxBytes       =  maxLenBufRx;
-   spi_vars.isFirst          =  isFirst;
-   spi_vars.isLast           =  isLast;
-
-   // SPI is now busy
-   spi_vars.busy             =  1;
-
-
-   // lower CS signal to have slave listening
-   if (spi_vars.isFirst==SPI_FIRST) {
-        CSn_CLR();
-   }
-
-#ifdef SPI_IN_INTERRUPT_MODE
-   // implementation 1. use a callback function when transaction finishes
-
-   // write first byte to TX buffer
-   SPI_I2S_SendData(SPI1,*spi_vars.pNextTxByte);
-
-   // re-enable interrupts
-   NVIC_SETPRIMASK();
-#else
-   // implementation 2. busy wait for each byte to be sent
-   // send all bytes
-   while (spi_vars.txBytesLeft>0) {
-      // write next byte to TX buffer
-   // SPI_I2S_SendData(SPI1,*spi_vars.pNextTxByte);
-        spi_transfer_byte(SPI_0, *((char*)spi_vars.pNextTxByte), NULL);
-
-      // busy wait on the interrupt flag
-//       uint16_t c = 0;
-//       while (SPI_I2S_GetFlagStatus(SPI1,SPI_I2S_FLAG_RXNE) == RESET)
-//           ;// if (c++ == 10000) {
-// //               //DEBUG("spi_txrx timeout\n");
-// //               break;
-// //           }
-
-//       // clear the interrupt flag
-//       SPI_I2S_ClearFlag(SPI1, SPI_I2S_FLAG_RXNE);
-      // save the byte just received in the RX buffer
-      switch (spi_vars.returnType) {
-         case SPI_FIRSTBYTE:
-            if (spi_vars.numTxedBytes==0) {
-                spi_transfer_byte(SPI_0, 0, (char*)spi_vars.pNextRxByte);
-               // *spi_vars.pNextRxByte   = SPI_I2S_ReceiveData(SPI1);
-            }
-            break;
-         case SPI_BUFFER:
-            spi_transfer_byte(SPI_0, 0, (char*)spi_vars.pNextRxByte);
-            // *spi_vars.pNextRxByte      = SPI_I2S_ReceiveData(SPI1);
-            spi_vars.pNextRxByte++;
-            break;
-         case SPI_LASTBYTE:
-            spi_transfer_byte(SPI_0, 0, (char*)spi_vars.pNextRxByte);
-            // *spi_vars.pNextRxByte      = SPI_I2S_ReceiveData(SPI1);
-            break;
-      }
-      // one byte less to go
-      spi_vars.pNextTxByte++;
-      spi_vars.numTxedBytes++;
-      spi_vars.txBytesLeft--;
-   }
-
-   // put CS signal high to signal end of transmission to slave
-   if (spi_vars.isLast==SPI_LAST) {
-        CSn_SET();
-   }
-
-   // SPI is not busy anymore
-   spi_vars.busy             =  0;
-#endif
-}
-
-//=========================== private =========================================
-
-//=========================== interrupt handlers ==============================
-
-kick_scheduler_t spi_isr(void) {
-#ifdef SPI_IN_INTERRUPT_MODE
-   // save the byte just received in the RX buffer
-   switch (spi_vars.returnType) {
-      case SPI_FIRSTBYTE:
-         if (spi_vars.numTxedBytes==0) {
-            *spi_vars.pNextRxByte = SPI_I2S_ReceiveData(SPI1);
-         }
-         break;
-      case SPI_BUFFER:
-         *spi_vars.pNextRxByte    = SPI_I2S_ReceiveData(SPI1);
-         spi_vars.pNextRxByte++;
-         break;
-      case SPI_LASTBYTE:
-         *spi_vars.pNextRxByte    = SPI_I2S_ReceiveData(SPI1);
-         break;
-   }
-
-   // one byte less to go
-   spi_vars.pNextTxByte++;
-   spi_vars.numTxedBytes++;
-   spi_vars.txBytesLeft--;
-
-   if (spi_vars.txBytesLeft>0) {
-      // write next byte to TX buffer
-   SPI_SendData(SPI1,*spi_vars.pNextTxByte);
-   } else {
-      // put CS signal high to signal end of transmission to slave
-      if (spi_vars.isLast==SPI_LAST) {
-   GPIO_SetBits(GPIOA, GPIO_Pin_4);
-      }
-      // SPI is not busy anymore
-      spi_vars.busy          =  0;
-
-      // SPI is done!
-      if (spi_vars.callback!=NULL) {
-         // call the callback
-         spi_vars.callback();
-         // kick the OS
-         return 1;
-      }
-   }
-#else
-   while(1);// this should never happen
-   return 1;
-#endif
-}
\ No newline at end of file
diff --git a/bsp/boards/riot-adaption/uart_ow.c b/bsp/boards/riot-adaption/uart_ow.c
index c2bcb4f..bd62ee6 100644
--- a/bsp/boards/riot-adaption/uart_ow.c
+++ b/bsp/boards/riot-adaption/uart_ow.c
@@ -1,4 +1,4 @@
-#include "uart_ow.h"
+#include "uart.h"
 #include "leds.h"
 #include "periph/uart.h"
 
@@ -22,7 +22,7 @@ volatile uart_vars_t uart_vars;
 void uart_init_ow(void)
 {
   // reset local variables
-  memset(&uart_vars,0,sizeof(uart_vars_t));
+  memset((void*)&uart_vars,0,sizeof(uart_vars_t));
 
   //when this value is 0, we are send the first data
   uart_vars.startOrend = 0;
@@ -76,9 +76,9 @@ void uart_writeByte(uint8_t byteToWrite)
 
 uint8_t uart_readByte(void)
 {
-  // uint16_t temp;
+  uint16_t temp = 0;
   // temp = USART_ReceiveData(USART1);
-  // return (uint8_t)temp;
+  return (uint8_t)temp;
 }
 
 //=========================== interrupt handlers ==============================
diff --git a/bsp/boards/uart.h b/bsp/boards/uart.h
index 4f02a23..57f93cf 100644
--- a/bsp/boards/uart.h
+++ b/bsp/boards/uart.h
@@ -31,7 +31,7 @@ typedef void (*uart_rx_cbt)(void);
 
 //=========================== prototypes ======================================
 
-void    uart_init(void);
+void    uart_init_ow(void);
 void    uart_setCallbacks(uart_tx_cbt txCb, uart_rx_cbt rxCb);
 void    uart_enableInterrupts(void);
 void    uart_disableInterrupts(void);
diff --git a/drivers/common/Makefile b/drivers/common/Makefile
index fbf6584..c703506 100644
--- a/drivers/common/Makefile
+++ b/drivers/common/Makefile
@@ -1,2 +1,8 @@
+INCLUDES += -I$(OPENWSN_ROOT)/openstack/02a-MAClow \
+			-I$(OPENWSN_ROOT)/openstack/02b-MAChigh \
+			-I$(OPENWSN_ROOT)/openstack/03a-IPHC \
+			-I$(OPENWSN_ROOT)/openstack/03b-IPv6 \
+			-I$(OPENWSN_ROOT)/openstack/cross-layers \
+			-I$(CURDIR)
 
 include $(RIOTBASE)/Makefile.base
\ No newline at end of file
diff --git a/drivers/common/openserial.c b/drivers/common/openserial.c
index c54cfff..ebb2743 100644
--- a/drivers/common/openserial.c
+++ b/drivers/common/openserial.c
@@ -1,48 +1,48 @@
-/**
-\brief Definition of the "openserial" driver.
-
-\author Fabien Chraim <chraim@eecs.berkeley.edu>, March 2012.
-*/
-
-#include "opendefs.h"
-#include "openserial.h"
-#include "IEEE802154E.h"
-#include "neighbors.h"
-#include "sixtop.h"
-#include "icmpv6echo.h"
-#include "idmanager.h"
-#include "openqueue.h"
-#include "openbridge.h"
-#include "leds.h"
-#include "schedule.h"
-#include "uart.h"
-#include "opentimers.h"
-#include "openhdlc.h"
-
-//=========================== variables =======================================
-
-openserial_vars_t openserial_vars;
-
-//=========================== prototypes ======================================
-
-owerror_t openserial_printInfoErrorCritical(
-   char             severity,
-   uint8_t          calling_component,
-   uint8_t          error_code,
-   errorparameter_t arg1,
-   errorparameter_t arg2
-);
-// HDLC output
-void outputHdlcOpen(void);
-void outputHdlcWrite(uint8_t b);
-void outputHdlcClose(void);
-// HDLC input
-void inputHdlcOpen(void);
-void inputHdlcWrite(uint8_t b);
-void inputHdlcClose(void);
-
-//=========================== public ==========================================
-
+/**
+\brief Definition of the "openserial" driver.
+
+\author Fabien Chraim <chraim@eecs.berkeley.edu>, March 2012.
+*/
+
+#include "opendefs.h"
+#include "openserial.h"
+#include "IEEE802154E.h"
+#include "neighbors.h"
+#include "sixtop.h"
+#include "icmpv6echo.h"
+#include "idmanager.h"
+#include "openqueue.h"
+#include "openbridge.h"
+#include "leds.h"
+#include "schedule.h"
+#include "uart.h"
+#include "opentimers.h"
+#include "openhdlc.h"
+
+//=========================== variables =======================================
+
+openserial_vars_t openserial_vars;
+
+//=========================== prototypes ======================================
+
+owerror_t openserial_printInfoErrorCritical(
+   char             severity,
+   uint8_t          calling_component,
+   uint8_t          error_code,
+   errorparameter_t arg1,
+   errorparameter_t arg2
+);
+// HDLC output
+void outputHdlcOpen(void);
+void outputHdlcWrite(uint8_t b);
+void outputHdlcClose(void);
+// HDLC input
+void inputHdlcOpen(void);
+void inputHdlcWrite(uint8_t b);
+void inputHdlcClose(void);
+
+//=========================== public ==========================================
+
 void openserial_init(void) {
    // uint16_t crc;
 
@@ -76,9 +76,9 @@ void openserial_init(void) {
    // // set callbacks
    // uart_setCallbacks(isr_openserial_tx,
    //                   isr_openserial_rx);
-}
-
-owerror_t openserial_printStatus(uint8_t statusElement,uint8_t* buffer, uint8_t length) {
+}
+
+owerror_t openserial_printStatus(uint8_t statusElement,uint8_t* buffer, uint8_t length) {
    // uint8_t i;
    // INTERRUPT_DECLARATION();
 
@@ -94,17 +94,17 @@ owerror_t openserial_printStatus(uint8_t statusElement,uint8_t* buffer, uint8_t
    // }
    // outputHdlcClose();
    // ENABLE_INTERRUPTS();
-   
-   return E_SUCCESS;
-}
-
-owerror_t openserial_printInfoErrorCritical(
-      char             severity,
-      uint8_t          calling_component,
-      uint8_t          error_code,
-      errorparameter_t arg1,
-      errorparameter_t arg2
-   ) {
+
+   return E_SUCCESS;
+}
+
+owerror_t openserial_printInfoErrorCritical(
+      char             severity,
+      uint8_t          calling_component,
+      uint8_t          error_code,
+      errorparameter_t arg1,
+      errorparameter_t arg2
+   ) {
    // INTERRUPT_DECLARATION();
 
    // DISABLE_INTERRUPTS();
@@ -121,11 +121,11 @@ owerror_t openserial_printInfoErrorCritical(
    // outputHdlcWrite((uint8_t) (arg2 & 0x00ff));
    // outputHdlcClose();
    // ENABLE_INTERRUPTS();
-   
-   return E_SUCCESS;
-}
-
-owerror_t openserial_printData(uint8_t* buffer, uint8_t length) {
+
+   return E_SUCCESS;
+}
+
+owerror_t openserial_printData(uint8_t* buffer, uint8_t length) {
    // uint8_t  i;
    // uint8_t  asn[5];
    // INTERRUPT_DECLARATION();
@@ -149,70 +149,70 @@ owerror_t openserial_printData(uint8_t* buffer, uint8_t length) {
    // }
    // outputHdlcClose();
    // ENABLE_INTERRUPTS();
-   
-   return E_SUCCESS;
-}
-
-owerror_t openserial_printInfo(uint8_t calling_component, uint8_t error_code,
-                              errorparameter_t arg1,
-                              errorparameter_t arg2) {
-   return openserial_printInfoErrorCritical(
-      SERFRAME_MOTE2PC_INFO,
-      calling_component,
-      error_code,
-      arg1,
-      arg2
-   );
-}
-
-owerror_t openserial_printError(uint8_t calling_component, uint8_t error_code,
-                              errorparameter_t arg1,
-                              errorparameter_t arg2) {
-   // blink error LED, this is serious
+
+   return E_SUCCESS;
+}
+
+owerror_t openserial_printInfo(uint8_t calling_component, uint8_t error_code,
+                              errorparameter_t arg1,
+                              errorparameter_t arg2) {
+   return openserial_printInfoErrorCritical(
+      SERFRAME_MOTE2PC_INFO,
+      calling_component,
+      error_code,
+      arg1,
+      arg2
+   );
+}
+
+owerror_t openserial_printError(uint8_t calling_component, uint8_t error_code,
+                              errorparameter_t arg1,
+                              errorparameter_t arg2) {
+   // blink error LED, this is serious
    // leds_error_toggle();
-   
-   return openserial_printInfoErrorCritical(
-      SERFRAME_MOTE2PC_ERROR,
-      calling_component,
-      error_code,
-      arg1,
-      arg2
-   );
-}
-
-owerror_t openserial_printCritical(uint8_t calling_component, uint8_t error_code,
-                              errorparameter_t arg1,
-                              errorparameter_t arg2) {
-   // blink error LED, this is serious
+
+   return openserial_printInfoErrorCritical(
+      SERFRAME_MOTE2PC_ERROR,
+      calling_component,
+      error_code,
+      arg1,
+      arg2
+   );
+}
+
+owerror_t openserial_printCritical(uint8_t calling_component, uint8_t error_code,
+                              errorparameter_t arg1,
+                              errorparameter_t arg2) {
+   // blink error LED, this is serious
    // leds_error_blink();
-   
+
    // // schedule for the mote to reboot in 10s
    // opentimers_start(10000,
    //                  TIMER_ONESHOT,TIME_MS,
    //                  board_reset);
-   
-   return openserial_printInfoErrorCritical(
-      SERFRAME_MOTE2PC_CRITICAL,
-      calling_component,
-      error_code,
-      arg1,
-      arg2
-   );
-}
-
+
+   return openserial_printInfoErrorCritical(
+      SERFRAME_MOTE2PC_CRITICAL,
+      calling_component,
+      error_code,
+      arg1,
+      arg2
+   );
+}
+
 uint8_t openserial_getNumDataBytes(void) {
-   uint8_t inputBufFill;
+   uint8_t inputBufFill = 0;
    // INTERRUPT_DECLARATION();
-   
+
    // DISABLE_INTERRUPTS();
    // inputBufFill = openserial_vars.inputBufFill;
    // ENABLE_INTERRUPTS();
-
-   return inputBufFill-1; // removing the command byte
-}
-
-uint8_t openserial_getInputBuffer(uint8_t* bufferToWrite, uint8_t maxNumBytes) {
-   uint8_t numBytesWritten;
+
+   return inputBufFill-1; // removing the command byte
+}
+
+uint8_t openserial_getInputBuffer(uint8_t* bufferToWrite, uint8_t maxNumBytes) {
+   uint8_t numBytesWritten = 0;
    // uint8_t inputBufFill;
    // INTERRUPT_DECLARATION();
 
@@ -229,10 +229,10 @@ uint8_t openserial_getInputBuffer(uint8_t* bufferToWrite, uint8_t maxNumBytes) {
    //    numBytesWritten = inputBufFill-1;
    //    memcpy(bufferToWrite,&(openserial_vars.inputBuf[1]),numBytesWritten);
    // }
-   
-   return numBytesWritten;
-}
-
+
+   return numBytesWritten;
+}
+
 void openserial_startInput(void) {
 //    INTERRUPT_DECLARATION();
 
@@ -263,8 +263,8 @@ void openserial_startInput(void) {
 //    uart_writeByte(openserial_vars.reqFrame[openserial_vars.reqFrameIdx]);
 // #endif
 //    ENABLE_INTERRUPTS();
-}
-
+}
+
 void openserial_startOutput(void) {
 //    //schedule a task to get new status in the output buffer
 //    uint8_t debugPrintCounter;
@@ -347,8 +347,8 @@ void openserial_startOutput(void) {
 //       openserial_stop();
 //    }
 //    ENABLE_INTERRUPTS();
-}
-
+}
+
 void openserial_stop(void) {
    // uint8_t inputBufFill;
    // uint8_t cmdByte;
@@ -405,16 +405,16 @@ void openserial_stop(void) {
    // openserial_vars.inputBufFill  = 0;
    // openserial_vars.busyReceiving = FALSE;
    // ENABLE_INTERRUPTS();
-}
-
-/**
-\brief Trigger this module to print status information, over serial.
-
-debugPrint_* functions are used by the openserial module to continuously print
-status information about several modules in the OpenWSN stack.
-
-\returns TRUE if this function printed something, FALSE otherwise.
-*/
+}
+
+/**
+\brief Trigger this module to print status information, over serial.
+
+debugPrint_* functions are used by the openserial module to continuously print
+status information about several modules in the OpenWSN stack.
+
+\returns TRUE if this function printed something, FALSE otherwise.
+*/
 bool debugPrint_outBufferIndexes(void) {
    // uint16_t temp_buffer[2];
    // INTERRUPT_DECLARATION();
@@ -423,72 +423,72 @@ bool debugPrint_outBufferIndexes(void) {
    // temp_buffer[1] = openserial_vars.outputBufIdxR;
    // ENABLE_INTERRUPTS();
    // openserial_printStatus(STATUS_OUTBUFFERINDEXES,(uint8_t*)temp_buffer,sizeof(temp_buffer));
-   return TRUE;
-}
-
-//=========================== private =========================================
-
-//===== hdlc (output)
-
-/**
-\brief Start an HDLC frame in the output buffer.
-*/
+   return TRUE;
+}
+
+//=========================== private =========================================
+
+//===== hdlc (output)
+
+/**
+\brief Start an HDLC frame in the output buffer.
+*/
 port_INLINE void outputHdlcOpen(void) {
    // // initialize the value of the CRC
    // openserial_vars.outputCrc                          = HDLC_CRCINIT;
-   
+
    // // write the opening HDLC flag
    // openserial_vars.outputBuf[openserial_vars.outputBufIdxW++]     = HDLC_FLAG;
-}
-/**
-\brief Add a byte to the outgoing HDLC frame being built.
-*/
-port_INLINE void outputHdlcWrite(uint8_t b) {
-   
+}
+/**
+\brief Add a byte to the outgoing HDLC frame being built.
+*/
+port_INLINE void outputHdlcWrite(uint8_t b) {
+
    // // iterate through CRC calculator
    // openserial_vars.outputCrc = crcIteration(openserial_vars.outputCrc,b);
-   
+
    // // add byte to buffer
    // if (b==HDLC_FLAG || b==HDLC_ESCAPE) {
    //    openserial_vars.outputBuf[openserial_vars.outputBufIdxW++]  = HDLC_ESCAPE;
    //    b                                               = b^HDLC_ESCAPE_MASK;
    // }
    // openserial_vars.outputBuf[openserial_vars.outputBufIdxW++]     = b;
-   
-}
-/**
-\brief Finalize the outgoing HDLC frame.
-*/
+
+}
+/**
+\brief Finalize the outgoing HDLC frame.
+*/
 port_INLINE void outputHdlcClose(void) {
    // uint16_t   finalCrc;
-    
+
    // // finalize the calculation of the CRC
    // finalCrc   = ~openserial_vars.outputCrc;
-   
+
    // // write the CRC value
    // outputHdlcWrite((finalCrc>>0)&0xff);
    // outputHdlcWrite((finalCrc>>8)&0xff);
-   
+
    // // write the closing HDLC flag
    // openserial_vars.outputBuf[openserial_vars.outputBufIdxW++]   = HDLC_FLAG;
-}
-
-//===== hdlc (input)
-
-/**
-\brief Start an HDLC frame in the input buffer.
-*/
+}
+
+//===== hdlc (input)
+
+/**
+\brief Start an HDLC frame in the input buffer.
+*/
 port_INLINE void inputHdlcOpen(void) {
    // // reset the input buffer index
    // openserial_vars.inputBufFill                       = 0;
-   
+
    // // initialize the value of the CRC
    // openserial_vars.inputCrc                           = HDLC_CRCINIT;
-}
-/**
-\brief Add a byte to the incoming HDLC frame.
-*/
-port_INLINE void inputHdlcWrite(uint8_t b) {
+}
+/**
+\brief Add a byte to the incoming HDLC frame.
+*/
+port_INLINE void inputHdlcWrite(uint8_t b) {
    // if (b==HDLC_ESCAPE) {
    //    openserial_vars.inputEscaping = TRUE;
    // } else {
@@ -496,37 +496,37 @@ port_INLINE void inputHdlcWrite(uint8_t b) {
    //       b                             = b^HDLC_ESCAPE_MASK;
    //       openserial_vars.inputEscaping = FALSE;
    //    }
-      
+
    //    // add byte to input buffer
    //    openserial_vars.inputBuf[openserial_vars.inputBufFill] = b;
    //    openserial_vars.inputBufFill++;
-      
+
    //    // iterate through CRC calculator
    //    openserial_vars.inputCrc = crcIteration(openserial_vars.inputCrc,b);
    // }
-}
-/**
-\brief Finalize the incoming HDLC frame.
-*/
+}
+/**
+\brief Finalize the incoming HDLC frame.
+*/
 port_INLINE void inputHdlcClose(void) {
-   
+
    // // verify the validity of the frame
    // if (openserial_vars.inputCrc==HDLC_CRCGOOD) {
    //    // the CRC is correct
-      
+
    //    // remove the CRC from the input buffer
    //    openserial_vars.inputBufFill    -= 2;
    // } else {
    //    // the CRC is incorrect
-      
+
    //    // drop the incoming fram
    //    openserial_vars.inputBufFill     = 0;
    // }
-}
-
-//=========================== interrupt handlers ==============================
-
-//executed in ISR, called from scheduler.c
+}
+
+//=========================== interrupt handlers ==============================
+
+//executed in ISR, called from scheduler.c
 void isr_openserial_tx(void) {
    // switch (openserial_vars.mode) {
    //    case MODE_INPUT:
@@ -547,9 +547,9 @@ void isr_openserial_tx(void) {
    //    default:
    //       break;
    // }
-}
-
-// executed in ISR, called from scheduler.c
+}
+
+// executed in ISR, called from scheduler.c
 void isr_openserial_rx(void) {
    // uint8_t rxbyte;
    // uint8_t inputBufFill;
@@ -570,13 +570,13 @@ void isr_openserial_rx(void) {
    //              rxbyte!=HDLC_FLAG
    //            ) {
    //    // start of frame
-      
+
    //    // I'm now receiving
    //    openserial_vars.busyReceiving         = TRUE;
-      
+
    //    // create the HDLC frame
    //    inputHdlcOpen();
-      
+
    //    // add the byte just received
    //    inputHdlcWrite(rxbyte);
    // } else if (
@@ -584,7 +584,7 @@ void isr_openserial_rx(void) {
    //              rxbyte!=HDLC_FLAG
    //           ) {
    //    // middle of frame
-      
+
    //    // add the byte just received
    //    inputHdlcWrite(rxbyte);
    //    if (openserial_vars.inputBufFill+1>SERIAL_INPUT_BUFFER_SIZE){
@@ -601,28 +601,28 @@ void isr_openserial_rx(void) {
    //              rxbyte==HDLC_FLAG
    //            ) {
    //       // end of frame
-         
+
    //       // finalize the HDLC frame
    //       inputHdlcClose();
-         
+
    //       if (openserial_vars.inputBufFill==0){
    //          // invalid HDLC frame
    //          openserial_printError(COMPONENT_OPENSERIAL,ERR_WRONG_CRC_INPUT,
    //                                (errorparameter_t)inputBufFill,
    //                                (errorparameter_t)0);
-         
+
    //       }
-         
+
    //       openserial_vars.busyReceiving      = FALSE;
    //       openserial_stop();
    // }
-   
+
    // openserial_vars.lastRxByte = rxbyte;
-}
-
-//======== SERIAL ECHO =============
-
-void openserial_echo(uint8_t* buf, uint8_t bufLen){
+}
+
+//======== SERIAL ECHO =============
+
+void openserial_echo(uint8_t* buf, uint8_t bufLen){
    // INTERRUPT_DECLARATION();
    // // echo back what you received
    // openserial_printData(
@@ -633,4 +633,4 @@ void openserial_echo(uint8_t* buf, uint8_t bufLen){
    //  DISABLE_INTERRUPTS();
    //  openserial_vars.inputBufFill = 0;
    //  ENABLE_INTERRUPTS();
-}
+}
diff --git a/drivers/common/opentimers.c b/drivers/common/opentimers.c
index 5c6ba4f..cd5c550 100644
--- a/drivers/common/opentimers.c
+++ b/drivers/common/opentimers.c
@@ -9,9 +9,12 @@ at most MAX_NUM_TIMERS timers.
 
 #include "opendefs.h"
 #include "opentimers.h"
-#include "bsp_timer.h"
+#include "board_ow.h"
 #include "leds.h"
 
+#include "riot.h"
+#include "periph/timer.h"
+
 //=========================== define ==========================================
 
 //=========================== variables =======================================
@@ -22,9 +25,19 @@ opentimers_vars_t opentimers_vars;
 //=========================== prototypes ======================================
 
 void opentimers_timer_callback(void);
+extern void radiotimer_isr(void);
 
 //=========================== public ==========================================
 
+void timers_isr(int channel) {
+   if (channel) {
+      radiotimer_isr();
+   }
+   else {
+      opentimers_timer_callback();
+   }
+}
+
 /**
 \brief Initialize this module.
 
@@ -45,7 +58,8 @@ void opentimers_init(void) {
    }
 
    // set callback for bsp_timers module
-   bsp_timer_set_callback(opentimers_timer_callback);
+   // bsp_timer_set_callback(opentimers_timer_callback);
+   timer_init(OWSN_TIMER, 1, &timers_isr);
 }
 
 /**
@@ -121,9 +135,13 @@ opentimer_id_t opentimers_start(uint32_t duration, timer_type_t type, time_type_
       ) {  
          opentimers_vars.currentTimeout            = opentimers_vars.timersBuf[id].ticks_remaining;
          if (opentimers_vars.running==FALSE) {
-            bsp_timer_reset();
+            // bsp_timer_reset();
+            timer_reset(OWSN_TIMER);
+            timer_set_absolute(OWSN_TIMER, 0, 0);
+            timer_set_absolute(OWSN_TIMER, 1, 0);
          }
-         bsp_timer_scheduleIn(opentimers_vars.timersBuf[id].ticks_remaining);
+         // bsp_timer_scheduleIn(opentimers_vars.timersBuf[id].ticks_remaining);
+         timer_set(OWSN_TIMER, 0, opentimers_vars.timersBuf[id].ticks_remaining);
       }
 
       opentimers_vars.running                         = TRUE;
@@ -274,7 +292,8 @@ void opentimers_timer_callback(void) {
    if (found==TRUE) {
       // at least one timer pending
       opentimers_vars.currentTimeout = min_timeout;
-      bsp_timer_scheduleIn(opentimers_vars.currentTimeout);
+      // bsp_timer_scheduleIn(opentimers_vars.currentTimeout);
+      timer_set(OWSN_TIMER, 0, opentimers_vars.currentTimeout);
    } else {
       // no more timers pending
       opentimers_vars.running = FALSE;
@@ -355,7 +374,8 @@ void opentimers_sleepTimeCompesation(uint16_t sleepTime)
    if (found==TRUE) {
       // at least one timer pending
       opentimers_vars.currentTimeout = min_timeout;
-      bsp_timer_scheduleIn(opentimers_vars.currentTimeout);
+      // bsp_timer_scheduleIn(opentimers_vars.currentTimeout);
+      timer_set(OWSN_TIMER, 0, opentimers_vars.currentTimeout);
    } else {
       // no more timers pending
       opentimers_vars.running = FALSE;
diff --git a/kernel/openos/scheduler.c b/kernel/openos/scheduler.c
index 367513c..a5589ff 100644
--- a/kernel/openos/scheduler.c
+++ b/kernel/openos/scheduler.c
@@ -10,6 +10,11 @@
 #include "debugpins.h"
 #include "leds.h"
 
+#include "thread.h"
+
+#define ENABLE_DEBUG (0)
+#include "debug.h"
+
 //=========================== variables =======================================
 
 scheduler_vars_t scheduler_vars;
@@ -18,14 +23,13 @@ scheduler_dbg_t  scheduler_dbg;
 //=========================== prototypes ======================================
 
 void consumeTask(uint8_t taskId);
-
-//=========================== public ==========================================
-
+
+//=========================== public ==========================================
+
 void scheduler_init(void) {
-   
-   // initialization module variables
-   memset(&scheduler_vars,0,sizeof(scheduler_vars_t));
-   memset(&scheduler_dbg,0,sizeof(scheduler_dbg_t));
+   // initialization module variables
+   memset(&scheduler_vars,0,sizeof(scheduler_vars_t));
+   memset(&scheduler_dbg,0,sizeof(scheduler_dbg_t));
    
    // enable the scheduler's interrupt so SW can wake up the scheduler
    SCHEDULER_ENABLE_INTERRUPT();
@@ -53,7 +57,8 @@ void scheduler_start(void) {
          scheduler_dbg.numTasksCur--;
       }
       debugpins_task_clr();
-      board_sleep();
+      // board_sleep();
+      thread_yield();
       debugpins_task_set();                      // IAR should halt here if nothing to do
    }
 }
@@ -63,6 +68,7 @@ void scheduler_start(void) {
    taskList_item_t** taskListWalker;
    INTERRUPT_DECLARATION();
    
+   DEBUG("owsn scheduler: push back task %p.\n", cb);
    DISABLE_INTERRUPTS();
    
    // find an empty task container
diff --git a/openapps/Makefile b/openapps/Makefile
index ab615ba..57aa5c8 100644
--- a/openapps/Makefile
+++ b/openapps/Makefile
@@ -2,7 +2,11 @@
 
 DIRS += $(CURDIR)/c6t \
         $(CURDIR)/uecho \
-        $(CURDIR)/techo
+        $(CURDIR)/techo \
+        $(CURDIR)/cinfo \
+        $(CURDIR)/cleds \
+        $(CURDIR)/cstorm \
+        $(CURDIR)/cwellknown
 
 INCLUDES += -I$(CURDIR)/c6t \
 			-I$(CURDIR)/techo \
diff --git a/openapps/cstorm/cstorm.c b/openapps/cstorm/cstorm.c
index ffcf106..c0cdcc3 100644
--- a/openapps/cstorm/cstorm.c
+++ b/openapps/cstorm/cstorm.c
@@ -196,7 +196,7 @@ void cstorm_task_cb(void) {
    
    // content-type option
    packetfunctions_reserveHeaderSize(pkt,2);
-   pkt->payload[0] = (COAP_OPTION_NUM_CONTENTFORMAT-COAP_OPTION_NUM_URIPATH) << 4 | sizeof(cstorm_payload)-1; 
+   pkt->payload[0] = (((COAP_OPTION_NUM_CONTENTFORMAT-COAP_OPTION_NUM_URIPATH) << 4) | (sizeof(cstorm_payload)-1));
    pkt->payload[1] = COAP_MEDTYPE_APPOCTETSTREAM;
    numOptions++;
    
diff --git a/openapps/uecho/uecho.c b/openapps/uecho/uecho.c
index 1141c51..d98f0fe 100644
--- a/openapps/uecho/uecho.c
+++ b/openapps/uecho/uecho.c
@@ -5,8 +5,13 @@
 #include "openserial.h"
 #include "packetfunctions.h"
 
-//=========================== variables =======================================
+#include "riot.h"
+
+#define ENABLE_DEBUG (0)
+#include "debug.h"
 
+//=========================== variables =======================================
+uint8_t expect_echo;
 //=========================== prototypes ======================================
 
 //=========================== public ==========================================
@@ -17,37 +22,43 @@ void uecho_init(void) {
 void uecho_receive(OpenQueueEntry_t* request) {
    uint16_t          temp_l4_destination_port;
    OpenQueueEntry_t* reply;
-   
-   reply = openqueue_getFreePacketBuffer(COMPONENT_UECHO);
-   if (reply==NULL) {
-      openserial_printError(
-         COMPONENT_UECHO,
-         ERR_NO_FREE_PACKET_BUFFER,
-         (errorparameter_t)0,
-         (errorparameter_t)0
-      );
-      return;
+
+   if (!expect_echo) {
+      reply = openqueue_getFreePacketBuffer(COMPONENT_UECHO);
+      if (reply==NULL) {
+         openserial_printError(
+            COMPONENT_UECHO,
+            ERR_NO_FREE_PACKET_BUFFER,
+            (errorparameter_t)0,
+            (errorparameter_t)0
+         );
+         return;
+      }
+
+      reply->owner                         = COMPONENT_UECHO;
+
+      // reply with the same OpenQueueEntry_t
+      reply->creator                       = COMPONENT_UECHO;
+      reply->l4_protocol                   = IANA_UDP;
+      temp_l4_destination_port           = request->l4_destination_port;
+      reply->l4_destination_port           = request->l4_sourcePortORicmpv6Type;
+      reply->l4_sourcePortORicmpv6Type     = temp_l4_destination_port;
+      reply->l3_destinationAdd.type        = ADDR_128B;
+
+      // copy source to destination to echo.
+      memcpy(&reply->l3_destinationAdd.addr_128b[0],&request->l3_sourceAdd.addr_128b[0],16);
+
+      packetfunctions_reserveHeaderSize(reply,request->length);
+      memcpy(&reply->payload[0],&request->payload[0],request->length);
+      openqueue_freePacketBuffer(request);
+
+      if ((openudp_send(reply))==E_FAIL) {
+         openqueue_freePacketBuffer(reply);
+      }
    }
-   
-   reply->owner                         = COMPONENT_UECHO;
-   
-   // reply with the same OpenQueueEntry_t
-   reply->creator                       = COMPONENT_UECHO;
-   reply->l4_protocol                   = IANA_UDP;
-   temp_l4_destination_port           = request->l4_destination_port;
-   reply->l4_destination_port           = request->l4_sourcePortORicmpv6Type;
-   reply->l4_sourcePortORicmpv6Type     = temp_l4_destination_port;
-   reply->l3_destinationAdd.type        = ADDR_128B;
-   
-   // copy source to destination to echo.
-   memcpy(&reply->l3_destinationAdd.addr_128b[0],&request->l3_sourceAdd.addr_128b[0],16);
-   
-   packetfunctions_reserveHeaderSize(reply,request->length);
-   memcpy(&reply->payload[0],&request->payload[0],request->length);
-   openqueue_freePacketBuffer(request);
-   
-   if ((openudp_send(reply))==E_FAIL) {
-      openqueue_freePacketBuffer(reply);
+   else {
+      openqueue_freePacketBuffer(request);
+      expect_echo = FALSE;
    }
 }
 
@@ -59,4 +70,29 @@ bool uecho_debugPrint(void) {
    return FALSE;
 }
 
+void uecho_send(uint8_t *dest_addr)
+{
+   OpenQueueEntry_t *request;
+   request = openqueue_getFreePacketBuffer(COMPONENT_UECHO);
+
+   if (request==NULL) {
+      DEBUG("UECHO: ERROR, no free packet.\n");
+      return;
+   }
+
+   request->owner = COMPONENT_UECHO;
+   request->creator = COMPONENT_UECHO;
+   request->l4_protocol = IANA_UDP;
+   request->l4_destination_port = UDP_PORTS_16b_SRC_16b_DEST_INLINE;
+   request->l4_sourcePortORicmpv6Type = UDP_PORTS_16b_SRC_16b_DEST_INLINE;
+   request->l3_destinationAdd.type = ADDR_128B;
+   memcpy(&(request->l3_destinationAdd.addr_128b[0]), dest_addr, 16);
+
+   packetfunctions_reserveHeaderSize(request, 13);
+   expect_echo = TRUE;
+   if ((openudp_send(request))==E_FAIL) {
+      openqueue_freePacketBuffer(request);
+   }
+}
+
 //=========================== private =========================================
\ No newline at end of file
diff --git a/openstack/02a-MAClow/IEEE802154E.c b/openstack/02a-MAClow/IEEE802154E.c
index 461a8bd..c0038a7 100644
--- a/openstack/02a-MAClow/IEEE802154E.c
+++ b/openstack/02a-MAClow/IEEE802154E.c
@@ -16,6 +16,9 @@
 #include "adaptive_sync.h"
 #include "processIE.h"
 
+#define ENABLE_DEBUG (0)
+#include "debug.h"
+
 //=========================== variables =======================================
 
 ieee154e_vars_t    ieee154e_vars;
@@ -1849,9 +1852,11 @@ void changeIsSync(bool newIsSync) {
    ieee154e_vars.isSync = newIsSync;
    
    if (ieee154e_vars.isSync==TRUE) {
+      DEBUG("Synced.\n");
       leds_sync_on();
       resetStats();
    } else {
+      DEBUG("Unsynced.\n");
       leds_sync_off();
       schedule_resetBackoff();
    }
diff --git a/openstack/02a-MAClow/IEEE802154E.h b/openstack/02a-MAClow/IEEE802154E.h
index fd3fe17..ef34b71 100644
--- a/openstack/02a-MAClow/IEEE802154E.h
+++ b/openstack/02a-MAClow/IEEE802154E.h
@@ -127,10 +127,10 @@ typedef enum {
 //    - duration_in_seconds = ticks / 32768
 enum ieee154e_atomicdurations_enum {
    // time-slot related
-   TsTxOffset                =  131,                  //  4000us
-   TsLongGT                  =   43,                  //  1300us
-   TsTxAckDelay              =  151,                  //  4606us
-   TsShortGT                 =   16,                  //   500us
+   TsTxOffset                =  4000,                  //  4000us
+   TsLongGT                  =  1300,                  //  1300us
+   TsTxAckDelay              =  4606,                  //  4606us
+   TsShortGT                 =   500,                  //   500us
    TsSlotDuration            =  PORT_TsSlotDuration,  // 15000us
    // execution speed related
    maxTxDataPrepare          =  PORT_maxTxDataPrepare,
@@ -141,9 +141,9 @@ enum ieee154e_atomicdurations_enum {
    delayTx                   =  PORT_delayTx,         // between GO signal and SFD
    delayRx                   =  PORT_delayRx,         // between GO signal and start listening
    // radio watchdog
-   wdRadioTx                 =   33,                  //  1000us (needs to be >delayTx)
-   wdDataDuration            =  164,                  //  5000us (measured 4280us with max payload)
-   wdAckDuration             =   98,                  //  3000us (measured 1000us)
+   wdRadioTx                 =   1000,                  //  1000us (needs to be >delayTx)
+   wdDataDuration            =  5000,                  //  5000us (measured 4280us with max payload)
+   wdAckDuration             =   3000,                  //  3000us (measured 1000us)
 };
 
 //shift of bytes in the linkOption bitmap
diff --git a/openstack/02b-MAChigh/schedule.c b/openstack/02b-MAChigh/schedule.c
index fafb6f6..933534f 100644
--- a/openstack/02b-MAChigh/schedule.c
+++ b/openstack/02b-MAChigh/schedule.c
@@ -52,21 +52,21 @@ void schedule_init(void) {
       );
       running_slotOffset++;
    } 
-   
-   // shared TXRX anycast slot(s)
-   memset(&temp_neighbor,0,sizeof(temp_neighbor));
-   temp_neighbor.type             = ADDR_ANYCAST;
-   for (i=0;i<NUMSHAREDTXRX;i++) {
-      schedule_addActiveSlot(
-         running_slotOffset,      // slot offset
-         CELLTYPE_TXRX,           // type of slot
-         TRUE,                    // shared?
-         0,                       // channel offset
-         &temp_neighbor           // neighbor
-      );
-      running_slotOffset++;
-   }
-   
+
+   // // shared TXRX anycast slot(s)
+   // memset(&temp_neighbor,0,sizeof(temp_neighbor));
+   // temp_neighbor.type             = ADDR_ANYCAST;
+   // for (i=0;i<NUMSHAREDTXRX;i++) {
+   //    schedule_addActiveSlot(
+   //       running_slotOffset,      // slot offset
+   //       CELLTYPE_TXRX,           // type of slot
+   //       TRUE,                    // shared?
+   //       0,                       // channel offset
+   //       &temp_neighbor           // neighbor
+   //    );
+   //    running_slotOffset++;
+   // }
+
    // serial RX slot(s)
    memset(&temp_neighbor,0,sizeof(temp_neighbor));
    schedule_addActiveSlot(
diff --git a/openstack/Makefile b/openstack/Makefile
index 33de77f..5dfd42f 100644
--- a/openstack/Makefile
+++ b/openstack/Makefile
@@ -15,4 +15,6 @@ INCLUDES += -I$(CURDIR)/../drivers/common \
 			-I$(CURDIR)/04-TRAN \
 			-I$(CURDIR)/cross-layers
 
+# CFLAGS += -DDAGROOT
+
 include $(RIOTBASE)/Makefile.base
diff --git a/openstack/cross-layers/idmanager.c b/openstack/cross-layers/idmanager.c
index a6f5e2c..1b21536 100644
--- a/openstack/cross-layers/idmanager.c
+++ b/openstack/cross-layers/idmanager.c
@@ -9,24 +9,25 @@
 
 idmanager_vars_t idmanager_vars;
 
-//=========================== prototypes ======================================
-
-//=========================== public ==========================================
-
-void idmanager_init(void) {
-   
-   // reset local variables
-   memset(&idmanager_vars, 0, sizeof(idmanager_vars_t));
-   
-   // isDAGroot
-#ifdef DAGROOT
-   idmanager_vars.isDAGroot            = TRUE;
-#else
-   idmanager_vars.isDAGroot            = FALSE;
-#endif
-   
-   // myPANID
-   idmanager_vars.myPANID.type         = ADDR_PANID;
+//=========================== prototypes ======================================
+
+//=========================== public ==========================================
+// #define DAGROOT
+void idmanager_init(uint8_t role) {
+
+   // reset local variables
+   memset(&idmanager_vars, 0, sizeof(idmanager_vars_t));
+
+   // isDAGroot
+// #ifdef DAGROOT
+//    idmanager_vars.isDAGroot            = TRUE;
+// #else
+//    idmanager_vars.isDAGroot            = FALSE;
+// #endif
+   idmanager_vars.isDAGroot            = role;
+
+   // myPANID
+   idmanager_vars.myPANID.type         = ADDR_PANID;
    idmanager_vars.myPANID.panid[0]     = 0xca;
    idmanager_vars.myPANID.panid[1]     = 0xfe;
    
diff --git a/openstack/cross-layers/idmanager.h b/openstack/cross-layers/idmanager.h
index 26bfc04..a99d8c2 100644
--- a/openstack/cross-layers/idmanager.h
+++ b/openstack/cross-layers/idmanager.h
@@ -42,7 +42,7 @@ typedef struct {
 
 //=========================== prototypes ======================================
 
-void         idmanager_init(void);
+void         idmanager_init(uint8_t role);
 bool         idmanager_getIsDAGroot(void);
 void         idmanager_setIsDAGroot(bool newRole);
 open_addr_t* idmanager_getMyID(uint8_t type);
diff --git a/openstack/openstack.c b/openstack/openstack.c
index cc72deb..3e87a76 100644
--- a/openstack/openstack.c
+++ b/openstack/openstack.c
@@ -36,6 +36,9 @@
 //===== applications
 #include "openapps.h"
 
+#define ENABLE_DEBUG (0)
+#include "debug.h"
+
 //=========================== variables =======================================
 
 //=========================== prototypes ======================================
@@ -44,14 +47,15 @@
 
 //=========================== private =========================================
 
-void openstack_init(void) {
+void openstack_init(uint8_t role) {
+   DEBUG("%s\n",__PRETTY_FUNCTION__);
    
    //===== drivers
    openserial_init();
    
    //===== stack
    //-- cross-layer
-   idmanager_init();    // call first since initializes EUI64 and isDAGroot
+   idmanager_init(role);    // call first since initializes EUI64 and isDAGroot
    openqueue_init();
    openrandom_init();
    opentimers_init();
diff --git a/openstack/openstack.h b/openstack/openstack.h
index 55042df..bde13b7 100644
--- a/openstack/openstack.h
+++ b/openstack/openstack.h
@@ -17,6 +17,6 @@
 
 //=========================== prototypes ======================================
 
-void openstack_init(void);
+void openstack_init(uint8_t role);
 
 #endif
diff --git a/projects/common/03oos_openwsn/03oos_openwsn.c b/projects/common/03oos_openwsn/03oos_openwsn.c
index 3f4b36e..70f1750 100644
--- a/projects/common/03oos_openwsn/03oos_openwsn.c
+++ b/projects/common/03oos_openwsn/03oos_openwsn.c
@@ -1,57 +1,67 @@
 /**
-\brief This project runs the full OpenWSN stack.
-
-\author Thomas Watteyne <watteyne@eecs.berkeley.edu>, August 2010
-*/
-
+\brief This project runs the full OpenWSN stack.
+
+\author Thomas Watteyne <watteyne@eecs.berkeley.edu>, August 2010
+\author Thomas Eichinger <thomas.eichinger@fu-berlin.de>, December 2014
+*/
+
 #include "thread.h"
 
 #include "board_ow.h"
 #include "leds.h"
-#include "scheduler.h"
-#include "openstack.h"
-#include "opendefs.h"
-
+#include "scheduler.h"
+#include "openstack.h"
+#include "opendefs.h"
+#include "idmanager.h"
+
 #include "03oos_openwsn.h"
 
+#include "riot.h"
+
 #define ENABLE_DEBUG (0)
 #include "debug.h"
 
-static char openwsn_stack[THREAD_STACKSIZE_MAIN];
-int openwsn_pid = -1;
+static char openwsn_stack[THREAD_STACKSIZE_MAIN*2];
+kernel_pid_t openwsn_pid = -1;
+uint8_t owsn_mop;
 
 void openwsn_init(void);
 void* openwsn_start(void *arg);
 
-void openwsn_start_thread(void) {
+void openwsn_start_thread(int argc, char **argv) {
     DEBUG("%s\n",__PRETTY_FUNCTION__);
-    openwsn_pid = thread_create(openwsn_stack, THREAD_STACKSIZE_MAIN,
-                                PRIORITY_OPENWSN-2, CREATE_STACKTEST,
-                                openwsn_start, NULL, "openwsn thread");
+    if (argc < 2) {
+        printf("usage: %s (r|n)\n", argv[0]);
+        puts("\tr\tinitialise as DAGROOT.");
+        puts("\tn\tinitialise as node.");
+        return;
+    }
+
+    char command = argv[1][0];
+    if (command == 'r') {
+        printf("Starting OpenWSN as root ... ");
+        owsn_mop = 1;
+        openwsn_pid = thread_create(openwsn_stack, THREAD_STACKSIZE_MAIN,
+                                    PRIORITY_OPENWSN, CREATE_STACKTEST,
+                                    openwsn_start, (void*)&owsn_mop, "openwsn thread");
+    }
+    else {
+        printf("Starting OpenWSN as node ... ");
+        owsn_mop = 0;
+        openwsn_pid = thread_create(openwsn_stack, THREAD_STACKSIZE_MAIN,
+                                    PRIORITY_OPENWSN, CREATE_STACKTEST,
+                                    openwsn_start, (void*)&owsn_mop, "openwsn thread");
+    }
 }
 
 void* openwsn_start(void *arg) {
     DEBUG("%s\n",__PRETTY_FUNCTION__);
-    (void)arg;
     leds_all_off();
     board_init_ow();
     scheduler_init();
-    openstack_init();
-    puts("OpenWSN thread started.");
+    openstack_init(*((uint8_t*)arg));
+    puts("DONE");
     scheduler_start();
     return NULL;
 }
 
-int mote_main(void) {
-   
-   // initialize
-   board_init();
-   scheduler_init();
-   openstack_init();
-   
-   // indicate
-   
-   // start
-   scheduler_start();
-   return 0; // this line should never be reached
-}
diff --git a/projects/common/03oos_openwsn/03oos_openwsn.h b/projects/common/03oos_openwsn/03oos_openwsn.h
index 5a9f1fa..8125096 100644
--- a/projects/common/03oos_openwsn/03oos_openwsn.h
+++ b/projects/common/03oos_openwsn/03oos_openwsn.h
@@ -4,10 +4,10 @@
 \author Thomas Watteyne <watteyne@eecs.berkeley.edu>, August 2010
 */
 
-#ifndef __openwsn_H
-#define __openwsn_H
-
-void openwsn_start_thread(void);
+#ifndef __openwsn_H
+#define __openwsn_H
+
+void openwsn_start_thread(int argc, char **argv);
 
 //=========================== define ==========================================
 
diff --git a/projects/common/03oos_openwsn/Makefile b/projects/common/03oos_openwsn/Makefile
index 47289c6..5ebc02a 100644
--- a/projects/common/03oos_openwsn/Makefile
+++ b/projects/common/03oos_openwsn/Makefile
@@ -1,3 +1,5 @@
 #MODULE = openwsn
 
+INCLUDES += -I$(OPENWSN_ROOT)/openstack/cross-layers
+
 include $(RIOTBASE)/Makefile.base
-- 
2.2.0

