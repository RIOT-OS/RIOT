/*	Copyright (C) 2005 Garrett A. Kajmowicz

	This file is part of the uClibc++ Library.
	This library is free software; you can redistribute it and/or
	modify it under the terms of the GNU Lesser General Public
	License as published by the Free Software Foundation; either
	version 2.1 of the License, or (at your option) any later version.

	This library is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
	Lesser General Public License for more details.

	You should have received a copy of the GNU Lesser General Public
	License along with this library; if not, write to the Free Software
	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
*/

#include <basic_definitions>
#include <exception>
#include <memory>
#include <char_traits>

#ifndef __HEADER_TYPE_TRAITS
#define __HEADER_TYPE_TRAITS 1

#pragma GCC visibility push(default)

namespace std {

	struct _UCXXEXPORT __true_type{};
	struct _UCXXEXPORT __false_type{};

	template <class I> class _UCXXEXPORT __is_integer{
	public:
		typedef __false_type value;
	};

	template <> class _UCXXEXPORT __is_integer <unsigned int>{
	public:
		typedef __true_type value;
	};

	template <> class _UCXXEXPORT __is_integer <signed int>{
	public:
		typedef __true_type value;
	};

	template <> class _UCXXEXPORT __is_integer <short unsigned int>{
	public:
		typedef __true_type value;
	};

	template <> class _UCXXEXPORT __is_integer <short signed int>{
	public:
		typedef __true_type value;
	};

	template <> class _UCXXEXPORT __is_integer <char>{
	public:
		typedef __true_type value;
	};

	template <> class _UCXXEXPORT __is_integer <signed char>{
	public:
		typedef __true_type value;
	};

	template <> class _UCXXEXPORT __is_integer <unsigned char>{
	public:
		typedef __true_type value;
	};

	template <> class _UCXXEXPORT __is_integer <long unsigned int>{
	public:
		typedef __true_type value;
	};

	template <> class _UCXXEXPORT __is_integer <long signed int>{
	public:
		typedef __true_type value;
	};


	/* std::conditional<> */
	template <bool _Bp, class _If, class _Then>
	struct _UCXXEXPORT conditional { typedef _If type; };

	template <class _If, class _Then>
	struct _UCXXEXPORT conditional<false, _If, _Then> { typedef _Then type; };

	template <bool _Bp, class _If, class _Then> using conditional_t = typename conditional<_Bp, _If, _Then>::type;


	/* integral_constant */
	template<typename _Tp, _Tp __v>
	struct integral_constant {
		static constexpr _Tp value = __v;
		typedef _Tp value_type;
		typedef integral_constant<_Tp, __v> type;
		constexpr operator value_type() const {
			return value;
		}
#if __cplusplus > 201103L
#define __cpp_lib_integral_constant_callable 201304
		constexpr value_type operator()() const {
			return value;
		}
#endif
	};

	template<typename _Tp, _Tp __v>
	constexpr _Tp integral_constant<_Tp, __v>::value;

	/// The type used as a compile-time boolean with true value.
	typedef integral_constant<bool, true> true_type;

	/// The type used as a compile-time boolean with false value.
	typedef integral_constant<bool, false> false_type;

	template<bool __v>
	using __bool_constant = integral_constant<bool, __v>;

#if __cplusplus > 201402L
#define __cpp_lib_bool_constant 201505
	template<bool __v>
	using bool_constant = integral_constant<bool, __v>;
#endif


	/* std::is_same */
	template<typename, typename >
	struct is_same: public false_type {
	};

	template<typename _Tp>
	struct is_same<_Tp, _Tp> : public true_type {
	};


	/* std::enable_if */
	template<bool, typename _Tp = void>
	struct enable_if {
	};

	// Partial specialization for true.
	template<typename _Tp>
	struct enable_if<true, _Tp> {
		typedef _Tp type;
	};


	// remove_const
	template <class _Tp> struct remove_const            { typedef _Tp type; };
	template <class _Tp> struct remove_const<const _Tp> { typedef _Tp type; };
	template <class _Tp> using remove_const_t = typename remove_const<_Tp>::type;

	// remove_volatile
	template <class _Tp> struct remove_volatile               { typedef _Tp type; };
	template <class _Tp> struct remove_volatile<volatile _Tp> { typedef _Tp type; };
	template <class _Tp> using remove_volatile_t = typename remove_volatile<_Tp>::type;

	// remove_cv
	template <class _Tp> struct remove_cv { typedef typename remove_volatile<typename remove_const<_Tp>::type>::type type;	};
	template <class _Tp> using remove_cv_t = typename remove_cv<_Tp>::type;

	// remove_reference
	template <class _Tp> struct remove_reference        {typedef _Tp type;};
	template <class _Tp> struct remove_reference<_Tp&>  {typedef _Tp type;};
	template <class _Tp> struct remove_reference<_Tp&&> {typedef _Tp type;};
	template <class _Tp> using remove_reference_t = typename remove_reference<_Tp>::type;

	// is_integral
	template <class _Tp> struct __libcpp_is_integral                     : public false_type {};
	template <>          struct __libcpp_is_integral<bool>               : public true_type {};
	template <>          struct __libcpp_is_integral<char>               : public true_type {};
	template <>          struct __libcpp_is_integral<signed char>        : public true_type {};
	template <>          struct __libcpp_is_integral<unsigned char>      : public true_type {};
	template <>          struct __libcpp_is_integral<wchar_t>            : public true_type {};
	template <>          struct __libcpp_is_integral<short>              : public true_type {};
	template <>          struct __libcpp_is_integral<unsigned short>     : public true_type {};
	template <>          struct __libcpp_is_integral<int>                : public true_type {};
	template <>          struct __libcpp_is_integral<unsigned int>       : public true_type {};
	template <>          struct __libcpp_is_integral<long>               : public true_type {};
	template <>          struct __libcpp_is_integral<unsigned long>      : public true_type {};
	template <>          struct __libcpp_is_integral<long long>          : public true_type {};
	template <>          struct __libcpp_is_integral<unsigned long long> : public true_type {};

	template <class _Tp> struct is_integral
	    : public __libcpp_is_integral<typename remove_cv<_Tp>::type> {};

	// is_floating_point
	template <class _Tp> struct __libcpp_is_floating_point              : public false_type {};
	template <>          struct __libcpp_is_floating_point<float>       : public true_type {};
	template <>          struct __libcpp_is_floating_point<double>      : public true_type {};
	template <>          struct __libcpp_is_floating_point<long double> : public true_type {};

	template <class _Tp> struct is_floating_point
	    : public __libcpp_is_floating_point<typename remove_cv<_Tp>::type> {};


	// is_arithmetic
	template <class _Tp> struct is_arithmetic
	    : public integral_constant<bool, is_integral<_Tp>::value || is_floating_point<_Tp>::value> {};

	// is_signed
	template <class _Tp, bool = is_integral<_Tp>::value>
	struct __libcpp_is_signed_impl : public integral_constant<bool, _Tp(-1) < _Tp(0)> {};

	template <class _Tp>
	struct __libcpp_is_signed_impl<_Tp, false> : public true_type {}; // floating point

	template <class _Tp, bool = is_arithmetic<_Tp>::value>
	struct __libcpp_is_signed : public __libcpp_is_signed_impl<_Tp> {};

	template <class _Tp> struct __libcpp_is_signed<_Tp, false> : public false_type {};

	template <class _Tp> struct is_signed : public __libcpp_is_signed<_Tp> {};

	// is_unsigned
	template <class _Tp, bool = is_integral<_Tp>::value>
	struct __libcpp_is_unsigned_impl : public integral_constant<bool, _Tp(0) < _Tp(-1)> {};

	template <class _Tp>
	struct __libcpp_is_unsigned_impl<_Tp, false> : public false_type {}; // floating point

	template <class _Tp, bool = is_arithmetic<_Tp>::value>
	struct __libcpp_is_unsigned : public __libcpp_is_unsigned_impl<_Tp> {};

	template <class _Tp> struct __libcpp_is_unsigned<_Tp, false> : public false_type {};

	template <class _Tp> struct is_unsigned : public __libcpp_is_unsigned<_Tp> {};

	// is_reference

	template <class _Tp> struct is_lvalue_reference       : public false_type {};
	template <class _Tp> struct is_lvalue_reference<_Tp&> : public true_type {};

	template <class _Tp> struct is_rvalue_reference        : public false_type {};
	template <class _Tp> struct is_rvalue_reference<_Tp&&> : public true_type {};

	template <class _Tp> struct is_reference        : public false_type {};
	template <class _Tp> struct is_reference<_Tp&>  : public true_type {};
	template <class _Tp> struct is_reference<_Tp&&> : public true_type {};

	// move
	template <class _Tp>
	inline constexpr typename remove_reference<_Tp>::type&& move(_Tp&& __t) noexcept {
		typedef typename remove_reference<_Tp>::type _Up;
		return static_cast<_Up&&>(__t);
	}

	template <class _Tp>
	inline constexpr _Tp&& forward(typename remove_reference<_Tp>::type& __t) noexcept {
		return static_cast<_Tp&&>(__t);
	}

	template <class _Tp>
	inline constexpr _Tp&& forward(typename remove_reference<_Tp>::type&& __t) noexcept {
		static_assert(!is_lvalue_reference<_Tp>::value, "can not forward an rvalue as an lvalue");
		return static_cast<_Tp&&>(__t);
	}
} /* namespace std */

#pragma GCC visibility pop

#endif // __HEADER_TYPE_TRAITS

