/*
 * Copyright (c) 2020 Raspberry Pi (Trading) Ltd. 
 * 
 * SPDX-License-Identifier: BSD-3-Clause
 *
 * @file     /home/fabian/rp2040//RP2040.h
 * @brief    CMSIS HeaderFile
 * @version  0.1
 * @date     01. June 2021
 * @note     Generated by SVDConv V3.3.35 on Tuesday, 01.06.2021 16:07:25
 *           from File '/usr/lib/python3.9/site-packages/cmsis_svd/data/RaspberryPi/rp2040.svd',
 */



/** @addtogroup Raspberry Pi
  * @{
  */


/** @addtogroup RP2040
  * @{
  */


#ifndef RP2040_H
#define RP2040_H

#ifdef __cplusplus
extern "C" {
#endif


/** @addtogroup Configuration_of_CMSIS
  * @{
  */



/* =========================================================================================================================== */
/* ================                                Interrupt Number Definition                                ================ */
/* =========================================================================================================================== */

typedef enum {
/* =======================================  ARM Cortex-M0+ Specific Interrupt Numbers  ======================================= */
  Reset_IRQn                = -15,              /*!< -15  Reset Vector, invoked on Power up and warm reset                     */
  NonMaskableInt_IRQn       = -14,              /*!< -14  Non maskable Interrupt, cannot be stopped or preempted               */
  HardFault_IRQn            = -13,              /*!< -13  Hard Fault, all classes of Fault                                     */
  SVCall_IRQn               =  -5,              /*!< -5 System Service Call via SVC instruction                                */
  PendSV_IRQn               =  -2,              /*!< -2 Pendable request for system service                                    */
  SysTick_IRQn              =  -1,              /*!< -1 System Tick Timer                                                      */
/* ===========================================  RP2040 Specific Interrupt Numbers  =========================================== */
  TIMER_IRQ_0_IRQn          =   0,              /*!< 0  TIMER_IRQ_0                                                            */
  TIMER_IRQ_1_IRQn          =   1,              /*!< 1  TIMER_IRQ_1                                                            */
  TIMER_IRQ_2_IRQn          =   2,              /*!< 2  TIMER_IRQ_2                                                            */
  TIMER_IRQ_3_IRQn          =   3,              /*!< 3  TIMER_IRQ_3                                                            */
  PWM_IRQ_WRAP_IRQn         =   4,              /*!< 4  PWM_IRQ_WRAP                                                           */
  USBCTRL_IRQ_IRQn          =   5,              /*!< 5  USBCTRL_IRQ                                                            */
  XIP_IRQ_IRQn              =   6,              /*!< 6  XIP_IRQ                                                                */
  PIO0_IRQ_0_IRQn           =   7,              /*!< 7  PIO0_IRQ_0                                                             */
  PIO0_IRQ_1_IRQn           =   8,              /*!< 8  PIO0_IRQ_1                                                             */
  PIO1_IRQ_0_IRQn           =   9,              /*!< 9  PIO1_IRQ_0                                                             */
  PIO1_IRQ_1_IRQn           =  10,              /*!< 10 PIO1_IRQ_1                                                             */
  DMA_IRQ_0_IRQn            =  11,              /*!< 11 DMA_IRQ_0                                                              */
  DMA_IRQ_1_IRQn            =  12,              /*!< 12 DMA_IRQ_1                                                              */
  IO_IRQ_BANK0_IRQn         =  13,              /*!< 13 IO_IRQ_BANK0                                                           */
  IO_IRQ_QSPI_IRQn          =  14,              /*!< 14 IO_IRQ_QSPI                                                            */
  SIO_IRQ_PROC0_IRQn        =  15,              /*!< 15 SIO_IRQ_PROC0                                                          */
  SIO_IRQ_PROC1_IRQn        =  16,              /*!< 16 SIO_IRQ_PROC1                                                          */
  CLOCKS_IRQ_IRQn           =  17,              /*!< 17 CLOCKS_IRQ                                                             */
  SPI0_IRQ_IRQn             =  18,              /*!< 18 SPI0_IRQ                                                               */
  SPI1_IRQ_IRQn             =  19,              /*!< 19 SPI1_IRQ                                                               */
  UART0_IRQ_IRQn            =  20,              /*!< 20 UART0_IRQ                                                              */
  UART1_IRQ_IRQn            =  21,              /*!< 21 UART1_IRQ                                                              */
  ADC_IRQ_FIFO_IRQn         =  22,              /*!< 22 ADC_IRQ_FIFO                                                           */
  I2C0_IRQ_IRQn             =  23,              /*!< 23 I2C0_IRQ                                                               */
  I2C1_IRQ_IRQn             =  24,              /*!< 24 I2C1_IRQ                                                               */
  RTC_IRQ_IRQn              =  25               /*!< 25 RTC_IRQ                                                                */
} IRQn_Type;



/* =========================================================================================================================== */
/* ================                           Processor and Core Peripheral Section                           ================ */
/* =========================================================================================================================== */

/* ==========================  Configuration of the ARM Cortex-M0+ Processor and Core Peripherals  =========================== */
#define __CM0PLUS_REV                 0x0001U   /*!< CM0PLUS Core Revision                                                     */
#define __NVIC_PRIO_BITS               2        /*!< Number of Bits used for Priority Levels                                   */
#define __Vendor_SysTickConfig         0        /*!< Set to 1 if different SysTick Config is used                              */
#define __VTOR_PRESENT                 1        /*!< Set to 1 if CPU supports Vector Table Offset Register                     */
#define __MPU_PRESENT                  1        /*!< MPU present                                                               */
#define __FPU_PRESENT                  0        /*!< FPU present                                                               */


/** @} */ /* End of group Configuration_of_CMSIS */

#include "core_cm0plus.h"                       /*!< ARM Cortex-M0+ processor and core peripherals                             */
#include "system_RP2040.h"                      /*!< RP2040 System                                                             */

#ifndef __IM                                    /*!< Fallback for older CMSIS versions                                         */
  #define __IM   __I
#endif
#ifndef __OM                                    /*!< Fallback for older CMSIS versions                                         */
  #define __OM   __O
#endif
#ifndef __IOM                                   /*!< Fallback for older CMSIS versions                                         */
  #define __IOM  __IO
#endif


/* =========================================================================================================================== */
/* ================                            Device Specific Peripheral Section                             ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripherals
  * @{
  */



/* =========================================================================================================================== */
/* ================                                         XIP_CTRL                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief QSPI flash execute-in-place block (XIP_CTRL)
  */

typedef struct {                                /*!< (@ 0x14000000) XIP_CTRL Structure                                         */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000000) Cache control                                              */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] When 1, enable the cache. When the cache is disabled,
                                                     all XIP accesses
                                                     will go straight to the flash, without querying the cache.
                                                     When enabled,
                                                     cacheable XIP accesses will query the cache, and the flash
                                                     will
                                                     not be accessed if the tag matches and the valid bit is
                                                     set.
                                                     
                                                     If the cache is enabled, cache-as-SRAM accesses have no
                                                     effect on the
                                                     cache data RAM, and will produce a bus error response.                    */
      __IOM uint32_t ERR_BADWRITE : 1;          /*!< [1..1] When 1, writes to any alias other than 0x0 (caching,
                                                     allocating)
                                                     will produce a bus fault. When 0, these writes are silently
                                                     ignored.
                                                     In either case, writes to the 0x0 alias will deallocate
                                                     on tag match,
                                                     as usual.                                                                 */
            uint32_t            : 1;
      __IOM uint32_t POWER_DOWN : 1;            /*!< [3..3] When 1, the cache memories are powered down. They retain
                                                     state,
                                                     but can not be accessed. This reduces static power dissipation.
                                                     Writing 1 to this bit forces CTRL_EN to 0, i.e. the cache
                                                     cannot
                                                     be enabled when powered down.
                                                     Cache-as-SRAM accesses will produce a bus error response
                                                     when
                                                     the cache is powered down.                                                */
            uint32_t            : 28;
    } bit;
  } CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000004) Cache Flush control                                        */
    
    struct {
      __IOM uint32_t FLUSH      : 1;            /*!< [0..0] Write 1 to flush the cache. This clears the tag memory,
                                                     but
                                                     the data memory retains its contents. (This means cache-as-SRAM
                                                     contents is not affected by flush or reset.)
                                                     Reading will hold the bus (stall the processor) until the
                                                     flush
                                                     completes. Alternatively STAT can be polled until completion.             */
            uint32_t            : 31;
    } bit;
  } FLUSH;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000008) Cache Status                                               */
    
    struct {
      __IM  uint32_t FLUSH_READY : 1;           /*!< [0..0] Reads as 0 while a cache flush is in progress, and 1
                                                     otherwise.
                                                     The cache is flushed whenever the XIP block is reset, and
                                                     also
                                                     when requested via the FLUSH register.                                    */
      __IM  uint32_t FIFO_EMPTY : 1;            /*!< [1..1] When 1, indicates the XIP streaming FIFO is completely
                                                     empty.                                                                    */
      __IM  uint32_t FIFO_FULL  : 1;            /*!< [2..2] When 1, indicates the XIP streaming FIFO is completely
                                                     full.
                                                     The streaming FIFO is 2 entries deep, so the full and empty
                                                     flag allow its level to be ascertained.                                   */
            uint32_t            : 29;
    } bit;
  } STAT;
  __IOM uint32_t  CTR_HIT;                      /*!< (@ 0x0000000C) Cache Hit counter
                                                                    A 32 bit saturating counter that increments
                                                                    upon each cache hit,
                                                                    i.e. when an XIP access is serviced directly
                                                                    from cached data.
                                                                    Write any value to clear.                                  */
  __IOM uint32_t  CTR_ACC;                      /*!< (@ 0x00000010) Cache Access counter
                                                                    A 32 bit saturating counter that increments
                                                                    upon each XIP access,
                                                                    whether the cache is hit or not. This includes
                                                                    noncacheable accesses.
                                                                    Write any value to clear.                                  */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000014) FIFO stream address                                        */
    
    struct {
            uint32_t            : 2;
      __IOM uint32_t STREAM_ADDR : 30;          /*!< [31..2] The address of the next word to be streamed from flash
                                                     to the streaming FIFO.
                                                     Increments automatically after each flash access.
                                                     Write the initial access address here before starting a
                                                     streaming read.                                                           */
    } bit;
  } STREAM_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000018) FIFO stream control                                        */
    
    struct {
      __IOM uint32_t STREAM_CTR : 22;           /*!< [21..0] Write a nonzero value to start a streaming read. This
                                                     will then
                                                     progress in the background, using flash idle cycles to
                                                     transfer
                                                     a linear data block from flash to the streaming FIFO.
                                                     Decrements automatically (1 at a time) as the stream
                                                     progresses, and halts on reaching 0.
                                                     Write 0 to halt an in-progress stream, and discard any
                                                     in-flight
                                                     read, so that a new stream can immediately be started (aft                */
            uint32_t            : 10;
    } bit;
  } STREAM_CTR;
  __IM  uint32_t  STREAM_FIFO;                  /*!< (@ 0x0000001C) FIFO stream data
                                                                    Streamed data is buffered here, for retrieval
                                                                    by the system DMA.
                                                                    This FIFO can also be accessed via the XIP_AUX
                                                                    slave, to avoid exposing
                                                                    the DMA to bus stalls caused by other XIP
                                                                    traffic.                                                   */
} XIP_CTRL_Type;                                /*!< Size = 32 (0x20)                                                          */



/* =========================================================================================================================== */
/* ================                                          XIP_SSI                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief DW_apb_ssi has the following features:\n
        * APB interface – Allows for easy integration into a DesignWare Synthesizable Components for AMBA 2 implementation.\n
        * APB3 and APB4 protocol support.\n
        * Scalable APB data bus width – Supports APB data bus widths of 8, 16, and 32 bits.\n
        * Serial-master or serial-slave operation – Enables serial communication with serial-master or serial-slave peripheral devices.\n
        * Programmable Dual/Quad/Octal SPI support in Master Mode.\n
        * Dual Data Rate (DDR) and Read Data Strobe (RDS) Support - Enables the DW_apb_ssi master to perform operations with the device in DDR and RDS modes when working in Dual/Quad/Octal mode of operation.\n
        * Data Mask Support - Enables the DW_apb_ssi to selectively update the bytes in the device. This feature is applicable only in enhanced SPI modes.\n
        * eXecute-In-Place (XIP) support - Enables the DW_apb_ssi master to behave as a memory mapped I/O and fetches the data from the device based on the APB read request. This feature is applicable only in enhanced SPI modes.\n
        * DMA Controller Interface – Enables the DW_apb_ssi to interface to a DMA controller over the bus using a handshaking interface for transfer requests.\n
        * Independent masking of interrupts – Master collision, transmit FIFO overflow, transmit FIFO empty, receive FIFO full, receive FIFO underflow, and receive FIFO overflow interrupts can all be masked independently.\n
        * Multi-master contention detection – Informs the processor of multiple serial-master accesses on the serial bus.\n
        * Bypass of meta-stability flip-flops for synchronous clocks – When the APB clock (pclk) and the DW_apb_ssi serial clock (ssi_clk) are synchronous, meta-stable flip-flops are not used when transferring control signals across these clock domains.\n
        * Programmable delay on the sample time of the received serial data bit (rxd); enables programmable control of routing delays resulting in higher serial data-bit rates.\n
        * Programmable features:\n
        - Serial interface operation – Choice of Motorola SPI, Texas Instruments Synchronous Serial Protocol or National Semiconductor Microwire.\n
        - Clock bit-rate – Dynamic control of the serial bit rate of the data transfer; used in only serial-master mode of operation.\n
        - Data Item size (4 to 32 bits) – Item size of each data transfer under the control of the programmer.\n
        * Configured features:\n
        - FIFO depth – 16 words deep. The FIFO width is fixed at 32 bits.\n
        - 1 slave select output.\n
        - Hardware slave-select – Dedicated hardware slave-select line.\n
        - Combined interrupt line - one combined interrupt line from the DW_apb_ssi to the interrupt controller.\n
        - Interrupt polarity – active high interrupt lines.\n
        - Serial clock polarity – low serial-clock polarity directly after reset.\n
        - Serial clock phase – capture on first edge of serial-clock directly after reset. (XIP_SSI)
  */

typedef struct {                                /*!< (@ 0x18000000) XIP_SSI Structure                                          */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000000) Control register 0                                         */
    
    struct {
      __IOM uint32_t DFS        : 4;            /*!< [3..0] Data frame size                                                    */
      __IOM uint32_t FRF        : 2;            /*!< [5..4] Frame format                                                       */
      __IOM uint32_t SCPH       : 1;            /*!< [6..6] Serial clock phase                                                 */
      __IOM uint32_t SCPOL      : 1;            /*!< [7..7] Serial clock polarity                                              */
      __IOM uint32_t TMOD       : 2;            /*!< [9..8] Transfer mode                                                      */
      __IOM uint32_t SLV_OE     : 1;            /*!< [10..10] Slave output enable                                              */
      __IOM uint32_t SRL        : 1;            /*!< [11..11] Shift register loop (test mode)                                  */
      __IOM uint32_t CFS        : 4;            /*!< [15..12] Control frame size
                                                     Value of n -> n+1 clocks per frame.                                       */
      __IOM uint32_t DFS_32     : 5;            /*!< [20..16] Data frame size in 32b transfer mode
                                                     Value of n -> n+1 clocks per frame.                                       */
      __IOM uint32_t SPI_FRF    : 2;            /*!< [22..21] SPI frame format                                                 */
            uint32_t            : 1;
      __IOM uint32_t SSTE       : 1;            /*!< [24..24] Slave select toggle enable                                       */
            uint32_t            : 7;
    } bit;
  } CTRLR0;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000004) Master Control register 1                                  */
    
    struct {
      __IOM uint32_t NDF        : 16;           /*!< [15..0] Number of data frames                                             */
            uint32_t            : 16;
    } bit;
  } CTRLR1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000008) SSI Enable                                                 */
    
    struct {
      __IOM uint32_t SSI_EN     : 1;            /*!< [0..0] SSI enable                                                         */
            uint32_t            : 31;
    } bit;
  } SSIENR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000000C) Microwire Control                                          */
    
    struct {
      __IOM uint32_t MWMOD      : 1;            /*!< [0..0] Microwire transfer mode                                            */
      __IOM uint32_t MDD        : 1;            /*!< [1..1] Microwire control                                                  */
      __IOM uint32_t MHS        : 1;            /*!< [2..2] Microwire handshaking                                              */
            uint32_t            : 29;
    } bit;
  } MWCR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000010) Slave enable                                               */
    
    struct {
      __IOM uint32_t SER        : 1;            /*!< [0..0] For each bit:
                                                     0 -> slave not selected
                                                     1 -> slave selected                                                       */
            uint32_t            : 31;
    } bit;
  } SER;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000014) Baud rate                                                  */
    
    struct {
      __IOM uint32_t SCKDV      : 16;           /*!< [15..0] SSI clock divider                                                 */
            uint32_t            : 16;
    } bit;
  } BAUDR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000018) TX FIFO threshold level                                    */
    
    struct {
      __IOM uint32_t TFT        : 8;            /*!< [7..0] Transmit FIFO threshold                                            */
            uint32_t            : 24;
    } bit;
  } TXFTLR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000001C) RX FIFO threshold level                                    */
    
    struct {
      __IOM uint32_t RFT        : 8;            /*!< [7..0] Receive FIFO threshold                                             */
            uint32_t            : 24;
    } bit;
  } RXFTLR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000020) TX FIFO level                                              */
    
    struct {
      __IM  uint32_t TFTFL      : 8;            /*!< [7..0] Transmit FIFO level                                                */
            uint32_t            : 24;
    } bit;
  } TXFLR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000024) RX FIFO level                                              */
    
    struct {
      __IM  uint32_t RXTFL      : 8;            /*!< [7..0] Receive FIFO level                                                 */
            uint32_t            : 24;
    } bit;
  } RXFLR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000028) Status register                                            */
    
    struct {
      __IM  uint32_t BUSY       : 1;            /*!< [0..0] SSI busy flag                                                      */
      __IM  uint32_t TFNF       : 1;            /*!< [1..1] Transmit FIFO not full                                             */
      __IM  uint32_t TFE        : 1;            /*!< [2..2] Transmit FIFO empty                                                */
      __IM  uint32_t RFNE       : 1;            /*!< [3..3] Receive FIFO not empty                                             */
      __IM  uint32_t RFF        : 1;            /*!< [4..4] Receive FIFO full                                                  */
      __IM  uint32_t TXE        : 1;            /*!< [5..5] Transmission error                                                 */
      __IM  uint32_t DCOL       : 1;            /*!< [6..6] Data collision error                                               */
            uint32_t            : 25;
    } bit;
  } SR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000002C) Interrupt mask                                             */
    
    struct {
      __IOM uint32_t TXEIM      : 1;            /*!< [0..0] Transmit FIFO empty interrupt mask                                 */
      __IOM uint32_t TXOIM      : 1;            /*!< [1..1] Transmit FIFO overflow interrupt mask                              */
      __IOM uint32_t RXUIM      : 1;            /*!< [2..2] Receive FIFO underflow interrupt mask                              */
      __IOM uint32_t RXOIM      : 1;            /*!< [3..3] Receive FIFO overflow interrupt mask                               */
      __IOM uint32_t RXFIM      : 1;            /*!< [4..4] Receive FIFO full interrupt mask                                   */
      __IOM uint32_t MSTIM      : 1;            /*!< [5..5] Multi-master contention interrupt mask                             */
            uint32_t            : 26;
    } bit;
  } IMR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000030) Interrupt status                                           */
    
    struct {
      __IM  uint32_t TXEIS      : 1;            /*!< [0..0] Transmit FIFO empty interrupt status                               */
      __IM  uint32_t TXOIS      : 1;            /*!< [1..1] Transmit FIFO overflow interrupt status                            */
      __IM  uint32_t RXUIS      : 1;            /*!< [2..2] Receive FIFO underflow interrupt status                            */
      __IM  uint32_t RXOIS      : 1;            /*!< [3..3] Receive FIFO overflow interrupt status                             */
      __IM  uint32_t RXFIS      : 1;            /*!< [4..4] Receive FIFO full interrupt status                                 */
      __IM  uint32_t MSTIS      : 1;            /*!< [5..5] Multi-master contention interrupt status                           */
            uint32_t            : 26;
    } bit;
  } ISR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000034) Raw interrupt status                                       */
    
    struct {
      __IM  uint32_t TXEIR      : 1;            /*!< [0..0] Transmit FIFO empty raw interrupt status                           */
      __IM  uint32_t TXOIR      : 1;            /*!< [1..1] Transmit FIFO overflow raw interrupt status                        */
      __IM  uint32_t RXUIR      : 1;            /*!< [2..2] Receive FIFO underflow raw interrupt status                        */
      __IM  uint32_t RXOIR      : 1;            /*!< [3..3] Receive FIFO overflow raw interrupt status                         */
      __IM  uint32_t RXFIR      : 1;            /*!< [4..4] Receive FIFO full raw interrupt status                             */
      __IM  uint32_t MSTIR      : 1;            /*!< [5..5] Multi-master contention raw interrupt status                       */
            uint32_t            : 26;
    } bit;
  } RISR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000038) TX FIFO overflow interrupt clear                           */
    
    struct {
      __IM  uint32_t TXOICR     : 1;            /*!< [0..0] Clear-on-read transmit FIFO overflow interrupt                     */
            uint32_t            : 31;
    } bit;
  } TXOICR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000003C) RX FIFO overflow interrupt clear                           */
    
    struct {
      __IM  uint32_t RXOICR     : 1;            /*!< [0..0] Clear-on-read receive FIFO overflow interrupt                      */
            uint32_t            : 31;
    } bit;
  } RXOICR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000040) RX FIFO underflow interrupt clear                          */
    
    struct {
      __IM  uint32_t RXUICR     : 1;            /*!< [0..0] Clear-on-read receive FIFO underflow interrupt                     */
            uint32_t            : 31;
    } bit;
  } RXUICR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000044) Multi-master interrupt clear                               */
    
    struct {
      __IM  uint32_t MSTICR     : 1;            /*!< [0..0] Clear-on-read multi-master contention interrupt                    */
            uint32_t            : 31;
    } bit;
  } MSTICR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000048) Interrupt clear                                            */
    
    struct {
      __IM  uint32_t ICR        : 1;            /*!< [0..0] Clear-on-read all active interrupts                                */
            uint32_t            : 31;
    } bit;
  } ICR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000004C) DMA control                                                */
    
    struct {
      __IOM uint32_t RDMAE      : 1;            /*!< [0..0] Receive DMA enable                                                 */
      __IOM uint32_t TDMAE      : 1;            /*!< [1..1] Transmit DMA enable                                                */
            uint32_t            : 30;
    } bit;
  } DMACR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000050) DMA TX data level                                          */
    
    struct {
      __IOM uint32_t DMATDL     : 8;            /*!< [7..0] Transmit data watermark level                                      */
            uint32_t            : 24;
    } bit;
  } DMATDLR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000054) DMA RX data level                                          */
    
    struct {
      __IOM uint32_t DMARDL     : 8;            /*!< [7..0] Receive data watermark level (DMARDLR+1)                           */
            uint32_t            : 24;
    } bit;
  } DMARDLR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000058) Identification register                                    */
    
    struct {
      __IM  uint32_t IDCODE     : 32;           /*!< [31..0] Peripheral dentification code                                     */
    } bit;
  } IDR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000005C) Version ID                                                 */
    
    struct {
      __IM  uint32_t SSI_COMP_VERSION : 32;     /*!< [31..0] SNPS component version (format X.YY)                              */
    } bit;
  } SSI_VERSION_ID;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000060) Data Register 0 (of 36)                                    */
    
    struct {
      __IOM uint32_t DR         : 32;           /*!< [31..0] First data register of 36                                         */
    } bit;
  } DR0;
  __IM  uint32_t  RESERVED[35];
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000F0) RX sample delay                                            */
    
    struct {
      __IOM uint32_t RSD        : 8;            /*!< [7..0] RXD sample delay (in SCLK cycles)                                  */
            uint32_t            : 24;
    } bit;
  } RX_SAMPLE_DLY;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000F4) SPI control                                                */
    
    struct {
      __IOM uint32_t TRANS_TYPE : 2;            /*!< [1..0] Address and instruction transfer format                            */
      __IOM uint32_t ADDR_L     : 4;            /*!< [5..2] Address length (0b-60b in 4b increments)                           */
            uint32_t            : 2;
      __IOM uint32_t INST_L     : 2;            /*!< [9..8] Instruction length (0/4/8/16b)                                     */
            uint32_t            : 1;
      __IOM uint32_t WAIT_CYCLES : 5;           /*!< [15..11] Wait cycles between control frame transmit and data
                                                     reception (in SCLK cycles)                                                */
      __IOM uint32_t SPI_DDR_EN : 1;            /*!< [16..16] SPI DDR transfer enable                                          */
      __IOM uint32_t INST_DDR_EN : 1;           /*!< [17..17] Instruction DDR transfer enable                                  */
      __IOM uint32_t SPI_RXDS_EN : 1;           /*!< [18..18] Read data strobe enable                                          */
            uint32_t            : 5;
      __IOM uint32_t XIP_CMD    : 8;            /*!< [31..24] SPI Command to send in XIP mode (INST_L = 8-bit) or
                                                     to append to Address (INST_L = 0-bit)                                     */
    } bit;
  } SPI_CTRLR0;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000F8) TX drive edge                                              */
    
    struct {
      __IOM uint32_t TDE        : 8;            /*!< [7..0] TXD drive edge                                                     */
            uint32_t            : 24;
    } bit;
  } TXD_DRIVE_EDGE;
} XIP_SSI_Type;                                 /*!< Size = 252 (0xfc)                                                         */



/* =========================================================================================================================== */
/* ================                                          SYSINFO                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief SYSINFO (SYSINFO)
  */

typedef struct {                                /*!< (@ 0x40000000) SYSINFO Structure                                          */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000000) JEDEC JEP-106 compliant chip identifier.                   */
    
    struct {
      __IM  uint32_t MANUFACTURER : 12;         /*!< [11..0] MANUFACTURER                                                      */
      __IM  uint32_t PART       : 16;           /*!< [27..12] PART                                                             */
      __IM  uint32_t REVISION   : 4;            /*!< [31..28] REVISION                                                         */
    } bit;
  } CHIP_ID;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000004) Platform register. Allows software to know what
                                                                    environment it is running in.                              */
    
    struct {
      __IM  uint32_t FPGA       : 1;            /*!< [0..0] FPGA                                                               */
      __IM  uint32_t ASIC       : 1;            /*!< [1..1] ASIC                                                               */
            uint32_t            : 30;
    } bit;
  } PLATFORM;
  __IM  uint32_t  RESERVED[14];
  __IM  uint32_t  GITREF_RP2040;                /*!< (@ 0x00000040) Git hash of the chip source. Used to identify
                                                                    chip version.                                              */
} SYSINFO_Type;                                 /*!< Size = 68 (0x44)                                                          */



/* =========================================================================================================================== */
/* ================                                          SYSCFG                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Register block for various chip control signals (SYSCFG)
  */

typedef struct {                                /*!< (@ 0x40004000) SYSCFG Structure                                           */
  __IOM uint32_t  PROC0_NMI_MASK;               /*!< (@ 0x00000000) Processor core 0 NMI source mask
                                                                    Set a bit high to enable NMI from that IRQ                 */
  __IOM uint32_t  PROC1_NMI_MASK;               /*!< (@ 0x00000004) Processor core 1 NMI source mask
                                                                    Set a bit high to enable NMI from that IRQ                 */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000008) Configuration for processors                               */
    
    struct {
      __IM  uint32_t PROC0_HALTED : 1;          /*!< [0..0] Indication that proc0 has halted                                   */
      __IM  uint32_t PROC1_HALTED : 1;          /*!< [1..1] Indication that proc1 has halted                                   */
            uint32_t            : 22;
      __IOM uint32_t PROC0_DAP_INSTID : 4;      /*!< [27..24] Configure proc0 DAP instance ID.
                                                     Recommend that this is NOT changed until you require debug
                                                     access in multi-chip environment
                                                     WARNING: do not set to 15 as this is reserved for RescueDP                */
      __IOM uint32_t PROC1_DAP_INSTID : 4;      /*!< [31..28] Configure proc1 DAP instance ID.
                                                     Recommend that this is NOT changed until you require debug
                                                     access in multi-chip environment
                                                     WARNING: do not set to 15 as this is reserved for RescueDP                */
    } bit;
  } PROC_CONFIG;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000000C) For each bit, if 1, bypass the input synchronizer
                                                                    between that GPIO
                                                                    and the GPIO input register in the SIO.
                                                                    The input synchronizers should
                                                                    generally be unbypassed, to avoid injecting
                                                                    metastabilities into processors.
                                                                    If you're feeling brave, you can bypass
                                                                    to save two cycles of input
                                                                    latency. This register applies to GPIO 0...29.             */
    
    struct {
      __IOM uint32_t PROC_IN_SYNC_BYPASS : 30;  /*!< [29..0] PROC_IN_SYNC_BYPASS                                               */
            uint32_t            : 2;
    } bit;
  } PROC_IN_SYNC_BYPASS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000010) For each bit, if 1, bypass the input synchronizer
                                                                    between that GPIO
                                                                    and the GPIO input register in the SIO.
                                                                    The input synchronizers should
                                                                    generally be unbypassed, to avoid injecting
                                                                    metastabilities into processors.
                                                                    If you're feeling brave, you can bypass
                                                                    to save two cycles of input
                                                                    latency. This register applies to GPIO 30...35
                                                                    (the QSPI IOs).                                            */
    
    struct {
      __IOM uint32_t PROC_IN_SYNC_BYPASS_HI : 6;/*!< [5..0] PROC_IN_SYNC_BYPASS_HI                                             */
            uint32_t            : 26;
    } bit;
  } PROC_IN_SYNC_BYPASS_HI;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000014) Directly control the SWD debug port of either
                                                                    processor                                                  */
    
    struct {
      __IM  uint32_t PROC0_SWDO : 1;            /*!< [0..0] Observe the value of processor 0 SWDIO output.                     */
      __IOM uint32_t PROC0_SWDI : 1;            /*!< [1..1] Directly drive processor 0 SWDIO input, if PROC0_ATTACH
                                                     is set                                                                    */
      __IOM uint32_t PROC0_SWCLK : 1;           /*!< [2..2] Directly drive processor 0 SWCLK, if PROC0_ATTACH is
                                                     set                                                                       */
      __IOM uint32_t PROC0_ATTACH : 1;          /*!< [3..3] Attach processor 0 debug port to syscfg controls, and
                                                     disconnect it from external SWD pads.                                     */
      __IM  uint32_t PROC1_SWDO : 1;            /*!< [4..4] Observe the value of processor 1 SWDIO output.                     */
      __IOM uint32_t PROC1_SWDI : 1;            /*!< [5..5] Directly drive processor 1 SWDIO input, if PROC1_ATTACH
                                                     is set                                                                    */
      __IOM uint32_t PROC1_SWCLK : 1;           /*!< [6..6] Directly drive processor 1 SWCLK, if PROC1_ATTACH is
                                                     set                                                                       */
      __IOM uint32_t PROC1_ATTACH : 1;          /*!< [7..7] Attach processor 1 debug port to syscfg controls, and
                                                     disconnect it from external SWD pads.                                     */
            uint32_t            : 24;
    } bit;
  } DBGFORCE;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000018) Control power downs to memories. Set high to
                                                                    power down memories.
                                                                    Use with extreme caution                                   */
    
    struct {
      __IOM uint32_t SRAM0      : 1;            /*!< [0..0] SRAM0                                                              */
      __IOM uint32_t SRAM1      : 1;            /*!< [1..1] SRAM1                                                              */
      __IOM uint32_t SRAM2      : 1;            /*!< [2..2] SRAM2                                                              */
      __IOM uint32_t SRAM3      : 1;            /*!< [3..3] SRAM3                                                              */
      __IOM uint32_t SRAM4      : 1;            /*!< [4..4] SRAM4                                                              */
      __IOM uint32_t SRAM5      : 1;            /*!< [5..5] SRAM5                                                              */
      __IOM uint32_t USB        : 1;            /*!< [6..6] USB                                                                */
      __IOM uint32_t ROM        : 1;            /*!< [7..7] ROM                                                                */
            uint32_t            : 24;
    } bit;
  } MEMPOWERDOWN;
} SYSCFG_Type;                                  /*!< Size = 28 (0x1c)                                                          */



/* =========================================================================================================================== */
/* ================                                          CLOCKS                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief CLOCKS (CLOCKS)
  */

typedef struct {                                /*!< (@ 0x40008000) CLOCKS Structure                                           */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000000) Clock control, can be changed on-the-fly (except
                                                                    for auxsrc)                                                */
    
    struct {
            uint32_t            : 5;
      __IOM uint32_t AUXSRC     : 4;            /*!< [8..5] Selects the auxiliary clock source, will glitch when
                                                     switching                                                                 */
            uint32_t            : 1;
      __IOM uint32_t KILL       : 1;            /*!< [10..10] Asynchronously kills the clock generator                         */
      __IOM uint32_t ENABLE     : 1;            /*!< [11..11] Starts and stops the clock generator cleanly                     */
      __IOM uint32_t DC50       : 1;            /*!< [12..12] Enables duty cycle correction for odd divisors                   */
            uint32_t            : 3;
      __IOM uint32_t PHASE      : 2;            /*!< [17..16] This delays the enable signal by up to 3 cycles of
                                                     the input clock
                                                     This must be set before the clock is enabled to have any
                                                     effect                                                                    */
            uint32_t            : 2;
      __IOM uint32_t NUDGE      : 1;            /*!< [20..20] An edge on this signal shifts the phase of the output
                                                     by 1 cycle of the input clock
                                                     This can be done at any time                                              */
            uint32_t            : 11;
    } bit;
  } CLK_GPOUT0_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000004) Clock divisor, can be changed on-the-fly                   */
    
    struct {
      __IOM uint32_t FRAC       : 8;            /*!< [7..0] Fractional component of the divisor                                */
      __IOM uint32_t INT        : 24;           /*!< [31..8] Integer component of the divisor, 0 -> divide by 2^16             */
    } bit;
  } CLK_GPOUT0_DIV;
  __IM  uint32_t  CLK_GPOUT0_SELECTED;          /*!< (@ 0x00000008) Indicates which src is currently selected (one-hot)        */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000000C) Clock control, can be changed on-the-fly (except
                                                                    for auxsrc)                                                */
    
    struct {
            uint32_t            : 5;
      __IOM uint32_t AUXSRC     : 4;            /*!< [8..5] Selects the auxiliary clock source, will glitch when
                                                     switching                                                                 */
            uint32_t            : 1;
      __IOM uint32_t KILL       : 1;            /*!< [10..10] Asynchronously kills the clock generator                         */
      __IOM uint32_t ENABLE     : 1;            /*!< [11..11] Starts and stops the clock generator cleanly                     */
      __IOM uint32_t DC50       : 1;            /*!< [12..12] Enables duty cycle correction for odd divisors                   */
            uint32_t            : 3;
      __IOM uint32_t PHASE      : 2;            /*!< [17..16] This delays the enable signal by up to 3 cycles of
                                                     the input clock
                                                     This must be set before the clock is enabled to have any
                                                     effect                                                                    */
            uint32_t            : 2;
      __IOM uint32_t NUDGE      : 1;            /*!< [20..20] An edge on this signal shifts the phase of the output
                                                     by 1 cycle of the input clock
                                                     This can be done at any time                                              */
            uint32_t            : 11;
    } bit;
  } CLK_GPOUT1_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000010) Clock divisor, can be changed on-the-fly                   */
    
    struct {
      __IOM uint32_t FRAC       : 8;            /*!< [7..0] Fractional component of the divisor                                */
      __IOM uint32_t INT        : 24;           /*!< [31..8] Integer component of the divisor, 0 -> divide by 2^16             */
    } bit;
  } CLK_GPOUT1_DIV;
  __IM  uint32_t  CLK_GPOUT1_SELECTED;          /*!< (@ 0x00000014) Indicates which src is currently selected (one-hot)        */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000018) Clock control, can be changed on-the-fly (except
                                                                    for auxsrc)                                                */
    
    struct {
            uint32_t            : 5;
      __IOM uint32_t AUXSRC     : 4;            /*!< [8..5] Selects the auxiliary clock source, will glitch when
                                                     switching                                                                 */
            uint32_t            : 1;
      __IOM uint32_t KILL       : 1;            /*!< [10..10] Asynchronously kills the clock generator                         */
      __IOM uint32_t ENABLE     : 1;            /*!< [11..11] Starts and stops the clock generator cleanly                     */
      __IOM uint32_t DC50       : 1;            /*!< [12..12] Enables duty cycle correction for odd divisors                   */
            uint32_t            : 3;
      __IOM uint32_t PHASE      : 2;            /*!< [17..16] This delays the enable signal by up to 3 cycles of
                                                     the input clock
                                                     This must be set before the clock is enabled to have any
                                                     effect                                                                    */
            uint32_t            : 2;
      __IOM uint32_t NUDGE      : 1;            /*!< [20..20] An edge on this signal shifts the phase of the output
                                                     by 1 cycle of the input clock
                                                     This can be done at any time                                              */
            uint32_t            : 11;
    } bit;
  } CLK_GPOUT2_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000001C) Clock divisor, can be changed on-the-fly                   */
    
    struct {
      __IOM uint32_t FRAC       : 8;            /*!< [7..0] Fractional component of the divisor                                */
      __IOM uint32_t INT        : 24;           /*!< [31..8] Integer component of the divisor, 0 -> divide by 2^16             */
    } bit;
  } CLK_GPOUT2_DIV;
  __IM  uint32_t  CLK_GPOUT2_SELECTED;          /*!< (@ 0x00000020) Indicates which src is currently selected (one-hot)        */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000024) Clock control, can be changed on-the-fly (except
                                                                    for auxsrc)                                                */
    
    struct {
            uint32_t            : 5;
      __IOM uint32_t AUXSRC     : 4;            /*!< [8..5] Selects the auxiliary clock source, will glitch when
                                                     switching                                                                 */
            uint32_t            : 1;
      __IOM uint32_t KILL       : 1;            /*!< [10..10] Asynchronously kills the clock generator                         */
      __IOM uint32_t ENABLE     : 1;            /*!< [11..11] Starts and stops the clock generator cleanly                     */
      __IOM uint32_t DC50       : 1;            /*!< [12..12] Enables duty cycle correction for odd divisors                   */
            uint32_t            : 3;
      __IOM uint32_t PHASE      : 2;            /*!< [17..16] This delays the enable signal by up to 3 cycles of
                                                     the input clock
                                                     This must be set before the clock is enabled to have any
                                                     effect                                                                    */
            uint32_t            : 2;
      __IOM uint32_t NUDGE      : 1;            /*!< [20..20] An edge on this signal shifts the phase of the output
                                                     by 1 cycle of the input clock
                                                     This can be done at any time                                              */
            uint32_t            : 11;
    } bit;
  } CLK_GPOUT3_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000028) Clock divisor, can be changed on-the-fly                   */
    
    struct {
      __IOM uint32_t FRAC       : 8;            /*!< [7..0] Fractional component of the divisor                                */
      __IOM uint32_t INT        : 24;           /*!< [31..8] Integer component of the divisor, 0 -> divide by 2^16             */
    } bit;
  } CLK_GPOUT3_DIV;
  __IM  uint32_t  CLK_GPOUT3_SELECTED;          /*!< (@ 0x0000002C) Indicates which src is currently selected (one-hot)        */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000030) Clock control, can be changed on-the-fly (except
                                                                    for auxsrc)                                                */
    
    struct {
      __IOM uint32_t SRC        : 2;            /*!< [1..0] Selects the clock source glitchlessly, can be changed
                                                     on-the-fly                                                                */
            uint32_t            : 3;
      __IOM uint32_t AUXSRC     : 2;            /*!< [6..5] Selects the auxiliary clock source, will glitch when
                                                     switching                                                                 */
            uint32_t            : 25;
    } bit;
  } CLK_REF_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000034) Clock divisor, can be changed on-the-fly                   */
    
    struct {
            uint32_t            : 8;
      __IOM uint32_t INT        : 2;            /*!< [9..8] Integer component of the divisor, 0 -> divide by 2^16              */
            uint32_t            : 22;
    } bit;
  } CLK_REF_DIV;
  __IM  uint32_t  CLK_REF_SELECTED;             /*!< (@ 0x00000038) Indicates which src is currently selected (one-hot)        */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000003C) Clock control, can be changed on-the-fly (except
                                                                    for auxsrc)                                                */
    
    struct {
      __IOM uint32_t SRC        : 1;            /*!< [0..0] Selects the clock source glitchlessly, can be changed
                                                     on-the-fly                                                                */
            uint32_t            : 4;
      __IOM uint32_t AUXSRC     : 3;            /*!< [7..5] Selects the auxiliary clock source, will glitch when
                                                     switching                                                                 */
            uint32_t            : 24;
    } bit;
  } CLK_SYS_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000040) Clock divisor, can be changed on-the-fly                   */
    
    struct {
      __IOM uint32_t FRAC       : 8;            /*!< [7..0] Fractional component of the divisor                                */
      __IOM uint32_t INT        : 24;           /*!< [31..8] Integer component of the divisor, 0 -> divide by 2^16             */
    } bit;
  } CLK_SYS_DIV;
  __IM  uint32_t  CLK_SYS_SELECTED;             /*!< (@ 0x00000044) Indicates which src is currently selected (one-hot)        */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000048) Clock control, can be changed on-the-fly (except
                                                                    for auxsrc)                                                */
    
    struct {
            uint32_t            : 5;
      __IOM uint32_t AUXSRC     : 3;            /*!< [7..5] Selects the auxiliary clock source, will glitch when
                                                     switching                                                                 */
            uint32_t            : 2;
      __IOM uint32_t KILL       : 1;            /*!< [10..10] Asynchronously kills the clock generator                         */
      __IOM uint32_t ENABLE     : 1;            /*!< [11..11] Starts and stops the clock generator cleanly                     */
            uint32_t            : 20;
    } bit;
  } CLK_PERI_CTRL;
  __IM  uint32_t  RESERVED;
  __IM  uint32_t  CLK_PERI_SELECTED;            /*!< (@ 0x00000050) Indicates which src is currently selected (one-hot)        */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000054) Clock control, can be changed on-the-fly (except
                                                                    for auxsrc)                                                */
    
    struct {
            uint32_t            : 5;
      __IOM uint32_t AUXSRC     : 3;            /*!< [7..5] Selects the auxiliary clock source, will glitch when
                                                     switching                                                                 */
            uint32_t            : 2;
      __IOM uint32_t KILL       : 1;            /*!< [10..10] Asynchronously kills the clock generator                         */
      __IOM uint32_t ENABLE     : 1;            /*!< [11..11] Starts and stops the clock generator cleanly                     */
            uint32_t            : 4;
      __IOM uint32_t PHASE      : 2;            /*!< [17..16] This delays the enable signal by up to 3 cycles of
                                                     the input clock
                                                     This must be set before the clock is enabled to have any
                                                     effect                                                                    */
            uint32_t            : 2;
      __IOM uint32_t NUDGE      : 1;            /*!< [20..20] An edge on this signal shifts the phase of the output
                                                     by 1 cycle of the input clock
                                                     This can be done at any time                                              */
            uint32_t            : 11;
    } bit;
  } CLK_USB_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000058) Clock divisor, can be changed on-the-fly                   */
    
    struct {
            uint32_t            : 8;
      __IOM uint32_t INT        : 2;            /*!< [9..8] Integer component of the divisor, 0 -> divide by 2^16              */
            uint32_t            : 22;
    } bit;
  } CLK_USB_DIV;
  __IM  uint32_t  CLK_USB_SELECTED;             /*!< (@ 0x0000005C) Indicates which src is currently selected (one-hot)        */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000060) Clock control, can be changed on-the-fly (except
                                                                    for auxsrc)                                                */
    
    struct {
            uint32_t            : 5;
      __IOM uint32_t AUXSRC     : 3;            /*!< [7..5] Selects the auxiliary clock source, will glitch when
                                                     switching                                                                 */
            uint32_t            : 2;
      __IOM uint32_t KILL       : 1;            /*!< [10..10] Asynchronously kills the clock generator                         */
      __IOM uint32_t ENABLE     : 1;            /*!< [11..11] Starts and stops the clock generator cleanly                     */
            uint32_t            : 4;
      __IOM uint32_t PHASE      : 2;            /*!< [17..16] This delays the enable signal by up to 3 cycles of
                                                     the input clock
                                                     This must be set before the clock is enabled to have any
                                                     effect                                                                    */
            uint32_t            : 2;
      __IOM uint32_t NUDGE      : 1;            /*!< [20..20] An edge on this signal shifts the phase of the output
                                                     by 1 cycle of the input clock
                                                     This can be done at any time                                              */
            uint32_t            : 11;
    } bit;
  } CLK_ADC_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000064) Clock divisor, can be changed on-the-fly                   */
    
    struct {
            uint32_t            : 8;
      __IOM uint32_t INT        : 2;            /*!< [9..8] Integer component of the divisor, 0 -> divide by 2^16              */
            uint32_t            : 22;
    } bit;
  } CLK_ADC_DIV;
  __IM  uint32_t  CLK_ADC_SELECTED;             /*!< (@ 0x00000068) Indicates which src is currently selected (one-hot)        */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000006C) Clock control, can be changed on-the-fly (except
                                                                    for auxsrc)                                                */
    
    struct {
            uint32_t            : 5;
      __IOM uint32_t AUXSRC     : 3;            /*!< [7..5] Selects the auxiliary clock source, will glitch when
                                                     switching                                                                 */
            uint32_t            : 2;
      __IOM uint32_t KILL       : 1;            /*!< [10..10] Asynchronously kills the clock generator                         */
      __IOM uint32_t ENABLE     : 1;            /*!< [11..11] Starts and stops the clock generator cleanly                     */
            uint32_t            : 4;
      __IOM uint32_t PHASE      : 2;            /*!< [17..16] This delays the enable signal by up to 3 cycles of
                                                     the input clock
                                                     This must be set before the clock is enabled to have any
                                                     effect                                                                    */
            uint32_t            : 2;
      __IOM uint32_t NUDGE      : 1;            /*!< [20..20] An edge on this signal shifts the phase of the output
                                                     by 1 cycle of the input clock
                                                     This can be done at any time                                              */
            uint32_t            : 11;
    } bit;
  } CLK_RTC_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000070) Clock divisor, can be changed on-the-fly                   */
    
    struct {
      __IOM uint32_t FRAC       : 8;            /*!< [7..0] Fractional component of the divisor                                */
      __IOM uint32_t INT        : 24;           /*!< [31..8] Integer component of the divisor, 0 -> divide by 2^16             */
    } bit;
  } CLK_RTC_DIV;
  __IM  uint32_t  CLK_RTC_SELECTED;             /*!< (@ 0x00000074) Indicates which src is currently selected (one-hot)        */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000078) CLK_SYS_RESUS_CTRL                                         */
    
    struct {
      __IOM uint32_t TIMEOUT    : 8;            /*!< [7..0] This is expressed as a number of clk_ref cycles
                                                     and must be >= 2x clk_ref_freq/min_clk_tst_freq                           */
      __IOM uint32_t ENABLE     : 1;            /*!< [8..8] Enable resus                                                       */
            uint32_t            : 3;
      __IOM uint32_t FRCE       : 1;            /*!< [12..12] Force a resus, for test purposes only                            */
            uint32_t            : 3;
      __IOM uint32_t CLEAR      : 1;            /*!< [16..16] For clearing the resus after the fault that triggered
                                                     it has been corrected                                                     */
            uint32_t            : 15;
    } bit;
  } CLK_SYS_RESUS_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000007C) CLK_SYS_RESUS_STATUS                                       */
    
    struct {
      __IM  uint32_t RESUSSED   : 1;            /*!< [0..0] Clock has been resuscitated, correct the error then send
                                                     ctrl_clear=1                                                              */
            uint32_t            : 31;
    } bit;
  } CLK_SYS_RESUS_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000080) Reference clock frequency in kHz                           */
    
    struct {
      __IOM uint32_t FC0_REF_KHZ : 20;          /*!< [19..0] FC0_REF_KHZ                                                       */
            uint32_t            : 12;
    } bit;
  } FC0_REF_KHZ;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000084) Minimum pass frequency in kHz. This is optional.
                                                                    Set to 0 if you are not using the pass/fail
                                                                    flags                                                      */
    
    struct {
      __IOM uint32_t FC0_MIN_KHZ : 25;          /*!< [24..0] FC0_MIN_KHZ                                                       */
            uint32_t            : 7;
    } bit;
  } FC0_MIN_KHZ;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000088) Maximum pass frequency in kHz. This is optional.
                                                                    Set to 0x1ffffff if you are not using the
                                                                    pass/fail flags                                            */
    
    struct {
      __IOM uint32_t FC0_MAX_KHZ : 25;          /*!< [24..0] FC0_MAX_KHZ                                                       */
            uint32_t            : 7;
    } bit;
  } FC0_MAX_KHZ;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000008C) Delays the start of frequency counting to allow
                                                                    the mux to settle
                                                                    Delay is measured in multiples of the reference
                                                                    clock period                                               */
    
    struct {
      __IOM uint32_t FC0_DELAY  : 3;            /*!< [2..0] FC0_DELAY                                                          */
            uint32_t            : 29;
    } bit;
  } FC0_DELAY;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000090) The test interval is 0.98us * 2**interval, but
                                                                    let's call it 1us * 2**interval
                                                                    The default gives a test interval of 250us                 */
    
    struct {
      __IOM uint32_t FC0_INTERVAL : 4;          /*!< [3..0] FC0_INTERVAL                                                       */
            uint32_t            : 28;
    } bit;
  } FC0_INTERVAL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000094) Clock sent to frequency counter, set to 0 when
                                                                    not required
                                                                    Writing to this register initiates the frequency
                                                                    count                                                      */
    
    struct {
      __IOM uint32_t FC0_SRC    : 8;            /*!< [7..0] FC0_SRC                                                            */
            uint32_t            : 24;
    } bit;
  } FC0_SRC;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000098) Frequency counter status                                   */
    
    struct {
      __IM  uint32_t PASS       : 1;            /*!< [0..0] Test passed                                                        */
            uint32_t            : 3;
      __IM  uint32_t DONE       : 1;            /*!< [4..4] Test complete                                                      */
            uint32_t            : 3;
      __IM  uint32_t RUNNING    : 1;            /*!< [8..8] Test running                                                       */
            uint32_t            : 3;
      __IM  uint32_t WAITING    : 1;            /*!< [12..12] Waiting for test clock to start                                  */
            uint32_t            : 3;
      __IM  uint32_t FAIL       : 1;            /*!< [16..16] Test failed                                                      */
            uint32_t            : 3;
      __IM  uint32_t SLOW       : 1;            /*!< [20..20] Test clock slower than expected, only valid when status_done=1   */
            uint32_t            : 3;
      __IM  uint32_t FAST       : 1;            /*!< [24..24] Test clock faster than expected, only valid when status_done=1   */
            uint32_t            : 3;
      __IM  uint32_t DIED       : 1;            /*!< [28..28] Test clock stopped during test                                   */
            uint32_t            : 3;
    } bit;
  } FC0_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000009C) Result of frequency measurement, only valid when
                                                                    status_done=1                                              */
    
    struct {
      __IM  uint32_t FRAC       : 5;            /*!< [4..0] FRAC                                                               */
      __IM  uint32_t KHZ        : 25;           /*!< [29..5] KHZ                                                               */
            uint32_t            : 2;
    } bit;
  } FC0_RESULT;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000A0) enable clock in wake mode                                  */
    
    struct {
      __IOM uint32_t clk_sys_clocks : 1;        /*!< [0..0] clk_sys_clocks                                                     */
      __IOM uint32_t clk_adc_adc : 1;           /*!< [1..1] clk_adc_adc                                                        */
      __IOM uint32_t clk_sys_adc : 1;           /*!< [2..2] clk_sys_adc                                                        */
      __IOM uint32_t clk_sys_busctrl : 1;       /*!< [3..3] clk_sys_busctrl                                                    */
      __IOM uint32_t clk_sys_busfabric : 1;     /*!< [4..4] clk_sys_busfabric                                                  */
      __IOM uint32_t clk_sys_dma : 1;           /*!< [5..5] clk_sys_dma                                                        */
      __IOM uint32_t clk_sys_i2c0 : 1;          /*!< [6..6] clk_sys_i2c0                                                       */
      __IOM uint32_t clk_sys_i2c1 : 1;          /*!< [7..7] clk_sys_i2c1                                                       */
      __IOM uint32_t clk_sys_io : 1;            /*!< [8..8] clk_sys_io                                                         */
      __IOM uint32_t clk_sys_jtag : 1;          /*!< [9..9] clk_sys_jtag                                                       */
      __IOM uint32_t clk_sys_vreg_and_chip_reset : 1;/*!< [10..10] clk_sys_vreg_and_chip_reset                                 */
      __IOM uint32_t clk_sys_pads : 1;          /*!< [11..11] clk_sys_pads                                                     */
      __IOM uint32_t clk_sys_pio0 : 1;          /*!< [12..12] clk_sys_pio0                                                     */
      __IOM uint32_t clk_sys_pio1 : 1;          /*!< [13..13] clk_sys_pio1                                                     */
      __IOM uint32_t clk_sys_pll_sys : 1;       /*!< [14..14] clk_sys_pll_sys                                                  */
      __IOM uint32_t clk_sys_pll_usb : 1;       /*!< [15..15] clk_sys_pll_usb                                                  */
      __IOM uint32_t clk_sys_psm : 1;           /*!< [16..16] clk_sys_psm                                                      */
      __IOM uint32_t clk_sys_pwm : 1;           /*!< [17..17] clk_sys_pwm                                                      */
      __IOM uint32_t clk_sys_resets : 1;        /*!< [18..18] clk_sys_resets                                                   */
      __IOM uint32_t clk_sys_rom : 1;           /*!< [19..19] clk_sys_rom                                                      */
      __IOM uint32_t clk_sys_rosc : 1;          /*!< [20..20] clk_sys_rosc                                                     */
      __IOM uint32_t clk_rtc_rtc : 1;           /*!< [21..21] clk_rtc_rtc                                                      */
      __IOM uint32_t clk_sys_rtc : 1;           /*!< [22..22] clk_sys_rtc                                                      */
      __IOM uint32_t clk_sys_sio : 1;           /*!< [23..23] clk_sys_sio                                                      */
      __IOM uint32_t clk_peri_spi0 : 1;         /*!< [24..24] clk_peri_spi0                                                    */
      __IOM uint32_t clk_sys_spi0 : 1;          /*!< [25..25] clk_sys_spi0                                                     */
      __IOM uint32_t clk_peri_spi1 : 1;         /*!< [26..26] clk_peri_spi1                                                    */
      __IOM uint32_t clk_sys_spi1 : 1;          /*!< [27..27] clk_sys_spi1                                                     */
      __IOM uint32_t clk_sys_sram0 : 1;         /*!< [28..28] clk_sys_sram0                                                    */
      __IOM uint32_t clk_sys_sram1 : 1;         /*!< [29..29] clk_sys_sram1                                                    */
      __IOM uint32_t clk_sys_sram2 : 1;         /*!< [30..30] clk_sys_sram2                                                    */
      __IOM uint32_t clk_sys_sram3 : 1;         /*!< [31..31] clk_sys_sram3                                                    */
    } bit;
  } WAKE_EN0;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000A4) enable clock in wake mode                                  */
    
    struct {
      __IOM uint32_t clk_sys_sram4 : 1;         /*!< [0..0] clk_sys_sram4                                                      */
      __IOM uint32_t clk_sys_sram5 : 1;         /*!< [1..1] clk_sys_sram5                                                      */
      __IOM uint32_t clk_sys_syscfg : 1;        /*!< [2..2] clk_sys_syscfg                                                     */
      __IOM uint32_t clk_sys_sysinfo : 1;       /*!< [3..3] clk_sys_sysinfo                                                    */
      __IOM uint32_t clk_sys_tbman : 1;         /*!< [4..4] clk_sys_tbman                                                      */
      __IOM uint32_t clk_sys_timer : 1;         /*!< [5..5] clk_sys_timer                                                      */
      __IOM uint32_t clk_peri_uart0 : 1;        /*!< [6..6] clk_peri_uart0                                                     */
      __IOM uint32_t clk_sys_uart0 : 1;         /*!< [7..7] clk_sys_uart0                                                      */
      __IOM uint32_t clk_peri_uart1 : 1;        /*!< [8..8] clk_peri_uart1                                                     */
      __IOM uint32_t clk_sys_uart1 : 1;         /*!< [9..9] clk_sys_uart1                                                      */
      __IOM uint32_t clk_sys_usbctrl : 1;       /*!< [10..10] clk_sys_usbctrl                                                  */
      __IOM uint32_t clk_usb_usbctrl : 1;       /*!< [11..11] clk_usb_usbctrl                                                  */
      __IOM uint32_t clk_sys_watchdog : 1;      /*!< [12..12] clk_sys_watchdog                                                 */
      __IOM uint32_t clk_sys_xip : 1;           /*!< [13..13] clk_sys_xip                                                      */
      __IOM uint32_t clk_sys_xosc : 1;          /*!< [14..14] clk_sys_xosc                                                     */
            uint32_t            : 17;
    } bit;
  } WAKE_EN1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000A8) enable clock in sleep mode                                 */
    
    struct {
      __IOM uint32_t clk_sys_clocks : 1;        /*!< [0..0] clk_sys_clocks                                                     */
      __IOM uint32_t clk_adc_adc : 1;           /*!< [1..1] clk_adc_adc                                                        */
      __IOM uint32_t clk_sys_adc : 1;           /*!< [2..2] clk_sys_adc                                                        */
      __IOM uint32_t clk_sys_busctrl : 1;       /*!< [3..3] clk_sys_busctrl                                                    */
      __IOM uint32_t clk_sys_busfabric : 1;     /*!< [4..4] clk_sys_busfabric                                                  */
      __IOM uint32_t clk_sys_dma : 1;           /*!< [5..5] clk_sys_dma                                                        */
      __IOM uint32_t clk_sys_i2c0 : 1;          /*!< [6..6] clk_sys_i2c0                                                       */
      __IOM uint32_t clk_sys_i2c1 : 1;          /*!< [7..7] clk_sys_i2c1                                                       */
      __IOM uint32_t clk_sys_io : 1;            /*!< [8..8] clk_sys_io                                                         */
      __IOM uint32_t clk_sys_jtag : 1;          /*!< [9..9] clk_sys_jtag                                                       */
      __IOM uint32_t clk_sys_vreg_and_chip_reset : 1;/*!< [10..10] clk_sys_vreg_and_chip_reset                                 */
      __IOM uint32_t clk_sys_pads : 1;          /*!< [11..11] clk_sys_pads                                                     */
      __IOM uint32_t clk_sys_pio0 : 1;          /*!< [12..12] clk_sys_pio0                                                     */
      __IOM uint32_t clk_sys_pio1 : 1;          /*!< [13..13] clk_sys_pio1                                                     */
      __IOM uint32_t clk_sys_pll_sys : 1;       /*!< [14..14] clk_sys_pll_sys                                                  */
      __IOM uint32_t clk_sys_pll_usb : 1;       /*!< [15..15] clk_sys_pll_usb                                                  */
      __IOM uint32_t clk_sys_psm : 1;           /*!< [16..16] clk_sys_psm                                                      */
      __IOM uint32_t clk_sys_pwm : 1;           /*!< [17..17] clk_sys_pwm                                                      */
      __IOM uint32_t clk_sys_resets : 1;        /*!< [18..18] clk_sys_resets                                                   */
      __IOM uint32_t clk_sys_rom : 1;           /*!< [19..19] clk_sys_rom                                                      */
      __IOM uint32_t clk_sys_rosc : 1;          /*!< [20..20] clk_sys_rosc                                                     */
      __IOM uint32_t clk_rtc_rtc : 1;           /*!< [21..21] clk_rtc_rtc                                                      */
      __IOM uint32_t clk_sys_rtc : 1;           /*!< [22..22] clk_sys_rtc                                                      */
      __IOM uint32_t clk_sys_sio : 1;           /*!< [23..23] clk_sys_sio                                                      */
      __IOM uint32_t clk_peri_spi0 : 1;         /*!< [24..24] clk_peri_spi0                                                    */
      __IOM uint32_t clk_sys_spi0 : 1;          /*!< [25..25] clk_sys_spi0                                                     */
      __IOM uint32_t clk_peri_spi1 : 1;         /*!< [26..26] clk_peri_spi1                                                    */
      __IOM uint32_t clk_sys_spi1 : 1;          /*!< [27..27] clk_sys_spi1                                                     */
      __IOM uint32_t clk_sys_sram0 : 1;         /*!< [28..28] clk_sys_sram0                                                    */
      __IOM uint32_t clk_sys_sram1 : 1;         /*!< [29..29] clk_sys_sram1                                                    */
      __IOM uint32_t clk_sys_sram2 : 1;         /*!< [30..30] clk_sys_sram2                                                    */
      __IOM uint32_t clk_sys_sram3 : 1;         /*!< [31..31] clk_sys_sram3                                                    */
    } bit;
  } SLEEP_EN0;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000AC) enable clock in sleep mode                                 */
    
    struct {
      __IOM uint32_t clk_sys_sram4 : 1;         /*!< [0..0] clk_sys_sram4                                                      */
      __IOM uint32_t clk_sys_sram5 : 1;         /*!< [1..1] clk_sys_sram5                                                      */
      __IOM uint32_t clk_sys_syscfg : 1;        /*!< [2..2] clk_sys_syscfg                                                     */
      __IOM uint32_t clk_sys_sysinfo : 1;       /*!< [3..3] clk_sys_sysinfo                                                    */
      __IOM uint32_t clk_sys_tbman : 1;         /*!< [4..4] clk_sys_tbman                                                      */
      __IOM uint32_t clk_sys_timer : 1;         /*!< [5..5] clk_sys_timer                                                      */
      __IOM uint32_t clk_peri_uart0 : 1;        /*!< [6..6] clk_peri_uart0                                                     */
      __IOM uint32_t clk_sys_uart0 : 1;         /*!< [7..7] clk_sys_uart0                                                      */
      __IOM uint32_t clk_peri_uart1 : 1;        /*!< [8..8] clk_peri_uart1                                                     */
      __IOM uint32_t clk_sys_uart1 : 1;         /*!< [9..9] clk_sys_uart1                                                      */
      __IOM uint32_t clk_sys_usbctrl : 1;       /*!< [10..10] clk_sys_usbctrl                                                  */
      __IOM uint32_t clk_usb_usbctrl : 1;       /*!< [11..11] clk_usb_usbctrl                                                  */
      __IOM uint32_t clk_sys_watchdog : 1;      /*!< [12..12] clk_sys_watchdog                                                 */
      __IOM uint32_t clk_sys_xip : 1;           /*!< [13..13] clk_sys_xip                                                      */
      __IOM uint32_t clk_sys_xosc : 1;          /*!< [14..14] clk_sys_xosc                                                     */
            uint32_t            : 17;
    } bit;
  } SLEEP_EN1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000B0) indicates the state of the clock enable                    */
    
    struct {
      __IM  uint32_t clk_sys_clocks : 1;        /*!< [0..0] clk_sys_clocks                                                     */
      __IM  uint32_t clk_adc_adc : 1;           /*!< [1..1] clk_adc_adc                                                        */
      __IM  uint32_t clk_sys_adc : 1;           /*!< [2..2] clk_sys_adc                                                        */
      __IM  uint32_t clk_sys_busctrl : 1;       /*!< [3..3] clk_sys_busctrl                                                    */
      __IM  uint32_t clk_sys_busfabric : 1;     /*!< [4..4] clk_sys_busfabric                                                  */
      __IM  uint32_t clk_sys_dma : 1;           /*!< [5..5] clk_sys_dma                                                        */
      __IM  uint32_t clk_sys_i2c0 : 1;          /*!< [6..6] clk_sys_i2c0                                                       */
      __IM  uint32_t clk_sys_i2c1 : 1;          /*!< [7..7] clk_sys_i2c1                                                       */
      __IM  uint32_t clk_sys_io : 1;            /*!< [8..8] clk_sys_io                                                         */
      __IM  uint32_t clk_sys_jtag : 1;          /*!< [9..9] clk_sys_jtag                                                       */
      __IM  uint32_t clk_sys_vreg_and_chip_reset : 1;/*!< [10..10] clk_sys_vreg_and_chip_reset                                 */
      __IM  uint32_t clk_sys_pads : 1;          /*!< [11..11] clk_sys_pads                                                     */
      __IM  uint32_t clk_sys_pio0 : 1;          /*!< [12..12] clk_sys_pio0                                                     */
      __IM  uint32_t clk_sys_pio1 : 1;          /*!< [13..13] clk_sys_pio1                                                     */
      __IM  uint32_t clk_sys_pll_sys : 1;       /*!< [14..14] clk_sys_pll_sys                                                  */
      __IM  uint32_t clk_sys_pll_usb : 1;       /*!< [15..15] clk_sys_pll_usb                                                  */
      __IM  uint32_t clk_sys_psm : 1;           /*!< [16..16] clk_sys_psm                                                      */
      __IM  uint32_t clk_sys_pwm : 1;           /*!< [17..17] clk_sys_pwm                                                      */
      __IM  uint32_t clk_sys_resets : 1;        /*!< [18..18] clk_sys_resets                                                   */
      __IM  uint32_t clk_sys_rom : 1;           /*!< [19..19] clk_sys_rom                                                      */
      __IM  uint32_t clk_sys_rosc : 1;          /*!< [20..20] clk_sys_rosc                                                     */
      __IM  uint32_t clk_rtc_rtc : 1;           /*!< [21..21] clk_rtc_rtc                                                      */
      __IM  uint32_t clk_sys_rtc : 1;           /*!< [22..22] clk_sys_rtc                                                      */
      __IM  uint32_t clk_sys_sio : 1;           /*!< [23..23] clk_sys_sio                                                      */
      __IM  uint32_t clk_peri_spi0 : 1;         /*!< [24..24] clk_peri_spi0                                                    */
      __IM  uint32_t clk_sys_spi0 : 1;          /*!< [25..25] clk_sys_spi0                                                     */
      __IM  uint32_t clk_peri_spi1 : 1;         /*!< [26..26] clk_peri_spi1                                                    */
      __IM  uint32_t clk_sys_spi1 : 1;          /*!< [27..27] clk_sys_spi1                                                     */
      __IM  uint32_t clk_sys_sram0 : 1;         /*!< [28..28] clk_sys_sram0                                                    */
      __IM  uint32_t clk_sys_sram1 : 1;         /*!< [29..29] clk_sys_sram1                                                    */
      __IM  uint32_t clk_sys_sram2 : 1;         /*!< [30..30] clk_sys_sram2                                                    */
      __IM  uint32_t clk_sys_sram3 : 1;         /*!< [31..31] clk_sys_sram3                                                    */
    } bit;
  } ENABLED0;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000B4) indicates the state of the clock enable                    */
    
    struct {
      __IM  uint32_t clk_sys_sram4 : 1;         /*!< [0..0] clk_sys_sram4                                                      */
      __IM  uint32_t clk_sys_sram5 : 1;         /*!< [1..1] clk_sys_sram5                                                      */
      __IM  uint32_t clk_sys_syscfg : 1;        /*!< [2..2] clk_sys_syscfg                                                     */
      __IM  uint32_t clk_sys_sysinfo : 1;       /*!< [3..3] clk_sys_sysinfo                                                    */
      __IM  uint32_t clk_sys_tbman : 1;         /*!< [4..4] clk_sys_tbman                                                      */
      __IM  uint32_t clk_sys_timer : 1;         /*!< [5..5] clk_sys_timer                                                      */
      __IM  uint32_t clk_peri_uart0 : 1;        /*!< [6..6] clk_peri_uart0                                                     */
      __IM  uint32_t clk_sys_uart0 : 1;         /*!< [7..7] clk_sys_uart0                                                      */
      __IM  uint32_t clk_peri_uart1 : 1;        /*!< [8..8] clk_peri_uart1                                                     */
      __IM  uint32_t clk_sys_uart1 : 1;         /*!< [9..9] clk_sys_uart1                                                      */
      __IM  uint32_t clk_sys_usbctrl : 1;       /*!< [10..10] clk_sys_usbctrl                                                  */
      __IM  uint32_t clk_usb_usbctrl : 1;       /*!< [11..11] clk_usb_usbctrl                                                  */
      __IM  uint32_t clk_sys_watchdog : 1;      /*!< [12..12] clk_sys_watchdog                                                 */
      __IM  uint32_t clk_sys_xip : 1;           /*!< [13..13] clk_sys_xip                                                      */
      __IM  uint32_t clk_sys_xosc : 1;          /*!< [14..14] clk_sys_xosc                                                     */
            uint32_t            : 17;
    } bit;
  } ENABLED1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000B8) Raw Interrupts                                             */
    
    struct {
      __IM  uint32_t CLK_SYS_RESUS : 1;         /*!< [0..0] CLK_SYS_RESUS                                                      */
            uint32_t            : 31;
    } bit;
  } INTR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000BC) Interrupt Enable                                           */
    
    struct {
      __IOM uint32_t CLK_SYS_RESUS : 1;         /*!< [0..0] CLK_SYS_RESUS                                                      */
            uint32_t            : 31;
    } bit;
  } INTE;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000C0) Interrupt Force                                            */
    
    struct {
      __IOM uint32_t CLK_SYS_RESUS : 1;         /*!< [0..0] CLK_SYS_RESUS                                                      */
            uint32_t            : 31;
    } bit;
  } INTF;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000C4) Interrupt status after masking & forcing                   */
    
    struct {
      __IM  uint32_t CLK_SYS_RESUS : 1;         /*!< [0..0] CLK_SYS_RESUS                                                      */
            uint32_t            : 31;
    } bit;
  } INTS;
} CLOCKS_Type;                                  /*!< Size = 200 (0xc8)                                                         */



/* =========================================================================================================================== */
/* ================                                          RESETS                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief RESETS (RESETS)
  */

typedef struct {                                /*!< (@ 0x4000C000) RESETS Structure                                           */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000000) Reset control. If a bit is set it means the peripheral
                                                                    is in reset. 0 means the peripheral's reset
                                                                    is deasserted.                                             */
    
    struct {
      __IOM uint32_t adc        : 1;            /*!< [0..0] adc                                                                */
      __IOM uint32_t busctrl    : 1;            /*!< [1..1] busctrl                                                            */
      __IOM uint32_t dma        : 1;            /*!< [2..2] dma                                                                */
      __IOM uint32_t i2c0       : 1;            /*!< [3..3] i2c0                                                               */
      __IOM uint32_t i2c1       : 1;            /*!< [4..4] i2c1                                                               */
      __IOM uint32_t io_bank0   : 1;            /*!< [5..5] io_bank0                                                           */
      __IOM uint32_t io_qspi    : 1;            /*!< [6..6] io_qspi                                                            */
      __IOM uint32_t jtag       : 1;            /*!< [7..7] jtag                                                               */
      __IOM uint32_t pads_bank0 : 1;            /*!< [8..8] pads_bank0                                                         */
      __IOM uint32_t pads_qspi  : 1;            /*!< [9..9] pads_qspi                                                          */
      __IOM uint32_t pio0       : 1;            /*!< [10..10] pio0                                                             */
      __IOM uint32_t pio1       : 1;            /*!< [11..11] pio1                                                             */
      __IOM uint32_t pll_sys    : 1;            /*!< [12..12] pll_sys                                                          */
      __IOM uint32_t pll_usb    : 1;            /*!< [13..13] pll_usb                                                          */
      __IOM uint32_t pwm        : 1;            /*!< [14..14] pwm                                                              */
      __IOM uint32_t rtc        : 1;            /*!< [15..15] rtc                                                              */
      __IOM uint32_t spi0       : 1;            /*!< [16..16] spi0                                                             */
      __IOM uint32_t spi1       : 1;            /*!< [17..17] spi1                                                             */
      __IOM uint32_t syscfg     : 1;            /*!< [18..18] syscfg                                                           */
      __IOM uint32_t sysinfo    : 1;            /*!< [19..19] sysinfo                                                          */
      __IOM uint32_t tbman      : 1;            /*!< [20..20] tbman                                                            */
      __IOM uint32_t timer      : 1;            /*!< [21..21] timer                                                            */
      __IOM uint32_t uart0      : 1;            /*!< [22..22] uart0                                                            */
      __IOM uint32_t uart1      : 1;            /*!< [23..23] uart1                                                            */
      __IOM uint32_t usbctrl    : 1;            /*!< [24..24] usbctrl                                                          */
            uint32_t            : 7;
    } bit;
  } RESET;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000004) Watchdog select. If a bit is set then the watchdog
                                                                    will reset this peripheral when the watchdog
                                                                    fires.                                                     */
    
    struct {
      __IOM uint32_t adc        : 1;            /*!< [0..0] adc                                                                */
      __IOM uint32_t busctrl    : 1;            /*!< [1..1] busctrl                                                            */
      __IOM uint32_t dma        : 1;            /*!< [2..2] dma                                                                */
      __IOM uint32_t i2c0       : 1;            /*!< [3..3] i2c0                                                               */
      __IOM uint32_t i2c1       : 1;            /*!< [4..4] i2c1                                                               */
      __IOM uint32_t io_bank0   : 1;            /*!< [5..5] io_bank0                                                           */
      __IOM uint32_t io_qspi    : 1;            /*!< [6..6] io_qspi                                                            */
      __IOM uint32_t jtag       : 1;            /*!< [7..7] jtag                                                               */
      __IOM uint32_t pads_bank0 : 1;            /*!< [8..8] pads_bank0                                                         */
      __IOM uint32_t pads_qspi  : 1;            /*!< [9..9] pads_qspi                                                          */
      __IOM uint32_t pio0       : 1;            /*!< [10..10] pio0                                                             */
      __IOM uint32_t pio1       : 1;            /*!< [11..11] pio1                                                             */
      __IOM uint32_t pll_sys    : 1;            /*!< [12..12] pll_sys                                                          */
      __IOM uint32_t pll_usb    : 1;            /*!< [13..13] pll_usb                                                          */
      __IOM uint32_t pwm        : 1;            /*!< [14..14] pwm                                                              */
      __IOM uint32_t rtc        : 1;            /*!< [15..15] rtc                                                              */
      __IOM uint32_t spi0       : 1;            /*!< [16..16] spi0                                                             */
      __IOM uint32_t spi1       : 1;            /*!< [17..17] spi1                                                             */
      __IOM uint32_t syscfg     : 1;            /*!< [18..18] syscfg                                                           */
      __IOM uint32_t sysinfo    : 1;            /*!< [19..19] sysinfo                                                          */
      __IOM uint32_t tbman      : 1;            /*!< [20..20] tbman                                                            */
      __IOM uint32_t timer      : 1;            /*!< [21..21] timer                                                            */
      __IOM uint32_t uart0      : 1;            /*!< [22..22] uart0                                                            */
      __IOM uint32_t uart1      : 1;            /*!< [23..23] uart1                                                            */
      __IOM uint32_t usbctrl    : 1;            /*!< [24..24] usbctrl                                                          */
            uint32_t            : 7;
    } bit;
  } WDSEL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000008) Reset done. If a bit is set then a reset done
                                                                    signal has been returned by the peripheral.
                                                                    This indicates that the peripheral's registers
                                                                    are ready to be accessed.                                  */
    
    struct {
      __IM  uint32_t adc        : 1;            /*!< [0..0] adc                                                                */
      __IM  uint32_t busctrl    : 1;            /*!< [1..1] busctrl                                                            */
      __IM  uint32_t dma        : 1;            /*!< [2..2] dma                                                                */
      __IM  uint32_t i2c0       : 1;            /*!< [3..3] i2c0                                                               */
      __IM  uint32_t i2c1       : 1;            /*!< [4..4] i2c1                                                               */
      __IM  uint32_t io_bank0   : 1;            /*!< [5..5] io_bank0                                                           */
      __IM  uint32_t io_qspi    : 1;            /*!< [6..6] io_qspi                                                            */
      __IM  uint32_t jtag       : 1;            /*!< [7..7] jtag                                                               */
      __IM  uint32_t pads_bank0 : 1;            /*!< [8..8] pads_bank0                                                         */
      __IM  uint32_t pads_qspi  : 1;            /*!< [9..9] pads_qspi                                                          */
      __IM  uint32_t pio0       : 1;            /*!< [10..10] pio0                                                             */
      __IM  uint32_t pio1       : 1;            /*!< [11..11] pio1                                                             */
      __IM  uint32_t pll_sys    : 1;            /*!< [12..12] pll_sys                                                          */
      __IM  uint32_t pll_usb    : 1;            /*!< [13..13] pll_usb                                                          */
      __IM  uint32_t pwm        : 1;            /*!< [14..14] pwm                                                              */
      __IM  uint32_t rtc        : 1;            /*!< [15..15] rtc                                                              */
      __IM  uint32_t spi0       : 1;            /*!< [16..16] spi0                                                             */
      __IM  uint32_t spi1       : 1;            /*!< [17..17] spi1                                                             */
      __IM  uint32_t syscfg     : 1;            /*!< [18..18] syscfg                                                           */
      __IM  uint32_t sysinfo    : 1;            /*!< [19..19] sysinfo                                                          */
      __IM  uint32_t tbman      : 1;            /*!< [20..20] tbman                                                            */
      __IM  uint32_t timer      : 1;            /*!< [21..21] timer                                                            */
      __IM  uint32_t uart0      : 1;            /*!< [22..22] uart0                                                            */
      __IM  uint32_t uart1      : 1;            /*!< [23..23] uart1                                                            */
      __IM  uint32_t usbctrl    : 1;            /*!< [24..24] usbctrl                                                          */
            uint32_t            : 7;
    } bit;
  } RESET_DONE;
} RESETS_Type;                                  /*!< Size = 12 (0xc)                                                           */



/* =========================================================================================================================== */
/* ================                                            PSM                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief PSM (PSM)
  */

typedef struct {                                /*!< (@ 0x40010000) PSM Structure                                              */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000000) Force block out of reset (i.e. power it on)                */
    
    struct {
      __IOM uint32_t rosc       : 1;            /*!< [0..0] rosc                                                               */
      __IOM uint32_t xosc       : 1;            /*!< [1..1] xosc                                                               */
      __IOM uint32_t clocks     : 1;            /*!< [2..2] clocks                                                             */
      __IOM uint32_t resets     : 1;            /*!< [3..3] resets                                                             */
      __IOM uint32_t busfabric  : 1;            /*!< [4..4] busfabric                                                          */
      __IOM uint32_t rom        : 1;            /*!< [5..5] rom                                                                */
      __IOM uint32_t sram0      : 1;            /*!< [6..6] sram0                                                              */
      __IOM uint32_t sram1      : 1;            /*!< [7..7] sram1                                                              */
      __IOM uint32_t sram2      : 1;            /*!< [8..8] sram2                                                              */
      __IOM uint32_t sram3      : 1;            /*!< [9..9] sram3                                                              */
      __IOM uint32_t sram4      : 1;            /*!< [10..10] sram4                                                            */
      __IOM uint32_t sram5      : 1;            /*!< [11..11] sram5                                                            */
      __IOM uint32_t xip        : 1;            /*!< [12..12] xip                                                              */
      __IOM uint32_t vreg_and_chip_reset : 1;   /*!< [13..13] vreg_and_chip_reset                                              */
      __IOM uint32_t sio        : 1;            /*!< [14..14] sio                                                              */
      __IOM uint32_t proc0      : 1;            /*!< [15..15] proc0                                                            */
      __IOM uint32_t proc1      : 1;            /*!< [16..16] proc1                                                            */
            uint32_t            : 15;
    } bit;
  } FRCE_ON;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000004) Force into reset (i.e. power it off)                       */
    
    struct {
      __IOM uint32_t rosc       : 1;            /*!< [0..0] rosc                                                               */
      __IOM uint32_t xosc       : 1;            /*!< [1..1] xosc                                                               */
      __IOM uint32_t clocks     : 1;            /*!< [2..2] clocks                                                             */
      __IOM uint32_t resets     : 1;            /*!< [3..3] resets                                                             */
      __IOM uint32_t busfabric  : 1;            /*!< [4..4] busfabric                                                          */
      __IOM uint32_t rom        : 1;            /*!< [5..5] rom                                                                */
      __IOM uint32_t sram0      : 1;            /*!< [6..6] sram0                                                              */
      __IOM uint32_t sram1      : 1;            /*!< [7..7] sram1                                                              */
      __IOM uint32_t sram2      : 1;            /*!< [8..8] sram2                                                              */
      __IOM uint32_t sram3      : 1;            /*!< [9..9] sram3                                                              */
      __IOM uint32_t sram4      : 1;            /*!< [10..10] sram4                                                            */
      __IOM uint32_t sram5      : 1;            /*!< [11..11] sram5                                                            */
      __IOM uint32_t xip        : 1;            /*!< [12..12] xip                                                              */
      __IOM uint32_t vreg_and_chip_reset : 1;   /*!< [13..13] vreg_and_chip_reset                                              */
      __IOM uint32_t sio        : 1;            /*!< [14..14] sio                                                              */
      __IOM uint32_t proc0      : 1;            /*!< [15..15] proc0                                                            */
      __IOM uint32_t proc1      : 1;            /*!< [16..16] proc1                                                            */
            uint32_t            : 15;
    } bit;
  } FRCE_OFF;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000008) Set to 1 if this peripheral should be reset when
                                                                    the watchdog fires.                                        */
    
    struct {
      __IOM uint32_t rosc       : 1;            /*!< [0..0] rosc                                                               */
      __IOM uint32_t xosc       : 1;            /*!< [1..1] xosc                                                               */
      __IOM uint32_t clocks     : 1;            /*!< [2..2] clocks                                                             */
      __IOM uint32_t resets     : 1;            /*!< [3..3] resets                                                             */
      __IOM uint32_t busfabric  : 1;            /*!< [4..4] busfabric                                                          */
      __IOM uint32_t rom        : 1;            /*!< [5..5] rom                                                                */
      __IOM uint32_t sram0      : 1;            /*!< [6..6] sram0                                                              */
      __IOM uint32_t sram1      : 1;            /*!< [7..7] sram1                                                              */
      __IOM uint32_t sram2      : 1;            /*!< [8..8] sram2                                                              */
      __IOM uint32_t sram3      : 1;            /*!< [9..9] sram3                                                              */
      __IOM uint32_t sram4      : 1;            /*!< [10..10] sram4                                                            */
      __IOM uint32_t sram5      : 1;            /*!< [11..11] sram5                                                            */
      __IOM uint32_t xip        : 1;            /*!< [12..12] xip                                                              */
      __IOM uint32_t vreg_and_chip_reset : 1;   /*!< [13..13] vreg_and_chip_reset                                              */
      __IOM uint32_t sio        : 1;            /*!< [14..14] sio                                                              */
      __IOM uint32_t proc0      : 1;            /*!< [15..15] proc0                                                            */
      __IOM uint32_t proc1      : 1;            /*!< [16..16] proc1                                                            */
            uint32_t            : 15;
    } bit;
  } WDSEL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000000C) Indicates the peripheral's registers are ready
                                                                    to access.                                                 */
    
    struct {
      __IM  uint32_t rosc       : 1;            /*!< [0..0] rosc                                                               */
      __IM  uint32_t xosc       : 1;            /*!< [1..1] xosc                                                               */
      __IM  uint32_t clocks     : 1;            /*!< [2..2] clocks                                                             */
      __IM  uint32_t resets     : 1;            /*!< [3..3] resets                                                             */
      __IM  uint32_t busfabric  : 1;            /*!< [4..4] busfabric                                                          */
      __IM  uint32_t rom        : 1;            /*!< [5..5] rom                                                                */
      __IM  uint32_t sram0      : 1;            /*!< [6..6] sram0                                                              */
      __IM  uint32_t sram1      : 1;            /*!< [7..7] sram1                                                              */
      __IM  uint32_t sram2      : 1;            /*!< [8..8] sram2                                                              */
      __IM  uint32_t sram3      : 1;            /*!< [9..9] sram3                                                              */
      __IM  uint32_t sram4      : 1;            /*!< [10..10] sram4                                                            */
      __IM  uint32_t sram5      : 1;            /*!< [11..11] sram5                                                            */
      __IM  uint32_t xip        : 1;            /*!< [12..12] xip                                                              */
      __IM  uint32_t vreg_and_chip_reset : 1;   /*!< [13..13] vreg_and_chip_reset                                              */
      __IM  uint32_t sio        : 1;            /*!< [14..14] sio                                                              */
      __IM  uint32_t proc0      : 1;            /*!< [15..15] proc0                                                            */
      __IM  uint32_t proc1      : 1;            /*!< [16..16] proc1                                                            */
            uint32_t            : 15;
    } bit;
  } DONE;
} PSM_Type;                                     /*!< Size = 16 (0x10)                                                          */



/* =========================================================================================================================== */
/* ================                                         IO_BANK0                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief IO_BANK0 (IO_BANK0)
  */

typedef struct {                                /*!< (@ 0x40014000) IO_BANK0 Structure                                         */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000000) GPIO status                                                */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied            */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied          */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied                */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied            */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied                    */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied               */
            uint32_t            : 5;
    } bit;
  } GPIO0_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000004) GPIO control including function select and overrides.      */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table
                                                     31 == NULL                                                                */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER                                                            */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER                                                           */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER                                                           */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER                                                          */
            uint32_t            : 2;
    } bit;
  } GPIO0_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000008) GPIO status                                                */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied            */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied          */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied                */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied            */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied                    */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied               */
            uint32_t            : 5;
    } bit;
  } GPIO1_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000000C) GPIO control including function select and overrides.      */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table
                                                     31 == NULL                                                                */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER                                                            */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER                                                           */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER                                                           */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER                                                          */
            uint32_t            : 2;
    } bit;
  } GPIO1_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000010) GPIO status                                                */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied            */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied          */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied                */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied            */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied                    */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied               */
            uint32_t            : 5;
    } bit;
  } GPIO2_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000014) GPIO control including function select and overrides.      */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table
                                                     31 == NULL                                                                */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER                                                            */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER                                                           */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER                                                           */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER                                                          */
            uint32_t            : 2;
    } bit;
  } GPIO2_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000018) GPIO status                                                */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied            */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied          */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied                */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied            */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied                    */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied               */
            uint32_t            : 5;
    } bit;
  } GPIO3_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000001C) GPIO control including function select and overrides.      */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table
                                                     31 == NULL                                                                */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER                                                            */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER                                                           */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER                                                           */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER                                                          */
            uint32_t            : 2;
    } bit;
  } GPIO3_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000020) GPIO status                                                */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied            */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied          */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied                */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied            */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied                    */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied               */
            uint32_t            : 5;
    } bit;
  } GPIO4_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000024) GPIO control including function select and overrides.      */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table
                                                     31 == NULL                                                                */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER                                                            */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER                                                           */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER                                                           */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER                                                          */
            uint32_t            : 2;
    } bit;
  } GPIO4_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000028) GPIO status                                                */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied            */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied          */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied                */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied            */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied                    */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied               */
            uint32_t            : 5;
    } bit;
  } GPIO5_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000002C) GPIO control including function select and overrides.      */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table
                                                     31 == NULL                                                                */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER                                                            */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER                                                           */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER                                                           */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER                                                          */
            uint32_t            : 2;
    } bit;
  } GPIO5_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000030) GPIO status                                                */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied            */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied          */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied                */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied            */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied                    */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied               */
            uint32_t            : 5;
    } bit;
  } GPIO6_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000034) GPIO control including function select and overrides.      */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table
                                                     31 == NULL                                                                */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER                                                            */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER                                                           */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER                                                           */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER                                                          */
            uint32_t            : 2;
    } bit;
  } GPIO6_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000038) GPIO status                                                */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied            */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied          */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied                */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied            */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied                    */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied               */
            uint32_t            : 5;
    } bit;
  } GPIO7_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000003C) GPIO control including function select and overrides.      */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table
                                                     31 == NULL                                                                */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER                                                            */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER                                                           */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER                                                           */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER                                                          */
            uint32_t            : 2;
    } bit;
  } GPIO7_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000040) GPIO status                                                */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied            */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied          */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied                */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied            */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied                    */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied               */
            uint32_t            : 5;
    } bit;
  } GPIO8_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000044) GPIO control including function select and overrides.      */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table
                                                     31 == NULL                                                                */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER                                                            */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER                                                           */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER                                                           */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER                                                          */
            uint32_t            : 2;
    } bit;
  } GPIO8_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000048) GPIO status                                                */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied            */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied          */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied                */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied            */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied                    */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied               */
            uint32_t            : 5;
    } bit;
  } GPIO9_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000004C) GPIO control including function select and overrides.      */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table
                                                     31 == NULL                                                                */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER                                                            */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER                                                           */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER                                                           */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER                                                          */
            uint32_t            : 2;
    } bit;
  } GPIO9_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000050) GPIO status                                                */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied            */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied          */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied                */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied            */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied                    */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied               */
            uint32_t            : 5;
    } bit;
  } GPIO10_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000054) GPIO control including function select and overrides.      */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table
                                                     31 == NULL                                                                */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER                                                            */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER                                                           */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER                                                           */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER                                                          */
            uint32_t            : 2;
    } bit;
  } GPIO10_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000058) GPIO status                                                */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied            */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied          */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied                */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied            */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied                    */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied               */
            uint32_t            : 5;
    } bit;
  } GPIO11_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000005C) GPIO control including function select and overrides.      */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table
                                                     31 == NULL                                                                */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER                                                            */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER                                                           */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER                                                           */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER                                                          */
            uint32_t            : 2;
    } bit;
  } GPIO11_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000060) GPIO status                                                */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied            */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied          */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied                */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied            */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied                    */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied               */
            uint32_t            : 5;
    } bit;
  } GPIO12_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000064) GPIO control including function select and overrides.      */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table
                                                     31 == NULL                                                                */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER                                                            */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER                                                           */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER                                                           */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER                                                          */
            uint32_t            : 2;
    } bit;
  } GPIO12_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000068) GPIO status                                                */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied            */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied          */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied                */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied            */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied                    */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied               */
            uint32_t            : 5;
    } bit;
  } GPIO13_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000006C) GPIO control including function select and overrides.      */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table
                                                     31 == NULL                                                                */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER                                                            */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER                                                           */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER                                                           */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER                                                          */
            uint32_t            : 2;
    } bit;
  } GPIO13_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000070) GPIO status                                                */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied            */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied          */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied                */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied            */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied                    */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied               */
            uint32_t            : 5;
    } bit;
  } GPIO14_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000074) GPIO control including function select and overrides.      */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table
                                                     31 == NULL                                                                */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER                                                            */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER                                                           */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER                                                           */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER                                                          */
            uint32_t            : 2;
    } bit;
  } GPIO14_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000078) GPIO status                                                */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied            */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied          */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied                */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied            */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied                    */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied               */
            uint32_t            : 5;
    } bit;
  } GPIO15_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000007C) GPIO control including function select and overrides.      */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table
                                                     31 == NULL                                                                */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER                                                            */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER                                                           */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER                                                           */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER                                                          */
            uint32_t            : 2;
    } bit;
  } GPIO15_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000080) GPIO status                                                */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied            */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied          */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied                */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied            */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied                    */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied               */
            uint32_t            : 5;
    } bit;
  } GPIO16_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000084) GPIO control including function select and overrides.      */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table
                                                     31 == NULL                                                                */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER                                                            */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER                                                           */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER                                                           */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER                                                          */
            uint32_t            : 2;
    } bit;
  } GPIO16_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000088) GPIO status                                                */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied            */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied          */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied                */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied            */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied                    */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied               */
            uint32_t            : 5;
    } bit;
  } GPIO17_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000008C) GPIO control including function select and overrides.      */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table
                                                     31 == NULL                                                                */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER                                                            */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER                                                           */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER                                                           */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER                                                          */
            uint32_t            : 2;
    } bit;
  } GPIO17_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000090) GPIO status                                                */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied            */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied          */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied                */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied            */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied                    */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied               */
            uint32_t            : 5;
    } bit;
  } GPIO18_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000094) GPIO control including function select and overrides.      */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table
                                                     31 == NULL                                                                */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER                                                            */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER                                                           */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER                                                           */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER                                                          */
            uint32_t            : 2;
    } bit;
  } GPIO18_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000098) GPIO status                                                */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied            */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied          */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied                */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied            */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied                    */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied               */
            uint32_t            : 5;
    } bit;
  } GPIO19_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000009C) GPIO control including function select and overrides.      */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table
                                                     31 == NULL                                                                */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER                                                            */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER                                                           */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER                                                           */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER                                                          */
            uint32_t            : 2;
    } bit;
  } GPIO19_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000A0) GPIO status                                                */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied            */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied          */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied                */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied            */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied                    */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied               */
            uint32_t            : 5;
    } bit;
  } GPIO20_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000A4) GPIO control including function select and overrides.      */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table
                                                     31 == NULL                                                                */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER                                                            */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER                                                           */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER                                                           */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER                                                          */
            uint32_t            : 2;
    } bit;
  } GPIO20_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000A8) GPIO status                                                */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied            */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied          */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied                */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied            */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied                    */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied               */
            uint32_t            : 5;
    } bit;
  } GPIO21_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000AC) GPIO control including function select and overrides.      */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table
                                                     31 == NULL                                                                */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER                                                            */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER                                                           */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER                                                           */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER                                                          */
            uint32_t            : 2;
    } bit;
  } GPIO21_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000B0) GPIO status                                                */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied            */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied          */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied                */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied            */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied                    */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied               */
            uint32_t            : 5;
    } bit;
  } GPIO22_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000B4) GPIO control including function select and overrides.      */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table
                                                     31 == NULL                                                                */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER                                                            */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER                                                           */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER                                                           */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER                                                          */
            uint32_t            : 2;
    } bit;
  } GPIO22_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000B8) GPIO status                                                */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied            */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied          */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied                */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied            */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied                    */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied               */
            uint32_t            : 5;
    } bit;
  } GPIO23_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000BC) GPIO control including function select and overrides.      */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table
                                                     31 == NULL                                                                */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER                                                            */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER                                                           */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER                                                           */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER                                                          */
            uint32_t            : 2;
    } bit;
  } GPIO23_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000C0) GPIO status                                                */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied            */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied          */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied                */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied            */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied                    */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied               */
            uint32_t            : 5;
    } bit;
  } GPIO24_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000C4) GPIO control including function select and overrides.      */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table
                                                     31 == NULL                                                                */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER                                                            */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER                                                           */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER                                                           */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER                                                          */
            uint32_t            : 2;
    } bit;
  } GPIO24_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000C8) GPIO status                                                */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied            */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied          */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied                */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied            */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied                    */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied               */
            uint32_t            : 5;
    } bit;
  } GPIO25_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000CC) GPIO control including function select and overrides.      */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table
                                                     31 == NULL                                                                */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER                                                            */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER                                                           */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER                                                           */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER                                                          */
            uint32_t            : 2;
    } bit;
  } GPIO25_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000D0) GPIO status                                                */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied            */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied          */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied                */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied            */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied                    */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied               */
            uint32_t            : 5;
    } bit;
  } GPIO26_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000D4) GPIO control including function select and overrides.      */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table
                                                     31 == NULL                                                                */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER                                                            */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER                                                           */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER                                                           */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER                                                          */
            uint32_t            : 2;
    } bit;
  } GPIO26_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000D8) GPIO status                                                */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied            */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied          */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied                */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied            */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied                    */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied               */
            uint32_t            : 5;
    } bit;
  } GPIO27_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000DC) GPIO control including function select and overrides.      */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table
                                                     31 == NULL                                                                */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER                                                            */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER                                                           */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER                                                           */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER                                                          */
            uint32_t            : 2;
    } bit;
  } GPIO27_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000E0) GPIO status                                                */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied            */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied          */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied                */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied            */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied                    */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied               */
            uint32_t            : 5;
    } bit;
  } GPIO28_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000E4) GPIO control including function select and overrides.      */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table
                                                     31 == NULL                                                                */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER                                                            */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER                                                           */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER                                                           */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER                                                          */
            uint32_t            : 2;
    } bit;
  } GPIO28_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000E8) GPIO status                                                */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied            */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied          */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied                */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied            */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied                    */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied               */
            uint32_t            : 5;
    } bit;
  } GPIO29_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000EC) GPIO control including function select and overrides.      */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table
                                                     31 == NULL                                                                */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER                                                            */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER                                                           */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER                                                           */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER                                                          */
            uint32_t            : 2;
    } bit;
  } GPIO29_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000F0) Raw Interrupts                                             */
    
    struct {
      __IM  uint32_t GPIO0_LEVEL_LOW : 1;       /*!< [0..0] GPIO0_LEVEL_LOW                                                    */
      __IM  uint32_t GPIO0_LEVEL_HIGH : 1;      /*!< [1..1] GPIO0_LEVEL_HIGH                                                   */
      __IOM uint32_t GPIO0_EDGE_LOW : 1;        /*!< [2..2] GPIO0_EDGE_LOW                                                     */
      __IOM uint32_t GPIO0_EDGE_HIGH : 1;       /*!< [3..3] GPIO0_EDGE_HIGH                                                    */
      __IM  uint32_t GPIO1_LEVEL_LOW : 1;       /*!< [4..4] GPIO1_LEVEL_LOW                                                    */
      __IM  uint32_t GPIO1_LEVEL_HIGH : 1;      /*!< [5..5] GPIO1_LEVEL_HIGH                                                   */
      __IOM uint32_t GPIO1_EDGE_LOW : 1;        /*!< [6..6] GPIO1_EDGE_LOW                                                     */
      __IOM uint32_t GPIO1_EDGE_HIGH : 1;       /*!< [7..7] GPIO1_EDGE_HIGH                                                    */
      __IM  uint32_t GPIO2_LEVEL_LOW : 1;       /*!< [8..8] GPIO2_LEVEL_LOW                                                    */
      __IM  uint32_t GPIO2_LEVEL_HIGH : 1;      /*!< [9..9] GPIO2_LEVEL_HIGH                                                   */
      __IOM uint32_t GPIO2_EDGE_LOW : 1;        /*!< [10..10] GPIO2_EDGE_LOW                                                   */
      __IOM uint32_t GPIO2_EDGE_HIGH : 1;       /*!< [11..11] GPIO2_EDGE_HIGH                                                  */
      __IM  uint32_t GPIO3_LEVEL_LOW : 1;       /*!< [12..12] GPIO3_LEVEL_LOW                                                  */
      __IM  uint32_t GPIO3_LEVEL_HIGH : 1;      /*!< [13..13] GPIO3_LEVEL_HIGH                                                 */
      __IOM uint32_t GPIO3_EDGE_LOW : 1;        /*!< [14..14] GPIO3_EDGE_LOW                                                   */
      __IOM uint32_t GPIO3_EDGE_HIGH : 1;       /*!< [15..15] GPIO3_EDGE_HIGH                                                  */
      __IM  uint32_t GPIO4_LEVEL_LOW : 1;       /*!< [16..16] GPIO4_LEVEL_LOW                                                  */
      __IM  uint32_t GPIO4_LEVEL_HIGH : 1;      /*!< [17..17] GPIO4_LEVEL_HIGH                                                 */
      __IOM uint32_t GPIO4_EDGE_LOW : 1;        /*!< [18..18] GPIO4_EDGE_LOW                                                   */
      __IOM uint32_t GPIO4_EDGE_HIGH : 1;       /*!< [19..19] GPIO4_EDGE_HIGH                                                  */
      __IM  uint32_t GPIO5_LEVEL_LOW : 1;       /*!< [20..20] GPIO5_LEVEL_LOW                                                  */
      __IM  uint32_t GPIO5_LEVEL_HIGH : 1;      /*!< [21..21] GPIO5_LEVEL_HIGH                                                 */
      __IOM uint32_t GPIO5_EDGE_LOW : 1;        /*!< [22..22] GPIO5_EDGE_LOW                                                   */
      __IOM uint32_t GPIO5_EDGE_HIGH : 1;       /*!< [23..23] GPIO5_EDGE_HIGH                                                  */
      __IM  uint32_t GPIO6_LEVEL_LOW : 1;       /*!< [24..24] GPIO6_LEVEL_LOW                                                  */
      __IM  uint32_t GPIO6_LEVEL_HIGH : 1;      /*!< [25..25] GPIO6_LEVEL_HIGH                                                 */
      __IOM uint32_t GPIO6_EDGE_LOW : 1;        /*!< [26..26] GPIO6_EDGE_LOW                                                   */
      __IOM uint32_t GPIO6_EDGE_HIGH : 1;       /*!< [27..27] GPIO6_EDGE_HIGH                                                  */
      __IM  uint32_t GPIO7_LEVEL_LOW : 1;       /*!< [28..28] GPIO7_LEVEL_LOW                                                  */
      __IM  uint32_t GPIO7_LEVEL_HIGH : 1;      /*!< [29..29] GPIO7_LEVEL_HIGH                                                 */
      __IOM uint32_t GPIO7_EDGE_LOW : 1;        /*!< [30..30] GPIO7_EDGE_LOW                                                   */
      __IOM uint32_t GPIO7_EDGE_HIGH : 1;       /*!< [31..31] GPIO7_EDGE_HIGH                                                  */
    } bit;
  } INTR0;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000F4) Raw Interrupts                                             */
    
    struct {
      __IM  uint32_t GPIO8_LEVEL_LOW : 1;       /*!< [0..0] GPIO8_LEVEL_LOW                                                    */
      __IM  uint32_t GPIO8_LEVEL_HIGH : 1;      /*!< [1..1] GPIO8_LEVEL_HIGH                                                   */
      __IOM uint32_t GPIO8_EDGE_LOW : 1;        /*!< [2..2] GPIO8_EDGE_LOW                                                     */
      __IOM uint32_t GPIO8_EDGE_HIGH : 1;       /*!< [3..3] GPIO8_EDGE_HIGH                                                    */
      __IM  uint32_t GPIO9_LEVEL_LOW : 1;       /*!< [4..4] GPIO9_LEVEL_LOW                                                    */
      __IM  uint32_t GPIO9_LEVEL_HIGH : 1;      /*!< [5..5] GPIO9_LEVEL_HIGH                                                   */
      __IOM uint32_t GPIO9_EDGE_LOW : 1;        /*!< [6..6] GPIO9_EDGE_LOW                                                     */
      __IOM uint32_t GPIO9_EDGE_HIGH : 1;       /*!< [7..7] GPIO9_EDGE_HIGH                                                    */
      __IM  uint32_t GPIO10_LEVEL_LOW : 1;      /*!< [8..8] GPIO10_LEVEL_LOW                                                   */
      __IM  uint32_t GPIO10_LEVEL_HIGH : 1;     /*!< [9..9] GPIO10_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO10_EDGE_LOW : 1;       /*!< [10..10] GPIO10_EDGE_LOW                                                  */
      __IOM uint32_t GPIO10_EDGE_HIGH : 1;      /*!< [11..11] GPIO10_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO11_LEVEL_LOW : 1;      /*!< [12..12] GPIO11_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO11_LEVEL_HIGH : 1;     /*!< [13..13] GPIO11_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO11_EDGE_LOW : 1;       /*!< [14..14] GPIO11_EDGE_LOW                                                  */
      __IOM uint32_t GPIO11_EDGE_HIGH : 1;      /*!< [15..15] GPIO11_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO12_LEVEL_LOW : 1;      /*!< [16..16] GPIO12_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO12_LEVEL_HIGH : 1;     /*!< [17..17] GPIO12_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO12_EDGE_LOW : 1;       /*!< [18..18] GPIO12_EDGE_LOW                                                  */
      __IOM uint32_t GPIO12_EDGE_HIGH : 1;      /*!< [19..19] GPIO12_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO13_LEVEL_LOW : 1;      /*!< [20..20] GPIO13_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO13_LEVEL_HIGH : 1;     /*!< [21..21] GPIO13_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO13_EDGE_LOW : 1;       /*!< [22..22] GPIO13_EDGE_LOW                                                  */
      __IOM uint32_t GPIO13_EDGE_HIGH : 1;      /*!< [23..23] GPIO13_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO14_LEVEL_LOW : 1;      /*!< [24..24] GPIO14_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO14_LEVEL_HIGH : 1;     /*!< [25..25] GPIO14_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO14_EDGE_LOW : 1;       /*!< [26..26] GPIO14_EDGE_LOW                                                  */
      __IOM uint32_t GPIO14_EDGE_HIGH : 1;      /*!< [27..27] GPIO14_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO15_LEVEL_LOW : 1;      /*!< [28..28] GPIO15_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO15_LEVEL_HIGH : 1;     /*!< [29..29] GPIO15_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO15_EDGE_LOW : 1;       /*!< [30..30] GPIO15_EDGE_LOW                                                  */
      __IOM uint32_t GPIO15_EDGE_HIGH : 1;      /*!< [31..31] GPIO15_EDGE_HIGH                                                 */
    } bit;
  } INTR1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000F8) Raw Interrupts                                             */
    
    struct {
      __IM  uint32_t GPIO16_LEVEL_LOW : 1;      /*!< [0..0] GPIO16_LEVEL_LOW                                                   */
      __IM  uint32_t GPIO16_LEVEL_HIGH : 1;     /*!< [1..1] GPIO16_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO16_EDGE_LOW : 1;       /*!< [2..2] GPIO16_EDGE_LOW                                                    */
      __IOM uint32_t GPIO16_EDGE_HIGH : 1;      /*!< [3..3] GPIO16_EDGE_HIGH                                                   */
      __IM  uint32_t GPIO17_LEVEL_LOW : 1;      /*!< [4..4] GPIO17_LEVEL_LOW                                                   */
      __IM  uint32_t GPIO17_LEVEL_HIGH : 1;     /*!< [5..5] GPIO17_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO17_EDGE_LOW : 1;       /*!< [6..6] GPIO17_EDGE_LOW                                                    */
      __IOM uint32_t GPIO17_EDGE_HIGH : 1;      /*!< [7..7] GPIO17_EDGE_HIGH                                                   */
      __IM  uint32_t GPIO18_LEVEL_LOW : 1;      /*!< [8..8] GPIO18_LEVEL_LOW                                                   */
      __IM  uint32_t GPIO18_LEVEL_HIGH : 1;     /*!< [9..9] GPIO18_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO18_EDGE_LOW : 1;       /*!< [10..10] GPIO18_EDGE_LOW                                                  */
      __IOM uint32_t GPIO18_EDGE_HIGH : 1;      /*!< [11..11] GPIO18_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO19_LEVEL_LOW : 1;      /*!< [12..12] GPIO19_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO19_LEVEL_HIGH : 1;     /*!< [13..13] GPIO19_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO19_EDGE_LOW : 1;       /*!< [14..14] GPIO19_EDGE_LOW                                                  */
      __IOM uint32_t GPIO19_EDGE_HIGH : 1;      /*!< [15..15] GPIO19_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO20_LEVEL_LOW : 1;      /*!< [16..16] GPIO20_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO20_LEVEL_HIGH : 1;     /*!< [17..17] GPIO20_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO20_EDGE_LOW : 1;       /*!< [18..18] GPIO20_EDGE_LOW                                                  */
      __IOM uint32_t GPIO20_EDGE_HIGH : 1;      /*!< [19..19] GPIO20_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO21_LEVEL_LOW : 1;      /*!< [20..20] GPIO21_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO21_LEVEL_HIGH : 1;     /*!< [21..21] GPIO21_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO21_EDGE_LOW : 1;       /*!< [22..22] GPIO21_EDGE_LOW                                                  */
      __IOM uint32_t GPIO21_EDGE_HIGH : 1;      /*!< [23..23] GPIO21_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO22_LEVEL_LOW : 1;      /*!< [24..24] GPIO22_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO22_LEVEL_HIGH : 1;     /*!< [25..25] GPIO22_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO22_EDGE_LOW : 1;       /*!< [26..26] GPIO22_EDGE_LOW                                                  */
      __IOM uint32_t GPIO22_EDGE_HIGH : 1;      /*!< [27..27] GPIO22_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO23_LEVEL_LOW : 1;      /*!< [28..28] GPIO23_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO23_LEVEL_HIGH : 1;     /*!< [29..29] GPIO23_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO23_EDGE_LOW : 1;       /*!< [30..30] GPIO23_EDGE_LOW                                                  */
      __IOM uint32_t GPIO23_EDGE_HIGH : 1;      /*!< [31..31] GPIO23_EDGE_HIGH                                                 */
    } bit;
  } INTR2;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000FC) Raw Interrupts                                             */
    
    struct {
      __IM  uint32_t GPIO24_LEVEL_LOW : 1;      /*!< [0..0] GPIO24_LEVEL_LOW                                                   */
      __IM  uint32_t GPIO24_LEVEL_HIGH : 1;     /*!< [1..1] GPIO24_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO24_EDGE_LOW : 1;       /*!< [2..2] GPIO24_EDGE_LOW                                                    */
      __IOM uint32_t GPIO24_EDGE_HIGH : 1;      /*!< [3..3] GPIO24_EDGE_HIGH                                                   */
      __IM  uint32_t GPIO25_LEVEL_LOW : 1;      /*!< [4..4] GPIO25_LEVEL_LOW                                                   */
      __IM  uint32_t GPIO25_LEVEL_HIGH : 1;     /*!< [5..5] GPIO25_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO25_EDGE_LOW : 1;       /*!< [6..6] GPIO25_EDGE_LOW                                                    */
      __IOM uint32_t GPIO25_EDGE_HIGH : 1;      /*!< [7..7] GPIO25_EDGE_HIGH                                                   */
      __IM  uint32_t GPIO26_LEVEL_LOW : 1;      /*!< [8..8] GPIO26_LEVEL_LOW                                                   */
      __IM  uint32_t GPIO26_LEVEL_HIGH : 1;     /*!< [9..9] GPIO26_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO26_EDGE_LOW : 1;       /*!< [10..10] GPIO26_EDGE_LOW                                                  */
      __IOM uint32_t GPIO26_EDGE_HIGH : 1;      /*!< [11..11] GPIO26_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO27_LEVEL_LOW : 1;      /*!< [12..12] GPIO27_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO27_LEVEL_HIGH : 1;     /*!< [13..13] GPIO27_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO27_EDGE_LOW : 1;       /*!< [14..14] GPIO27_EDGE_LOW                                                  */
      __IOM uint32_t GPIO27_EDGE_HIGH : 1;      /*!< [15..15] GPIO27_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO28_LEVEL_LOW : 1;      /*!< [16..16] GPIO28_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO28_LEVEL_HIGH : 1;     /*!< [17..17] GPIO28_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO28_EDGE_LOW : 1;       /*!< [18..18] GPIO28_EDGE_LOW                                                  */
      __IOM uint32_t GPIO28_EDGE_HIGH : 1;      /*!< [19..19] GPIO28_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO29_LEVEL_LOW : 1;      /*!< [20..20] GPIO29_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO29_LEVEL_HIGH : 1;     /*!< [21..21] GPIO29_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO29_EDGE_LOW : 1;       /*!< [22..22] GPIO29_EDGE_LOW                                                  */
      __IOM uint32_t GPIO29_EDGE_HIGH : 1;      /*!< [23..23] GPIO29_EDGE_HIGH                                                 */
            uint32_t            : 8;
    } bit;
  } INTR3;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000100) Interrupt Enable for proc0                                 */
    
    struct {
      __IOM uint32_t GPIO0_LEVEL_LOW : 1;       /*!< [0..0] GPIO0_LEVEL_LOW                                                    */
      __IOM uint32_t GPIO0_LEVEL_HIGH : 1;      /*!< [1..1] GPIO0_LEVEL_HIGH                                                   */
      __IOM uint32_t GPIO0_EDGE_LOW : 1;        /*!< [2..2] GPIO0_EDGE_LOW                                                     */
      __IOM uint32_t GPIO0_EDGE_HIGH : 1;       /*!< [3..3] GPIO0_EDGE_HIGH                                                    */
      __IOM uint32_t GPIO1_LEVEL_LOW : 1;       /*!< [4..4] GPIO1_LEVEL_LOW                                                    */
      __IOM uint32_t GPIO1_LEVEL_HIGH : 1;      /*!< [5..5] GPIO1_LEVEL_HIGH                                                   */
      __IOM uint32_t GPIO1_EDGE_LOW : 1;        /*!< [6..6] GPIO1_EDGE_LOW                                                     */
      __IOM uint32_t GPIO1_EDGE_HIGH : 1;       /*!< [7..7] GPIO1_EDGE_HIGH                                                    */
      __IOM uint32_t GPIO2_LEVEL_LOW : 1;       /*!< [8..8] GPIO2_LEVEL_LOW                                                    */
      __IOM uint32_t GPIO2_LEVEL_HIGH : 1;      /*!< [9..9] GPIO2_LEVEL_HIGH                                                   */
      __IOM uint32_t GPIO2_EDGE_LOW : 1;        /*!< [10..10] GPIO2_EDGE_LOW                                                   */
      __IOM uint32_t GPIO2_EDGE_HIGH : 1;       /*!< [11..11] GPIO2_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO3_LEVEL_LOW : 1;       /*!< [12..12] GPIO3_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO3_LEVEL_HIGH : 1;      /*!< [13..13] GPIO3_LEVEL_HIGH                                                 */
      __IOM uint32_t GPIO3_EDGE_LOW : 1;        /*!< [14..14] GPIO3_EDGE_LOW                                                   */
      __IOM uint32_t GPIO3_EDGE_HIGH : 1;       /*!< [15..15] GPIO3_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO4_LEVEL_LOW : 1;       /*!< [16..16] GPIO4_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO4_LEVEL_HIGH : 1;      /*!< [17..17] GPIO4_LEVEL_HIGH                                                 */
      __IOM uint32_t GPIO4_EDGE_LOW : 1;        /*!< [18..18] GPIO4_EDGE_LOW                                                   */
      __IOM uint32_t GPIO4_EDGE_HIGH : 1;       /*!< [19..19] GPIO4_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO5_LEVEL_LOW : 1;       /*!< [20..20] GPIO5_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO5_LEVEL_HIGH : 1;      /*!< [21..21] GPIO5_LEVEL_HIGH                                                 */
      __IOM uint32_t GPIO5_EDGE_LOW : 1;        /*!< [22..22] GPIO5_EDGE_LOW                                                   */
      __IOM uint32_t GPIO5_EDGE_HIGH : 1;       /*!< [23..23] GPIO5_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO6_LEVEL_LOW : 1;       /*!< [24..24] GPIO6_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO6_LEVEL_HIGH : 1;      /*!< [25..25] GPIO6_LEVEL_HIGH                                                 */
      __IOM uint32_t GPIO6_EDGE_LOW : 1;        /*!< [26..26] GPIO6_EDGE_LOW                                                   */
      __IOM uint32_t GPIO6_EDGE_HIGH : 1;       /*!< [27..27] GPIO6_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO7_LEVEL_LOW : 1;       /*!< [28..28] GPIO7_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO7_LEVEL_HIGH : 1;      /*!< [29..29] GPIO7_LEVEL_HIGH                                                 */
      __IOM uint32_t GPIO7_EDGE_LOW : 1;        /*!< [30..30] GPIO7_EDGE_LOW                                                   */
      __IOM uint32_t GPIO7_EDGE_HIGH : 1;       /*!< [31..31] GPIO7_EDGE_HIGH                                                  */
    } bit;
  } PROC0_INTE0;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000104) Interrupt Enable for proc0                                 */
    
    struct {
      __IOM uint32_t GPIO8_LEVEL_LOW : 1;       /*!< [0..0] GPIO8_LEVEL_LOW                                                    */
      __IOM uint32_t GPIO8_LEVEL_HIGH : 1;      /*!< [1..1] GPIO8_LEVEL_HIGH                                                   */
      __IOM uint32_t GPIO8_EDGE_LOW : 1;        /*!< [2..2] GPIO8_EDGE_LOW                                                     */
      __IOM uint32_t GPIO8_EDGE_HIGH : 1;       /*!< [3..3] GPIO8_EDGE_HIGH                                                    */
      __IOM uint32_t GPIO9_LEVEL_LOW : 1;       /*!< [4..4] GPIO9_LEVEL_LOW                                                    */
      __IOM uint32_t GPIO9_LEVEL_HIGH : 1;      /*!< [5..5] GPIO9_LEVEL_HIGH                                                   */
      __IOM uint32_t GPIO9_EDGE_LOW : 1;        /*!< [6..6] GPIO9_EDGE_LOW                                                     */
      __IOM uint32_t GPIO9_EDGE_HIGH : 1;       /*!< [7..7] GPIO9_EDGE_HIGH                                                    */
      __IOM uint32_t GPIO10_LEVEL_LOW : 1;      /*!< [8..8] GPIO10_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO10_LEVEL_HIGH : 1;     /*!< [9..9] GPIO10_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO10_EDGE_LOW : 1;       /*!< [10..10] GPIO10_EDGE_LOW                                                  */
      __IOM uint32_t GPIO10_EDGE_HIGH : 1;      /*!< [11..11] GPIO10_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO11_LEVEL_LOW : 1;      /*!< [12..12] GPIO11_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO11_LEVEL_HIGH : 1;     /*!< [13..13] GPIO11_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO11_EDGE_LOW : 1;       /*!< [14..14] GPIO11_EDGE_LOW                                                  */
      __IOM uint32_t GPIO11_EDGE_HIGH : 1;      /*!< [15..15] GPIO11_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO12_LEVEL_LOW : 1;      /*!< [16..16] GPIO12_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO12_LEVEL_HIGH : 1;     /*!< [17..17] GPIO12_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO12_EDGE_LOW : 1;       /*!< [18..18] GPIO12_EDGE_LOW                                                  */
      __IOM uint32_t GPIO12_EDGE_HIGH : 1;      /*!< [19..19] GPIO12_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO13_LEVEL_LOW : 1;      /*!< [20..20] GPIO13_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO13_LEVEL_HIGH : 1;     /*!< [21..21] GPIO13_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO13_EDGE_LOW : 1;       /*!< [22..22] GPIO13_EDGE_LOW                                                  */
      __IOM uint32_t GPIO13_EDGE_HIGH : 1;      /*!< [23..23] GPIO13_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO14_LEVEL_LOW : 1;      /*!< [24..24] GPIO14_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO14_LEVEL_HIGH : 1;     /*!< [25..25] GPIO14_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO14_EDGE_LOW : 1;       /*!< [26..26] GPIO14_EDGE_LOW                                                  */
      __IOM uint32_t GPIO14_EDGE_HIGH : 1;      /*!< [27..27] GPIO14_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO15_LEVEL_LOW : 1;      /*!< [28..28] GPIO15_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO15_LEVEL_HIGH : 1;     /*!< [29..29] GPIO15_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO15_EDGE_LOW : 1;       /*!< [30..30] GPIO15_EDGE_LOW                                                  */
      __IOM uint32_t GPIO15_EDGE_HIGH : 1;      /*!< [31..31] GPIO15_EDGE_HIGH                                                 */
    } bit;
  } PROC0_INTE1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000108) Interrupt Enable for proc0                                 */
    
    struct {
      __IOM uint32_t GPIO16_LEVEL_LOW : 1;      /*!< [0..0] GPIO16_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO16_LEVEL_HIGH : 1;     /*!< [1..1] GPIO16_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO16_EDGE_LOW : 1;       /*!< [2..2] GPIO16_EDGE_LOW                                                    */
      __IOM uint32_t GPIO16_EDGE_HIGH : 1;      /*!< [3..3] GPIO16_EDGE_HIGH                                                   */
      __IOM uint32_t GPIO17_LEVEL_LOW : 1;      /*!< [4..4] GPIO17_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO17_LEVEL_HIGH : 1;     /*!< [5..5] GPIO17_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO17_EDGE_LOW : 1;       /*!< [6..6] GPIO17_EDGE_LOW                                                    */
      __IOM uint32_t GPIO17_EDGE_HIGH : 1;      /*!< [7..7] GPIO17_EDGE_HIGH                                                   */
      __IOM uint32_t GPIO18_LEVEL_LOW : 1;      /*!< [8..8] GPIO18_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO18_LEVEL_HIGH : 1;     /*!< [9..9] GPIO18_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO18_EDGE_LOW : 1;       /*!< [10..10] GPIO18_EDGE_LOW                                                  */
      __IOM uint32_t GPIO18_EDGE_HIGH : 1;      /*!< [11..11] GPIO18_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO19_LEVEL_LOW : 1;      /*!< [12..12] GPIO19_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO19_LEVEL_HIGH : 1;     /*!< [13..13] GPIO19_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO19_EDGE_LOW : 1;       /*!< [14..14] GPIO19_EDGE_LOW                                                  */
      __IOM uint32_t GPIO19_EDGE_HIGH : 1;      /*!< [15..15] GPIO19_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO20_LEVEL_LOW : 1;      /*!< [16..16] GPIO20_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO20_LEVEL_HIGH : 1;     /*!< [17..17] GPIO20_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO20_EDGE_LOW : 1;       /*!< [18..18] GPIO20_EDGE_LOW                                                  */
      __IOM uint32_t GPIO20_EDGE_HIGH : 1;      /*!< [19..19] GPIO20_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO21_LEVEL_LOW : 1;      /*!< [20..20] GPIO21_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO21_LEVEL_HIGH : 1;     /*!< [21..21] GPIO21_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO21_EDGE_LOW : 1;       /*!< [22..22] GPIO21_EDGE_LOW                                                  */
      __IOM uint32_t GPIO21_EDGE_HIGH : 1;      /*!< [23..23] GPIO21_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO22_LEVEL_LOW : 1;      /*!< [24..24] GPIO22_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO22_LEVEL_HIGH : 1;     /*!< [25..25] GPIO22_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO22_EDGE_LOW : 1;       /*!< [26..26] GPIO22_EDGE_LOW                                                  */
      __IOM uint32_t GPIO22_EDGE_HIGH : 1;      /*!< [27..27] GPIO22_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO23_LEVEL_LOW : 1;      /*!< [28..28] GPIO23_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO23_LEVEL_HIGH : 1;     /*!< [29..29] GPIO23_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO23_EDGE_LOW : 1;       /*!< [30..30] GPIO23_EDGE_LOW                                                  */
      __IOM uint32_t GPIO23_EDGE_HIGH : 1;      /*!< [31..31] GPIO23_EDGE_HIGH                                                 */
    } bit;
  } PROC0_INTE2;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000010C) Interrupt Enable for proc0                                 */
    
    struct {
      __IOM uint32_t GPIO24_LEVEL_LOW : 1;      /*!< [0..0] GPIO24_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO24_LEVEL_HIGH : 1;     /*!< [1..1] GPIO24_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO24_EDGE_LOW : 1;       /*!< [2..2] GPIO24_EDGE_LOW                                                    */
      __IOM uint32_t GPIO24_EDGE_HIGH : 1;      /*!< [3..3] GPIO24_EDGE_HIGH                                                   */
      __IOM uint32_t GPIO25_LEVEL_LOW : 1;      /*!< [4..4] GPIO25_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO25_LEVEL_HIGH : 1;     /*!< [5..5] GPIO25_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO25_EDGE_LOW : 1;       /*!< [6..6] GPIO25_EDGE_LOW                                                    */
      __IOM uint32_t GPIO25_EDGE_HIGH : 1;      /*!< [7..7] GPIO25_EDGE_HIGH                                                   */
      __IOM uint32_t GPIO26_LEVEL_LOW : 1;      /*!< [8..8] GPIO26_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO26_LEVEL_HIGH : 1;     /*!< [9..9] GPIO26_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO26_EDGE_LOW : 1;       /*!< [10..10] GPIO26_EDGE_LOW                                                  */
      __IOM uint32_t GPIO26_EDGE_HIGH : 1;      /*!< [11..11] GPIO26_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO27_LEVEL_LOW : 1;      /*!< [12..12] GPIO27_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO27_LEVEL_HIGH : 1;     /*!< [13..13] GPIO27_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO27_EDGE_LOW : 1;       /*!< [14..14] GPIO27_EDGE_LOW                                                  */
      __IOM uint32_t GPIO27_EDGE_HIGH : 1;      /*!< [15..15] GPIO27_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO28_LEVEL_LOW : 1;      /*!< [16..16] GPIO28_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO28_LEVEL_HIGH : 1;     /*!< [17..17] GPIO28_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO28_EDGE_LOW : 1;       /*!< [18..18] GPIO28_EDGE_LOW                                                  */
      __IOM uint32_t GPIO28_EDGE_HIGH : 1;      /*!< [19..19] GPIO28_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO29_LEVEL_LOW : 1;      /*!< [20..20] GPIO29_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO29_LEVEL_HIGH : 1;     /*!< [21..21] GPIO29_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO29_EDGE_LOW : 1;       /*!< [22..22] GPIO29_EDGE_LOW                                                  */
      __IOM uint32_t GPIO29_EDGE_HIGH : 1;      /*!< [23..23] GPIO29_EDGE_HIGH                                                 */
            uint32_t            : 8;
    } bit;
  } PROC0_INTE3;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000110) Interrupt Force for proc0                                  */
    
    struct {
      __IOM uint32_t GPIO0_LEVEL_LOW : 1;       /*!< [0..0] GPIO0_LEVEL_LOW                                                    */
      __IOM uint32_t GPIO0_LEVEL_HIGH : 1;      /*!< [1..1] GPIO0_LEVEL_HIGH                                                   */
      __IOM uint32_t GPIO0_EDGE_LOW : 1;        /*!< [2..2] GPIO0_EDGE_LOW                                                     */
      __IOM uint32_t GPIO0_EDGE_HIGH : 1;       /*!< [3..3] GPIO0_EDGE_HIGH                                                    */
      __IOM uint32_t GPIO1_LEVEL_LOW : 1;       /*!< [4..4] GPIO1_LEVEL_LOW                                                    */
      __IOM uint32_t GPIO1_LEVEL_HIGH : 1;      /*!< [5..5] GPIO1_LEVEL_HIGH                                                   */
      __IOM uint32_t GPIO1_EDGE_LOW : 1;        /*!< [6..6] GPIO1_EDGE_LOW                                                     */
      __IOM uint32_t GPIO1_EDGE_HIGH : 1;       /*!< [7..7] GPIO1_EDGE_HIGH                                                    */
      __IOM uint32_t GPIO2_LEVEL_LOW : 1;       /*!< [8..8] GPIO2_LEVEL_LOW                                                    */
      __IOM uint32_t GPIO2_LEVEL_HIGH : 1;      /*!< [9..9] GPIO2_LEVEL_HIGH                                                   */
      __IOM uint32_t GPIO2_EDGE_LOW : 1;        /*!< [10..10] GPIO2_EDGE_LOW                                                   */
      __IOM uint32_t GPIO2_EDGE_HIGH : 1;       /*!< [11..11] GPIO2_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO3_LEVEL_LOW : 1;       /*!< [12..12] GPIO3_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO3_LEVEL_HIGH : 1;      /*!< [13..13] GPIO3_LEVEL_HIGH                                                 */
      __IOM uint32_t GPIO3_EDGE_LOW : 1;        /*!< [14..14] GPIO3_EDGE_LOW                                                   */
      __IOM uint32_t GPIO3_EDGE_HIGH : 1;       /*!< [15..15] GPIO3_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO4_LEVEL_LOW : 1;       /*!< [16..16] GPIO4_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO4_LEVEL_HIGH : 1;      /*!< [17..17] GPIO4_LEVEL_HIGH                                                 */
      __IOM uint32_t GPIO4_EDGE_LOW : 1;        /*!< [18..18] GPIO4_EDGE_LOW                                                   */
      __IOM uint32_t GPIO4_EDGE_HIGH : 1;       /*!< [19..19] GPIO4_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO5_LEVEL_LOW : 1;       /*!< [20..20] GPIO5_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO5_LEVEL_HIGH : 1;      /*!< [21..21] GPIO5_LEVEL_HIGH                                                 */
      __IOM uint32_t GPIO5_EDGE_LOW : 1;        /*!< [22..22] GPIO5_EDGE_LOW                                                   */
      __IOM uint32_t GPIO5_EDGE_HIGH : 1;       /*!< [23..23] GPIO5_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO6_LEVEL_LOW : 1;       /*!< [24..24] GPIO6_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO6_LEVEL_HIGH : 1;      /*!< [25..25] GPIO6_LEVEL_HIGH                                                 */
      __IOM uint32_t GPIO6_EDGE_LOW : 1;        /*!< [26..26] GPIO6_EDGE_LOW                                                   */
      __IOM uint32_t GPIO6_EDGE_HIGH : 1;       /*!< [27..27] GPIO6_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO7_LEVEL_LOW : 1;       /*!< [28..28] GPIO7_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO7_LEVEL_HIGH : 1;      /*!< [29..29] GPIO7_LEVEL_HIGH                                                 */
      __IOM uint32_t GPIO7_EDGE_LOW : 1;        /*!< [30..30] GPIO7_EDGE_LOW                                                   */
      __IOM uint32_t GPIO7_EDGE_HIGH : 1;       /*!< [31..31] GPIO7_EDGE_HIGH                                                  */
    } bit;
  } PROC0_INTF0;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000114) Interrupt Force for proc0                                  */
    
    struct {
      __IOM uint32_t GPIO8_LEVEL_LOW : 1;       /*!< [0..0] GPIO8_LEVEL_LOW                                                    */
      __IOM uint32_t GPIO8_LEVEL_HIGH : 1;      /*!< [1..1] GPIO8_LEVEL_HIGH                                                   */
      __IOM uint32_t GPIO8_EDGE_LOW : 1;        /*!< [2..2] GPIO8_EDGE_LOW                                                     */
      __IOM uint32_t GPIO8_EDGE_HIGH : 1;       /*!< [3..3] GPIO8_EDGE_HIGH                                                    */
      __IOM uint32_t GPIO9_LEVEL_LOW : 1;       /*!< [4..4] GPIO9_LEVEL_LOW                                                    */
      __IOM uint32_t GPIO9_LEVEL_HIGH : 1;      /*!< [5..5] GPIO9_LEVEL_HIGH                                                   */
      __IOM uint32_t GPIO9_EDGE_LOW : 1;        /*!< [6..6] GPIO9_EDGE_LOW                                                     */
      __IOM uint32_t GPIO9_EDGE_HIGH : 1;       /*!< [7..7] GPIO9_EDGE_HIGH                                                    */
      __IOM uint32_t GPIO10_LEVEL_LOW : 1;      /*!< [8..8] GPIO10_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO10_LEVEL_HIGH : 1;     /*!< [9..9] GPIO10_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO10_EDGE_LOW : 1;       /*!< [10..10] GPIO10_EDGE_LOW                                                  */
      __IOM uint32_t GPIO10_EDGE_HIGH : 1;      /*!< [11..11] GPIO10_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO11_LEVEL_LOW : 1;      /*!< [12..12] GPIO11_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO11_LEVEL_HIGH : 1;     /*!< [13..13] GPIO11_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO11_EDGE_LOW : 1;       /*!< [14..14] GPIO11_EDGE_LOW                                                  */
      __IOM uint32_t GPIO11_EDGE_HIGH : 1;      /*!< [15..15] GPIO11_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO12_LEVEL_LOW : 1;      /*!< [16..16] GPIO12_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO12_LEVEL_HIGH : 1;     /*!< [17..17] GPIO12_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO12_EDGE_LOW : 1;       /*!< [18..18] GPIO12_EDGE_LOW                                                  */
      __IOM uint32_t GPIO12_EDGE_HIGH : 1;      /*!< [19..19] GPIO12_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO13_LEVEL_LOW : 1;      /*!< [20..20] GPIO13_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO13_LEVEL_HIGH : 1;     /*!< [21..21] GPIO13_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO13_EDGE_LOW : 1;       /*!< [22..22] GPIO13_EDGE_LOW                                                  */
      __IOM uint32_t GPIO13_EDGE_HIGH : 1;      /*!< [23..23] GPIO13_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO14_LEVEL_LOW : 1;      /*!< [24..24] GPIO14_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO14_LEVEL_HIGH : 1;     /*!< [25..25] GPIO14_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO14_EDGE_LOW : 1;       /*!< [26..26] GPIO14_EDGE_LOW                                                  */
      __IOM uint32_t GPIO14_EDGE_HIGH : 1;      /*!< [27..27] GPIO14_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO15_LEVEL_LOW : 1;      /*!< [28..28] GPIO15_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO15_LEVEL_HIGH : 1;     /*!< [29..29] GPIO15_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO15_EDGE_LOW : 1;       /*!< [30..30] GPIO15_EDGE_LOW                                                  */
      __IOM uint32_t GPIO15_EDGE_HIGH : 1;      /*!< [31..31] GPIO15_EDGE_HIGH                                                 */
    } bit;
  } PROC0_INTF1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000118) Interrupt Force for proc0                                  */
    
    struct {
      __IOM uint32_t GPIO16_LEVEL_LOW : 1;      /*!< [0..0] GPIO16_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO16_LEVEL_HIGH : 1;     /*!< [1..1] GPIO16_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO16_EDGE_LOW : 1;       /*!< [2..2] GPIO16_EDGE_LOW                                                    */
      __IOM uint32_t GPIO16_EDGE_HIGH : 1;      /*!< [3..3] GPIO16_EDGE_HIGH                                                   */
      __IOM uint32_t GPIO17_LEVEL_LOW : 1;      /*!< [4..4] GPIO17_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO17_LEVEL_HIGH : 1;     /*!< [5..5] GPIO17_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO17_EDGE_LOW : 1;       /*!< [6..6] GPIO17_EDGE_LOW                                                    */
      __IOM uint32_t GPIO17_EDGE_HIGH : 1;      /*!< [7..7] GPIO17_EDGE_HIGH                                                   */
      __IOM uint32_t GPIO18_LEVEL_LOW : 1;      /*!< [8..8] GPIO18_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO18_LEVEL_HIGH : 1;     /*!< [9..9] GPIO18_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO18_EDGE_LOW : 1;       /*!< [10..10] GPIO18_EDGE_LOW                                                  */
      __IOM uint32_t GPIO18_EDGE_HIGH : 1;      /*!< [11..11] GPIO18_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO19_LEVEL_LOW : 1;      /*!< [12..12] GPIO19_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO19_LEVEL_HIGH : 1;     /*!< [13..13] GPIO19_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO19_EDGE_LOW : 1;       /*!< [14..14] GPIO19_EDGE_LOW                                                  */
      __IOM uint32_t GPIO19_EDGE_HIGH : 1;      /*!< [15..15] GPIO19_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO20_LEVEL_LOW : 1;      /*!< [16..16] GPIO20_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO20_LEVEL_HIGH : 1;     /*!< [17..17] GPIO20_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO20_EDGE_LOW : 1;       /*!< [18..18] GPIO20_EDGE_LOW                                                  */
      __IOM uint32_t GPIO20_EDGE_HIGH : 1;      /*!< [19..19] GPIO20_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO21_LEVEL_LOW : 1;      /*!< [20..20] GPIO21_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO21_LEVEL_HIGH : 1;     /*!< [21..21] GPIO21_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO21_EDGE_LOW : 1;       /*!< [22..22] GPIO21_EDGE_LOW                                                  */
      __IOM uint32_t GPIO21_EDGE_HIGH : 1;      /*!< [23..23] GPIO21_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO22_LEVEL_LOW : 1;      /*!< [24..24] GPIO22_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO22_LEVEL_HIGH : 1;     /*!< [25..25] GPIO22_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO22_EDGE_LOW : 1;       /*!< [26..26] GPIO22_EDGE_LOW                                                  */
      __IOM uint32_t GPIO22_EDGE_HIGH : 1;      /*!< [27..27] GPIO22_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO23_LEVEL_LOW : 1;      /*!< [28..28] GPIO23_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO23_LEVEL_HIGH : 1;     /*!< [29..29] GPIO23_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO23_EDGE_LOW : 1;       /*!< [30..30] GPIO23_EDGE_LOW                                                  */
      __IOM uint32_t GPIO23_EDGE_HIGH : 1;      /*!< [31..31] GPIO23_EDGE_HIGH                                                 */
    } bit;
  } PROC0_INTF2;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000011C) Interrupt Force for proc0                                  */
    
    struct {
      __IOM uint32_t GPIO24_LEVEL_LOW : 1;      /*!< [0..0] GPIO24_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO24_LEVEL_HIGH : 1;     /*!< [1..1] GPIO24_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO24_EDGE_LOW : 1;       /*!< [2..2] GPIO24_EDGE_LOW                                                    */
      __IOM uint32_t GPIO24_EDGE_HIGH : 1;      /*!< [3..3] GPIO24_EDGE_HIGH                                                   */
      __IOM uint32_t GPIO25_LEVEL_LOW : 1;      /*!< [4..4] GPIO25_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO25_LEVEL_HIGH : 1;     /*!< [5..5] GPIO25_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO25_EDGE_LOW : 1;       /*!< [6..6] GPIO25_EDGE_LOW                                                    */
      __IOM uint32_t GPIO25_EDGE_HIGH : 1;      /*!< [7..7] GPIO25_EDGE_HIGH                                                   */
      __IOM uint32_t GPIO26_LEVEL_LOW : 1;      /*!< [8..8] GPIO26_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO26_LEVEL_HIGH : 1;     /*!< [9..9] GPIO26_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO26_EDGE_LOW : 1;       /*!< [10..10] GPIO26_EDGE_LOW                                                  */
      __IOM uint32_t GPIO26_EDGE_HIGH : 1;      /*!< [11..11] GPIO26_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO27_LEVEL_LOW : 1;      /*!< [12..12] GPIO27_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO27_LEVEL_HIGH : 1;     /*!< [13..13] GPIO27_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO27_EDGE_LOW : 1;       /*!< [14..14] GPIO27_EDGE_LOW                                                  */
      __IOM uint32_t GPIO27_EDGE_HIGH : 1;      /*!< [15..15] GPIO27_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO28_LEVEL_LOW : 1;      /*!< [16..16] GPIO28_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO28_LEVEL_HIGH : 1;     /*!< [17..17] GPIO28_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO28_EDGE_LOW : 1;       /*!< [18..18] GPIO28_EDGE_LOW                                                  */
      __IOM uint32_t GPIO28_EDGE_HIGH : 1;      /*!< [19..19] GPIO28_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO29_LEVEL_LOW : 1;      /*!< [20..20] GPIO29_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO29_LEVEL_HIGH : 1;     /*!< [21..21] GPIO29_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO29_EDGE_LOW : 1;       /*!< [22..22] GPIO29_EDGE_LOW                                                  */
      __IOM uint32_t GPIO29_EDGE_HIGH : 1;      /*!< [23..23] GPIO29_EDGE_HIGH                                                 */
            uint32_t            : 8;
    } bit;
  } PROC0_INTF3;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000120) Interrupt status after masking & forcing for
                                                                    proc0                                                      */
    
    struct {
      __IM  uint32_t GPIO0_LEVEL_LOW : 1;       /*!< [0..0] GPIO0_LEVEL_LOW                                                    */
      __IM  uint32_t GPIO0_LEVEL_HIGH : 1;      /*!< [1..1] GPIO0_LEVEL_HIGH                                                   */
      __IM  uint32_t GPIO0_EDGE_LOW : 1;        /*!< [2..2] GPIO0_EDGE_LOW                                                     */
      __IM  uint32_t GPIO0_EDGE_HIGH : 1;       /*!< [3..3] GPIO0_EDGE_HIGH                                                    */
      __IM  uint32_t GPIO1_LEVEL_LOW : 1;       /*!< [4..4] GPIO1_LEVEL_LOW                                                    */
      __IM  uint32_t GPIO1_LEVEL_HIGH : 1;      /*!< [5..5] GPIO1_LEVEL_HIGH                                                   */
      __IM  uint32_t GPIO1_EDGE_LOW : 1;        /*!< [6..6] GPIO1_EDGE_LOW                                                     */
      __IM  uint32_t GPIO1_EDGE_HIGH : 1;       /*!< [7..7] GPIO1_EDGE_HIGH                                                    */
      __IM  uint32_t GPIO2_LEVEL_LOW : 1;       /*!< [8..8] GPIO2_LEVEL_LOW                                                    */
      __IM  uint32_t GPIO2_LEVEL_HIGH : 1;      /*!< [9..9] GPIO2_LEVEL_HIGH                                                   */
      __IM  uint32_t GPIO2_EDGE_LOW : 1;        /*!< [10..10] GPIO2_EDGE_LOW                                                   */
      __IM  uint32_t GPIO2_EDGE_HIGH : 1;       /*!< [11..11] GPIO2_EDGE_HIGH                                                  */
      __IM  uint32_t GPIO3_LEVEL_LOW : 1;       /*!< [12..12] GPIO3_LEVEL_LOW                                                  */
      __IM  uint32_t GPIO3_LEVEL_HIGH : 1;      /*!< [13..13] GPIO3_LEVEL_HIGH                                                 */
      __IM  uint32_t GPIO3_EDGE_LOW : 1;        /*!< [14..14] GPIO3_EDGE_LOW                                                   */
      __IM  uint32_t GPIO3_EDGE_HIGH : 1;       /*!< [15..15] GPIO3_EDGE_HIGH                                                  */
      __IM  uint32_t GPIO4_LEVEL_LOW : 1;       /*!< [16..16] GPIO4_LEVEL_LOW                                                  */
      __IM  uint32_t GPIO4_LEVEL_HIGH : 1;      /*!< [17..17] GPIO4_LEVEL_HIGH                                                 */
      __IM  uint32_t GPIO4_EDGE_LOW : 1;        /*!< [18..18] GPIO4_EDGE_LOW                                                   */
      __IM  uint32_t GPIO4_EDGE_HIGH : 1;       /*!< [19..19] GPIO4_EDGE_HIGH                                                  */
      __IM  uint32_t GPIO5_LEVEL_LOW : 1;       /*!< [20..20] GPIO5_LEVEL_LOW                                                  */
      __IM  uint32_t GPIO5_LEVEL_HIGH : 1;      /*!< [21..21] GPIO5_LEVEL_HIGH                                                 */
      __IM  uint32_t GPIO5_EDGE_LOW : 1;        /*!< [22..22] GPIO5_EDGE_LOW                                                   */
      __IM  uint32_t GPIO5_EDGE_HIGH : 1;       /*!< [23..23] GPIO5_EDGE_HIGH                                                  */
      __IM  uint32_t GPIO6_LEVEL_LOW : 1;       /*!< [24..24] GPIO6_LEVEL_LOW                                                  */
      __IM  uint32_t GPIO6_LEVEL_HIGH : 1;      /*!< [25..25] GPIO6_LEVEL_HIGH                                                 */
      __IM  uint32_t GPIO6_EDGE_LOW : 1;        /*!< [26..26] GPIO6_EDGE_LOW                                                   */
      __IM  uint32_t GPIO6_EDGE_HIGH : 1;       /*!< [27..27] GPIO6_EDGE_HIGH                                                  */
      __IM  uint32_t GPIO7_LEVEL_LOW : 1;       /*!< [28..28] GPIO7_LEVEL_LOW                                                  */
      __IM  uint32_t GPIO7_LEVEL_HIGH : 1;      /*!< [29..29] GPIO7_LEVEL_HIGH                                                 */
      __IM  uint32_t GPIO7_EDGE_LOW : 1;        /*!< [30..30] GPIO7_EDGE_LOW                                                   */
      __IM  uint32_t GPIO7_EDGE_HIGH : 1;       /*!< [31..31] GPIO7_EDGE_HIGH                                                  */
    } bit;
  } PROC0_INTS0;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000124) Interrupt status after masking & forcing for
                                                                    proc0                                                      */
    
    struct {
      __IM  uint32_t GPIO8_LEVEL_LOW : 1;       /*!< [0..0] GPIO8_LEVEL_LOW                                                    */
      __IM  uint32_t GPIO8_LEVEL_HIGH : 1;      /*!< [1..1] GPIO8_LEVEL_HIGH                                                   */
      __IM  uint32_t GPIO8_EDGE_LOW : 1;        /*!< [2..2] GPIO8_EDGE_LOW                                                     */
      __IM  uint32_t GPIO8_EDGE_HIGH : 1;       /*!< [3..3] GPIO8_EDGE_HIGH                                                    */
      __IM  uint32_t GPIO9_LEVEL_LOW : 1;       /*!< [4..4] GPIO9_LEVEL_LOW                                                    */
      __IM  uint32_t GPIO9_LEVEL_HIGH : 1;      /*!< [5..5] GPIO9_LEVEL_HIGH                                                   */
      __IM  uint32_t GPIO9_EDGE_LOW : 1;        /*!< [6..6] GPIO9_EDGE_LOW                                                     */
      __IM  uint32_t GPIO9_EDGE_HIGH : 1;       /*!< [7..7] GPIO9_EDGE_HIGH                                                    */
      __IM  uint32_t GPIO10_LEVEL_LOW : 1;      /*!< [8..8] GPIO10_LEVEL_LOW                                                   */
      __IM  uint32_t GPIO10_LEVEL_HIGH : 1;     /*!< [9..9] GPIO10_LEVEL_HIGH                                                  */
      __IM  uint32_t GPIO10_EDGE_LOW : 1;       /*!< [10..10] GPIO10_EDGE_LOW                                                  */
      __IM  uint32_t GPIO10_EDGE_HIGH : 1;      /*!< [11..11] GPIO10_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO11_LEVEL_LOW : 1;      /*!< [12..12] GPIO11_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO11_LEVEL_HIGH : 1;     /*!< [13..13] GPIO11_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO11_EDGE_LOW : 1;       /*!< [14..14] GPIO11_EDGE_LOW                                                  */
      __IM  uint32_t GPIO11_EDGE_HIGH : 1;      /*!< [15..15] GPIO11_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO12_LEVEL_LOW : 1;      /*!< [16..16] GPIO12_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO12_LEVEL_HIGH : 1;     /*!< [17..17] GPIO12_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO12_EDGE_LOW : 1;       /*!< [18..18] GPIO12_EDGE_LOW                                                  */
      __IM  uint32_t GPIO12_EDGE_HIGH : 1;      /*!< [19..19] GPIO12_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO13_LEVEL_LOW : 1;      /*!< [20..20] GPIO13_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO13_LEVEL_HIGH : 1;     /*!< [21..21] GPIO13_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO13_EDGE_LOW : 1;       /*!< [22..22] GPIO13_EDGE_LOW                                                  */
      __IM  uint32_t GPIO13_EDGE_HIGH : 1;      /*!< [23..23] GPIO13_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO14_LEVEL_LOW : 1;      /*!< [24..24] GPIO14_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO14_LEVEL_HIGH : 1;     /*!< [25..25] GPIO14_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO14_EDGE_LOW : 1;       /*!< [26..26] GPIO14_EDGE_LOW                                                  */
      __IM  uint32_t GPIO14_EDGE_HIGH : 1;      /*!< [27..27] GPIO14_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO15_LEVEL_LOW : 1;      /*!< [28..28] GPIO15_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO15_LEVEL_HIGH : 1;     /*!< [29..29] GPIO15_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO15_EDGE_LOW : 1;       /*!< [30..30] GPIO15_EDGE_LOW                                                  */
      __IM  uint32_t GPIO15_EDGE_HIGH : 1;      /*!< [31..31] GPIO15_EDGE_HIGH                                                 */
    } bit;
  } PROC0_INTS1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000128) Interrupt status after masking & forcing for
                                                                    proc0                                                      */
    
    struct {
      __IM  uint32_t GPIO16_LEVEL_LOW : 1;      /*!< [0..0] GPIO16_LEVEL_LOW                                                   */
      __IM  uint32_t GPIO16_LEVEL_HIGH : 1;     /*!< [1..1] GPIO16_LEVEL_HIGH                                                  */
      __IM  uint32_t GPIO16_EDGE_LOW : 1;       /*!< [2..2] GPIO16_EDGE_LOW                                                    */
      __IM  uint32_t GPIO16_EDGE_HIGH : 1;      /*!< [3..3] GPIO16_EDGE_HIGH                                                   */
      __IM  uint32_t GPIO17_LEVEL_LOW : 1;      /*!< [4..4] GPIO17_LEVEL_LOW                                                   */
      __IM  uint32_t GPIO17_LEVEL_HIGH : 1;     /*!< [5..5] GPIO17_LEVEL_HIGH                                                  */
      __IM  uint32_t GPIO17_EDGE_LOW : 1;       /*!< [6..6] GPIO17_EDGE_LOW                                                    */
      __IM  uint32_t GPIO17_EDGE_HIGH : 1;      /*!< [7..7] GPIO17_EDGE_HIGH                                                   */
      __IM  uint32_t GPIO18_LEVEL_LOW : 1;      /*!< [8..8] GPIO18_LEVEL_LOW                                                   */
      __IM  uint32_t GPIO18_LEVEL_HIGH : 1;     /*!< [9..9] GPIO18_LEVEL_HIGH                                                  */
      __IM  uint32_t GPIO18_EDGE_LOW : 1;       /*!< [10..10] GPIO18_EDGE_LOW                                                  */
      __IM  uint32_t GPIO18_EDGE_HIGH : 1;      /*!< [11..11] GPIO18_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO19_LEVEL_LOW : 1;      /*!< [12..12] GPIO19_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO19_LEVEL_HIGH : 1;     /*!< [13..13] GPIO19_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO19_EDGE_LOW : 1;       /*!< [14..14] GPIO19_EDGE_LOW                                                  */
      __IM  uint32_t GPIO19_EDGE_HIGH : 1;      /*!< [15..15] GPIO19_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO20_LEVEL_LOW : 1;      /*!< [16..16] GPIO20_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO20_LEVEL_HIGH : 1;     /*!< [17..17] GPIO20_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO20_EDGE_LOW : 1;       /*!< [18..18] GPIO20_EDGE_LOW                                                  */
      __IM  uint32_t GPIO20_EDGE_HIGH : 1;      /*!< [19..19] GPIO20_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO21_LEVEL_LOW : 1;      /*!< [20..20] GPIO21_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO21_LEVEL_HIGH : 1;     /*!< [21..21] GPIO21_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO21_EDGE_LOW : 1;       /*!< [22..22] GPIO21_EDGE_LOW                                                  */
      __IM  uint32_t GPIO21_EDGE_HIGH : 1;      /*!< [23..23] GPIO21_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO22_LEVEL_LOW : 1;      /*!< [24..24] GPIO22_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO22_LEVEL_HIGH : 1;     /*!< [25..25] GPIO22_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO22_EDGE_LOW : 1;       /*!< [26..26] GPIO22_EDGE_LOW                                                  */
      __IM  uint32_t GPIO22_EDGE_HIGH : 1;      /*!< [27..27] GPIO22_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO23_LEVEL_LOW : 1;      /*!< [28..28] GPIO23_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO23_LEVEL_HIGH : 1;     /*!< [29..29] GPIO23_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO23_EDGE_LOW : 1;       /*!< [30..30] GPIO23_EDGE_LOW                                                  */
      __IM  uint32_t GPIO23_EDGE_HIGH : 1;      /*!< [31..31] GPIO23_EDGE_HIGH                                                 */
    } bit;
  } PROC0_INTS2;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000012C) Interrupt status after masking & forcing for
                                                                    proc0                                                      */
    
    struct {
      __IM  uint32_t GPIO24_LEVEL_LOW : 1;      /*!< [0..0] GPIO24_LEVEL_LOW                                                   */
      __IM  uint32_t GPIO24_LEVEL_HIGH : 1;     /*!< [1..1] GPIO24_LEVEL_HIGH                                                  */
      __IM  uint32_t GPIO24_EDGE_LOW : 1;       /*!< [2..2] GPIO24_EDGE_LOW                                                    */
      __IM  uint32_t GPIO24_EDGE_HIGH : 1;      /*!< [3..3] GPIO24_EDGE_HIGH                                                   */
      __IM  uint32_t GPIO25_LEVEL_LOW : 1;      /*!< [4..4] GPIO25_LEVEL_LOW                                                   */
      __IM  uint32_t GPIO25_LEVEL_HIGH : 1;     /*!< [5..5] GPIO25_LEVEL_HIGH                                                  */
      __IM  uint32_t GPIO25_EDGE_LOW : 1;       /*!< [6..6] GPIO25_EDGE_LOW                                                    */
      __IM  uint32_t GPIO25_EDGE_HIGH : 1;      /*!< [7..7] GPIO25_EDGE_HIGH                                                   */
      __IM  uint32_t GPIO26_LEVEL_LOW : 1;      /*!< [8..8] GPIO26_LEVEL_LOW                                                   */
      __IM  uint32_t GPIO26_LEVEL_HIGH : 1;     /*!< [9..9] GPIO26_LEVEL_HIGH                                                  */
      __IM  uint32_t GPIO26_EDGE_LOW : 1;       /*!< [10..10] GPIO26_EDGE_LOW                                                  */
      __IM  uint32_t GPIO26_EDGE_HIGH : 1;      /*!< [11..11] GPIO26_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO27_LEVEL_LOW : 1;      /*!< [12..12] GPIO27_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO27_LEVEL_HIGH : 1;     /*!< [13..13] GPIO27_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO27_EDGE_LOW : 1;       /*!< [14..14] GPIO27_EDGE_LOW                                                  */
      __IM  uint32_t GPIO27_EDGE_HIGH : 1;      /*!< [15..15] GPIO27_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO28_LEVEL_LOW : 1;      /*!< [16..16] GPIO28_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO28_LEVEL_HIGH : 1;     /*!< [17..17] GPIO28_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO28_EDGE_LOW : 1;       /*!< [18..18] GPIO28_EDGE_LOW                                                  */
      __IM  uint32_t GPIO28_EDGE_HIGH : 1;      /*!< [19..19] GPIO28_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO29_LEVEL_LOW : 1;      /*!< [20..20] GPIO29_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO29_LEVEL_HIGH : 1;     /*!< [21..21] GPIO29_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO29_EDGE_LOW : 1;       /*!< [22..22] GPIO29_EDGE_LOW                                                  */
      __IM  uint32_t GPIO29_EDGE_HIGH : 1;      /*!< [23..23] GPIO29_EDGE_HIGH                                                 */
            uint32_t            : 8;
    } bit;
  } PROC0_INTS3;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000130) Interrupt Enable for proc1                                 */
    
    struct {
      __IOM uint32_t GPIO0_LEVEL_LOW : 1;       /*!< [0..0] GPIO0_LEVEL_LOW                                                    */
      __IOM uint32_t GPIO0_LEVEL_HIGH : 1;      /*!< [1..1] GPIO0_LEVEL_HIGH                                                   */
      __IOM uint32_t GPIO0_EDGE_LOW : 1;        /*!< [2..2] GPIO0_EDGE_LOW                                                     */
      __IOM uint32_t GPIO0_EDGE_HIGH : 1;       /*!< [3..3] GPIO0_EDGE_HIGH                                                    */
      __IOM uint32_t GPIO1_LEVEL_LOW : 1;       /*!< [4..4] GPIO1_LEVEL_LOW                                                    */
      __IOM uint32_t GPIO1_LEVEL_HIGH : 1;      /*!< [5..5] GPIO1_LEVEL_HIGH                                                   */
      __IOM uint32_t GPIO1_EDGE_LOW : 1;        /*!< [6..6] GPIO1_EDGE_LOW                                                     */
      __IOM uint32_t GPIO1_EDGE_HIGH : 1;       /*!< [7..7] GPIO1_EDGE_HIGH                                                    */
      __IOM uint32_t GPIO2_LEVEL_LOW : 1;       /*!< [8..8] GPIO2_LEVEL_LOW                                                    */
      __IOM uint32_t GPIO2_LEVEL_HIGH : 1;      /*!< [9..9] GPIO2_LEVEL_HIGH                                                   */
      __IOM uint32_t GPIO2_EDGE_LOW : 1;        /*!< [10..10] GPIO2_EDGE_LOW                                                   */
      __IOM uint32_t GPIO2_EDGE_HIGH : 1;       /*!< [11..11] GPIO2_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO3_LEVEL_LOW : 1;       /*!< [12..12] GPIO3_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO3_LEVEL_HIGH : 1;      /*!< [13..13] GPIO3_LEVEL_HIGH                                                 */
      __IOM uint32_t GPIO3_EDGE_LOW : 1;        /*!< [14..14] GPIO3_EDGE_LOW                                                   */
      __IOM uint32_t GPIO3_EDGE_HIGH : 1;       /*!< [15..15] GPIO3_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO4_LEVEL_LOW : 1;       /*!< [16..16] GPIO4_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO4_LEVEL_HIGH : 1;      /*!< [17..17] GPIO4_LEVEL_HIGH                                                 */
      __IOM uint32_t GPIO4_EDGE_LOW : 1;        /*!< [18..18] GPIO4_EDGE_LOW                                                   */
      __IOM uint32_t GPIO4_EDGE_HIGH : 1;       /*!< [19..19] GPIO4_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO5_LEVEL_LOW : 1;       /*!< [20..20] GPIO5_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO5_LEVEL_HIGH : 1;      /*!< [21..21] GPIO5_LEVEL_HIGH                                                 */
      __IOM uint32_t GPIO5_EDGE_LOW : 1;        /*!< [22..22] GPIO5_EDGE_LOW                                                   */
      __IOM uint32_t GPIO5_EDGE_HIGH : 1;       /*!< [23..23] GPIO5_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO6_LEVEL_LOW : 1;       /*!< [24..24] GPIO6_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO6_LEVEL_HIGH : 1;      /*!< [25..25] GPIO6_LEVEL_HIGH                                                 */
      __IOM uint32_t GPIO6_EDGE_LOW : 1;        /*!< [26..26] GPIO6_EDGE_LOW                                                   */
      __IOM uint32_t GPIO6_EDGE_HIGH : 1;       /*!< [27..27] GPIO6_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO7_LEVEL_LOW : 1;       /*!< [28..28] GPIO7_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO7_LEVEL_HIGH : 1;      /*!< [29..29] GPIO7_LEVEL_HIGH                                                 */
      __IOM uint32_t GPIO7_EDGE_LOW : 1;        /*!< [30..30] GPIO7_EDGE_LOW                                                   */
      __IOM uint32_t GPIO7_EDGE_HIGH : 1;       /*!< [31..31] GPIO7_EDGE_HIGH                                                  */
    } bit;
  } PROC1_INTE0;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000134) Interrupt Enable for proc1                                 */
    
    struct {
      __IOM uint32_t GPIO8_LEVEL_LOW : 1;       /*!< [0..0] GPIO8_LEVEL_LOW                                                    */
      __IOM uint32_t GPIO8_LEVEL_HIGH : 1;      /*!< [1..1] GPIO8_LEVEL_HIGH                                                   */
      __IOM uint32_t GPIO8_EDGE_LOW : 1;        /*!< [2..2] GPIO8_EDGE_LOW                                                     */
      __IOM uint32_t GPIO8_EDGE_HIGH : 1;       /*!< [3..3] GPIO8_EDGE_HIGH                                                    */
      __IOM uint32_t GPIO9_LEVEL_LOW : 1;       /*!< [4..4] GPIO9_LEVEL_LOW                                                    */
      __IOM uint32_t GPIO9_LEVEL_HIGH : 1;      /*!< [5..5] GPIO9_LEVEL_HIGH                                                   */
      __IOM uint32_t GPIO9_EDGE_LOW : 1;        /*!< [6..6] GPIO9_EDGE_LOW                                                     */
      __IOM uint32_t GPIO9_EDGE_HIGH : 1;       /*!< [7..7] GPIO9_EDGE_HIGH                                                    */
      __IOM uint32_t GPIO10_LEVEL_LOW : 1;      /*!< [8..8] GPIO10_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO10_LEVEL_HIGH : 1;     /*!< [9..9] GPIO10_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO10_EDGE_LOW : 1;       /*!< [10..10] GPIO10_EDGE_LOW                                                  */
      __IOM uint32_t GPIO10_EDGE_HIGH : 1;      /*!< [11..11] GPIO10_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO11_LEVEL_LOW : 1;      /*!< [12..12] GPIO11_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO11_LEVEL_HIGH : 1;     /*!< [13..13] GPIO11_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO11_EDGE_LOW : 1;       /*!< [14..14] GPIO11_EDGE_LOW                                                  */
      __IOM uint32_t GPIO11_EDGE_HIGH : 1;      /*!< [15..15] GPIO11_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO12_LEVEL_LOW : 1;      /*!< [16..16] GPIO12_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO12_LEVEL_HIGH : 1;     /*!< [17..17] GPIO12_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO12_EDGE_LOW : 1;       /*!< [18..18] GPIO12_EDGE_LOW                                                  */
      __IOM uint32_t GPIO12_EDGE_HIGH : 1;      /*!< [19..19] GPIO12_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO13_LEVEL_LOW : 1;      /*!< [20..20] GPIO13_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO13_LEVEL_HIGH : 1;     /*!< [21..21] GPIO13_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO13_EDGE_LOW : 1;       /*!< [22..22] GPIO13_EDGE_LOW                                                  */
      __IOM uint32_t GPIO13_EDGE_HIGH : 1;      /*!< [23..23] GPIO13_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO14_LEVEL_LOW : 1;      /*!< [24..24] GPIO14_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO14_LEVEL_HIGH : 1;     /*!< [25..25] GPIO14_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO14_EDGE_LOW : 1;       /*!< [26..26] GPIO14_EDGE_LOW                                                  */
      __IOM uint32_t GPIO14_EDGE_HIGH : 1;      /*!< [27..27] GPIO14_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO15_LEVEL_LOW : 1;      /*!< [28..28] GPIO15_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO15_LEVEL_HIGH : 1;     /*!< [29..29] GPIO15_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO15_EDGE_LOW : 1;       /*!< [30..30] GPIO15_EDGE_LOW                                                  */
      __IOM uint32_t GPIO15_EDGE_HIGH : 1;      /*!< [31..31] GPIO15_EDGE_HIGH                                                 */
    } bit;
  } PROC1_INTE1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000138) Interrupt Enable for proc1                                 */
    
    struct {
      __IOM uint32_t GPIO16_LEVEL_LOW : 1;      /*!< [0..0] GPIO16_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO16_LEVEL_HIGH : 1;     /*!< [1..1] GPIO16_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO16_EDGE_LOW : 1;       /*!< [2..2] GPIO16_EDGE_LOW                                                    */
      __IOM uint32_t GPIO16_EDGE_HIGH : 1;      /*!< [3..3] GPIO16_EDGE_HIGH                                                   */
      __IOM uint32_t GPIO17_LEVEL_LOW : 1;      /*!< [4..4] GPIO17_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO17_LEVEL_HIGH : 1;     /*!< [5..5] GPIO17_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO17_EDGE_LOW : 1;       /*!< [6..6] GPIO17_EDGE_LOW                                                    */
      __IOM uint32_t GPIO17_EDGE_HIGH : 1;      /*!< [7..7] GPIO17_EDGE_HIGH                                                   */
      __IOM uint32_t GPIO18_LEVEL_LOW : 1;      /*!< [8..8] GPIO18_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO18_LEVEL_HIGH : 1;     /*!< [9..9] GPIO18_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO18_EDGE_LOW : 1;       /*!< [10..10] GPIO18_EDGE_LOW                                                  */
      __IOM uint32_t GPIO18_EDGE_HIGH : 1;      /*!< [11..11] GPIO18_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO19_LEVEL_LOW : 1;      /*!< [12..12] GPIO19_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO19_LEVEL_HIGH : 1;     /*!< [13..13] GPIO19_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO19_EDGE_LOW : 1;       /*!< [14..14] GPIO19_EDGE_LOW                                                  */
      __IOM uint32_t GPIO19_EDGE_HIGH : 1;      /*!< [15..15] GPIO19_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO20_LEVEL_LOW : 1;      /*!< [16..16] GPIO20_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO20_LEVEL_HIGH : 1;     /*!< [17..17] GPIO20_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO20_EDGE_LOW : 1;       /*!< [18..18] GPIO20_EDGE_LOW                                                  */
      __IOM uint32_t GPIO20_EDGE_HIGH : 1;      /*!< [19..19] GPIO20_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO21_LEVEL_LOW : 1;      /*!< [20..20] GPIO21_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO21_LEVEL_HIGH : 1;     /*!< [21..21] GPIO21_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO21_EDGE_LOW : 1;       /*!< [22..22] GPIO21_EDGE_LOW                                                  */
      __IOM uint32_t GPIO21_EDGE_HIGH : 1;      /*!< [23..23] GPIO21_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO22_LEVEL_LOW : 1;      /*!< [24..24] GPIO22_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO22_LEVEL_HIGH : 1;     /*!< [25..25] GPIO22_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO22_EDGE_LOW : 1;       /*!< [26..26] GPIO22_EDGE_LOW                                                  */
      __IOM uint32_t GPIO22_EDGE_HIGH : 1;      /*!< [27..27] GPIO22_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO23_LEVEL_LOW : 1;      /*!< [28..28] GPIO23_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO23_LEVEL_HIGH : 1;     /*!< [29..29] GPIO23_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO23_EDGE_LOW : 1;       /*!< [30..30] GPIO23_EDGE_LOW                                                  */
      __IOM uint32_t GPIO23_EDGE_HIGH : 1;      /*!< [31..31] GPIO23_EDGE_HIGH                                                 */
    } bit;
  } PROC1_INTE2;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000013C) Interrupt Enable for proc1                                 */
    
    struct {
      __IOM uint32_t GPIO24_LEVEL_LOW : 1;      /*!< [0..0] GPIO24_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO24_LEVEL_HIGH : 1;     /*!< [1..1] GPIO24_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO24_EDGE_LOW : 1;       /*!< [2..2] GPIO24_EDGE_LOW                                                    */
      __IOM uint32_t GPIO24_EDGE_HIGH : 1;      /*!< [3..3] GPIO24_EDGE_HIGH                                                   */
      __IOM uint32_t GPIO25_LEVEL_LOW : 1;      /*!< [4..4] GPIO25_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO25_LEVEL_HIGH : 1;     /*!< [5..5] GPIO25_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO25_EDGE_LOW : 1;       /*!< [6..6] GPIO25_EDGE_LOW                                                    */
      __IOM uint32_t GPIO25_EDGE_HIGH : 1;      /*!< [7..7] GPIO25_EDGE_HIGH                                                   */
      __IOM uint32_t GPIO26_LEVEL_LOW : 1;      /*!< [8..8] GPIO26_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO26_LEVEL_HIGH : 1;     /*!< [9..9] GPIO26_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO26_EDGE_LOW : 1;       /*!< [10..10] GPIO26_EDGE_LOW                                                  */
      __IOM uint32_t GPIO26_EDGE_HIGH : 1;      /*!< [11..11] GPIO26_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO27_LEVEL_LOW : 1;      /*!< [12..12] GPIO27_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO27_LEVEL_HIGH : 1;     /*!< [13..13] GPIO27_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO27_EDGE_LOW : 1;       /*!< [14..14] GPIO27_EDGE_LOW                                                  */
      __IOM uint32_t GPIO27_EDGE_HIGH : 1;      /*!< [15..15] GPIO27_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO28_LEVEL_LOW : 1;      /*!< [16..16] GPIO28_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO28_LEVEL_HIGH : 1;     /*!< [17..17] GPIO28_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO28_EDGE_LOW : 1;       /*!< [18..18] GPIO28_EDGE_LOW                                                  */
      __IOM uint32_t GPIO28_EDGE_HIGH : 1;      /*!< [19..19] GPIO28_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO29_LEVEL_LOW : 1;      /*!< [20..20] GPIO29_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO29_LEVEL_HIGH : 1;     /*!< [21..21] GPIO29_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO29_EDGE_LOW : 1;       /*!< [22..22] GPIO29_EDGE_LOW                                                  */
      __IOM uint32_t GPIO29_EDGE_HIGH : 1;      /*!< [23..23] GPIO29_EDGE_HIGH                                                 */
            uint32_t            : 8;
    } bit;
  } PROC1_INTE3;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000140) Interrupt Force for proc1                                  */
    
    struct {
      __IOM uint32_t GPIO0_LEVEL_LOW : 1;       /*!< [0..0] GPIO0_LEVEL_LOW                                                    */
      __IOM uint32_t GPIO0_LEVEL_HIGH : 1;      /*!< [1..1] GPIO0_LEVEL_HIGH                                                   */
      __IOM uint32_t GPIO0_EDGE_LOW : 1;        /*!< [2..2] GPIO0_EDGE_LOW                                                     */
      __IOM uint32_t GPIO0_EDGE_HIGH : 1;       /*!< [3..3] GPIO0_EDGE_HIGH                                                    */
      __IOM uint32_t GPIO1_LEVEL_LOW : 1;       /*!< [4..4] GPIO1_LEVEL_LOW                                                    */
      __IOM uint32_t GPIO1_LEVEL_HIGH : 1;      /*!< [5..5] GPIO1_LEVEL_HIGH                                                   */
      __IOM uint32_t GPIO1_EDGE_LOW : 1;        /*!< [6..6] GPIO1_EDGE_LOW                                                     */
      __IOM uint32_t GPIO1_EDGE_HIGH : 1;       /*!< [7..7] GPIO1_EDGE_HIGH                                                    */
      __IOM uint32_t GPIO2_LEVEL_LOW : 1;       /*!< [8..8] GPIO2_LEVEL_LOW                                                    */
      __IOM uint32_t GPIO2_LEVEL_HIGH : 1;      /*!< [9..9] GPIO2_LEVEL_HIGH                                                   */
      __IOM uint32_t GPIO2_EDGE_LOW : 1;        /*!< [10..10] GPIO2_EDGE_LOW                                                   */
      __IOM uint32_t GPIO2_EDGE_HIGH : 1;       /*!< [11..11] GPIO2_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO3_LEVEL_LOW : 1;       /*!< [12..12] GPIO3_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO3_LEVEL_HIGH : 1;      /*!< [13..13] GPIO3_LEVEL_HIGH                                                 */
      __IOM uint32_t GPIO3_EDGE_LOW : 1;        /*!< [14..14] GPIO3_EDGE_LOW                                                   */
      __IOM uint32_t GPIO3_EDGE_HIGH : 1;       /*!< [15..15] GPIO3_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO4_LEVEL_LOW : 1;       /*!< [16..16] GPIO4_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO4_LEVEL_HIGH : 1;      /*!< [17..17] GPIO4_LEVEL_HIGH                                                 */
      __IOM uint32_t GPIO4_EDGE_LOW : 1;        /*!< [18..18] GPIO4_EDGE_LOW                                                   */
      __IOM uint32_t GPIO4_EDGE_HIGH : 1;       /*!< [19..19] GPIO4_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO5_LEVEL_LOW : 1;       /*!< [20..20] GPIO5_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO5_LEVEL_HIGH : 1;      /*!< [21..21] GPIO5_LEVEL_HIGH                                                 */
      __IOM uint32_t GPIO5_EDGE_LOW : 1;        /*!< [22..22] GPIO5_EDGE_LOW                                                   */
      __IOM uint32_t GPIO5_EDGE_HIGH : 1;       /*!< [23..23] GPIO5_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO6_LEVEL_LOW : 1;       /*!< [24..24] GPIO6_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO6_LEVEL_HIGH : 1;      /*!< [25..25] GPIO6_LEVEL_HIGH                                                 */
      __IOM uint32_t GPIO6_EDGE_LOW : 1;        /*!< [26..26] GPIO6_EDGE_LOW                                                   */
      __IOM uint32_t GPIO6_EDGE_HIGH : 1;       /*!< [27..27] GPIO6_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO7_LEVEL_LOW : 1;       /*!< [28..28] GPIO7_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO7_LEVEL_HIGH : 1;      /*!< [29..29] GPIO7_LEVEL_HIGH                                                 */
      __IOM uint32_t GPIO7_EDGE_LOW : 1;        /*!< [30..30] GPIO7_EDGE_LOW                                                   */
      __IOM uint32_t GPIO7_EDGE_HIGH : 1;       /*!< [31..31] GPIO7_EDGE_HIGH                                                  */
    } bit;
  } PROC1_INTF0;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000144) Interrupt Force for proc1                                  */
    
    struct {
      __IOM uint32_t GPIO8_LEVEL_LOW : 1;       /*!< [0..0] GPIO8_LEVEL_LOW                                                    */
      __IOM uint32_t GPIO8_LEVEL_HIGH : 1;      /*!< [1..1] GPIO8_LEVEL_HIGH                                                   */
      __IOM uint32_t GPIO8_EDGE_LOW : 1;        /*!< [2..2] GPIO8_EDGE_LOW                                                     */
      __IOM uint32_t GPIO8_EDGE_HIGH : 1;       /*!< [3..3] GPIO8_EDGE_HIGH                                                    */
      __IOM uint32_t GPIO9_LEVEL_LOW : 1;       /*!< [4..4] GPIO9_LEVEL_LOW                                                    */
      __IOM uint32_t GPIO9_LEVEL_HIGH : 1;      /*!< [5..5] GPIO9_LEVEL_HIGH                                                   */
      __IOM uint32_t GPIO9_EDGE_LOW : 1;        /*!< [6..6] GPIO9_EDGE_LOW                                                     */
      __IOM uint32_t GPIO9_EDGE_HIGH : 1;       /*!< [7..7] GPIO9_EDGE_HIGH                                                    */
      __IOM uint32_t GPIO10_LEVEL_LOW : 1;      /*!< [8..8] GPIO10_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO10_LEVEL_HIGH : 1;     /*!< [9..9] GPIO10_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO10_EDGE_LOW : 1;       /*!< [10..10] GPIO10_EDGE_LOW                                                  */
      __IOM uint32_t GPIO10_EDGE_HIGH : 1;      /*!< [11..11] GPIO10_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO11_LEVEL_LOW : 1;      /*!< [12..12] GPIO11_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO11_LEVEL_HIGH : 1;     /*!< [13..13] GPIO11_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO11_EDGE_LOW : 1;       /*!< [14..14] GPIO11_EDGE_LOW                                                  */
      __IOM uint32_t GPIO11_EDGE_HIGH : 1;      /*!< [15..15] GPIO11_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO12_LEVEL_LOW : 1;      /*!< [16..16] GPIO12_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO12_LEVEL_HIGH : 1;     /*!< [17..17] GPIO12_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO12_EDGE_LOW : 1;       /*!< [18..18] GPIO12_EDGE_LOW                                                  */
      __IOM uint32_t GPIO12_EDGE_HIGH : 1;      /*!< [19..19] GPIO12_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO13_LEVEL_LOW : 1;      /*!< [20..20] GPIO13_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO13_LEVEL_HIGH : 1;     /*!< [21..21] GPIO13_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO13_EDGE_LOW : 1;       /*!< [22..22] GPIO13_EDGE_LOW                                                  */
      __IOM uint32_t GPIO13_EDGE_HIGH : 1;      /*!< [23..23] GPIO13_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO14_LEVEL_LOW : 1;      /*!< [24..24] GPIO14_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO14_LEVEL_HIGH : 1;     /*!< [25..25] GPIO14_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO14_EDGE_LOW : 1;       /*!< [26..26] GPIO14_EDGE_LOW                                                  */
      __IOM uint32_t GPIO14_EDGE_HIGH : 1;      /*!< [27..27] GPIO14_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO15_LEVEL_LOW : 1;      /*!< [28..28] GPIO15_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO15_LEVEL_HIGH : 1;     /*!< [29..29] GPIO15_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO15_EDGE_LOW : 1;       /*!< [30..30] GPIO15_EDGE_LOW                                                  */
      __IOM uint32_t GPIO15_EDGE_HIGH : 1;      /*!< [31..31] GPIO15_EDGE_HIGH                                                 */
    } bit;
  } PROC1_INTF1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000148) Interrupt Force for proc1                                  */
    
    struct {
      __IOM uint32_t GPIO16_LEVEL_LOW : 1;      /*!< [0..0] GPIO16_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO16_LEVEL_HIGH : 1;     /*!< [1..1] GPIO16_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO16_EDGE_LOW : 1;       /*!< [2..2] GPIO16_EDGE_LOW                                                    */
      __IOM uint32_t GPIO16_EDGE_HIGH : 1;      /*!< [3..3] GPIO16_EDGE_HIGH                                                   */
      __IOM uint32_t GPIO17_LEVEL_LOW : 1;      /*!< [4..4] GPIO17_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO17_LEVEL_HIGH : 1;     /*!< [5..5] GPIO17_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO17_EDGE_LOW : 1;       /*!< [6..6] GPIO17_EDGE_LOW                                                    */
      __IOM uint32_t GPIO17_EDGE_HIGH : 1;      /*!< [7..7] GPIO17_EDGE_HIGH                                                   */
      __IOM uint32_t GPIO18_LEVEL_LOW : 1;      /*!< [8..8] GPIO18_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO18_LEVEL_HIGH : 1;     /*!< [9..9] GPIO18_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO18_EDGE_LOW : 1;       /*!< [10..10] GPIO18_EDGE_LOW                                                  */
      __IOM uint32_t GPIO18_EDGE_HIGH : 1;      /*!< [11..11] GPIO18_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO19_LEVEL_LOW : 1;      /*!< [12..12] GPIO19_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO19_LEVEL_HIGH : 1;     /*!< [13..13] GPIO19_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO19_EDGE_LOW : 1;       /*!< [14..14] GPIO19_EDGE_LOW                                                  */
      __IOM uint32_t GPIO19_EDGE_HIGH : 1;      /*!< [15..15] GPIO19_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO20_LEVEL_LOW : 1;      /*!< [16..16] GPIO20_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO20_LEVEL_HIGH : 1;     /*!< [17..17] GPIO20_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO20_EDGE_LOW : 1;       /*!< [18..18] GPIO20_EDGE_LOW                                                  */
      __IOM uint32_t GPIO20_EDGE_HIGH : 1;      /*!< [19..19] GPIO20_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO21_LEVEL_LOW : 1;      /*!< [20..20] GPIO21_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO21_LEVEL_HIGH : 1;     /*!< [21..21] GPIO21_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO21_EDGE_LOW : 1;       /*!< [22..22] GPIO21_EDGE_LOW                                                  */
      __IOM uint32_t GPIO21_EDGE_HIGH : 1;      /*!< [23..23] GPIO21_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO22_LEVEL_LOW : 1;      /*!< [24..24] GPIO22_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO22_LEVEL_HIGH : 1;     /*!< [25..25] GPIO22_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO22_EDGE_LOW : 1;       /*!< [26..26] GPIO22_EDGE_LOW                                                  */
      __IOM uint32_t GPIO22_EDGE_HIGH : 1;      /*!< [27..27] GPIO22_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO23_LEVEL_LOW : 1;      /*!< [28..28] GPIO23_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO23_LEVEL_HIGH : 1;     /*!< [29..29] GPIO23_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO23_EDGE_LOW : 1;       /*!< [30..30] GPIO23_EDGE_LOW                                                  */
      __IOM uint32_t GPIO23_EDGE_HIGH : 1;      /*!< [31..31] GPIO23_EDGE_HIGH                                                 */
    } bit;
  } PROC1_INTF2;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000014C) Interrupt Force for proc1                                  */
    
    struct {
      __IOM uint32_t GPIO24_LEVEL_LOW : 1;      /*!< [0..0] GPIO24_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO24_LEVEL_HIGH : 1;     /*!< [1..1] GPIO24_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO24_EDGE_LOW : 1;       /*!< [2..2] GPIO24_EDGE_LOW                                                    */
      __IOM uint32_t GPIO24_EDGE_HIGH : 1;      /*!< [3..3] GPIO24_EDGE_HIGH                                                   */
      __IOM uint32_t GPIO25_LEVEL_LOW : 1;      /*!< [4..4] GPIO25_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO25_LEVEL_HIGH : 1;     /*!< [5..5] GPIO25_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO25_EDGE_LOW : 1;       /*!< [6..6] GPIO25_EDGE_LOW                                                    */
      __IOM uint32_t GPIO25_EDGE_HIGH : 1;      /*!< [7..7] GPIO25_EDGE_HIGH                                                   */
      __IOM uint32_t GPIO26_LEVEL_LOW : 1;      /*!< [8..8] GPIO26_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO26_LEVEL_HIGH : 1;     /*!< [9..9] GPIO26_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO26_EDGE_LOW : 1;       /*!< [10..10] GPIO26_EDGE_LOW                                                  */
      __IOM uint32_t GPIO26_EDGE_HIGH : 1;      /*!< [11..11] GPIO26_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO27_LEVEL_LOW : 1;      /*!< [12..12] GPIO27_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO27_LEVEL_HIGH : 1;     /*!< [13..13] GPIO27_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO27_EDGE_LOW : 1;       /*!< [14..14] GPIO27_EDGE_LOW                                                  */
      __IOM uint32_t GPIO27_EDGE_HIGH : 1;      /*!< [15..15] GPIO27_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO28_LEVEL_LOW : 1;      /*!< [16..16] GPIO28_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO28_LEVEL_HIGH : 1;     /*!< [17..17] GPIO28_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO28_EDGE_LOW : 1;       /*!< [18..18] GPIO28_EDGE_LOW                                                  */
      __IOM uint32_t GPIO28_EDGE_HIGH : 1;      /*!< [19..19] GPIO28_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO29_LEVEL_LOW : 1;      /*!< [20..20] GPIO29_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO29_LEVEL_HIGH : 1;     /*!< [21..21] GPIO29_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO29_EDGE_LOW : 1;       /*!< [22..22] GPIO29_EDGE_LOW                                                  */
      __IOM uint32_t GPIO29_EDGE_HIGH : 1;      /*!< [23..23] GPIO29_EDGE_HIGH                                                 */
            uint32_t            : 8;
    } bit;
  } PROC1_INTF3;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000150) Interrupt status after masking & forcing for
                                                                    proc1                                                      */
    
    struct {
      __IM  uint32_t GPIO0_LEVEL_LOW : 1;       /*!< [0..0] GPIO0_LEVEL_LOW                                                    */
      __IM  uint32_t GPIO0_LEVEL_HIGH : 1;      /*!< [1..1] GPIO0_LEVEL_HIGH                                                   */
      __IM  uint32_t GPIO0_EDGE_LOW : 1;        /*!< [2..2] GPIO0_EDGE_LOW                                                     */
      __IM  uint32_t GPIO0_EDGE_HIGH : 1;       /*!< [3..3] GPIO0_EDGE_HIGH                                                    */
      __IM  uint32_t GPIO1_LEVEL_LOW : 1;       /*!< [4..4] GPIO1_LEVEL_LOW                                                    */
      __IM  uint32_t GPIO1_LEVEL_HIGH : 1;      /*!< [5..5] GPIO1_LEVEL_HIGH                                                   */
      __IM  uint32_t GPIO1_EDGE_LOW : 1;        /*!< [6..6] GPIO1_EDGE_LOW                                                     */
      __IM  uint32_t GPIO1_EDGE_HIGH : 1;       /*!< [7..7] GPIO1_EDGE_HIGH                                                    */
      __IM  uint32_t GPIO2_LEVEL_LOW : 1;       /*!< [8..8] GPIO2_LEVEL_LOW                                                    */
      __IM  uint32_t GPIO2_LEVEL_HIGH : 1;      /*!< [9..9] GPIO2_LEVEL_HIGH                                                   */
      __IM  uint32_t GPIO2_EDGE_LOW : 1;        /*!< [10..10] GPIO2_EDGE_LOW                                                   */
      __IM  uint32_t GPIO2_EDGE_HIGH : 1;       /*!< [11..11] GPIO2_EDGE_HIGH                                                  */
      __IM  uint32_t GPIO3_LEVEL_LOW : 1;       /*!< [12..12] GPIO3_LEVEL_LOW                                                  */
      __IM  uint32_t GPIO3_LEVEL_HIGH : 1;      /*!< [13..13] GPIO3_LEVEL_HIGH                                                 */
      __IM  uint32_t GPIO3_EDGE_LOW : 1;        /*!< [14..14] GPIO3_EDGE_LOW                                                   */
      __IM  uint32_t GPIO3_EDGE_HIGH : 1;       /*!< [15..15] GPIO3_EDGE_HIGH                                                  */
      __IM  uint32_t GPIO4_LEVEL_LOW : 1;       /*!< [16..16] GPIO4_LEVEL_LOW                                                  */
      __IM  uint32_t GPIO4_LEVEL_HIGH : 1;      /*!< [17..17] GPIO4_LEVEL_HIGH                                                 */
      __IM  uint32_t GPIO4_EDGE_LOW : 1;        /*!< [18..18] GPIO4_EDGE_LOW                                                   */
      __IM  uint32_t GPIO4_EDGE_HIGH : 1;       /*!< [19..19] GPIO4_EDGE_HIGH                                                  */
      __IM  uint32_t GPIO5_LEVEL_LOW : 1;       /*!< [20..20] GPIO5_LEVEL_LOW                                                  */
      __IM  uint32_t GPIO5_LEVEL_HIGH : 1;      /*!< [21..21] GPIO5_LEVEL_HIGH                                                 */
      __IM  uint32_t GPIO5_EDGE_LOW : 1;        /*!< [22..22] GPIO5_EDGE_LOW                                                   */
      __IM  uint32_t GPIO5_EDGE_HIGH : 1;       /*!< [23..23] GPIO5_EDGE_HIGH                                                  */
      __IM  uint32_t GPIO6_LEVEL_LOW : 1;       /*!< [24..24] GPIO6_LEVEL_LOW                                                  */
      __IM  uint32_t GPIO6_LEVEL_HIGH : 1;      /*!< [25..25] GPIO6_LEVEL_HIGH                                                 */
      __IM  uint32_t GPIO6_EDGE_LOW : 1;        /*!< [26..26] GPIO6_EDGE_LOW                                                   */
      __IM  uint32_t GPIO6_EDGE_HIGH : 1;       /*!< [27..27] GPIO6_EDGE_HIGH                                                  */
      __IM  uint32_t GPIO7_LEVEL_LOW : 1;       /*!< [28..28] GPIO7_LEVEL_LOW                                                  */
      __IM  uint32_t GPIO7_LEVEL_HIGH : 1;      /*!< [29..29] GPIO7_LEVEL_HIGH                                                 */
      __IM  uint32_t GPIO7_EDGE_LOW : 1;        /*!< [30..30] GPIO7_EDGE_LOW                                                   */
      __IM  uint32_t GPIO7_EDGE_HIGH : 1;       /*!< [31..31] GPIO7_EDGE_HIGH                                                  */
    } bit;
  } PROC1_INTS0;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000154) Interrupt status after masking & forcing for
                                                                    proc1                                                      */
    
    struct {
      __IM  uint32_t GPIO8_LEVEL_LOW : 1;       /*!< [0..0] GPIO8_LEVEL_LOW                                                    */
      __IM  uint32_t GPIO8_LEVEL_HIGH : 1;      /*!< [1..1] GPIO8_LEVEL_HIGH                                                   */
      __IM  uint32_t GPIO8_EDGE_LOW : 1;        /*!< [2..2] GPIO8_EDGE_LOW                                                     */
      __IM  uint32_t GPIO8_EDGE_HIGH : 1;       /*!< [3..3] GPIO8_EDGE_HIGH                                                    */
      __IM  uint32_t GPIO9_LEVEL_LOW : 1;       /*!< [4..4] GPIO9_LEVEL_LOW                                                    */
      __IM  uint32_t GPIO9_LEVEL_HIGH : 1;      /*!< [5..5] GPIO9_LEVEL_HIGH                                                   */
      __IM  uint32_t GPIO9_EDGE_LOW : 1;        /*!< [6..6] GPIO9_EDGE_LOW                                                     */
      __IM  uint32_t GPIO9_EDGE_HIGH : 1;       /*!< [7..7] GPIO9_EDGE_HIGH                                                    */
      __IM  uint32_t GPIO10_LEVEL_LOW : 1;      /*!< [8..8] GPIO10_LEVEL_LOW                                                   */
      __IM  uint32_t GPIO10_LEVEL_HIGH : 1;     /*!< [9..9] GPIO10_LEVEL_HIGH                                                  */
      __IM  uint32_t GPIO10_EDGE_LOW : 1;       /*!< [10..10] GPIO10_EDGE_LOW                                                  */
      __IM  uint32_t GPIO10_EDGE_HIGH : 1;      /*!< [11..11] GPIO10_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO11_LEVEL_LOW : 1;      /*!< [12..12] GPIO11_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO11_LEVEL_HIGH : 1;     /*!< [13..13] GPIO11_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO11_EDGE_LOW : 1;       /*!< [14..14] GPIO11_EDGE_LOW                                                  */
      __IM  uint32_t GPIO11_EDGE_HIGH : 1;      /*!< [15..15] GPIO11_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO12_LEVEL_LOW : 1;      /*!< [16..16] GPIO12_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO12_LEVEL_HIGH : 1;     /*!< [17..17] GPIO12_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO12_EDGE_LOW : 1;       /*!< [18..18] GPIO12_EDGE_LOW                                                  */
      __IM  uint32_t GPIO12_EDGE_HIGH : 1;      /*!< [19..19] GPIO12_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO13_LEVEL_LOW : 1;      /*!< [20..20] GPIO13_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO13_LEVEL_HIGH : 1;     /*!< [21..21] GPIO13_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO13_EDGE_LOW : 1;       /*!< [22..22] GPIO13_EDGE_LOW                                                  */
      __IM  uint32_t GPIO13_EDGE_HIGH : 1;      /*!< [23..23] GPIO13_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO14_LEVEL_LOW : 1;      /*!< [24..24] GPIO14_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO14_LEVEL_HIGH : 1;     /*!< [25..25] GPIO14_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO14_EDGE_LOW : 1;       /*!< [26..26] GPIO14_EDGE_LOW                                                  */
      __IM  uint32_t GPIO14_EDGE_HIGH : 1;      /*!< [27..27] GPIO14_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO15_LEVEL_LOW : 1;      /*!< [28..28] GPIO15_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO15_LEVEL_HIGH : 1;     /*!< [29..29] GPIO15_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO15_EDGE_LOW : 1;       /*!< [30..30] GPIO15_EDGE_LOW                                                  */
      __IM  uint32_t GPIO15_EDGE_HIGH : 1;      /*!< [31..31] GPIO15_EDGE_HIGH                                                 */
    } bit;
  } PROC1_INTS1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000158) Interrupt status after masking & forcing for
                                                                    proc1                                                      */
    
    struct {
      __IM  uint32_t GPIO16_LEVEL_LOW : 1;      /*!< [0..0] GPIO16_LEVEL_LOW                                                   */
      __IM  uint32_t GPIO16_LEVEL_HIGH : 1;     /*!< [1..1] GPIO16_LEVEL_HIGH                                                  */
      __IM  uint32_t GPIO16_EDGE_LOW : 1;       /*!< [2..2] GPIO16_EDGE_LOW                                                    */
      __IM  uint32_t GPIO16_EDGE_HIGH : 1;      /*!< [3..3] GPIO16_EDGE_HIGH                                                   */
      __IM  uint32_t GPIO17_LEVEL_LOW : 1;      /*!< [4..4] GPIO17_LEVEL_LOW                                                   */
      __IM  uint32_t GPIO17_LEVEL_HIGH : 1;     /*!< [5..5] GPIO17_LEVEL_HIGH                                                  */
      __IM  uint32_t GPIO17_EDGE_LOW : 1;       /*!< [6..6] GPIO17_EDGE_LOW                                                    */
      __IM  uint32_t GPIO17_EDGE_HIGH : 1;      /*!< [7..7] GPIO17_EDGE_HIGH                                                   */
      __IM  uint32_t GPIO18_LEVEL_LOW : 1;      /*!< [8..8] GPIO18_LEVEL_LOW                                                   */
      __IM  uint32_t GPIO18_LEVEL_HIGH : 1;     /*!< [9..9] GPIO18_LEVEL_HIGH                                                  */
      __IM  uint32_t GPIO18_EDGE_LOW : 1;       /*!< [10..10] GPIO18_EDGE_LOW                                                  */
      __IM  uint32_t GPIO18_EDGE_HIGH : 1;      /*!< [11..11] GPIO18_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO19_LEVEL_LOW : 1;      /*!< [12..12] GPIO19_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO19_LEVEL_HIGH : 1;     /*!< [13..13] GPIO19_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO19_EDGE_LOW : 1;       /*!< [14..14] GPIO19_EDGE_LOW                                                  */
      __IM  uint32_t GPIO19_EDGE_HIGH : 1;      /*!< [15..15] GPIO19_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO20_LEVEL_LOW : 1;      /*!< [16..16] GPIO20_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO20_LEVEL_HIGH : 1;     /*!< [17..17] GPIO20_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO20_EDGE_LOW : 1;       /*!< [18..18] GPIO20_EDGE_LOW                                                  */
      __IM  uint32_t GPIO20_EDGE_HIGH : 1;      /*!< [19..19] GPIO20_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO21_LEVEL_LOW : 1;      /*!< [20..20] GPIO21_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO21_LEVEL_HIGH : 1;     /*!< [21..21] GPIO21_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO21_EDGE_LOW : 1;       /*!< [22..22] GPIO21_EDGE_LOW                                                  */
      __IM  uint32_t GPIO21_EDGE_HIGH : 1;      /*!< [23..23] GPIO21_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO22_LEVEL_LOW : 1;      /*!< [24..24] GPIO22_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO22_LEVEL_HIGH : 1;     /*!< [25..25] GPIO22_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO22_EDGE_LOW : 1;       /*!< [26..26] GPIO22_EDGE_LOW                                                  */
      __IM  uint32_t GPIO22_EDGE_HIGH : 1;      /*!< [27..27] GPIO22_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO23_LEVEL_LOW : 1;      /*!< [28..28] GPIO23_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO23_LEVEL_HIGH : 1;     /*!< [29..29] GPIO23_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO23_EDGE_LOW : 1;       /*!< [30..30] GPIO23_EDGE_LOW                                                  */
      __IM  uint32_t GPIO23_EDGE_HIGH : 1;      /*!< [31..31] GPIO23_EDGE_HIGH                                                 */
    } bit;
  } PROC1_INTS2;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000015C) Interrupt status after masking & forcing for
                                                                    proc1                                                      */
    
    struct {
      __IM  uint32_t GPIO24_LEVEL_LOW : 1;      /*!< [0..0] GPIO24_LEVEL_LOW                                                   */
      __IM  uint32_t GPIO24_LEVEL_HIGH : 1;     /*!< [1..1] GPIO24_LEVEL_HIGH                                                  */
      __IM  uint32_t GPIO24_EDGE_LOW : 1;       /*!< [2..2] GPIO24_EDGE_LOW                                                    */
      __IM  uint32_t GPIO24_EDGE_HIGH : 1;      /*!< [3..3] GPIO24_EDGE_HIGH                                                   */
      __IM  uint32_t GPIO25_LEVEL_LOW : 1;      /*!< [4..4] GPIO25_LEVEL_LOW                                                   */
      __IM  uint32_t GPIO25_LEVEL_HIGH : 1;     /*!< [5..5] GPIO25_LEVEL_HIGH                                                  */
      __IM  uint32_t GPIO25_EDGE_LOW : 1;       /*!< [6..6] GPIO25_EDGE_LOW                                                    */
      __IM  uint32_t GPIO25_EDGE_HIGH : 1;      /*!< [7..7] GPIO25_EDGE_HIGH                                                   */
      __IM  uint32_t GPIO26_LEVEL_LOW : 1;      /*!< [8..8] GPIO26_LEVEL_LOW                                                   */
      __IM  uint32_t GPIO26_LEVEL_HIGH : 1;     /*!< [9..9] GPIO26_LEVEL_HIGH                                                  */
      __IM  uint32_t GPIO26_EDGE_LOW : 1;       /*!< [10..10] GPIO26_EDGE_LOW                                                  */
      __IM  uint32_t GPIO26_EDGE_HIGH : 1;      /*!< [11..11] GPIO26_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO27_LEVEL_LOW : 1;      /*!< [12..12] GPIO27_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO27_LEVEL_HIGH : 1;     /*!< [13..13] GPIO27_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO27_EDGE_LOW : 1;       /*!< [14..14] GPIO27_EDGE_LOW                                                  */
      __IM  uint32_t GPIO27_EDGE_HIGH : 1;      /*!< [15..15] GPIO27_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO28_LEVEL_LOW : 1;      /*!< [16..16] GPIO28_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO28_LEVEL_HIGH : 1;     /*!< [17..17] GPIO28_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO28_EDGE_LOW : 1;       /*!< [18..18] GPIO28_EDGE_LOW                                                  */
      __IM  uint32_t GPIO28_EDGE_HIGH : 1;      /*!< [19..19] GPIO28_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO29_LEVEL_LOW : 1;      /*!< [20..20] GPIO29_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO29_LEVEL_HIGH : 1;     /*!< [21..21] GPIO29_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO29_EDGE_LOW : 1;       /*!< [22..22] GPIO29_EDGE_LOW                                                  */
      __IM  uint32_t GPIO29_EDGE_HIGH : 1;      /*!< [23..23] GPIO29_EDGE_HIGH                                                 */
            uint32_t            : 8;
    } bit;
  } PROC1_INTS3;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000160) Interrupt Enable for dormant_wake                          */
    
    struct {
      __IOM uint32_t GPIO0_LEVEL_LOW : 1;       /*!< [0..0] GPIO0_LEVEL_LOW                                                    */
      __IOM uint32_t GPIO0_LEVEL_HIGH : 1;      /*!< [1..1] GPIO0_LEVEL_HIGH                                                   */
      __IOM uint32_t GPIO0_EDGE_LOW : 1;        /*!< [2..2] GPIO0_EDGE_LOW                                                     */
      __IOM uint32_t GPIO0_EDGE_HIGH : 1;       /*!< [3..3] GPIO0_EDGE_HIGH                                                    */
      __IOM uint32_t GPIO1_LEVEL_LOW : 1;       /*!< [4..4] GPIO1_LEVEL_LOW                                                    */
      __IOM uint32_t GPIO1_LEVEL_HIGH : 1;      /*!< [5..5] GPIO1_LEVEL_HIGH                                                   */
      __IOM uint32_t GPIO1_EDGE_LOW : 1;        /*!< [6..6] GPIO1_EDGE_LOW                                                     */
      __IOM uint32_t GPIO1_EDGE_HIGH : 1;       /*!< [7..7] GPIO1_EDGE_HIGH                                                    */
      __IOM uint32_t GPIO2_LEVEL_LOW : 1;       /*!< [8..8] GPIO2_LEVEL_LOW                                                    */
      __IOM uint32_t GPIO2_LEVEL_HIGH : 1;      /*!< [9..9] GPIO2_LEVEL_HIGH                                                   */
      __IOM uint32_t GPIO2_EDGE_LOW : 1;        /*!< [10..10] GPIO2_EDGE_LOW                                                   */
      __IOM uint32_t GPIO2_EDGE_HIGH : 1;       /*!< [11..11] GPIO2_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO3_LEVEL_LOW : 1;       /*!< [12..12] GPIO3_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO3_LEVEL_HIGH : 1;      /*!< [13..13] GPIO3_LEVEL_HIGH                                                 */
      __IOM uint32_t GPIO3_EDGE_LOW : 1;        /*!< [14..14] GPIO3_EDGE_LOW                                                   */
      __IOM uint32_t GPIO3_EDGE_HIGH : 1;       /*!< [15..15] GPIO3_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO4_LEVEL_LOW : 1;       /*!< [16..16] GPIO4_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO4_LEVEL_HIGH : 1;      /*!< [17..17] GPIO4_LEVEL_HIGH                                                 */
      __IOM uint32_t GPIO4_EDGE_LOW : 1;        /*!< [18..18] GPIO4_EDGE_LOW                                                   */
      __IOM uint32_t GPIO4_EDGE_HIGH : 1;       /*!< [19..19] GPIO4_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO5_LEVEL_LOW : 1;       /*!< [20..20] GPIO5_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO5_LEVEL_HIGH : 1;      /*!< [21..21] GPIO5_LEVEL_HIGH                                                 */
      __IOM uint32_t GPIO5_EDGE_LOW : 1;        /*!< [22..22] GPIO5_EDGE_LOW                                                   */
      __IOM uint32_t GPIO5_EDGE_HIGH : 1;       /*!< [23..23] GPIO5_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO6_LEVEL_LOW : 1;       /*!< [24..24] GPIO6_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO6_LEVEL_HIGH : 1;      /*!< [25..25] GPIO6_LEVEL_HIGH                                                 */
      __IOM uint32_t GPIO6_EDGE_LOW : 1;        /*!< [26..26] GPIO6_EDGE_LOW                                                   */
      __IOM uint32_t GPIO6_EDGE_HIGH : 1;       /*!< [27..27] GPIO6_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO7_LEVEL_LOW : 1;       /*!< [28..28] GPIO7_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO7_LEVEL_HIGH : 1;      /*!< [29..29] GPIO7_LEVEL_HIGH                                                 */
      __IOM uint32_t GPIO7_EDGE_LOW : 1;        /*!< [30..30] GPIO7_EDGE_LOW                                                   */
      __IOM uint32_t GPIO7_EDGE_HIGH : 1;       /*!< [31..31] GPIO7_EDGE_HIGH                                                  */
    } bit;
  } DORMANT_WAKE_INTE0;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000164) Interrupt Enable for dormant_wake                          */
    
    struct {
      __IOM uint32_t GPIO8_LEVEL_LOW : 1;       /*!< [0..0] GPIO8_LEVEL_LOW                                                    */
      __IOM uint32_t GPIO8_LEVEL_HIGH : 1;      /*!< [1..1] GPIO8_LEVEL_HIGH                                                   */
      __IOM uint32_t GPIO8_EDGE_LOW : 1;        /*!< [2..2] GPIO8_EDGE_LOW                                                     */
      __IOM uint32_t GPIO8_EDGE_HIGH : 1;       /*!< [3..3] GPIO8_EDGE_HIGH                                                    */
      __IOM uint32_t GPIO9_LEVEL_LOW : 1;       /*!< [4..4] GPIO9_LEVEL_LOW                                                    */
      __IOM uint32_t GPIO9_LEVEL_HIGH : 1;      /*!< [5..5] GPIO9_LEVEL_HIGH                                                   */
      __IOM uint32_t GPIO9_EDGE_LOW : 1;        /*!< [6..6] GPIO9_EDGE_LOW                                                     */
      __IOM uint32_t GPIO9_EDGE_HIGH : 1;       /*!< [7..7] GPIO9_EDGE_HIGH                                                    */
      __IOM uint32_t GPIO10_LEVEL_LOW : 1;      /*!< [8..8] GPIO10_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO10_LEVEL_HIGH : 1;     /*!< [9..9] GPIO10_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO10_EDGE_LOW : 1;       /*!< [10..10] GPIO10_EDGE_LOW                                                  */
      __IOM uint32_t GPIO10_EDGE_HIGH : 1;      /*!< [11..11] GPIO10_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO11_LEVEL_LOW : 1;      /*!< [12..12] GPIO11_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO11_LEVEL_HIGH : 1;     /*!< [13..13] GPIO11_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO11_EDGE_LOW : 1;       /*!< [14..14] GPIO11_EDGE_LOW                                                  */
      __IOM uint32_t GPIO11_EDGE_HIGH : 1;      /*!< [15..15] GPIO11_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO12_LEVEL_LOW : 1;      /*!< [16..16] GPIO12_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO12_LEVEL_HIGH : 1;     /*!< [17..17] GPIO12_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO12_EDGE_LOW : 1;       /*!< [18..18] GPIO12_EDGE_LOW                                                  */
      __IOM uint32_t GPIO12_EDGE_HIGH : 1;      /*!< [19..19] GPIO12_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO13_LEVEL_LOW : 1;      /*!< [20..20] GPIO13_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO13_LEVEL_HIGH : 1;     /*!< [21..21] GPIO13_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO13_EDGE_LOW : 1;       /*!< [22..22] GPIO13_EDGE_LOW                                                  */
      __IOM uint32_t GPIO13_EDGE_HIGH : 1;      /*!< [23..23] GPIO13_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO14_LEVEL_LOW : 1;      /*!< [24..24] GPIO14_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO14_LEVEL_HIGH : 1;     /*!< [25..25] GPIO14_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO14_EDGE_LOW : 1;       /*!< [26..26] GPIO14_EDGE_LOW                                                  */
      __IOM uint32_t GPIO14_EDGE_HIGH : 1;      /*!< [27..27] GPIO14_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO15_LEVEL_LOW : 1;      /*!< [28..28] GPIO15_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO15_LEVEL_HIGH : 1;     /*!< [29..29] GPIO15_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO15_EDGE_LOW : 1;       /*!< [30..30] GPIO15_EDGE_LOW                                                  */
      __IOM uint32_t GPIO15_EDGE_HIGH : 1;      /*!< [31..31] GPIO15_EDGE_HIGH                                                 */
    } bit;
  } DORMANT_WAKE_INTE1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000168) Interrupt Enable for dormant_wake                          */
    
    struct {
      __IOM uint32_t GPIO16_LEVEL_LOW : 1;      /*!< [0..0] GPIO16_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO16_LEVEL_HIGH : 1;     /*!< [1..1] GPIO16_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO16_EDGE_LOW : 1;       /*!< [2..2] GPIO16_EDGE_LOW                                                    */
      __IOM uint32_t GPIO16_EDGE_HIGH : 1;      /*!< [3..3] GPIO16_EDGE_HIGH                                                   */
      __IOM uint32_t GPIO17_LEVEL_LOW : 1;      /*!< [4..4] GPIO17_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO17_LEVEL_HIGH : 1;     /*!< [5..5] GPIO17_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO17_EDGE_LOW : 1;       /*!< [6..6] GPIO17_EDGE_LOW                                                    */
      __IOM uint32_t GPIO17_EDGE_HIGH : 1;      /*!< [7..7] GPIO17_EDGE_HIGH                                                   */
      __IOM uint32_t GPIO18_LEVEL_LOW : 1;      /*!< [8..8] GPIO18_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO18_LEVEL_HIGH : 1;     /*!< [9..9] GPIO18_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO18_EDGE_LOW : 1;       /*!< [10..10] GPIO18_EDGE_LOW                                                  */
      __IOM uint32_t GPIO18_EDGE_HIGH : 1;      /*!< [11..11] GPIO18_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO19_LEVEL_LOW : 1;      /*!< [12..12] GPIO19_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO19_LEVEL_HIGH : 1;     /*!< [13..13] GPIO19_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO19_EDGE_LOW : 1;       /*!< [14..14] GPIO19_EDGE_LOW                                                  */
      __IOM uint32_t GPIO19_EDGE_HIGH : 1;      /*!< [15..15] GPIO19_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO20_LEVEL_LOW : 1;      /*!< [16..16] GPIO20_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO20_LEVEL_HIGH : 1;     /*!< [17..17] GPIO20_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO20_EDGE_LOW : 1;       /*!< [18..18] GPIO20_EDGE_LOW                                                  */
      __IOM uint32_t GPIO20_EDGE_HIGH : 1;      /*!< [19..19] GPIO20_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO21_LEVEL_LOW : 1;      /*!< [20..20] GPIO21_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO21_LEVEL_HIGH : 1;     /*!< [21..21] GPIO21_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO21_EDGE_LOW : 1;       /*!< [22..22] GPIO21_EDGE_LOW                                                  */
      __IOM uint32_t GPIO21_EDGE_HIGH : 1;      /*!< [23..23] GPIO21_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO22_LEVEL_LOW : 1;      /*!< [24..24] GPIO22_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO22_LEVEL_HIGH : 1;     /*!< [25..25] GPIO22_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO22_EDGE_LOW : 1;       /*!< [26..26] GPIO22_EDGE_LOW                                                  */
      __IOM uint32_t GPIO22_EDGE_HIGH : 1;      /*!< [27..27] GPIO22_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO23_LEVEL_LOW : 1;      /*!< [28..28] GPIO23_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO23_LEVEL_HIGH : 1;     /*!< [29..29] GPIO23_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO23_EDGE_LOW : 1;       /*!< [30..30] GPIO23_EDGE_LOW                                                  */
      __IOM uint32_t GPIO23_EDGE_HIGH : 1;      /*!< [31..31] GPIO23_EDGE_HIGH                                                 */
    } bit;
  } DORMANT_WAKE_INTE2;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000016C) Interrupt Enable for dormant_wake                          */
    
    struct {
      __IOM uint32_t GPIO24_LEVEL_LOW : 1;      /*!< [0..0] GPIO24_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO24_LEVEL_HIGH : 1;     /*!< [1..1] GPIO24_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO24_EDGE_LOW : 1;       /*!< [2..2] GPIO24_EDGE_LOW                                                    */
      __IOM uint32_t GPIO24_EDGE_HIGH : 1;      /*!< [3..3] GPIO24_EDGE_HIGH                                                   */
      __IOM uint32_t GPIO25_LEVEL_LOW : 1;      /*!< [4..4] GPIO25_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO25_LEVEL_HIGH : 1;     /*!< [5..5] GPIO25_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO25_EDGE_LOW : 1;       /*!< [6..6] GPIO25_EDGE_LOW                                                    */
      __IOM uint32_t GPIO25_EDGE_HIGH : 1;      /*!< [7..7] GPIO25_EDGE_HIGH                                                   */
      __IOM uint32_t GPIO26_LEVEL_LOW : 1;      /*!< [8..8] GPIO26_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO26_LEVEL_HIGH : 1;     /*!< [9..9] GPIO26_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO26_EDGE_LOW : 1;       /*!< [10..10] GPIO26_EDGE_LOW                                                  */
      __IOM uint32_t GPIO26_EDGE_HIGH : 1;      /*!< [11..11] GPIO26_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO27_LEVEL_LOW : 1;      /*!< [12..12] GPIO27_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO27_LEVEL_HIGH : 1;     /*!< [13..13] GPIO27_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO27_EDGE_LOW : 1;       /*!< [14..14] GPIO27_EDGE_LOW                                                  */
      __IOM uint32_t GPIO27_EDGE_HIGH : 1;      /*!< [15..15] GPIO27_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO28_LEVEL_LOW : 1;      /*!< [16..16] GPIO28_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO28_LEVEL_HIGH : 1;     /*!< [17..17] GPIO28_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO28_EDGE_LOW : 1;       /*!< [18..18] GPIO28_EDGE_LOW                                                  */
      __IOM uint32_t GPIO28_EDGE_HIGH : 1;      /*!< [19..19] GPIO28_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO29_LEVEL_LOW : 1;      /*!< [20..20] GPIO29_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO29_LEVEL_HIGH : 1;     /*!< [21..21] GPIO29_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO29_EDGE_LOW : 1;       /*!< [22..22] GPIO29_EDGE_LOW                                                  */
      __IOM uint32_t GPIO29_EDGE_HIGH : 1;      /*!< [23..23] GPIO29_EDGE_HIGH                                                 */
            uint32_t            : 8;
    } bit;
  } DORMANT_WAKE_INTE3;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000170) Interrupt Force for dormant_wake                           */
    
    struct {
      __IOM uint32_t GPIO0_LEVEL_LOW : 1;       /*!< [0..0] GPIO0_LEVEL_LOW                                                    */
      __IOM uint32_t GPIO0_LEVEL_HIGH : 1;      /*!< [1..1] GPIO0_LEVEL_HIGH                                                   */
      __IOM uint32_t GPIO0_EDGE_LOW : 1;        /*!< [2..2] GPIO0_EDGE_LOW                                                     */
      __IOM uint32_t GPIO0_EDGE_HIGH : 1;       /*!< [3..3] GPIO0_EDGE_HIGH                                                    */
      __IOM uint32_t GPIO1_LEVEL_LOW : 1;       /*!< [4..4] GPIO1_LEVEL_LOW                                                    */
      __IOM uint32_t GPIO1_LEVEL_HIGH : 1;      /*!< [5..5] GPIO1_LEVEL_HIGH                                                   */
      __IOM uint32_t GPIO1_EDGE_LOW : 1;        /*!< [6..6] GPIO1_EDGE_LOW                                                     */
      __IOM uint32_t GPIO1_EDGE_HIGH : 1;       /*!< [7..7] GPIO1_EDGE_HIGH                                                    */
      __IOM uint32_t GPIO2_LEVEL_LOW : 1;       /*!< [8..8] GPIO2_LEVEL_LOW                                                    */
      __IOM uint32_t GPIO2_LEVEL_HIGH : 1;      /*!< [9..9] GPIO2_LEVEL_HIGH                                                   */
      __IOM uint32_t GPIO2_EDGE_LOW : 1;        /*!< [10..10] GPIO2_EDGE_LOW                                                   */
      __IOM uint32_t GPIO2_EDGE_HIGH : 1;       /*!< [11..11] GPIO2_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO3_LEVEL_LOW : 1;       /*!< [12..12] GPIO3_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO3_LEVEL_HIGH : 1;      /*!< [13..13] GPIO3_LEVEL_HIGH                                                 */
      __IOM uint32_t GPIO3_EDGE_LOW : 1;        /*!< [14..14] GPIO3_EDGE_LOW                                                   */
      __IOM uint32_t GPIO3_EDGE_HIGH : 1;       /*!< [15..15] GPIO3_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO4_LEVEL_LOW : 1;       /*!< [16..16] GPIO4_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO4_LEVEL_HIGH : 1;      /*!< [17..17] GPIO4_LEVEL_HIGH                                                 */
      __IOM uint32_t GPIO4_EDGE_LOW : 1;        /*!< [18..18] GPIO4_EDGE_LOW                                                   */
      __IOM uint32_t GPIO4_EDGE_HIGH : 1;       /*!< [19..19] GPIO4_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO5_LEVEL_LOW : 1;       /*!< [20..20] GPIO5_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO5_LEVEL_HIGH : 1;      /*!< [21..21] GPIO5_LEVEL_HIGH                                                 */
      __IOM uint32_t GPIO5_EDGE_LOW : 1;        /*!< [22..22] GPIO5_EDGE_LOW                                                   */
      __IOM uint32_t GPIO5_EDGE_HIGH : 1;       /*!< [23..23] GPIO5_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO6_LEVEL_LOW : 1;       /*!< [24..24] GPIO6_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO6_LEVEL_HIGH : 1;      /*!< [25..25] GPIO6_LEVEL_HIGH                                                 */
      __IOM uint32_t GPIO6_EDGE_LOW : 1;        /*!< [26..26] GPIO6_EDGE_LOW                                                   */
      __IOM uint32_t GPIO6_EDGE_HIGH : 1;       /*!< [27..27] GPIO6_EDGE_HIGH                                                  */
      __IOM uint32_t GPIO7_LEVEL_LOW : 1;       /*!< [28..28] GPIO7_LEVEL_LOW                                                  */
      __IOM uint32_t GPIO7_LEVEL_HIGH : 1;      /*!< [29..29] GPIO7_LEVEL_HIGH                                                 */
      __IOM uint32_t GPIO7_EDGE_LOW : 1;        /*!< [30..30] GPIO7_EDGE_LOW                                                   */
      __IOM uint32_t GPIO7_EDGE_HIGH : 1;       /*!< [31..31] GPIO7_EDGE_HIGH                                                  */
    } bit;
  } DORMANT_WAKE_INTF0;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000174) Interrupt Force for dormant_wake                           */
    
    struct {
      __IOM uint32_t GPIO8_LEVEL_LOW : 1;       /*!< [0..0] GPIO8_LEVEL_LOW                                                    */
      __IOM uint32_t GPIO8_LEVEL_HIGH : 1;      /*!< [1..1] GPIO8_LEVEL_HIGH                                                   */
      __IOM uint32_t GPIO8_EDGE_LOW : 1;        /*!< [2..2] GPIO8_EDGE_LOW                                                     */
      __IOM uint32_t GPIO8_EDGE_HIGH : 1;       /*!< [3..3] GPIO8_EDGE_HIGH                                                    */
      __IOM uint32_t GPIO9_LEVEL_LOW : 1;       /*!< [4..4] GPIO9_LEVEL_LOW                                                    */
      __IOM uint32_t GPIO9_LEVEL_HIGH : 1;      /*!< [5..5] GPIO9_LEVEL_HIGH                                                   */
      __IOM uint32_t GPIO9_EDGE_LOW : 1;        /*!< [6..6] GPIO9_EDGE_LOW                                                     */
      __IOM uint32_t GPIO9_EDGE_HIGH : 1;       /*!< [7..7] GPIO9_EDGE_HIGH                                                    */
      __IOM uint32_t GPIO10_LEVEL_LOW : 1;      /*!< [8..8] GPIO10_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO10_LEVEL_HIGH : 1;     /*!< [9..9] GPIO10_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO10_EDGE_LOW : 1;       /*!< [10..10] GPIO10_EDGE_LOW                                                  */
      __IOM uint32_t GPIO10_EDGE_HIGH : 1;      /*!< [11..11] GPIO10_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO11_LEVEL_LOW : 1;      /*!< [12..12] GPIO11_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO11_LEVEL_HIGH : 1;     /*!< [13..13] GPIO11_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO11_EDGE_LOW : 1;       /*!< [14..14] GPIO11_EDGE_LOW                                                  */
      __IOM uint32_t GPIO11_EDGE_HIGH : 1;      /*!< [15..15] GPIO11_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO12_LEVEL_LOW : 1;      /*!< [16..16] GPIO12_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO12_LEVEL_HIGH : 1;     /*!< [17..17] GPIO12_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO12_EDGE_LOW : 1;       /*!< [18..18] GPIO12_EDGE_LOW                                                  */
      __IOM uint32_t GPIO12_EDGE_HIGH : 1;      /*!< [19..19] GPIO12_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO13_LEVEL_LOW : 1;      /*!< [20..20] GPIO13_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO13_LEVEL_HIGH : 1;     /*!< [21..21] GPIO13_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO13_EDGE_LOW : 1;       /*!< [22..22] GPIO13_EDGE_LOW                                                  */
      __IOM uint32_t GPIO13_EDGE_HIGH : 1;      /*!< [23..23] GPIO13_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO14_LEVEL_LOW : 1;      /*!< [24..24] GPIO14_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO14_LEVEL_HIGH : 1;     /*!< [25..25] GPIO14_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO14_EDGE_LOW : 1;       /*!< [26..26] GPIO14_EDGE_LOW                                                  */
      __IOM uint32_t GPIO14_EDGE_HIGH : 1;      /*!< [27..27] GPIO14_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO15_LEVEL_LOW : 1;      /*!< [28..28] GPIO15_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO15_LEVEL_HIGH : 1;     /*!< [29..29] GPIO15_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO15_EDGE_LOW : 1;       /*!< [30..30] GPIO15_EDGE_LOW                                                  */
      __IOM uint32_t GPIO15_EDGE_HIGH : 1;      /*!< [31..31] GPIO15_EDGE_HIGH                                                 */
    } bit;
  } DORMANT_WAKE_INTF1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000178) Interrupt Force for dormant_wake                           */
    
    struct {
      __IOM uint32_t GPIO16_LEVEL_LOW : 1;      /*!< [0..0] GPIO16_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO16_LEVEL_HIGH : 1;     /*!< [1..1] GPIO16_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO16_EDGE_LOW : 1;       /*!< [2..2] GPIO16_EDGE_LOW                                                    */
      __IOM uint32_t GPIO16_EDGE_HIGH : 1;      /*!< [3..3] GPIO16_EDGE_HIGH                                                   */
      __IOM uint32_t GPIO17_LEVEL_LOW : 1;      /*!< [4..4] GPIO17_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO17_LEVEL_HIGH : 1;     /*!< [5..5] GPIO17_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO17_EDGE_LOW : 1;       /*!< [6..6] GPIO17_EDGE_LOW                                                    */
      __IOM uint32_t GPIO17_EDGE_HIGH : 1;      /*!< [7..7] GPIO17_EDGE_HIGH                                                   */
      __IOM uint32_t GPIO18_LEVEL_LOW : 1;      /*!< [8..8] GPIO18_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO18_LEVEL_HIGH : 1;     /*!< [9..9] GPIO18_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO18_EDGE_LOW : 1;       /*!< [10..10] GPIO18_EDGE_LOW                                                  */
      __IOM uint32_t GPIO18_EDGE_HIGH : 1;      /*!< [11..11] GPIO18_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO19_LEVEL_LOW : 1;      /*!< [12..12] GPIO19_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO19_LEVEL_HIGH : 1;     /*!< [13..13] GPIO19_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO19_EDGE_LOW : 1;       /*!< [14..14] GPIO19_EDGE_LOW                                                  */
      __IOM uint32_t GPIO19_EDGE_HIGH : 1;      /*!< [15..15] GPIO19_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO20_LEVEL_LOW : 1;      /*!< [16..16] GPIO20_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO20_LEVEL_HIGH : 1;     /*!< [17..17] GPIO20_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO20_EDGE_LOW : 1;       /*!< [18..18] GPIO20_EDGE_LOW                                                  */
      __IOM uint32_t GPIO20_EDGE_HIGH : 1;      /*!< [19..19] GPIO20_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO21_LEVEL_LOW : 1;      /*!< [20..20] GPIO21_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO21_LEVEL_HIGH : 1;     /*!< [21..21] GPIO21_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO21_EDGE_LOW : 1;       /*!< [22..22] GPIO21_EDGE_LOW                                                  */
      __IOM uint32_t GPIO21_EDGE_HIGH : 1;      /*!< [23..23] GPIO21_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO22_LEVEL_LOW : 1;      /*!< [24..24] GPIO22_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO22_LEVEL_HIGH : 1;     /*!< [25..25] GPIO22_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO22_EDGE_LOW : 1;       /*!< [26..26] GPIO22_EDGE_LOW                                                  */
      __IOM uint32_t GPIO22_EDGE_HIGH : 1;      /*!< [27..27] GPIO22_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO23_LEVEL_LOW : 1;      /*!< [28..28] GPIO23_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO23_LEVEL_HIGH : 1;     /*!< [29..29] GPIO23_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO23_EDGE_LOW : 1;       /*!< [30..30] GPIO23_EDGE_LOW                                                  */
      __IOM uint32_t GPIO23_EDGE_HIGH : 1;      /*!< [31..31] GPIO23_EDGE_HIGH                                                 */
    } bit;
  } DORMANT_WAKE_INTF2;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000017C) Interrupt Force for dormant_wake                           */
    
    struct {
      __IOM uint32_t GPIO24_LEVEL_LOW : 1;      /*!< [0..0] GPIO24_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO24_LEVEL_HIGH : 1;     /*!< [1..1] GPIO24_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO24_EDGE_LOW : 1;       /*!< [2..2] GPIO24_EDGE_LOW                                                    */
      __IOM uint32_t GPIO24_EDGE_HIGH : 1;      /*!< [3..3] GPIO24_EDGE_HIGH                                                   */
      __IOM uint32_t GPIO25_LEVEL_LOW : 1;      /*!< [4..4] GPIO25_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO25_LEVEL_HIGH : 1;     /*!< [5..5] GPIO25_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO25_EDGE_LOW : 1;       /*!< [6..6] GPIO25_EDGE_LOW                                                    */
      __IOM uint32_t GPIO25_EDGE_HIGH : 1;      /*!< [7..7] GPIO25_EDGE_HIGH                                                   */
      __IOM uint32_t GPIO26_LEVEL_LOW : 1;      /*!< [8..8] GPIO26_LEVEL_LOW                                                   */
      __IOM uint32_t GPIO26_LEVEL_HIGH : 1;     /*!< [9..9] GPIO26_LEVEL_HIGH                                                  */
      __IOM uint32_t GPIO26_EDGE_LOW : 1;       /*!< [10..10] GPIO26_EDGE_LOW                                                  */
      __IOM uint32_t GPIO26_EDGE_HIGH : 1;      /*!< [11..11] GPIO26_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO27_LEVEL_LOW : 1;      /*!< [12..12] GPIO27_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO27_LEVEL_HIGH : 1;     /*!< [13..13] GPIO27_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO27_EDGE_LOW : 1;       /*!< [14..14] GPIO27_EDGE_LOW                                                  */
      __IOM uint32_t GPIO27_EDGE_HIGH : 1;      /*!< [15..15] GPIO27_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO28_LEVEL_LOW : 1;      /*!< [16..16] GPIO28_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO28_LEVEL_HIGH : 1;     /*!< [17..17] GPIO28_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO28_EDGE_LOW : 1;       /*!< [18..18] GPIO28_EDGE_LOW                                                  */
      __IOM uint32_t GPIO28_EDGE_HIGH : 1;      /*!< [19..19] GPIO28_EDGE_HIGH                                                 */
      __IOM uint32_t GPIO29_LEVEL_LOW : 1;      /*!< [20..20] GPIO29_LEVEL_LOW                                                 */
      __IOM uint32_t GPIO29_LEVEL_HIGH : 1;     /*!< [21..21] GPIO29_LEVEL_HIGH                                                */
      __IOM uint32_t GPIO29_EDGE_LOW : 1;       /*!< [22..22] GPIO29_EDGE_LOW                                                  */
      __IOM uint32_t GPIO29_EDGE_HIGH : 1;      /*!< [23..23] GPIO29_EDGE_HIGH                                                 */
            uint32_t            : 8;
    } bit;
  } DORMANT_WAKE_INTF3;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000180) Interrupt status after masking & forcing for
                                                                    dormant_wake                                               */
    
    struct {
      __IM  uint32_t GPIO0_LEVEL_LOW : 1;       /*!< [0..0] GPIO0_LEVEL_LOW                                                    */
      __IM  uint32_t GPIO0_LEVEL_HIGH : 1;      /*!< [1..1] GPIO0_LEVEL_HIGH                                                   */
      __IM  uint32_t GPIO0_EDGE_LOW : 1;        /*!< [2..2] GPIO0_EDGE_LOW                                                     */
      __IM  uint32_t GPIO0_EDGE_HIGH : 1;       /*!< [3..3] GPIO0_EDGE_HIGH                                                    */
      __IM  uint32_t GPIO1_LEVEL_LOW : 1;       /*!< [4..4] GPIO1_LEVEL_LOW                                                    */
      __IM  uint32_t GPIO1_LEVEL_HIGH : 1;      /*!< [5..5] GPIO1_LEVEL_HIGH                                                   */
      __IM  uint32_t GPIO1_EDGE_LOW : 1;        /*!< [6..6] GPIO1_EDGE_LOW                                                     */
      __IM  uint32_t GPIO1_EDGE_HIGH : 1;       /*!< [7..7] GPIO1_EDGE_HIGH                                                    */
      __IM  uint32_t GPIO2_LEVEL_LOW : 1;       /*!< [8..8] GPIO2_LEVEL_LOW                                                    */
      __IM  uint32_t GPIO2_LEVEL_HIGH : 1;      /*!< [9..9] GPIO2_LEVEL_HIGH                                                   */
      __IM  uint32_t GPIO2_EDGE_LOW : 1;        /*!< [10..10] GPIO2_EDGE_LOW                                                   */
      __IM  uint32_t GPIO2_EDGE_HIGH : 1;       /*!< [11..11] GPIO2_EDGE_HIGH                                                  */
      __IM  uint32_t GPIO3_LEVEL_LOW : 1;       /*!< [12..12] GPIO3_LEVEL_LOW                                                  */
      __IM  uint32_t GPIO3_LEVEL_HIGH : 1;      /*!< [13..13] GPIO3_LEVEL_HIGH                                                 */
      __IM  uint32_t GPIO3_EDGE_LOW : 1;        /*!< [14..14] GPIO3_EDGE_LOW                                                   */
      __IM  uint32_t GPIO3_EDGE_HIGH : 1;       /*!< [15..15] GPIO3_EDGE_HIGH                                                  */
      __IM  uint32_t GPIO4_LEVEL_LOW : 1;       /*!< [16..16] GPIO4_LEVEL_LOW                                                  */
      __IM  uint32_t GPIO4_LEVEL_HIGH : 1;      /*!< [17..17] GPIO4_LEVEL_HIGH                                                 */
      __IM  uint32_t GPIO4_EDGE_LOW : 1;        /*!< [18..18] GPIO4_EDGE_LOW                                                   */
      __IM  uint32_t GPIO4_EDGE_HIGH : 1;       /*!< [19..19] GPIO4_EDGE_HIGH                                                  */
      __IM  uint32_t GPIO5_LEVEL_LOW : 1;       /*!< [20..20] GPIO5_LEVEL_LOW                                                  */
      __IM  uint32_t GPIO5_LEVEL_HIGH : 1;      /*!< [21..21] GPIO5_LEVEL_HIGH                                                 */
      __IM  uint32_t GPIO5_EDGE_LOW : 1;        /*!< [22..22] GPIO5_EDGE_LOW                                                   */
      __IM  uint32_t GPIO5_EDGE_HIGH : 1;       /*!< [23..23] GPIO5_EDGE_HIGH                                                  */
      __IM  uint32_t GPIO6_LEVEL_LOW : 1;       /*!< [24..24] GPIO6_LEVEL_LOW                                                  */
      __IM  uint32_t GPIO6_LEVEL_HIGH : 1;      /*!< [25..25] GPIO6_LEVEL_HIGH                                                 */
      __IM  uint32_t GPIO6_EDGE_LOW : 1;        /*!< [26..26] GPIO6_EDGE_LOW                                                   */
      __IM  uint32_t GPIO6_EDGE_HIGH : 1;       /*!< [27..27] GPIO6_EDGE_HIGH                                                  */
      __IM  uint32_t GPIO7_LEVEL_LOW : 1;       /*!< [28..28] GPIO7_LEVEL_LOW                                                  */
      __IM  uint32_t GPIO7_LEVEL_HIGH : 1;      /*!< [29..29] GPIO7_LEVEL_HIGH                                                 */
      __IM  uint32_t GPIO7_EDGE_LOW : 1;        /*!< [30..30] GPIO7_EDGE_LOW                                                   */
      __IM  uint32_t GPIO7_EDGE_HIGH : 1;       /*!< [31..31] GPIO7_EDGE_HIGH                                                  */
    } bit;
  } DORMANT_WAKE_INTS0;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000184) Interrupt status after masking & forcing for
                                                                    dormant_wake                                               */
    
    struct {
      __IM  uint32_t GPIO8_LEVEL_LOW : 1;       /*!< [0..0] GPIO8_LEVEL_LOW                                                    */
      __IM  uint32_t GPIO8_LEVEL_HIGH : 1;      /*!< [1..1] GPIO8_LEVEL_HIGH                                                   */
      __IM  uint32_t GPIO8_EDGE_LOW : 1;        /*!< [2..2] GPIO8_EDGE_LOW                                                     */
      __IM  uint32_t GPIO8_EDGE_HIGH : 1;       /*!< [3..3] GPIO8_EDGE_HIGH                                                    */
      __IM  uint32_t GPIO9_LEVEL_LOW : 1;       /*!< [4..4] GPIO9_LEVEL_LOW                                                    */
      __IM  uint32_t GPIO9_LEVEL_HIGH : 1;      /*!< [5..5] GPIO9_LEVEL_HIGH                                                   */
      __IM  uint32_t GPIO9_EDGE_LOW : 1;        /*!< [6..6] GPIO9_EDGE_LOW                                                     */
      __IM  uint32_t GPIO9_EDGE_HIGH : 1;       /*!< [7..7] GPIO9_EDGE_HIGH                                                    */
      __IM  uint32_t GPIO10_LEVEL_LOW : 1;      /*!< [8..8] GPIO10_LEVEL_LOW                                                   */
      __IM  uint32_t GPIO10_LEVEL_HIGH : 1;     /*!< [9..9] GPIO10_LEVEL_HIGH                                                  */
      __IM  uint32_t GPIO10_EDGE_LOW : 1;       /*!< [10..10] GPIO10_EDGE_LOW                                                  */
      __IM  uint32_t GPIO10_EDGE_HIGH : 1;      /*!< [11..11] GPIO10_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO11_LEVEL_LOW : 1;      /*!< [12..12] GPIO11_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO11_LEVEL_HIGH : 1;     /*!< [13..13] GPIO11_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO11_EDGE_LOW : 1;       /*!< [14..14] GPIO11_EDGE_LOW                                                  */
      __IM  uint32_t GPIO11_EDGE_HIGH : 1;      /*!< [15..15] GPIO11_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO12_LEVEL_LOW : 1;      /*!< [16..16] GPIO12_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO12_LEVEL_HIGH : 1;     /*!< [17..17] GPIO12_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO12_EDGE_LOW : 1;       /*!< [18..18] GPIO12_EDGE_LOW                                                  */
      __IM  uint32_t GPIO12_EDGE_HIGH : 1;      /*!< [19..19] GPIO12_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO13_LEVEL_LOW : 1;      /*!< [20..20] GPIO13_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO13_LEVEL_HIGH : 1;     /*!< [21..21] GPIO13_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO13_EDGE_LOW : 1;       /*!< [22..22] GPIO13_EDGE_LOW                                                  */
      __IM  uint32_t GPIO13_EDGE_HIGH : 1;      /*!< [23..23] GPIO13_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO14_LEVEL_LOW : 1;      /*!< [24..24] GPIO14_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO14_LEVEL_HIGH : 1;     /*!< [25..25] GPIO14_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO14_EDGE_LOW : 1;       /*!< [26..26] GPIO14_EDGE_LOW                                                  */
      __IM  uint32_t GPIO14_EDGE_HIGH : 1;      /*!< [27..27] GPIO14_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO15_LEVEL_LOW : 1;      /*!< [28..28] GPIO15_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO15_LEVEL_HIGH : 1;     /*!< [29..29] GPIO15_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO15_EDGE_LOW : 1;       /*!< [30..30] GPIO15_EDGE_LOW                                                  */
      __IM  uint32_t GPIO15_EDGE_HIGH : 1;      /*!< [31..31] GPIO15_EDGE_HIGH                                                 */
    } bit;
  } DORMANT_WAKE_INTS1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000188) Interrupt status after masking & forcing for
                                                                    dormant_wake                                               */
    
    struct {
      __IM  uint32_t GPIO16_LEVEL_LOW : 1;      /*!< [0..0] GPIO16_LEVEL_LOW                                                   */
      __IM  uint32_t GPIO16_LEVEL_HIGH : 1;     /*!< [1..1] GPIO16_LEVEL_HIGH                                                  */
      __IM  uint32_t GPIO16_EDGE_LOW : 1;       /*!< [2..2] GPIO16_EDGE_LOW                                                    */
      __IM  uint32_t GPIO16_EDGE_HIGH : 1;      /*!< [3..3] GPIO16_EDGE_HIGH                                                   */
      __IM  uint32_t GPIO17_LEVEL_LOW : 1;      /*!< [4..4] GPIO17_LEVEL_LOW                                                   */
      __IM  uint32_t GPIO17_LEVEL_HIGH : 1;     /*!< [5..5] GPIO17_LEVEL_HIGH                                                  */
      __IM  uint32_t GPIO17_EDGE_LOW : 1;       /*!< [6..6] GPIO17_EDGE_LOW                                                    */
      __IM  uint32_t GPIO17_EDGE_HIGH : 1;      /*!< [7..7] GPIO17_EDGE_HIGH                                                   */
      __IM  uint32_t GPIO18_LEVEL_LOW : 1;      /*!< [8..8] GPIO18_LEVEL_LOW                                                   */
      __IM  uint32_t GPIO18_LEVEL_HIGH : 1;     /*!< [9..9] GPIO18_LEVEL_HIGH                                                  */
      __IM  uint32_t GPIO18_EDGE_LOW : 1;       /*!< [10..10] GPIO18_EDGE_LOW                                                  */
      __IM  uint32_t GPIO18_EDGE_HIGH : 1;      /*!< [11..11] GPIO18_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO19_LEVEL_LOW : 1;      /*!< [12..12] GPIO19_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO19_LEVEL_HIGH : 1;     /*!< [13..13] GPIO19_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO19_EDGE_LOW : 1;       /*!< [14..14] GPIO19_EDGE_LOW                                                  */
      __IM  uint32_t GPIO19_EDGE_HIGH : 1;      /*!< [15..15] GPIO19_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO20_LEVEL_LOW : 1;      /*!< [16..16] GPIO20_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO20_LEVEL_HIGH : 1;     /*!< [17..17] GPIO20_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO20_EDGE_LOW : 1;       /*!< [18..18] GPIO20_EDGE_LOW                                                  */
      __IM  uint32_t GPIO20_EDGE_HIGH : 1;      /*!< [19..19] GPIO20_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO21_LEVEL_LOW : 1;      /*!< [20..20] GPIO21_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO21_LEVEL_HIGH : 1;     /*!< [21..21] GPIO21_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO21_EDGE_LOW : 1;       /*!< [22..22] GPIO21_EDGE_LOW                                                  */
      __IM  uint32_t GPIO21_EDGE_HIGH : 1;      /*!< [23..23] GPIO21_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO22_LEVEL_LOW : 1;      /*!< [24..24] GPIO22_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO22_LEVEL_HIGH : 1;     /*!< [25..25] GPIO22_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO22_EDGE_LOW : 1;       /*!< [26..26] GPIO22_EDGE_LOW                                                  */
      __IM  uint32_t GPIO22_EDGE_HIGH : 1;      /*!< [27..27] GPIO22_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO23_LEVEL_LOW : 1;      /*!< [28..28] GPIO23_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO23_LEVEL_HIGH : 1;     /*!< [29..29] GPIO23_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO23_EDGE_LOW : 1;       /*!< [30..30] GPIO23_EDGE_LOW                                                  */
      __IM  uint32_t GPIO23_EDGE_HIGH : 1;      /*!< [31..31] GPIO23_EDGE_HIGH                                                 */
    } bit;
  } DORMANT_WAKE_INTS2;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000018C) Interrupt status after masking & forcing for
                                                                    dormant_wake                                               */
    
    struct {
      __IM  uint32_t GPIO24_LEVEL_LOW : 1;      /*!< [0..0] GPIO24_LEVEL_LOW                                                   */
      __IM  uint32_t GPIO24_LEVEL_HIGH : 1;     /*!< [1..1] GPIO24_LEVEL_HIGH                                                  */
      __IM  uint32_t GPIO24_EDGE_LOW : 1;       /*!< [2..2] GPIO24_EDGE_LOW                                                    */
      __IM  uint32_t GPIO24_EDGE_HIGH : 1;      /*!< [3..3] GPIO24_EDGE_HIGH                                                   */
      __IM  uint32_t GPIO25_LEVEL_LOW : 1;      /*!< [4..4] GPIO25_LEVEL_LOW                                                   */
      __IM  uint32_t GPIO25_LEVEL_HIGH : 1;     /*!< [5..5] GPIO25_LEVEL_HIGH                                                  */
      __IM  uint32_t GPIO25_EDGE_LOW : 1;       /*!< [6..6] GPIO25_EDGE_LOW                                                    */
      __IM  uint32_t GPIO25_EDGE_HIGH : 1;      /*!< [7..7] GPIO25_EDGE_HIGH                                                   */
      __IM  uint32_t GPIO26_LEVEL_LOW : 1;      /*!< [8..8] GPIO26_LEVEL_LOW                                                   */
      __IM  uint32_t GPIO26_LEVEL_HIGH : 1;     /*!< [9..9] GPIO26_LEVEL_HIGH                                                  */
      __IM  uint32_t GPIO26_EDGE_LOW : 1;       /*!< [10..10] GPIO26_EDGE_LOW                                                  */
      __IM  uint32_t GPIO26_EDGE_HIGH : 1;      /*!< [11..11] GPIO26_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO27_LEVEL_LOW : 1;      /*!< [12..12] GPIO27_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO27_LEVEL_HIGH : 1;     /*!< [13..13] GPIO27_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO27_EDGE_LOW : 1;       /*!< [14..14] GPIO27_EDGE_LOW                                                  */
      __IM  uint32_t GPIO27_EDGE_HIGH : 1;      /*!< [15..15] GPIO27_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO28_LEVEL_LOW : 1;      /*!< [16..16] GPIO28_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO28_LEVEL_HIGH : 1;     /*!< [17..17] GPIO28_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO28_EDGE_LOW : 1;       /*!< [18..18] GPIO28_EDGE_LOW                                                  */
      __IM  uint32_t GPIO28_EDGE_HIGH : 1;      /*!< [19..19] GPIO28_EDGE_HIGH                                                 */
      __IM  uint32_t GPIO29_LEVEL_LOW : 1;      /*!< [20..20] GPIO29_LEVEL_LOW                                                 */
      __IM  uint32_t GPIO29_LEVEL_HIGH : 1;     /*!< [21..21] GPIO29_LEVEL_HIGH                                                */
      __IM  uint32_t GPIO29_EDGE_LOW : 1;       /*!< [22..22] GPIO29_EDGE_LOW                                                  */
      __IM  uint32_t GPIO29_EDGE_HIGH : 1;      /*!< [23..23] GPIO29_EDGE_HIGH                                                 */
            uint32_t            : 8;
    } bit;
  } DORMANT_WAKE_INTS3;
} IO_BANK0_Type;                                /*!< Size = 400 (0x190)                                                        */



/* =========================================================================================================================== */
/* ================                                          IO_QSPI                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief IO_QSPI (IO_QSPI)
  */

typedef struct {                                /*!< (@ 0x40018000) IO_QSPI Structure                                          */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000000) GPIO status                                                */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied            */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied          */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied                */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied            */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied                    */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied               */
            uint32_t            : 5;
    } bit;
  } GPIO_QSPI_SCLK_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000004) GPIO control including function select and overrides.      */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table
                                                     31 == NULL                                                                */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER                                                            */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER                                                           */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER                                                           */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER                                                          */
            uint32_t            : 2;
    } bit;
  } GPIO_QSPI_SCLK_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000008) GPIO status                                                */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied            */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied          */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied                */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied            */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied                    */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied               */
            uint32_t            : 5;
    } bit;
  } GPIO_QSPI_SS_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000000C) GPIO control including function select and overrides.      */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table
                                                     31 == NULL                                                                */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER                                                            */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER                                                           */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER                                                           */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER                                                          */
            uint32_t            : 2;
    } bit;
  } GPIO_QSPI_SS_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000010) GPIO status                                                */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied            */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied          */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied                */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied            */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied                    */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied               */
            uint32_t            : 5;
    } bit;
  } GPIO_QSPI_SD0_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000014) GPIO control including function select and overrides.      */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table
                                                     31 == NULL                                                                */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER                                                            */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER                                                           */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER                                                           */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER                                                          */
            uint32_t            : 2;
    } bit;
  } GPIO_QSPI_SD0_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000018) GPIO status                                                */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied            */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied          */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied                */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied            */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied                    */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied               */
            uint32_t            : 5;
    } bit;
  } GPIO_QSPI_SD1_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000001C) GPIO control including function select and overrides.      */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table
                                                     31 == NULL                                                                */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER                                                            */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER                                                           */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER                                                           */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER                                                          */
            uint32_t            : 2;
    } bit;
  } GPIO_QSPI_SD1_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000020) GPIO status                                                */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied            */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied          */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied                */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied            */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied                    */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied               */
            uint32_t            : 5;
    } bit;
  } GPIO_QSPI_SD2_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000024) GPIO control including function select and overrides.      */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table
                                                     31 == NULL                                                                */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER                                                            */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER                                                           */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER                                                           */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER                                                          */
            uint32_t            : 2;
    } bit;
  } GPIO_QSPI_SD2_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000028) GPIO status                                                */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t OUTFROMPERI : 1;           /*!< [8..8] output signal from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OUTTOPAD   : 1;            /*!< [9..9] output signal to pad after register override is applied            */
            uint32_t            : 2;
      __IM  uint32_t OEFROMPERI : 1;            /*!< [12..12] output enable from selected peripheral, before register
                                                     override is applied                                                       */
      __IM  uint32_t OETOPAD    : 1;            /*!< [13..13] output enable to pad after register override is applied          */
            uint32_t            : 3;
      __IM  uint32_t INFROMPAD  : 1;            /*!< [17..17] input signal from pad, before override is applied                */
            uint32_t            : 1;
      __IM  uint32_t INTOPERI   : 1;            /*!< [19..19] input signal to peripheral, after override is applied            */
            uint32_t            : 4;
      __IM  uint32_t IRQFROMPAD : 1;            /*!< [24..24] interrupt from pad before override is applied                    */
            uint32_t            : 1;
      __IM  uint32_t IRQTOPROC  : 1;            /*!< [26..26] interrupt to processors, after override is applied               */
            uint32_t            : 5;
    } bit;
  } GPIO_QSPI_SD3_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000002C) GPIO control including function select and overrides.      */
    
    struct {
      __IOM uint32_t FUNCSEL    : 5;            /*!< [4..0] 0-31 -> selects pin function according to the gpio table
                                                     31 == NULL                                                                */
            uint32_t            : 3;
      __IOM uint32_t OUTOVER    : 2;            /*!< [9..8] OUTOVER                                                            */
            uint32_t            : 2;
      __IOM uint32_t OEOVER     : 2;            /*!< [13..12] OEOVER                                                           */
            uint32_t            : 2;
      __IOM uint32_t INOVER     : 2;            /*!< [17..16] INOVER                                                           */
            uint32_t            : 10;
      __IOM uint32_t IRQOVER    : 2;            /*!< [29..28] IRQOVER                                                          */
            uint32_t            : 2;
    } bit;
  } GPIO_QSPI_SD3_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000030) Raw Interrupts                                             */
    
    struct {
      __IM  uint32_t GPIO_QSPI_SCLK_LEVEL_LOW : 1;/*!< [0..0] GPIO_QSPI_SCLK_LEVEL_LOW                                         */
      __IM  uint32_t GPIO_QSPI_SCLK_LEVEL_HIGH : 1;/*!< [1..1] GPIO_QSPI_SCLK_LEVEL_HIGH                                       */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_LOW : 1;/*!< [2..2] GPIO_QSPI_SCLK_EDGE_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_HIGH : 1;/*!< [3..3] GPIO_QSPI_SCLK_EDGE_HIGH                                         */
      __IM  uint32_t GPIO_QSPI_SS_LEVEL_LOW : 1;/*!< [4..4] GPIO_QSPI_SS_LEVEL_LOW                                             */
      __IM  uint32_t GPIO_QSPI_SS_LEVEL_HIGH : 1;/*!< [5..5] GPIO_QSPI_SS_LEVEL_HIGH                                           */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_LOW : 1; /*!< [6..6] GPIO_QSPI_SS_EDGE_LOW                                              */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_HIGH : 1;/*!< [7..7] GPIO_QSPI_SS_EDGE_HIGH                                             */
      __IM  uint32_t GPIO_QSPI_SD0_LEVEL_LOW : 1;/*!< [8..8] GPIO_QSPI_SD0_LEVEL_LOW                                           */
      __IM  uint32_t GPIO_QSPI_SD0_LEVEL_HIGH : 1;/*!< [9..9] GPIO_QSPI_SD0_LEVEL_HIGH                                         */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_LOW : 1;/*!< [10..10] GPIO_QSPI_SD0_EDGE_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_HIGH : 1;/*!< [11..11] GPIO_QSPI_SD0_EDGE_HIGH                                         */
      __IM  uint32_t GPIO_QSPI_SD1_LEVEL_LOW : 1;/*!< [12..12] GPIO_QSPI_SD1_LEVEL_LOW                                         */
      __IM  uint32_t GPIO_QSPI_SD1_LEVEL_HIGH : 1;/*!< [13..13] GPIO_QSPI_SD1_LEVEL_HIGH                                       */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_LOW : 1;/*!< [14..14] GPIO_QSPI_SD1_EDGE_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_HIGH : 1;/*!< [15..15] GPIO_QSPI_SD1_EDGE_HIGH                                         */
      __IM  uint32_t GPIO_QSPI_SD2_LEVEL_LOW : 1;/*!< [16..16] GPIO_QSPI_SD2_LEVEL_LOW                                         */
      __IM  uint32_t GPIO_QSPI_SD2_LEVEL_HIGH : 1;/*!< [17..17] GPIO_QSPI_SD2_LEVEL_HIGH                                       */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_LOW : 1;/*!< [18..18] GPIO_QSPI_SD2_EDGE_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_HIGH : 1;/*!< [19..19] GPIO_QSPI_SD2_EDGE_HIGH                                         */
      __IM  uint32_t GPIO_QSPI_SD3_LEVEL_LOW : 1;/*!< [20..20] GPIO_QSPI_SD3_LEVEL_LOW                                         */
      __IM  uint32_t GPIO_QSPI_SD3_LEVEL_HIGH : 1;/*!< [21..21] GPIO_QSPI_SD3_LEVEL_HIGH                                       */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_LOW : 1;/*!< [22..22] GPIO_QSPI_SD3_EDGE_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_HIGH : 1;/*!< [23..23] GPIO_QSPI_SD3_EDGE_HIGH                                         */
            uint32_t            : 8;
    } bit;
  } INTR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000034) Interrupt Enable for proc0                                 */
    
    struct {
      __IOM uint32_t GPIO_QSPI_SCLK_LEVEL_LOW : 1;/*!< [0..0] GPIO_QSPI_SCLK_LEVEL_LOW                                         */
      __IOM uint32_t GPIO_QSPI_SCLK_LEVEL_HIGH : 1;/*!< [1..1] GPIO_QSPI_SCLK_LEVEL_HIGH                                       */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_LOW : 1;/*!< [2..2] GPIO_QSPI_SCLK_EDGE_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_HIGH : 1;/*!< [3..3] GPIO_QSPI_SCLK_EDGE_HIGH                                         */
      __IOM uint32_t GPIO_QSPI_SS_LEVEL_LOW : 1;/*!< [4..4] GPIO_QSPI_SS_LEVEL_LOW                                             */
      __IOM uint32_t GPIO_QSPI_SS_LEVEL_HIGH : 1;/*!< [5..5] GPIO_QSPI_SS_LEVEL_HIGH                                           */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_LOW : 1; /*!< [6..6] GPIO_QSPI_SS_EDGE_LOW                                              */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_HIGH : 1;/*!< [7..7] GPIO_QSPI_SS_EDGE_HIGH                                             */
      __IOM uint32_t GPIO_QSPI_SD0_LEVEL_LOW : 1;/*!< [8..8] GPIO_QSPI_SD0_LEVEL_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SD0_LEVEL_HIGH : 1;/*!< [9..9] GPIO_QSPI_SD0_LEVEL_HIGH                                         */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_LOW : 1;/*!< [10..10] GPIO_QSPI_SD0_EDGE_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_HIGH : 1;/*!< [11..11] GPIO_QSPI_SD0_EDGE_HIGH                                         */
      __IOM uint32_t GPIO_QSPI_SD1_LEVEL_LOW : 1;/*!< [12..12] GPIO_QSPI_SD1_LEVEL_LOW                                         */
      __IOM uint32_t GPIO_QSPI_SD1_LEVEL_HIGH : 1;/*!< [13..13] GPIO_QSPI_SD1_LEVEL_HIGH                                       */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_LOW : 1;/*!< [14..14] GPIO_QSPI_SD1_EDGE_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_HIGH : 1;/*!< [15..15] GPIO_QSPI_SD1_EDGE_HIGH                                         */
      __IOM uint32_t GPIO_QSPI_SD2_LEVEL_LOW : 1;/*!< [16..16] GPIO_QSPI_SD2_LEVEL_LOW                                         */
      __IOM uint32_t GPIO_QSPI_SD2_LEVEL_HIGH : 1;/*!< [17..17] GPIO_QSPI_SD2_LEVEL_HIGH                                       */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_LOW : 1;/*!< [18..18] GPIO_QSPI_SD2_EDGE_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_HIGH : 1;/*!< [19..19] GPIO_QSPI_SD2_EDGE_HIGH                                         */
      __IOM uint32_t GPIO_QSPI_SD3_LEVEL_LOW : 1;/*!< [20..20] GPIO_QSPI_SD3_LEVEL_LOW                                         */
      __IOM uint32_t GPIO_QSPI_SD3_LEVEL_HIGH : 1;/*!< [21..21] GPIO_QSPI_SD3_LEVEL_HIGH                                       */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_LOW : 1;/*!< [22..22] GPIO_QSPI_SD3_EDGE_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_HIGH : 1;/*!< [23..23] GPIO_QSPI_SD3_EDGE_HIGH                                         */
            uint32_t            : 8;
    } bit;
  } PROC0_INTE;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000038) Interrupt Force for proc0                                  */
    
    struct {
      __IOM uint32_t GPIO_QSPI_SCLK_LEVEL_LOW : 1;/*!< [0..0] GPIO_QSPI_SCLK_LEVEL_LOW                                         */
      __IOM uint32_t GPIO_QSPI_SCLK_LEVEL_HIGH : 1;/*!< [1..1] GPIO_QSPI_SCLK_LEVEL_HIGH                                       */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_LOW : 1;/*!< [2..2] GPIO_QSPI_SCLK_EDGE_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_HIGH : 1;/*!< [3..3] GPIO_QSPI_SCLK_EDGE_HIGH                                         */
      __IOM uint32_t GPIO_QSPI_SS_LEVEL_LOW : 1;/*!< [4..4] GPIO_QSPI_SS_LEVEL_LOW                                             */
      __IOM uint32_t GPIO_QSPI_SS_LEVEL_HIGH : 1;/*!< [5..5] GPIO_QSPI_SS_LEVEL_HIGH                                           */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_LOW : 1; /*!< [6..6] GPIO_QSPI_SS_EDGE_LOW                                              */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_HIGH : 1;/*!< [7..7] GPIO_QSPI_SS_EDGE_HIGH                                             */
      __IOM uint32_t GPIO_QSPI_SD0_LEVEL_LOW : 1;/*!< [8..8] GPIO_QSPI_SD0_LEVEL_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SD0_LEVEL_HIGH : 1;/*!< [9..9] GPIO_QSPI_SD0_LEVEL_HIGH                                         */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_LOW : 1;/*!< [10..10] GPIO_QSPI_SD0_EDGE_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_HIGH : 1;/*!< [11..11] GPIO_QSPI_SD0_EDGE_HIGH                                         */
      __IOM uint32_t GPIO_QSPI_SD1_LEVEL_LOW : 1;/*!< [12..12] GPIO_QSPI_SD1_LEVEL_LOW                                         */
      __IOM uint32_t GPIO_QSPI_SD1_LEVEL_HIGH : 1;/*!< [13..13] GPIO_QSPI_SD1_LEVEL_HIGH                                       */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_LOW : 1;/*!< [14..14] GPIO_QSPI_SD1_EDGE_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_HIGH : 1;/*!< [15..15] GPIO_QSPI_SD1_EDGE_HIGH                                         */
      __IOM uint32_t GPIO_QSPI_SD2_LEVEL_LOW : 1;/*!< [16..16] GPIO_QSPI_SD2_LEVEL_LOW                                         */
      __IOM uint32_t GPIO_QSPI_SD2_LEVEL_HIGH : 1;/*!< [17..17] GPIO_QSPI_SD2_LEVEL_HIGH                                       */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_LOW : 1;/*!< [18..18] GPIO_QSPI_SD2_EDGE_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_HIGH : 1;/*!< [19..19] GPIO_QSPI_SD2_EDGE_HIGH                                         */
      __IOM uint32_t GPIO_QSPI_SD3_LEVEL_LOW : 1;/*!< [20..20] GPIO_QSPI_SD3_LEVEL_LOW                                         */
      __IOM uint32_t GPIO_QSPI_SD3_LEVEL_HIGH : 1;/*!< [21..21] GPIO_QSPI_SD3_LEVEL_HIGH                                       */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_LOW : 1;/*!< [22..22] GPIO_QSPI_SD3_EDGE_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_HIGH : 1;/*!< [23..23] GPIO_QSPI_SD3_EDGE_HIGH                                         */
            uint32_t            : 8;
    } bit;
  } PROC0_INTF;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000003C) Interrupt status after masking & forcing for
                                                                    proc0                                                      */
    
    struct {
      __IM  uint32_t GPIO_QSPI_SCLK_LEVEL_LOW : 1;/*!< [0..0] GPIO_QSPI_SCLK_LEVEL_LOW                                         */
      __IM  uint32_t GPIO_QSPI_SCLK_LEVEL_HIGH : 1;/*!< [1..1] GPIO_QSPI_SCLK_LEVEL_HIGH                                       */
      __IM  uint32_t GPIO_QSPI_SCLK_EDGE_LOW : 1;/*!< [2..2] GPIO_QSPI_SCLK_EDGE_LOW                                           */
      __IM  uint32_t GPIO_QSPI_SCLK_EDGE_HIGH : 1;/*!< [3..3] GPIO_QSPI_SCLK_EDGE_HIGH                                         */
      __IM  uint32_t GPIO_QSPI_SS_LEVEL_LOW : 1;/*!< [4..4] GPIO_QSPI_SS_LEVEL_LOW                                             */
      __IM  uint32_t GPIO_QSPI_SS_LEVEL_HIGH : 1;/*!< [5..5] GPIO_QSPI_SS_LEVEL_HIGH                                           */
      __IM  uint32_t GPIO_QSPI_SS_EDGE_LOW : 1; /*!< [6..6] GPIO_QSPI_SS_EDGE_LOW                                              */
      __IM  uint32_t GPIO_QSPI_SS_EDGE_HIGH : 1;/*!< [7..7] GPIO_QSPI_SS_EDGE_HIGH                                             */
      __IM  uint32_t GPIO_QSPI_SD0_LEVEL_LOW : 1;/*!< [8..8] GPIO_QSPI_SD0_LEVEL_LOW                                           */
      __IM  uint32_t GPIO_QSPI_SD0_LEVEL_HIGH : 1;/*!< [9..9] GPIO_QSPI_SD0_LEVEL_HIGH                                         */
      __IM  uint32_t GPIO_QSPI_SD0_EDGE_LOW : 1;/*!< [10..10] GPIO_QSPI_SD0_EDGE_LOW                                           */
      __IM  uint32_t GPIO_QSPI_SD0_EDGE_HIGH : 1;/*!< [11..11] GPIO_QSPI_SD0_EDGE_HIGH                                         */
      __IM  uint32_t GPIO_QSPI_SD1_LEVEL_LOW : 1;/*!< [12..12] GPIO_QSPI_SD1_LEVEL_LOW                                         */
      __IM  uint32_t GPIO_QSPI_SD1_LEVEL_HIGH : 1;/*!< [13..13] GPIO_QSPI_SD1_LEVEL_HIGH                                       */
      __IM  uint32_t GPIO_QSPI_SD1_EDGE_LOW : 1;/*!< [14..14] GPIO_QSPI_SD1_EDGE_LOW                                           */
      __IM  uint32_t GPIO_QSPI_SD1_EDGE_HIGH : 1;/*!< [15..15] GPIO_QSPI_SD1_EDGE_HIGH                                         */
      __IM  uint32_t GPIO_QSPI_SD2_LEVEL_LOW : 1;/*!< [16..16] GPIO_QSPI_SD2_LEVEL_LOW                                         */
      __IM  uint32_t GPIO_QSPI_SD2_LEVEL_HIGH : 1;/*!< [17..17] GPIO_QSPI_SD2_LEVEL_HIGH                                       */
      __IM  uint32_t GPIO_QSPI_SD2_EDGE_LOW : 1;/*!< [18..18] GPIO_QSPI_SD2_EDGE_LOW                                           */
      __IM  uint32_t GPIO_QSPI_SD2_EDGE_HIGH : 1;/*!< [19..19] GPIO_QSPI_SD2_EDGE_HIGH                                         */
      __IM  uint32_t GPIO_QSPI_SD3_LEVEL_LOW : 1;/*!< [20..20] GPIO_QSPI_SD3_LEVEL_LOW                                         */
      __IM  uint32_t GPIO_QSPI_SD3_LEVEL_HIGH : 1;/*!< [21..21] GPIO_QSPI_SD3_LEVEL_HIGH                                       */
      __IM  uint32_t GPIO_QSPI_SD3_EDGE_LOW : 1;/*!< [22..22] GPIO_QSPI_SD3_EDGE_LOW                                           */
      __IM  uint32_t GPIO_QSPI_SD3_EDGE_HIGH : 1;/*!< [23..23] GPIO_QSPI_SD3_EDGE_HIGH                                         */
            uint32_t            : 8;
    } bit;
  } PROC0_INTS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000040) Interrupt Enable for proc1                                 */
    
    struct {
      __IOM uint32_t GPIO_QSPI_SCLK_LEVEL_LOW : 1;/*!< [0..0] GPIO_QSPI_SCLK_LEVEL_LOW                                         */
      __IOM uint32_t GPIO_QSPI_SCLK_LEVEL_HIGH : 1;/*!< [1..1] GPIO_QSPI_SCLK_LEVEL_HIGH                                       */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_LOW : 1;/*!< [2..2] GPIO_QSPI_SCLK_EDGE_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_HIGH : 1;/*!< [3..3] GPIO_QSPI_SCLK_EDGE_HIGH                                         */
      __IOM uint32_t GPIO_QSPI_SS_LEVEL_LOW : 1;/*!< [4..4] GPIO_QSPI_SS_LEVEL_LOW                                             */
      __IOM uint32_t GPIO_QSPI_SS_LEVEL_HIGH : 1;/*!< [5..5] GPIO_QSPI_SS_LEVEL_HIGH                                           */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_LOW : 1; /*!< [6..6] GPIO_QSPI_SS_EDGE_LOW                                              */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_HIGH : 1;/*!< [7..7] GPIO_QSPI_SS_EDGE_HIGH                                             */
      __IOM uint32_t GPIO_QSPI_SD0_LEVEL_LOW : 1;/*!< [8..8] GPIO_QSPI_SD0_LEVEL_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SD0_LEVEL_HIGH : 1;/*!< [9..9] GPIO_QSPI_SD0_LEVEL_HIGH                                         */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_LOW : 1;/*!< [10..10] GPIO_QSPI_SD0_EDGE_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_HIGH : 1;/*!< [11..11] GPIO_QSPI_SD0_EDGE_HIGH                                         */
      __IOM uint32_t GPIO_QSPI_SD1_LEVEL_LOW : 1;/*!< [12..12] GPIO_QSPI_SD1_LEVEL_LOW                                         */
      __IOM uint32_t GPIO_QSPI_SD1_LEVEL_HIGH : 1;/*!< [13..13] GPIO_QSPI_SD1_LEVEL_HIGH                                       */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_LOW : 1;/*!< [14..14] GPIO_QSPI_SD1_EDGE_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_HIGH : 1;/*!< [15..15] GPIO_QSPI_SD1_EDGE_HIGH                                         */
      __IOM uint32_t GPIO_QSPI_SD2_LEVEL_LOW : 1;/*!< [16..16] GPIO_QSPI_SD2_LEVEL_LOW                                         */
      __IOM uint32_t GPIO_QSPI_SD2_LEVEL_HIGH : 1;/*!< [17..17] GPIO_QSPI_SD2_LEVEL_HIGH                                       */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_LOW : 1;/*!< [18..18] GPIO_QSPI_SD2_EDGE_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_HIGH : 1;/*!< [19..19] GPIO_QSPI_SD2_EDGE_HIGH                                         */
      __IOM uint32_t GPIO_QSPI_SD3_LEVEL_LOW : 1;/*!< [20..20] GPIO_QSPI_SD3_LEVEL_LOW                                         */
      __IOM uint32_t GPIO_QSPI_SD3_LEVEL_HIGH : 1;/*!< [21..21] GPIO_QSPI_SD3_LEVEL_HIGH                                       */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_LOW : 1;/*!< [22..22] GPIO_QSPI_SD3_EDGE_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_HIGH : 1;/*!< [23..23] GPIO_QSPI_SD3_EDGE_HIGH                                         */
            uint32_t            : 8;
    } bit;
  } PROC1_INTE;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000044) Interrupt Force for proc1                                  */
    
    struct {
      __IOM uint32_t GPIO_QSPI_SCLK_LEVEL_LOW : 1;/*!< [0..0] GPIO_QSPI_SCLK_LEVEL_LOW                                         */
      __IOM uint32_t GPIO_QSPI_SCLK_LEVEL_HIGH : 1;/*!< [1..1] GPIO_QSPI_SCLK_LEVEL_HIGH                                       */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_LOW : 1;/*!< [2..2] GPIO_QSPI_SCLK_EDGE_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_HIGH : 1;/*!< [3..3] GPIO_QSPI_SCLK_EDGE_HIGH                                         */
      __IOM uint32_t GPIO_QSPI_SS_LEVEL_LOW : 1;/*!< [4..4] GPIO_QSPI_SS_LEVEL_LOW                                             */
      __IOM uint32_t GPIO_QSPI_SS_LEVEL_HIGH : 1;/*!< [5..5] GPIO_QSPI_SS_LEVEL_HIGH                                           */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_LOW : 1; /*!< [6..6] GPIO_QSPI_SS_EDGE_LOW                                              */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_HIGH : 1;/*!< [7..7] GPIO_QSPI_SS_EDGE_HIGH                                             */
      __IOM uint32_t GPIO_QSPI_SD0_LEVEL_LOW : 1;/*!< [8..8] GPIO_QSPI_SD0_LEVEL_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SD0_LEVEL_HIGH : 1;/*!< [9..9] GPIO_QSPI_SD0_LEVEL_HIGH                                         */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_LOW : 1;/*!< [10..10] GPIO_QSPI_SD0_EDGE_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_HIGH : 1;/*!< [11..11] GPIO_QSPI_SD0_EDGE_HIGH                                         */
      __IOM uint32_t GPIO_QSPI_SD1_LEVEL_LOW : 1;/*!< [12..12] GPIO_QSPI_SD1_LEVEL_LOW                                         */
      __IOM uint32_t GPIO_QSPI_SD1_LEVEL_HIGH : 1;/*!< [13..13] GPIO_QSPI_SD1_LEVEL_HIGH                                       */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_LOW : 1;/*!< [14..14] GPIO_QSPI_SD1_EDGE_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_HIGH : 1;/*!< [15..15] GPIO_QSPI_SD1_EDGE_HIGH                                         */
      __IOM uint32_t GPIO_QSPI_SD2_LEVEL_LOW : 1;/*!< [16..16] GPIO_QSPI_SD2_LEVEL_LOW                                         */
      __IOM uint32_t GPIO_QSPI_SD2_LEVEL_HIGH : 1;/*!< [17..17] GPIO_QSPI_SD2_LEVEL_HIGH                                       */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_LOW : 1;/*!< [18..18] GPIO_QSPI_SD2_EDGE_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_HIGH : 1;/*!< [19..19] GPIO_QSPI_SD2_EDGE_HIGH                                         */
      __IOM uint32_t GPIO_QSPI_SD3_LEVEL_LOW : 1;/*!< [20..20] GPIO_QSPI_SD3_LEVEL_LOW                                         */
      __IOM uint32_t GPIO_QSPI_SD3_LEVEL_HIGH : 1;/*!< [21..21] GPIO_QSPI_SD3_LEVEL_HIGH                                       */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_LOW : 1;/*!< [22..22] GPIO_QSPI_SD3_EDGE_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_HIGH : 1;/*!< [23..23] GPIO_QSPI_SD3_EDGE_HIGH                                         */
            uint32_t            : 8;
    } bit;
  } PROC1_INTF;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000048) Interrupt status after masking & forcing for
                                                                    proc1                                                      */
    
    struct {
      __IM  uint32_t GPIO_QSPI_SCLK_LEVEL_LOW : 1;/*!< [0..0] GPIO_QSPI_SCLK_LEVEL_LOW                                         */
      __IM  uint32_t GPIO_QSPI_SCLK_LEVEL_HIGH : 1;/*!< [1..1] GPIO_QSPI_SCLK_LEVEL_HIGH                                       */
      __IM  uint32_t GPIO_QSPI_SCLK_EDGE_LOW : 1;/*!< [2..2] GPIO_QSPI_SCLK_EDGE_LOW                                           */
      __IM  uint32_t GPIO_QSPI_SCLK_EDGE_HIGH : 1;/*!< [3..3] GPIO_QSPI_SCLK_EDGE_HIGH                                         */
      __IM  uint32_t GPIO_QSPI_SS_LEVEL_LOW : 1;/*!< [4..4] GPIO_QSPI_SS_LEVEL_LOW                                             */
      __IM  uint32_t GPIO_QSPI_SS_LEVEL_HIGH : 1;/*!< [5..5] GPIO_QSPI_SS_LEVEL_HIGH                                           */
      __IM  uint32_t GPIO_QSPI_SS_EDGE_LOW : 1; /*!< [6..6] GPIO_QSPI_SS_EDGE_LOW                                              */
      __IM  uint32_t GPIO_QSPI_SS_EDGE_HIGH : 1;/*!< [7..7] GPIO_QSPI_SS_EDGE_HIGH                                             */
      __IM  uint32_t GPIO_QSPI_SD0_LEVEL_LOW : 1;/*!< [8..8] GPIO_QSPI_SD0_LEVEL_LOW                                           */
      __IM  uint32_t GPIO_QSPI_SD0_LEVEL_HIGH : 1;/*!< [9..9] GPIO_QSPI_SD0_LEVEL_HIGH                                         */
      __IM  uint32_t GPIO_QSPI_SD0_EDGE_LOW : 1;/*!< [10..10] GPIO_QSPI_SD0_EDGE_LOW                                           */
      __IM  uint32_t GPIO_QSPI_SD0_EDGE_HIGH : 1;/*!< [11..11] GPIO_QSPI_SD0_EDGE_HIGH                                         */
      __IM  uint32_t GPIO_QSPI_SD1_LEVEL_LOW : 1;/*!< [12..12] GPIO_QSPI_SD1_LEVEL_LOW                                         */
      __IM  uint32_t GPIO_QSPI_SD1_LEVEL_HIGH : 1;/*!< [13..13] GPIO_QSPI_SD1_LEVEL_HIGH                                       */
      __IM  uint32_t GPIO_QSPI_SD1_EDGE_LOW : 1;/*!< [14..14] GPIO_QSPI_SD1_EDGE_LOW                                           */
      __IM  uint32_t GPIO_QSPI_SD1_EDGE_HIGH : 1;/*!< [15..15] GPIO_QSPI_SD1_EDGE_HIGH                                         */
      __IM  uint32_t GPIO_QSPI_SD2_LEVEL_LOW : 1;/*!< [16..16] GPIO_QSPI_SD2_LEVEL_LOW                                         */
      __IM  uint32_t GPIO_QSPI_SD2_LEVEL_HIGH : 1;/*!< [17..17] GPIO_QSPI_SD2_LEVEL_HIGH                                       */
      __IM  uint32_t GPIO_QSPI_SD2_EDGE_LOW : 1;/*!< [18..18] GPIO_QSPI_SD2_EDGE_LOW                                           */
      __IM  uint32_t GPIO_QSPI_SD2_EDGE_HIGH : 1;/*!< [19..19] GPIO_QSPI_SD2_EDGE_HIGH                                         */
      __IM  uint32_t GPIO_QSPI_SD3_LEVEL_LOW : 1;/*!< [20..20] GPIO_QSPI_SD3_LEVEL_LOW                                         */
      __IM  uint32_t GPIO_QSPI_SD3_LEVEL_HIGH : 1;/*!< [21..21] GPIO_QSPI_SD3_LEVEL_HIGH                                       */
      __IM  uint32_t GPIO_QSPI_SD3_EDGE_LOW : 1;/*!< [22..22] GPIO_QSPI_SD3_EDGE_LOW                                           */
      __IM  uint32_t GPIO_QSPI_SD3_EDGE_HIGH : 1;/*!< [23..23] GPIO_QSPI_SD3_EDGE_HIGH                                         */
            uint32_t            : 8;
    } bit;
  } PROC1_INTS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000004C) Interrupt Enable for dormant_wake                          */
    
    struct {
      __IOM uint32_t GPIO_QSPI_SCLK_LEVEL_LOW : 1;/*!< [0..0] GPIO_QSPI_SCLK_LEVEL_LOW                                         */
      __IOM uint32_t GPIO_QSPI_SCLK_LEVEL_HIGH : 1;/*!< [1..1] GPIO_QSPI_SCLK_LEVEL_HIGH                                       */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_LOW : 1;/*!< [2..2] GPIO_QSPI_SCLK_EDGE_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_HIGH : 1;/*!< [3..3] GPIO_QSPI_SCLK_EDGE_HIGH                                         */
      __IOM uint32_t GPIO_QSPI_SS_LEVEL_LOW : 1;/*!< [4..4] GPIO_QSPI_SS_LEVEL_LOW                                             */
      __IOM uint32_t GPIO_QSPI_SS_LEVEL_HIGH : 1;/*!< [5..5] GPIO_QSPI_SS_LEVEL_HIGH                                           */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_LOW : 1; /*!< [6..6] GPIO_QSPI_SS_EDGE_LOW                                              */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_HIGH : 1;/*!< [7..7] GPIO_QSPI_SS_EDGE_HIGH                                             */
      __IOM uint32_t GPIO_QSPI_SD0_LEVEL_LOW : 1;/*!< [8..8] GPIO_QSPI_SD0_LEVEL_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SD0_LEVEL_HIGH : 1;/*!< [9..9] GPIO_QSPI_SD0_LEVEL_HIGH                                         */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_LOW : 1;/*!< [10..10] GPIO_QSPI_SD0_EDGE_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_HIGH : 1;/*!< [11..11] GPIO_QSPI_SD0_EDGE_HIGH                                         */
      __IOM uint32_t GPIO_QSPI_SD1_LEVEL_LOW : 1;/*!< [12..12] GPIO_QSPI_SD1_LEVEL_LOW                                         */
      __IOM uint32_t GPIO_QSPI_SD1_LEVEL_HIGH : 1;/*!< [13..13] GPIO_QSPI_SD1_LEVEL_HIGH                                       */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_LOW : 1;/*!< [14..14] GPIO_QSPI_SD1_EDGE_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_HIGH : 1;/*!< [15..15] GPIO_QSPI_SD1_EDGE_HIGH                                         */
      __IOM uint32_t GPIO_QSPI_SD2_LEVEL_LOW : 1;/*!< [16..16] GPIO_QSPI_SD2_LEVEL_LOW                                         */
      __IOM uint32_t GPIO_QSPI_SD2_LEVEL_HIGH : 1;/*!< [17..17] GPIO_QSPI_SD2_LEVEL_HIGH                                       */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_LOW : 1;/*!< [18..18] GPIO_QSPI_SD2_EDGE_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_HIGH : 1;/*!< [19..19] GPIO_QSPI_SD2_EDGE_HIGH                                         */
      __IOM uint32_t GPIO_QSPI_SD3_LEVEL_LOW : 1;/*!< [20..20] GPIO_QSPI_SD3_LEVEL_LOW                                         */
      __IOM uint32_t GPIO_QSPI_SD3_LEVEL_HIGH : 1;/*!< [21..21] GPIO_QSPI_SD3_LEVEL_HIGH                                       */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_LOW : 1;/*!< [22..22] GPIO_QSPI_SD3_EDGE_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_HIGH : 1;/*!< [23..23] GPIO_QSPI_SD3_EDGE_HIGH                                         */
            uint32_t            : 8;
    } bit;
  } DORMANT_WAKE_INTE;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000050) Interrupt Force for dormant_wake                           */
    
    struct {
      __IOM uint32_t GPIO_QSPI_SCLK_LEVEL_LOW : 1;/*!< [0..0] GPIO_QSPI_SCLK_LEVEL_LOW                                         */
      __IOM uint32_t GPIO_QSPI_SCLK_LEVEL_HIGH : 1;/*!< [1..1] GPIO_QSPI_SCLK_LEVEL_HIGH                                       */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_LOW : 1;/*!< [2..2] GPIO_QSPI_SCLK_EDGE_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SCLK_EDGE_HIGH : 1;/*!< [3..3] GPIO_QSPI_SCLK_EDGE_HIGH                                         */
      __IOM uint32_t GPIO_QSPI_SS_LEVEL_LOW : 1;/*!< [4..4] GPIO_QSPI_SS_LEVEL_LOW                                             */
      __IOM uint32_t GPIO_QSPI_SS_LEVEL_HIGH : 1;/*!< [5..5] GPIO_QSPI_SS_LEVEL_HIGH                                           */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_LOW : 1; /*!< [6..6] GPIO_QSPI_SS_EDGE_LOW                                              */
      __IOM uint32_t GPIO_QSPI_SS_EDGE_HIGH : 1;/*!< [7..7] GPIO_QSPI_SS_EDGE_HIGH                                             */
      __IOM uint32_t GPIO_QSPI_SD0_LEVEL_LOW : 1;/*!< [8..8] GPIO_QSPI_SD0_LEVEL_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SD0_LEVEL_HIGH : 1;/*!< [9..9] GPIO_QSPI_SD0_LEVEL_HIGH                                         */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_LOW : 1;/*!< [10..10] GPIO_QSPI_SD0_EDGE_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SD0_EDGE_HIGH : 1;/*!< [11..11] GPIO_QSPI_SD0_EDGE_HIGH                                         */
      __IOM uint32_t GPIO_QSPI_SD1_LEVEL_LOW : 1;/*!< [12..12] GPIO_QSPI_SD1_LEVEL_LOW                                         */
      __IOM uint32_t GPIO_QSPI_SD1_LEVEL_HIGH : 1;/*!< [13..13] GPIO_QSPI_SD1_LEVEL_HIGH                                       */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_LOW : 1;/*!< [14..14] GPIO_QSPI_SD1_EDGE_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SD1_EDGE_HIGH : 1;/*!< [15..15] GPIO_QSPI_SD1_EDGE_HIGH                                         */
      __IOM uint32_t GPIO_QSPI_SD2_LEVEL_LOW : 1;/*!< [16..16] GPIO_QSPI_SD2_LEVEL_LOW                                         */
      __IOM uint32_t GPIO_QSPI_SD2_LEVEL_HIGH : 1;/*!< [17..17] GPIO_QSPI_SD2_LEVEL_HIGH                                       */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_LOW : 1;/*!< [18..18] GPIO_QSPI_SD2_EDGE_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SD2_EDGE_HIGH : 1;/*!< [19..19] GPIO_QSPI_SD2_EDGE_HIGH                                         */
      __IOM uint32_t GPIO_QSPI_SD3_LEVEL_LOW : 1;/*!< [20..20] GPIO_QSPI_SD3_LEVEL_LOW                                         */
      __IOM uint32_t GPIO_QSPI_SD3_LEVEL_HIGH : 1;/*!< [21..21] GPIO_QSPI_SD3_LEVEL_HIGH                                       */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_LOW : 1;/*!< [22..22] GPIO_QSPI_SD3_EDGE_LOW                                           */
      __IOM uint32_t GPIO_QSPI_SD3_EDGE_HIGH : 1;/*!< [23..23] GPIO_QSPI_SD3_EDGE_HIGH                                         */
            uint32_t            : 8;
    } bit;
  } DORMANT_WAKE_INTF;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000054) Interrupt status after masking & forcing for
                                                                    dormant_wake                                               */
    
    struct {
      __IM  uint32_t GPIO_QSPI_SCLK_LEVEL_LOW : 1;/*!< [0..0] GPIO_QSPI_SCLK_LEVEL_LOW                                         */
      __IM  uint32_t GPIO_QSPI_SCLK_LEVEL_HIGH : 1;/*!< [1..1] GPIO_QSPI_SCLK_LEVEL_HIGH                                       */
      __IM  uint32_t GPIO_QSPI_SCLK_EDGE_LOW : 1;/*!< [2..2] GPIO_QSPI_SCLK_EDGE_LOW                                           */
      __IM  uint32_t GPIO_QSPI_SCLK_EDGE_HIGH : 1;/*!< [3..3] GPIO_QSPI_SCLK_EDGE_HIGH                                         */
      __IM  uint32_t GPIO_QSPI_SS_LEVEL_LOW : 1;/*!< [4..4] GPIO_QSPI_SS_LEVEL_LOW                                             */
      __IM  uint32_t GPIO_QSPI_SS_LEVEL_HIGH : 1;/*!< [5..5] GPIO_QSPI_SS_LEVEL_HIGH                                           */
      __IM  uint32_t GPIO_QSPI_SS_EDGE_LOW : 1; /*!< [6..6] GPIO_QSPI_SS_EDGE_LOW                                              */
      __IM  uint32_t GPIO_QSPI_SS_EDGE_HIGH : 1;/*!< [7..7] GPIO_QSPI_SS_EDGE_HIGH                                             */
      __IM  uint32_t GPIO_QSPI_SD0_LEVEL_LOW : 1;/*!< [8..8] GPIO_QSPI_SD0_LEVEL_LOW                                           */
      __IM  uint32_t GPIO_QSPI_SD0_LEVEL_HIGH : 1;/*!< [9..9] GPIO_QSPI_SD0_LEVEL_HIGH                                         */
      __IM  uint32_t GPIO_QSPI_SD0_EDGE_LOW : 1;/*!< [10..10] GPIO_QSPI_SD0_EDGE_LOW                                           */
      __IM  uint32_t GPIO_QSPI_SD0_EDGE_HIGH : 1;/*!< [11..11] GPIO_QSPI_SD0_EDGE_HIGH                                         */
      __IM  uint32_t GPIO_QSPI_SD1_LEVEL_LOW : 1;/*!< [12..12] GPIO_QSPI_SD1_LEVEL_LOW                                         */
      __IM  uint32_t GPIO_QSPI_SD1_LEVEL_HIGH : 1;/*!< [13..13] GPIO_QSPI_SD1_LEVEL_HIGH                                       */
      __IM  uint32_t GPIO_QSPI_SD1_EDGE_LOW : 1;/*!< [14..14] GPIO_QSPI_SD1_EDGE_LOW                                           */
      __IM  uint32_t GPIO_QSPI_SD1_EDGE_HIGH : 1;/*!< [15..15] GPIO_QSPI_SD1_EDGE_HIGH                                         */
      __IM  uint32_t GPIO_QSPI_SD2_LEVEL_LOW : 1;/*!< [16..16] GPIO_QSPI_SD2_LEVEL_LOW                                         */
      __IM  uint32_t GPIO_QSPI_SD2_LEVEL_HIGH : 1;/*!< [17..17] GPIO_QSPI_SD2_LEVEL_HIGH                                       */
      __IM  uint32_t GPIO_QSPI_SD2_EDGE_LOW : 1;/*!< [18..18] GPIO_QSPI_SD2_EDGE_LOW                                           */
      __IM  uint32_t GPIO_QSPI_SD2_EDGE_HIGH : 1;/*!< [19..19] GPIO_QSPI_SD2_EDGE_HIGH                                         */
      __IM  uint32_t GPIO_QSPI_SD3_LEVEL_LOW : 1;/*!< [20..20] GPIO_QSPI_SD3_LEVEL_LOW                                         */
      __IM  uint32_t GPIO_QSPI_SD3_LEVEL_HIGH : 1;/*!< [21..21] GPIO_QSPI_SD3_LEVEL_HIGH                                       */
      __IM  uint32_t GPIO_QSPI_SD3_EDGE_LOW : 1;/*!< [22..22] GPIO_QSPI_SD3_EDGE_LOW                                           */
      __IM  uint32_t GPIO_QSPI_SD3_EDGE_HIGH : 1;/*!< [23..23] GPIO_QSPI_SD3_EDGE_HIGH                                         */
            uint32_t            : 8;
    } bit;
  } DORMANT_WAKE_INTS;
} IO_QSPI_Type;                                 /*!< Size = 88 (0x58)                                                          */



/* =========================================================================================================================== */
/* ================                                        PADS_BANK0                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief PADS_BANK0 (PADS_BANK0)
  */

typedef struct {                                /*!< (@ 0x4001C000) PADS_BANK0 Structure                                       */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000000) Voltage select. Per bank control                           */
    
    struct {
      __IOM uint32_t VOLTAGE_SELECT : 1;        /*!< [0..0] VOLTAGE_SELECT                                                     */
            uint32_t            : 31;
    } bit;
  } VOLTAGE_SELECT;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000004) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } GPIO0;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000008) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } GPIO1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000000C) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } GPIO2;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000010) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } GPIO3;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000014) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } GPIO4;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000018) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } GPIO5;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000001C) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } GPIO6;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000020) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } GPIO7;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000024) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } GPIO8;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000028) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } GPIO9;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000002C) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } GPIO10;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000030) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } GPIO11;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000034) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } GPIO12;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000038) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } GPIO13;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000003C) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } GPIO14;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000040) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } GPIO15;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000044) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } GPIO16;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000048) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } GPIO17;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000004C) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } GPIO18;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000050) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } GPIO19;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000054) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } GPIO20;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000058) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } GPIO21;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000005C) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } GPIO22;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000060) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } GPIO23;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000064) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } GPIO24;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000068) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } GPIO25;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000006C) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } GPIO26;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000070) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } GPIO27;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000074) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } GPIO28;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000078) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } GPIO29;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000007C) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } SWCLK;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000080) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } SWD;
} PADS_BANK0_Type;                              /*!< Size = 132 (0x84)                                                         */



/* =========================================================================================================================== */
/* ================                                         PADS_QSPI                                         ================ */
/* =========================================================================================================================== */


/**
  * @brief PADS_QSPI (PADS_QSPI)
  */

typedef struct {                                /*!< (@ 0x40020000) PADS_QSPI Structure                                        */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000000) Voltage select. Per bank control                           */
    
    struct {
      __IOM uint32_t VOLTAGE_SELECT : 1;        /*!< [0..0] VOLTAGE_SELECT                                                     */
            uint32_t            : 31;
    } bit;
  } VOLTAGE_SELECT;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000004) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } GPIO_QSPI_SCLK;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000008) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } GPIO_QSPI_SD0;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000000C) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } GPIO_QSPI_SD1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000010) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } GPIO_QSPI_SD2;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000014) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } GPIO_QSPI_SD3;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000018) Pad control register                                       */
    
    struct {
      __IOM uint32_t SLEWFAST   : 1;            /*!< [0..0] Slew rate control. 1 = Fast, 0 = Slow                              */
      __IOM uint32_t SCHMITT    : 1;            /*!< [1..1] Enable schmitt trigger                                             */
      __IOM uint32_t PDE        : 1;            /*!< [2..2] Pull down enable                                                   */
      __IOM uint32_t PUE        : 1;            /*!< [3..3] Pull up enable                                                     */
      __IOM uint32_t DRIVE      : 2;            /*!< [5..4] Drive strength.                                                    */
      __IOM uint32_t IE         : 1;            /*!< [6..6] Input enable                                                       */
      __IOM uint32_t OD         : 1;            /*!< [7..7] Output disable. Has priority over output enable from
                                                     peripherals                                                               */
            uint32_t            : 24;
    } bit;
  } GPIO_QSPI_SS;
} PADS_QSPI_Type;                               /*!< Size = 28 (0x1c)                                                          */



/* =========================================================================================================================== */
/* ================                                           XOSC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Controls the crystal oscillator (XOSC)
  */

typedef struct {                                /*!< (@ 0x40024000) XOSC Structure                                             */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000000) Crystal Oscillator Control                                 */
    
    struct {
      __IOM uint32_t FREQ_RANGE : 12;           /*!< [11..0] Frequency range. This resets to 0xAA0 and cannot be
                                                     changed.                                                                  */
      __IOM uint32_t ENABLE     : 12;           /*!< [23..12] On power-up this field is initialised to DISABLE and
                                                     the chip runs from the ROSC.
                                                     If the chip has subsequently been programmed to run from
                                                     the XOSC then setting this field to DISABLE may lock-up
                                                     the chip. If this is a concern then run the clk_ref from
                                                     the ROSC and enable the clk_sys RESUS feature.
                                                     The 12-bit code is intended to give some protection against
                                                     accidental writes. An invalid setting will enable the oscillator.         */
            uint32_t            : 8;
    } bit;
  } CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000004) Crystal Oscillator Status                                  */
    
    struct {
      __IM  uint32_t FREQ_RANGE : 2;            /*!< [1..0] The current frequency range setting, always reads 0                */
            uint32_t            : 10;
      __IM  uint32_t ENABLED    : 1;            /*!< [12..12] Oscillator is enabled but not necessarily running and
                                                     stable, resets to 0                                                       */
            uint32_t            : 11;
      __IOM uint32_t BADWRITE   : 1;            /*!< [24..24] An invalid value has been written to CTRL_ENABLE or
                                                     CTRL_FREQ_RANGE or DORMANT                                                */
            uint32_t            : 6;
      __IM  uint32_t STABLE     : 1;            /*!< [31..31] Oscillator is running and stable                                 */
    } bit;
  } STATUS;
  __IOM uint32_t  DORMANT;                      /*!< (@ 0x00000008) Crystal Oscillator pause control
                                                                    This is used to save power by pausing the
                                                                    XOSC
                                                                    On power-up this field is initialised to
                                                                    WAKE
                                                                    An invalid write will also select WAKE
                                                                    WARNING: stop the PLLs before selecting
                                                                    dormant mode
                                                                    WARNING: setup the irq before selecting
                                                                    dormant mode                                               */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000000C) Controls the startup delay                                 */
    
    struct {
      __IOM uint32_t DELAY      : 14;           /*!< [13..0] in multiples of 256*xtal_period                                   */
            uint32_t            : 6;
      __IOM uint32_t X4         : 1;            /*!< [20..20] Multiplies the startup_delay by 4. This is of little
                                                     value to the user given that the delay can be programmed
                                                     directly                                                                  */
            uint32_t            : 11;
    } bit;
  } STARTUP;
  __IM  uint32_t  RESERVED[3];
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000001C) A down counter running at the xosc frequency
                                                                    which counts to zero and stops.
                                                                    To start the counter write a non-zero value.
                                                                    Can be used for short software pauses when
                                                                    setting up time sensitive hardware.                        */
    
    struct {
      __IOM uint32_t COUNT      : 8;            /*!< [7..0] COUNT                                                              */
            uint32_t            : 24;
    } bit;
  } COUNT;
} XOSC_Type;                                    /*!< Size = 32 (0x20)                                                          */



/* =========================================================================================================================== */
/* ================                                          PLL_SYS                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief PLL_SYS (PLL_SYS)
  */

typedef struct {                                /*!< (@ 0x40028000) PLL_SYS Structure                                          */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000000) Control and Status
                                                                    GENERAL CONSTRAINTS:
                                                                    Reference clock frequency min=5MHz, max=800MHz
                                                                    Feedback divider min=16, max=320
                                                                    VCO frequency min=400MHz, max=1600MHz                      */
    
    struct {
      __IOM uint32_t REFDIV     : 6;            /*!< [5..0] Divides the PLL input reference clock.
                                                     Behaviour is undefined for div=0.
                                                     PLL output will be unpredictable during refdiv changes,
                                                     wait for lock=1 before using it.                                          */
            uint32_t            : 2;
      __IOM uint32_t BYPASS     : 1;            /*!< [8..8] Passes the reference clock to the output instead of the
                                                     divided VCO. The VCO continues to run so the user can switch
                                                     between the reference clock and the divided VCO but the
                                                     output will glitch when doing so.                                         */
            uint32_t            : 22;
      __IM  uint32_t LOCK       : 1;            /*!< [31..31] PLL is locked                                                    */
    } bit;
  } CS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000004) Controls the PLL power modes.                              */
    
    struct {
      __IOM uint32_t PD         : 1;            /*!< [0..0] PLL powerdown
                                                     To save power set high when PLL output not required.                      */
            uint32_t            : 1;
      __IOM uint32_t DSMPD      : 1;            /*!< [2..2] PLL DSM powerdown
                                                     Nothing is achieved by setting this low.                                  */
      __IOM uint32_t POSTDIVPD  : 1;            /*!< [3..3] PLL post divider powerdown
                                                     To save power set high when PLL output not required or
                                                     bypass=1.                                                                 */
            uint32_t            : 1;
      __IOM uint32_t VCOPD      : 1;            /*!< [5..5] PLL VCO powerdown
                                                     To save power set high when PLL output not required or
                                                     bypass=1.                                                                 */
            uint32_t            : 26;
    } bit;
  } PWR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000008) Feedback divisor
                                                                    (note: this PLL does not support fractional
                                                                    division)                                                  */
    
    struct {
      __IOM uint32_t FBDIV_INT  : 12;           /*!< [11..0] see ctrl reg description for constraints                          */
            uint32_t            : 20;
    } bit;
  } FBDIV_INT;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000000C) Controls the PLL post dividers for the primary
                                                                    output
                                                                    (note: this PLL does not have a secondary
                                                                    output)
                                                                    the primary output is driven from VCO divided
                                                                    by postdiv1*postdiv2                                       */
    
    struct {
            uint32_t            : 12;
      __IOM uint32_t POSTDIV2   : 3;            /*!< [14..12] divide by 1-7                                                    */
            uint32_t            : 1;
      __IOM uint32_t POSTDIV1   : 3;            /*!< [18..16] divide by 1-7                                                    */
            uint32_t            : 13;
    } bit;
  } PRIM;
} PLL_SYS_Type;                                 /*!< Size = 16 (0x10)                                                          */



/* =========================================================================================================================== */
/* ================                                          BUSCTRL                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief Register block for busfabric control signals and performance counters (BUSCTRL)
  */

typedef struct {                                /*!< (@ 0x40030000) BUSCTRL Structure                                          */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000000) Set the priority of each master for bus arbitration.       */
    
    struct {
      __IOM uint32_t PROC0      : 1;            /*!< [0..0] 0 - low priority, 1 - high priority                                */
            uint32_t            : 3;
      __IOM uint32_t PROC1      : 1;            /*!< [4..4] 0 - low priority, 1 - high priority                                */
            uint32_t            : 3;
      __IOM uint32_t DMA_R      : 1;            /*!< [8..8] 0 - low priority, 1 - high priority                                */
            uint32_t            : 3;
      __IOM uint32_t DMA_W      : 1;            /*!< [12..12] 0 - low priority, 1 - high priority                              */
            uint32_t            : 19;
    } bit;
  } BUS_PRIORITY;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000004) Bus priority acknowledge                                   */
    
    struct {
      __IM  uint32_t BUS_PRIORITY_ACK : 1;      /*!< [0..0] Goes to 1 once all arbiters have registered the new global
                                                     priority levels.
                                                     Arbiters update their local priority when servicing a new
                                                     nonsequential access.
                                                     In normal circumstances this will happen almost immediately.              */
            uint32_t            : 31;
    } bit;
  } BUS_PRIORITY_ACK;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000008) Bus fabric performance counter 0                           */
    
    struct {
      __IOM uint32_t PERFCTR0   : 24;           /*!< [23..0] Busfabric saturating performance counter 0
                                                     Count some event signal from the busfabric arbiters.
                                                     Write any value to clear. Select an event to count using
                                                     PERFSEL0                                                                  */
            uint32_t            : 8;
    } bit;
  } PERFCTR0;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000000C) Bus fabric performance event select for PERFCTR0           */
    
    struct {
      __IOM uint32_t PERFSEL0   : 5;            /*!< [4..0] Select a performance event for PERFCTR0                            */
            uint32_t            : 27;
    } bit;
  } PERFSEL0;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000010) Bus fabric performance counter 1                           */
    
    struct {
      __IOM uint32_t PERFCTR1   : 24;           /*!< [23..0] Busfabric saturating performance counter 1
                                                     Count some event signal from the busfabric arbiters.
                                                     Write any value to clear. Select an event to count using
                                                     PERFSEL1                                                                  */
            uint32_t            : 8;
    } bit;
  } PERFCTR1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000014) Bus fabric performance event select for PERFCTR1           */
    
    struct {
      __IOM uint32_t PERFSEL1   : 5;            /*!< [4..0] Select a performance event for PERFCTR1                            */
            uint32_t            : 27;
    } bit;
  } PERFSEL1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000018) Bus fabric performance counter 2                           */
    
    struct {
      __IOM uint32_t PERFCTR2   : 24;           /*!< [23..0] Busfabric saturating performance counter 2
                                                     Count some event signal from the busfabric arbiters.
                                                     Write any value to clear. Select an event to count using
                                                     PERFSEL2                                                                  */
            uint32_t            : 8;
    } bit;
  } PERFCTR2;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000001C) Bus fabric performance event select for PERFCTR2           */
    
    struct {
      __IOM uint32_t PERFSEL2   : 5;            /*!< [4..0] Select a performance event for PERFCTR2                            */
            uint32_t            : 27;
    } bit;
  } PERFSEL2;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000020) Bus fabric performance counter 3                           */
    
    struct {
      __IOM uint32_t PERFCTR3   : 24;           /*!< [23..0] Busfabric saturating performance counter 3
                                                     Count some event signal from the busfabric arbiters.
                                                     Write any value to clear. Select an event to count using
                                                     PERFSEL3                                                                  */
            uint32_t            : 8;
    } bit;
  } PERFCTR3;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000024) Bus fabric performance event select for PERFCTR3           */
    
    struct {
      __IOM uint32_t PERFSEL3   : 5;            /*!< [4..0] Select a performance event for PERFCTR3                            */
            uint32_t            : 27;
    } bit;
  } PERFSEL3;
} BUSCTRL_Type;                                 /*!< Size = 40 (0x28)                                                          */



/* =========================================================================================================================== */
/* ================                                           UART0                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief UART0 (UART0)
  */

typedef struct {                                /*!< (@ 0x40034000) UART0 Structure                                            */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000000) Data Register, UARTDR                                      */
    
    struct {
      __IOM uint32_t DATA       : 8;            /*!< [7..0] Receive (read) data character. Transmit (write) data
                                                     character.                                                                */
      __IM  uint32_t FE         : 1;            /*!< [8..8] Framing error. When set to 1, it indicates that the received
                                                     character did not have a valid stop bit (a valid stop bit
                                                     is 1). In FIFO mode, this error is associated with the
                                                     character at the top of the FIFO.                                         */
      __IM  uint32_t PE         : 1;            /*!< [9..9] Parity error. When set to 1, it indicates that the parity
                                                     of the received data character does not match the parity
                                                     that the EPS and SPS bits in the Line Control Register,
                                                     UARTLCR_H. In FIFO mode, this error is associated with
                                                     the character at the top of the FIFO.                                     */
      __IM  uint32_t BE         : 1;            /*!< [10..10] Break error. This bit is set to 1 if a break condition
                                                     was detected, indicating that the received data input was
                                                     held LOW for longer than a full-word transmission time
                                                     (defined as start, data, parity and stop bits). In FIFO
                                                     mode, this error is associated with the character at the
                                                     top of the FIFO. When a break occurs, only one 0 character
                                                     is loaded into the FIFO. The next character is only enabled
                                                     after the receive data input goes to a 1 (marking state),
                                                     and the next valid start bit is received.                                 */
      __IM  uint32_t OE         : 1;            /*!< [11..11] Overrun error. This bit is set to 1 if data is received
                                                     and the receive FIFO is already full. This is cleared to
                                                     0 once there is an empty space in the FIFO and a new character
                                                     can be written to it.                                                     */
            uint32_t            : 20;
    } bit;
  } UARTDR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000004) Receive Status Register/Error Clear Register,
                                                                    UARTRSR/UARTECR                                            */
    
    struct {
      __IOM uint32_t FE         : 1;            /*!< [0..0] Framing error. When set to 1, it indicates that the received
                                                     character did not have a valid stop bit (a valid stop bit
                                                     is 1). This bit is cleared to 0 by a write to UARTECR.
                                                     In FIFO mode, this error is associated with the character
                                                     at the top of the FIFO.                                                   */
      __IOM uint32_t PE         : 1;            /*!< [1..1] Parity error. When set to 1, it indicates that the parity
                                                     of the received data character does not match the parity
                                                     that the EPS and SPS bits in the Line Control Register,
                                                     UARTLCR_H. This bit is cleared to 0 by a write to UARTECR.
                                                     In FIFO mode, this error is associated with the character
                                                     at the top of the FIFO.                                                   */
      __IOM uint32_t BE         : 1;            /*!< [2..2] Break error. This bit is set to 1 if a break condition
                                                     was detected, indicating that the received data input was
                                                     held LOW for longer than a full-word transmission time
                                                     (defined as start, data, parity, and stop bits). This bit
                                                     is cleared to 0 after a write to UARTECR. In FIFO mode,
                                                     this error is associated with the character at the top
                                                     of the FIFO. When a break occurs, only one 0 character
                                                     is loaded into the FIFO. The next character is only enabled
                                                     after the receive data input goes to a 1 (marking state)
                                                                                                                               */
      __IOM uint32_t OE         : 1;            /*!< [3..3] Overrun error. This bit is set to 1 if data is received
                                                     and the FIFO is already full. This bit is cleared to 0
                                                     by a write to UARTECR. The FIFO contents remain valid because
                                                     no more data is written when the FIFO is full, only the
                                                     contents of the shift register are overwritten. The CPU
                                                     must now read the data, to empty the FIFO.                                */
            uint32_t            : 28;
    } bit;
  } UARTRSR;
  __IM  uint32_t  RESERVED[4];
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000018) Flag Register, UARTFR                                      */
    
    struct {
      __IM  uint32_t CTS        : 1;            /*!< [0..0] Clear to send. This bit is the complement of the UART
                                                     clear to send, nUARTCTS, modem status input. That is, the
                                                     bit is 1 when nUARTCTS is LOW.                                            */
      __IM  uint32_t DSR        : 1;            /*!< [1..1] Data set ready. This bit is the complement of the UART
                                                     data set ready, nUARTDSR, modem status input. That is,
                                                     the bit is 1 when nUARTDSR is LOW.                                        */
      __IM  uint32_t DCD        : 1;            /*!< [2..2] Data carrier detect. This bit is the complement of the
                                                     UART data carrier detect, nUARTDCD, modem status input.
                                                     That is, the bit is 1 when nUARTDCD is LOW.                               */
      __IM  uint32_t BUSY       : 1;            /*!< [3..3] UART busy. If this bit is set to 1, the UART is busy
                                                     transmitting data. This bit remains set until the complete
                                                     byte, including all the stop bits, has been sent from the
                                                     shift register. This bit is set as soon as the transmit
                                                     FIFO becomes non-empty, regardless of whether the UART
                                                     is enabled or not.                                                        */
      __IM  uint32_t RXFE       : 1;            /*!< [4..4] Receive FIFO empty. The meaning of this bit depends on
                                                     the state of the FEN bit in the UARTLCR_H Register. If
                                                     the FIFO is disabled, this bit is set when the receive
                                                     holding register is empty. If the FIFO is enabled, the
                                                     RXFE bit is set when the receive FIFO is empty.                           */
      __IM  uint32_t TXFF       : 1;            /*!< [5..5] Transmit FIFO full. The meaning of this bit depends on
                                                     the state of the FEN bit in the UARTLCR_H Register. If
                                                     the FIFO is disabled, this bit is set when the transmit
                                                     holding register is full. If the FIFO is enabled, the TXFF
                                                     bit is set when the transmit FIFO is full.                                */
      __IM  uint32_t RXFF       : 1;            /*!< [6..6] Receive FIFO full. The meaning of this bit depends on
                                                     the state of the FEN bit in the UARTLCR_H Register. If
                                                     the FIFO is disabled, this bit is set when the receive
                                                     holding register is full. If the FIFO is enabled, the RXFF
                                                     bit is set when the receive FIFO is full.                                 */
      __IM  uint32_t TXFE       : 1;            /*!< [7..7] Transmit FIFO empty. The meaning of this bit depends
                                                     on the state of the FEN bit in the Line Control Register,
                                                     UARTLCR_H. If the FIFO is disabled, this bit is set when
                                                     the transmit holding register is empty. If the FIFO is
                                                     enabled, the TXFE bit is set when the transmit FIFO is
                                                     empty. This bit does not indicate if there is data in the
                                                     transmit shift register.                                                  */
      __IM  uint32_t RI         : 1;            /*!< [8..8] Ring indicator. This bit is the complement of the UART
                                                     ring indicator, nUARTRI, modem status input. That is, the
                                                     bit is 1 when nUARTRI is LOW.                                             */
            uint32_t            : 23;
    } bit;
  } UARTFR;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000020) IrDA Low-Power Counter Register, UARTILPR                  */
    
    struct {
      __IOM uint32_t ILPDVSR    : 8;            /*!< [7..0] 8-bit low-power divisor value. These bits are cleared
                                                     to 0 at reset.                                                            */
            uint32_t            : 24;
    } bit;
  } UARTILPR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000024) Integer Baud Rate Register, UARTIBRD                       */
    
    struct {
      __IOM uint32_t BAUD_DIVINT : 16;          /*!< [15..0] The integer baud rate divisor. These bits are cleared
                                                     to 0 on reset.                                                            */
            uint32_t            : 16;
    } bit;
  } UARTIBRD;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000028) Fractional Baud Rate Register, UARTFBRD                    */
    
    struct {
      __IOM uint32_t BAUD_DIVFRAC : 6;          /*!< [5..0] The fractional baud rate divisor. These bits are cleared
                                                     to 0 on reset.                                                            */
            uint32_t            : 26;
    } bit;
  } UARTFBRD;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000002C) Line Control Register, UARTLCR_H                           */
    
    struct {
      __IOM uint32_t BRK        : 1;            /*!< [0..0] Send break. If this bit is set to 1, a low-level is continually
                                                     output on the UARTTXD output, after completing transmission
                                                     of the current character. For the proper execution of the
                                                     break command, the software must set this bit for at least
                                                     two complete frames. For normal use, this bit must be cleared
                                                     to 0.                                                                     */
      __IOM uint32_t PEN        : 1;            /*!< [1..1] Parity enable: 0 = parity is disabled and no parity bit
                                                     added to the data frame 1 = parity checking and generation
                                                     is enabled.                                                               */
      __IOM uint32_t EPS        : 1;            /*!< [2..2] Even parity select. Controls the type of parity the UART
                                                     uses during transmission and reception: 0 = odd parity.
                                                     The UART generates or checks for an odd number of 1s in
                                                     the data and parity bits. 1 = even parity. The UART generates
                                                     or checks for an even number of 1s in the data and parity
                                                     bits. This bit has no effect when the PEN bit disables
                                                     parity checking and generation.                                           */
      __IOM uint32_t STP2       : 1;            /*!< [3..3] Two stop bits select. If this bit is set to 1, two stop
                                                     bits are transmitted at the end of the frame. The receive
                                                     logic does not check for two stop bits being received.                    */
      __IOM uint32_t FEN        : 1;            /*!< [4..4] Enable FIFOs: 0 = FIFOs are disabled (character mode)
                                                     that is, the FIFOs become 1-byte-deep holding registers
                                                     1 = transmit and receive FIFO buffers are enabled (FIFO
                                                     mode).                                                                    */
      __IOM uint32_t WLEN       : 2;            /*!< [6..5] Word length. These bits indicate the number of data bits
                                                     transmitted or received in a frame as follows: b11 = 8
                                                     bits b10 = 7 bits b01 = 6 bits b00 = 5 bits.                              */
      __IOM uint32_t SPS        : 1;            /*!< [7..7] Stick parity select. 0 = stick parity is disabled 1 =
                                                     either: * if the EPS bit is 0 then the parity bit is transmitted
                                                     and checked as a 1 * if the EPS bit is 1 then the parity
                                                     bit is transmitted and checked as a 0. This bit has no
                                                     effect when the PEN bit disables parity checking and generation.          */
            uint32_t            : 24;
    } bit;
  } UARTLCR_H;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000030) Control Register, UARTCR                                   */
    
    struct {
      __IOM uint32_t UARTEN     : 1;            /*!< [0..0] UART enable: 0 = UART is disabled. If the UART is disabled
                                                     in the middle of transmission or reception, it completes
                                                     the current character before stopping. 1 = the UART is
                                                     enabled. Data transmission and reception occurs for either
                                                     UART signals or SIR signals depending on the setting of
                                                     the SIREN bit.                                                            */
      __IOM uint32_t SIREN      : 1;            /*!< [1..1] SIR enable: 0 = IrDA SIR ENDEC is disabled. nSIROUT remains
                                                     LOW (no light pulse generated), and signal transitions
                                                     on SIRIN have no effect. 1 = IrDA SIR ENDEC is enabled.
                                                     Data is transmitted and received on nSIROUT and SIRIN.
                                                     UARTTXD remains HIGH, in the marking state. Signal transitions
                                                     on UARTRXD or modem status inputs have no effect. This
                                                     bit has no effect if the UARTEN bit disables the UART.                    */
      __IOM uint32_t SIRLP      : 1;            /*!< [2..2] SIR low-power IrDA mode. This bit selects the IrDA encoding
                                                     mode. If this bit is cleared to 0, low-level bits are transmitted
                                                     as an active high pulse with a width of 3 / 16th of the
                                                     bit period. If this bit is set to 1, low-level bits are
                                                     transmitted with a pulse width that is 3 times the period
                                                     of the IrLPBaud16 input signal, regardless of the selected
                                                     bit rate. Setting this bit uses less power, but might reduce
                                                     transmission distances.                                                   */
            uint32_t            : 4;
      __IOM uint32_t LBE        : 1;            /*!< [7..7] Loopback enable. If this bit is set to 1 and the SIREN
                                                     bit is set to 1 and the SIRTEST bit in the Test Control
                                                     Register, UARTTCR is set to 1, then the nSIROUT path is
                                                     inverted, and fed through to the SIRIN path. The SIRTEST
                                                     bit in the test register must be set to 1 to override the
                                                     normal half-duplex SIR operation. This must be the requirement
                                                     for accessing the test registers during normal operation,
                                                     and SIRTEST must be cleared to 0 when loopback testing
                                                     is finished. This feature reduces the amount of ext                       */
      __IOM uint32_t TXE        : 1;            /*!< [8..8] Transmit enable. If this bit is set to 1, the transmit
                                                     section of the UART is enabled. Data transmission occurs
                                                     for either UART signals, or SIR signals depending on the
                                                     setting of the SIREN bit. When the UART is disabled in
                                                     the middle of transmission, it completes the current character
                                                     before stopping.                                                          */
      __IOM uint32_t RXE        : 1;            /*!< [9..9] Receive enable. If this bit is set to 1, the receive
                                                     section of the UART is enabled. Data reception occurs for
                                                     either UART signals or SIR signals depending on the setting
                                                     of the SIREN bit. When the UART is disabled in the middle
                                                     of reception, it completes the current character before
                                                     stopping.                                                                 */
      __IOM uint32_t DTR        : 1;            /*!< [10..10] Data transmit ready. This bit is the complement of
                                                     the UART data transmit ready, nUARTDTR, modem status output.
                                                     That is, when the bit is programmed to a 1 then nUARTDTR
                                                     is LOW.                                                                   */
      __IOM uint32_t RTS        : 1;            /*!< [11..11] Request to send. This bit is the complement of the
                                                     UART request to send, nUARTRTS, modem status output. That
                                                     is, when the bit is programmed to a 1 then nUARTRTS is
                                                     LOW.                                                                      */
      __IOM uint32_t OUT1       : 1;            /*!< [12..12] This bit is the complement of the UART Out1 (nUARTOut1)
                                                     modem status output. That is, when the bit is programmed
                                                     to a 1 the output is 0. For DTE this can be used as Data
                                                     Carrier Detect (DCD).                                                     */
      __IOM uint32_t OUT2       : 1;            /*!< [13..13] This bit is the complement of the UART Out2 (nUARTOut2)
                                                     modem status output. That is, when the bit is programmed
                                                     to a 1, the output is 0. For DTE this can be used as Ring
                                                     Indicator (RI).                                                           */
      __IOM uint32_t RTSEN      : 1;            /*!< [14..14] RTS hardware flow control enable. If this bit is set
                                                     to 1, RTS hardware flow control is enabled. Data is only
                                                     requested when there is space in the receive FIFO for it
                                                     to be received.                                                           */
      __IOM uint32_t CTSEN      : 1;            /*!< [15..15] CTS hardware flow control enable. If this bit is set
                                                     to 1, CTS hardware flow control is enabled. Data is only
                                                     transmitted when the nUARTCTS signal is asserted.                         */
            uint32_t            : 16;
    } bit;
  } UARTCR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000034) Interrupt FIFO Level Select Register, UARTIFLS             */
    
    struct {
      __IOM uint32_t TXIFLSEL   : 3;            /*!< [2..0] Transmit interrupt FIFO level select. The trigger points
                                                     for the transmit interrupt are as follows: b000 = Transmit
                                                     FIFO becomes <= 1 / 8 full b001 = Transmit FIFO becomes
                                                     <= 1 / 4 full b010 = Transmit FIFO becomes <= 1 / 2 full
                                                     b011 = Transmit FIFO becomes <= 3 / 4 full b100 = Transmit
                                                     FIFO becomes <= 7 / 8 full b101-b111 = reserved.                          */
      __IOM uint32_t RXIFLSEL   : 3;            /*!< [5..3] Receive interrupt FIFO level select. The trigger points
                                                     for the receive interrupt are as follows: b000 = Receive
                                                     FIFO becomes >= 1 / 8 full b001 = Receive FIFO becomes
                                                     >= 1 / 4 full b010 = Receive FIFO becomes >= 1 / 2 full
                                                     b011 = Receive FIFO becomes >= 3 / 4 full b100 = Receive
                                                     FIFO becomes >= 7 / 8 full b101-b111 = reserved.                          */
            uint32_t            : 26;
    } bit;
  } UARTIFLS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000038) Interrupt Mask Set/Clear Register, UARTIMSC                */
    
    struct {
      __IOM uint32_t RIMIM      : 1;            /*!< [0..0] nUARTRI modem interrupt mask. A read returns the current
                                                     mask for the UARTRIINTR interrupt. On a write of 1, the
                                                     mask of the UARTRIINTR interrupt is set. A write of 0 clears
                                                     the mask.                                                                 */
      __IOM uint32_t CTSMIM     : 1;            /*!< [1..1] nUARTCTS modem interrupt mask. A read returns the current
                                                     mask for the UARTCTSINTR interrupt. On a write of 1, the
                                                     mask of the UARTCTSINTR interrupt is set. A write of 0
                                                     clears the mask.                                                          */
      __IOM uint32_t DCDMIM     : 1;            /*!< [2..2] nUARTDCD modem interrupt mask. A read returns the current
                                                     mask for the UARTDCDINTR interrupt. On a write of 1, the
                                                     mask of the UARTDCDINTR interrupt is set. A write of 0
                                                     clears the mask.                                                          */
      __IOM uint32_t DSRMIM     : 1;            /*!< [3..3] nUARTDSR modem interrupt mask. A read returns the current
                                                     mask for the UARTDSRINTR interrupt. On a write of 1, the
                                                     mask of the UARTDSRINTR interrupt is set. A write of 0
                                                     clears the mask.                                                          */
      __IOM uint32_t RXIM       : 1;            /*!< [4..4] Receive interrupt mask. A read returns the current mask
                                                     for the UARTRXINTR interrupt. On a write of 1, the mask
                                                     of the UARTRXINTR interrupt is set. A write of 0 clears
                                                     the mask.                                                                 */
      __IOM uint32_t TXIM       : 1;            /*!< [5..5] Transmit interrupt mask. A read returns the current mask
                                                     for the UARTTXINTR interrupt. On a write of 1, the mask
                                                     of the UARTTXINTR interrupt is set. A write of 0 clears
                                                     the mask.                                                                 */
      __IOM uint32_t RTIM       : 1;            /*!< [6..6] Receive timeout interrupt mask. A read returns the current
                                                     mask for the UARTRTINTR interrupt. On a write of 1, the
                                                     mask of the UARTRTINTR interrupt is set. A write of 0 clears
                                                     the mask.                                                                 */
      __IOM uint32_t FEIM       : 1;            /*!< [7..7] Framing error interrupt mask. A read returns the current
                                                     mask for the UARTFEINTR interrupt. On a write of 1, the
                                                     mask of the UARTFEINTR interrupt is set. A write of 0 clears
                                                     the mask.                                                                 */
      __IOM uint32_t PEIM       : 1;            /*!< [8..8] Parity error interrupt mask. A read returns the current
                                                     mask for the UARTPEINTR interrupt. On a write of 1, the
                                                     mask of the UARTPEINTR interrupt is set. A write of 0 clears
                                                     the mask.                                                                 */
      __IOM uint32_t BEIM       : 1;            /*!< [9..9] Break error interrupt mask. A read returns the current
                                                     mask for the UARTBEINTR interrupt. On a write of 1, the
                                                     mask of the UARTBEINTR interrupt is set. A write of 0 clears
                                                     the mask.                                                                 */
      __IOM uint32_t OEIM       : 1;            /*!< [10..10] Overrun error interrupt mask. A read returns the current
                                                     mask for the UARTOEINTR interrupt. On a write of 1, the
                                                     mask of the UARTOEINTR interrupt is set. A write of 0 clears
                                                     the mask.                                                                 */
            uint32_t            : 21;
    } bit;
  } UARTIMSC;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000003C) Raw Interrupt Status Register, UARTRIS                     */
    
    struct {
      __IM  uint32_t RIRMIS     : 1;            /*!< [0..0] nUARTRI modem interrupt status. Returns the raw interrupt
                                                     state of the UARTRIINTR interrupt.                                        */
      __IM  uint32_t CTSRMIS    : 1;            /*!< [1..1] nUARTCTS modem interrupt status. Returns the raw interrupt
                                                     state of the UARTCTSINTR interrupt.                                       */
      __IM  uint32_t DCDRMIS    : 1;            /*!< [2..2] nUARTDCD modem interrupt status. Returns the raw interrupt
                                                     state of the UARTDCDINTR interrupt.                                       */
      __IM  uint32_t DSRRMIS    : 1;            /*!< [3..3] nUARTDSR modem interrupt status. Returns the raw interrupt
                                                     state of the UARTDSRINTR interrupt.                                       */
      __IM  uint32_t RXRIS      : 1;            /*!< [4..4] Receive interrupt status. Returns the raw interrupt state
                                                     of the UARTRXINTR interrupt.                                              */
      __IM  uint32_t TXRIS      : 1;            /*!< [5..5] Transmit interrupt status. Returns the raw interrupt
                                                     state of the UARTTXINTR interrupt.                                        */
      __IM  uint32_t RTRIS      : 1;            /*!< [6..6] Receive timeout interrupt status. Returns the raw interrupt
                                                     state of the UARTRTINTR interrupt. a                                      */
      __IM  uint32_t FERIS      : 1;            /*!< [7..7] Framing error interrupt status. Returns the raw interrupt
                                                     state of the UARTFEINTR interrupt.                                        */
      __IM  uint32_t PERIS      : 1;            /*!< [8..8] Parity error interrupt status. Returns the raw interrupt
                                                     state of the UARTPEINTR interrupt.                                        */
      __IM  uint32_t BERIS      : 1;            /*!< [9..9] Break error interrupt status. Returns the raw interrupt
                                                     state of the UARTBEINTR interrupt.                                        */
      __IM  uint32_t OERIS      : 1;            /*!< [10..10] Overrun error interrupt status. Returns the raw interrupt
                                                     state of the UARTOEINTR interrupt.                                        */
            uint32_t            : 21;
    } bit;
  } UARTRIS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000040) Masked Interrupt Status Register, UARTMIS                  */
    
    struct {
      __IM  uint32_t RIMMIS     : 1;            /*!< [0..0] nUARTRI modem masked interrupt status. Returns the masked
                                                     interrupt state of the UARTRIINTR interrupt.                              */
      __IM  uint32_t CTSMMIS    : 1;            /*!< [1..1] nUARTCTS modem masked interrupt status. Returns the masked
                                                     interrupt state of the UARTCTSINTR interrupt.                             */
      __IM  uint32_t DCDMMIS    : 1;            /*!< [2..2] nUARTDCD modem masked interrupt status. Returns the masked
                                                     interrupt state of the UARTDCDINTR interrupt.                             */
      __IM  uint32_t DSRMMIS    : 1;            /*!< [3..3] nUARTDSR modem masked interrupt status. Returns the masked
                                                     interrupt state of the UARTDSRINTR interrupt.                             */
      __IM  uint32_t RXMIS      : 1;            /*!< [4..4] Receive masked interrupt status. Returns the masked interrupt
                                                     state of the UARTRXINTR interrupt.                                        */
      __IM  uint32_t TXMIS      : 1;            /*!< [5..5] Transmit masked interrupt status. Returns the masked
                                                     interrupt state of the UARTTXINTR interrupt.                              */
      __IM  uint32_t RTMIS      : 1;            /*!< [6..6] Receive timeout masked interrupt status. Returns the
                                                     masked interrupt state of the UARTRTINTR interrupt.                       */
      __IM  uint32_t FEMIS      : 1;            /*!< [7..7] Framing error masked interrupt status. Returns the masked
                                                     interrupt state of the UARTFEINTR interrupt.                              */
      __IM  uint32_t PEMIS      : 1;            /*!< [8..8] Parity error masked interrupt status. Returns the masked
                                                     interrupt state of the UARTPEINTR interrupt.                              */
      __IM  uint32_t BEMIS      : 1;            /*!< [9..9] Break error masked interrupt status. Returns the masked
                                                     interrupt state of the UARTBEINTR interrupt.                              */
      __IM  uint32_t OEMIS      : 1;            /*!< [10..10] Overrun error masked interrupt status. Returns the
                                                     masked interrupt state of the UARTOEINTR interrupt.                       */
            uint32_t            : 21;
    } bit;
  } UARTMIS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000044) Interrupt Clear Register, UARTICR                          */
    
    struct {
      __IOM uint32_t RIMIC      : 1;            /*!< [0..0] nUARTRI modem interrupt clear. Clears the UARTRIINTR
                                                     interrupt.                                                                */
      __IOM uint32_t CTSMIC     : 1;            /*!< [1..1] nUARTCTS modem interrupt clear. Clears the UARTCTSINTR
                                                     interrupt.                                                                */
      __IOM uint32_t DCDMIC     : 1;            /*!< [2..2] nUARTDCD modem interrupt clear. Clears the UARTDCDINTR
                                                     interrupt.                                                                */
      __IOM uint32_t DSRMIC     : 1;            /*!< [3..3] nUARTDSR modem interrupt clear. Clears the UARTDSRINTR
                                                     interrupt.                                                                */
      __IOM uint32_t RXIC       : 1;            /*!< [4..4] Receive interrupt clear. Clears the UARTRXINTR interrupt.          */
      __IOM uint32_t TXIC       : 1;            /*!< [5..5] Transmit interrupt clear. Clears the UARTTXINTR interrupt.         */
      __IOM uint32_t RTIC       : 1;            /*!< [6..6] Receive timeout interrupt clear. Clears the UARTRTINTR
                                                     interrupt.                                                                */
      __IOM uint32_t FEIC       : 1;            /*!< [7..7] Framing error interrupt clear. Clears the UARTFEINTR
                                                     interrupt.                                                                */
      __IOM uint32_t PEIC       : 1;            /*!< [8..8] Parity error interrupt clear. Clears the UARTPEINTR interrupt.     */
      __IOM uint32_t BEIC       : 1;            /*!< [9..9] Break error interrupt clear. Clears the UARTBEINTR interrupt.      */
      __IOM uint32_t OEIC       : 1;            /*!< [10..10] Overrun error interrupt clear. Clears the UARTOEINTR
                                                     interrupt.                                                                */
            uint32_t            : 21;
    } bit;
  } UARTICR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000048) DMA Control Register, UARTDMACR                            */
    
    struct {
      __IOM uint32_t RXDMAE     : 1;            /*!< [0..0] Receive DMA enable. If this bit is set to 1, DMA for
                                                     the receive FIFO is enabled.                                              */
      __IOM uint32_t TXDMAE     : 1;            /*!< [1..1] Transmit DMA enable. If this bit is set to 1, DMA for
                                                     the transmit FIFO is enabled.                                             */
      __IOM uint32_t DMAONERR   : 1;            /*!< [2..2] DMA on error. If this bit is set to 1, the DMA receive
                                                     request outputs, UARTRXDMASREQ or UARTRXDMABREQ, are disabled
                                                     when the UART error interrupt is asserted.                                */
            uint32_t            : 29;
    } bit;
  } UARTDMACR;
  __IM  uint32_t  RESERVED2[997];
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000FE0) UARTPeriphID0 Register                                     */
    
    struct {
      __IM  uint32_t PARTNUMBER0 : 8;           /*!< [7..0] These bits read back as 0x11                                       */
            uint32_t            : 24;
    } bit;
  } UARTPERIPHID0;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000FE4) UARTPeriphID1 Register                                     */
    
    struct {
      __IM  uint32_t PARTNUMBER1 : 4;           /*!< [3..0] These bits read back as 0x0                                        */
      __IM  uint32_t DESIGNER0  : 4;            /*!< [7..4] These bits read back as 0x1                                        */
            uint32_t            : 24;
    } bit;
  } UARTPERIPHID1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000FE8) UARTPeriphID2 Register                                     */
    
    struct {
      __IM  uint32_t DESIGNER1  : 4;            /*!< [3..0] These bits read back as 0x4                                        */
      __IM  uint32_t REVISION   : 4;            /*!< [7..4] This field depends on the revision of the UART: r1p0
                                                     0x0 r1p1 0x1 r1p3 0x2 r1p4 0x2 r1p5 0x3                                   */
            uint32_t            : 24;
    } bit;
  } UARTPERIPHID2;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000FEC) UARTPeriphID3 Register                                     */
    
    struct {
      __IM  uint32_t CONFIGURATION : 8;         /*!< [7..0] These bits read back as 0x00                                       */
            uint32_t            : 24;
    } bit;
  } UARTPERIPHID3;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000FF0) UARTPCellID0 Register                                      */
    
    struct {
      __IM  uint32_t UARTPCELLID0 : 8;          /*!< [7..0] These bits read back as 0x0D                                       */
            uint32_t            : 24;
    } bit;
  } UARTPCELLID0;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000FF4) UARTPCellID1 Register                                      */
    
    struct {
      __IM  uint32_t UARTPCELLID1 : 8;          /*!< [7..0] These bits read back as 0xF0                                       */
            uint32_t            : 24;
    } bit;
  } UARTPCELLID1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000FF8) UARTPCellID2 Register                                      */
    
    struct {
      __IM  uint32_t UARTPCELLID2 : 8;          /*!< [7..0] These bits read back as 0x05                                       */
            uint32_t            : 24;
    } bit;
  } UARTPCELLID2;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000FFC) UARTPCellID3 Register                                      */
    
    struct {
      __IM  uint32_t UARTPCELLID3 : 8;          /*!< [7..0] These bits read back as 0xB1                                       */
            uint32_t            : 24;
    } bit;
  } UARTPCELLID3;
} UART0_Type;                                   /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                           SPI0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief SPI0 (SPI0)
  */

typedef struct {                                /*!< (@ 0x4003C000) SPI0 Structure                                             */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000000) Control register 0, SSPCR0 on page 3-4                     */
    
    struct {
      __IOM uint32_t DSS        : 4;            /*!< [3..0] Data Size Select: 0000 Reserved, undefined operation.
                                                     0001 Reserved, undefined operation. 0010 Reserved, undefined
                                                     operation. 0011 4-bit data. 0100 5-bit data. 0101 6-bit
                                                     data. 0110 7-bit data. 0111 8-bit data. 1000 9-bit data.
                                                     1001 10-bit data. 1010 11-bit data. 1011 12-bit data. 1100
                                                     13-bit data. 1101 14-bit data. 1110 15-bit data. 1111 16-bit
                                                     data.                                                                     */
      __IOM uint32_t FRF        : 2;            /*!< [5..4] Frame format: 00 Motorola SPI frame format. 01 TI synchronous
                                                     serial frame format. 10 National Microwire frame format.
                                                     11 Reserved, undefined operation.                                         */
      __IOM uint32_t SPO        : 1;            /*!< [6..6] SSPCLKOUT polarity, applicable to Motorola SPI frame
                                                     format only. See Motorola SPI frame format on page 2-10.                  */
      __IOM uint32_t SPH        : 1;            /*!< [7..7] SSPCLKOUT phase, applicable to Motorola SPI frame format
                                                     only. See Motorola SPI frame format on page 2-10.                         */
      __IOM uint32_t SCR        : 8;            /*!< [15..8] Serial clock rate. The value SCR is used to generate
                                                     the transmit and receive bit rate of the PrimeCell SSP.
                                                     The bit rate is: F SSPCLK CPSDVSR x (1+SCR) where CPSDVSR
                                                     is an even value from 2-254, programmed through the SSPCPSR
                                                     register and SCR is a value from 0-255.                                   */
            uint32_t            : 16;
    } bit;
  } SSPCR0;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000004) Control register 1, SSPCR1 on page 3-5                     */
    
    struct {
      __IOM uint32_t LBM        : 1;            /*!< [0..0] Loop back mode: 0 Normal serial port operation enabled.
                                                     1 Output of transmit serial shifter is connected to input
                                                     of receive serial shifter internally.                                     */
      __IOM uint32_t SSE        : 1;            /*!< [1..1] Synchronous serial port enable: 0 SSP operation disabled.
                                                     1 SSP operation enabled.                                                  */
      __IOM uint32_t MS         : 1;            /*!< [2..2] Master or slave mode select. This bit can be modified
                                                     only when the PrimeCell SSP is disabled, SSE=0: 0 Device
                                                     configured as master, default. 1 Device configured as slave.              */
      __IOM uint32_t SOD        : 1;            /*!< [3..3] Slave-mode output disable. This bit is relevant only
                                                     in the slave mode, MS=1. In multiple-slave systems, it
                                                     is possible for an PrimeCell SSP master to broadcast a
                                                     message to all slaves in the system while ensuring that
                                                     only one slave drives data onto its serial output line.
                                                     In such systems the RXD lines from multiple slaves could
                                                     be tied together. To operate in such systems, the SOD bit
                                                     can be set if the PrimeCell SSP slave is not supposed to
                                                     drive the SSPTXD line: 0 SSP can drive the SSPTXD output
                                                     in sl                                                                     */
            uint32_t            : 28;
    } bit;
  } SSPCR1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000008) Data register, SSPDR on page 3-6                           */
    
    struct {
      __IOM uint32_t DATA       : 16;           /*!< [15..0] Transmit/Receive FIFO: Read Receive FIFO. Write Transmit
                                                     FIFO. You must right-justify data when the PrimeCell SSP
                                                     is programmed for a data size that is less than 16 bits.
                                                     Unused bits at the top are ignored by transmit logic. The
                                                     receive logic automatically right-justifies.                              */
            uint32_t            : 16;
    } bit;
  } SSPDR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000000C) Status register, SSPSR on page 3-7                         */
    
    struct {
      __IM  uint32_t TFE        : 1;            /*!< [0..0] Transmit FIFO empty, RO: 0 Transmit FIFO is not empty.
                                                     1 Transmit FIFO is empty.                                                 */
      __IM  uint32_t TNF        : 1;            /*!< [1..1] Transmit FIFO not full, RO: 0 Transmit FIFO is full.
                                                     1 Transmit FIFO is not full.                                              */
      __IM  uint32_t RNE        : 1;            /*!< [2..2] Receive FIFO not empty, RO: 0 Receive FIFO is empty.
                                                     1 Receive FIFO is not empty.                                              */
      __IM  uint32_t RFF        : 1;            /*!< [3..3] Receive FIFO full, RO: 0 Receive FIFO is not full. 1
                                                     Receive FIFO is full.                                                     */
      __IM  uint32_t BSY        : 1;            /*!< [4..4] PrimeCell SSP busy flag, RO: 0 SSP is idle. 1 SSP is
                                                     currently transmitting and/or receiving a frame or the
                                                     transmit FIFO is not empty.                                               */
            uint32_t            : 27;
    } bit;
  } SSPSR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000010) Clock prescale register, SSPCPSR on page 3-8               */
    
    struct {
      __IOM uint32_t CPSDVSR    : 8;            /*!< [7..0] Clock prescale divisor. Must be an even number from 2-254,
                                                     depending on the frequency of SSPCLK. The least significant
                                                     bit always returns zero on reads.                                         */
            uint32_t            : 24;
    } bit;
  } SSPCPSR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000014) Interrupt mask set or clear register, SSPIMSC
                                                                    on page 3-9                                                */
    
    struct {
      __IOM uint32_t RORIM      : 1;            /*!< [0..0] Receive overrun interrupt mask: 0 Receive FIFO written
                                                     to while full condition interrupt is masked. 1 Receive
                                                     FIFO written to while full condition interrupt is not masked.             */
      __IOM uint32_t RTIM       : 1;            /*!< [1..1] Receive timeout interrupt mask: 0 Receive FIFO not empty
                                                     and no read prior to timeout period interrupt is masked.
                                                     1 Receive FIFO not empty and no read prior to timeout period
                                                     interrupt is not masked.                                                  */
      __IOM uint32_t RXIM       : 1;            /*!< [2..2] Receive FIFO interrupt mask: 0 Receive FIFO half full
                                                     or less condition interrupt is masked. 1 Receive FIFO half
                                                     full or less condition interrupt is not masked.                           */
      __IOM uint32_t TXIM       : 1;            /*!< [3..3] Transmit FIFO interrupt mask: 0 Transmit FIFO half empty
                                                     or less condition interrupt is masked. 1 Transmit FIFO
                                                     half empty or less condition interrupt is not masked.                     */
            uint32_t            : 28;
    } bit;
  } SSPIMSC;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000018) Raw interrupt status register, SSPRIS on page
                                                                    3-10                                                       */
    
    struct {
      __IM  uint32_t RORRIS     : 1;            /*!< [0..0] Gives the raw interrupt state, prior to masking, of the
                                                     SSPRORINTR interrupt                                                      */
      __IM  uint32_t RTRIS      : 1;            /*!< [1..1] Gives the raw interrupt state, prior to masking, of the
                                                     SSPRTINTR interrupt                                                       */
      __IM  uint32_t RXRIS      : 1;            /*!< [2..2] Gives the raw interrupt state, prior to masking, of the
                                                     SSPRXINTR interrupt                                                       */
      __IM  uint32_t TXRIS      : 1;            /*!< [3..3] Gives the raw interrupt state, prior to masking, of the
                                                     SSPTXINTR interrupt                                                       */
            uint32_t            : 28;
    } bit;
  } SSPRIS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000001C) Masked interrupt status register, SSPMIS on page
                                                                    3-11                                                       */
    
    struct {
      __IM  uint32_t RORMIS     : 1;            /*!< [0..0] Gives the receive over run masked interrupt status, after
                                                     masking, of the SSPRORINTR interrupt                                      */
      __IM  uint32_t RTMIS      : 1;            /*!< [1..1] Gives the receive timeout masked interrupt state, after
                                                     masking, of the SSPRTINTR interrupt                                       */
      __IM  uint32_t RXMIS      : 1;            /*!< [2..2] Gives the receive FIFO masked interrupt state, after
                                                     masking, of the SSPRXINTR interrupt                                       */
      __IM  uint32_t TXMIS      : 1;            /*!< [3..3] Gives the transmit FIFO masked interrupt state, after
                                                     masking, of the SSPTXINTR interrupt                                       */
            uint32_t            : 28;
    } bit;
  } SSPMIS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000020) Interrupt clear register, SSPICR on page 3-11              */
    
    struct {
      __IOM uint32_t RORIC      : 1;            /*!< [0..0] Clears the SSPRORINTR interrupt                                    */
      __IOM uint32_t RTIC       : 1;            /*!< [1..1] Clears the SSPRTINTR interrupt                                     */
            uint32_t            : 30;
    } bit;
  } SSPICR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000024) DMA control register, SSPDMACR on page 3-12                */
    
    struct {
      __IOM uint32_t RXDMAE     : 1;            /*!< [0..0] Receive DMA Enable. If this bit is set to 1, DMA for
                                                     the receive FIFO is enabled.                                              */
      __IOM uint32_t TXDMAE     : 1;            /*!< [1..1] Transmit DMA Enable. If this bit is set to 1, DMA for
                                                     the transmit FIFO is enabled.                                             */
            uint32_t            : 30;
    } bit;
  } SSPDMACR;
  __IM  uint32_t  RESERVED[1006];
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000FE0) Peripheral identification registers, SSPPeriphID0-3
                                                                    on page 3-13                                               */
    
    struct {
      __IM  uint32_t PARTNUMBER0 : 8;           /*!< [7..0] These bits read back as 0x22                                       */
            uint32_t            : 24;
    } bit;
  } SSPPERIPHID0;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000FE4) Peripheral identification registers, SSPPeriphID0-3
                                                                    on page 3-13                                               */
    
    struct {
      __IM  uint32_t PARTNUMBER1 : 4;           /*!< [3..0] These bits read back as 0x0                                        */
      __IM  uint32_t DESIGNER0  : 4;            /*!< [7..4] These bits read back as 0x1                                        */
            uint32_t            : 24;
    } bit;
  } SSPPERIPHID1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000FE8) Peripheral identification registers, SSPPeriphID0-3
                                                                    on page 3-13                                               */
    
    struct {
      __IM  uint32_t DESIGNER1  : 4;            /*!< [3..0] These bits read back as 0x4                                        */
      __IM  uint32_t REVISION   : 4;            /*!< [7..4] These bits return the peripheral revision                          */
            uint32_t            : 24;
    } bit;
  } SSPPERIPHID2;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000FEC) Peripheral identification registers, SSPPeriphID0-3
                                                                    on page 3-13                                               */
    
    struct {
      __IM  uint32_t CONFIGURATION : 8;         /*!< [7..0] These bits read back as 0x00                                       */
            uint32_t            : 24;
    } bit;
  } SSPPERIPHID3;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000FF0) PrimeCell identification registers, SSPPCellID0-3
                                                                    on page 3-16                                               */
    
    struct {
      __IM  uint32_t SSPPCELLID0 : 8;           /*!< [7..0] These bits read back as 0x0D                                       */
            uint32_t            : 24;
    } bit;
  } SSPPCELLID0;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000FF4) PrimeCell identification registers, SSPPCellID0-3
                                                                    on page 3-16                                               */
    
    struct {
      __IM  uint32_t SSPPCELLID1 : 8;           /*!< [7..0] These bits read back as 0xF0                                       */
            uint32_t            : 24;
    } bit;
  } SSPPCELLID1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000FF8) PrimeCell identification registers, SSPPCellID0-3
                                                                    on page 3-16                                               */
    
    struct {
      __IM  uint32_t SSPPCELLID2 : 8;           /*!< [7..0] These bits read back as 0x05                                       */
            uint32_t            : 24;
    } bit;
  } SSPPCELLID2;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000FFC) PrimeCell identification registers, SSPPCellID0-3
                                                                    on page 3-16                                               */
    
    struct {
      __IM  uint32_t SSPPCELLID3 : 8;           /*!< [7..0] These bits read back as 0xB1                                       */
            uint32_t            : 24;
    } bit;
  } SSPPCELLID3;
} SPI0_Type;                                    /*!< Size = 4096 (0x1000)                                                      */



/* =========================================================================================================================== */
/* ================                                           I2C0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief DW_apb_i2c address block (I2C0)
  */

typedef struct {                                /*!< (@ 0x40044000) I2C0 Structure                                             */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000000) I2C Control Register. This register can be written
                                                                    only when the DW_apb_i2c is disabled, which
                                                                    corresponds to the IC_ENABLE[0] register
                                                                    being set to 0. Writes at other times have
                                                                    no effect.
                                                                    
                                                                    Read/Write Access: - bit 10 is read only.
                                                                    - bit 11 is read only - bit 16 is read only
                                                                    - bit 17 is read only - bits 18 and 19 are
                                                                    read only.                                                 */
    
    struct {
      __IOM uint32_t MASTER_MODE : 1;           /*!< [0..0] This bit controls whether the DW_apb_i2c master is enabled.
                                                     
                                                     NOTE: Software should ensure that if this bit is written
                                                     with '1' then bit 6 should also be written with a '1'.                    */
      __IOM uint32_t SPEED      : 2;            /*!< [2..1] These bits control at which speed the DW_apb_i2c operates;
                                                     its setting is relevant only if one is operating the DW_apb_i2c
                                                     in master mode. Hardware protects against illegal values
                                                     being programmed by software. These bits must be programmed
                                                     appropriately for slave mode also, as it is used to capture
                                                     correct value of spike filter as per the speed mode.
                                                     
                                                     This register should be programmed only with a value in
                                                     the range of 1 to IC_MAX_SPEED_MODE; otherwise, hardware
                                                     updates this register                                                     */
      __IOM uint32_t IC_10BITADDR_SLAVE : 1;    /*!< [3..3] When acting as a slave, this bit controls whether the
                                                     DW_apb_i2c responds to 7- or 10-bit addresses. - 0: 7-bit
                                                     addressing. The DW_apb_i2c ignores transactions that involve
                                                     10-bit addressing; for 7-bit addressing, only the lower
                                                     7 bits of the IC_SAR register are compared. - 1: 10-bit
                                                     addressing. The DW_apb_i2c responds to only 10-bit addressing
                                                     transfers that match the full 10 bits of the IC_SAR register.             */
      __IOM uint32_t IC_10BITADDR_MASTER : 1;   /*!< [4..4] Controls whether the DW_apb_i2c starts its transfers
                                                     in 7- or 10-bit addressing mode when acting as a master.
                                                     - 0: 7-bit addressing - 1: 10-bit addressing                              */
      __IOM uint32_t IC_RESTART_EN : 1;         /*!< [5..5] Determines whether RESTART conditions may be sent when
                                                     acting as a master. Some older slaves do not support handling
                                                     RESTART conditions; however, RESTART conditions are used
                                                     in several DW_apb_i2c operations. When RESTART is disabled,
                                                     the master is prohibited from performing the following
                                                     functions: - Sending a START BYTE - Performing any high-speed
                                                     mode operation - High-speed mode operation - Performing
                                                     direction changes in combined format mode - Performing
                                                     a read operation with a 10-bit address By repla                           */
      __IOM uint32_t IC_SLAVE_DISABLE : 1;      /*!< [6..6] This bit controls whether I2C has its slave disabled,
                                                     which means once the presetn signal is applied, then this
                                                     bit is set and the slave is disabled.
                                                     
                                                     If this bit is set (slave is disabled), DW_apb_i2c functions
                                                     only as a master and does not perform any action that requires
                                                     a slave.
                                                     
                                                     NOTE: Software should ensure that if this bit is written
                                                     with 0, then bit 0 should also be written with a 0.                       */
      __IOM uint32_t STOP_DET_IFADDRESSED : 1;  /*!< [7..7] In slave mode: - 1'b1: issues the STOP_DET interrupt
                                                     only when it is addressed. - 1'b0: issues the STOP_DET
                                                     irrespective of whether it's addressed or not. Reset value:
                                                     0x0
                                                     
                                                     NOTE: During a general call address, this slave does not
                                                     issue the STOP_DET interrupt if STOP_DET_IF_ADDRESSED =
                                                     1'b1, even if the slave responds to the general call address
                                                     by generating ACK. The STOP_DET interrupt is generated
                                                     only when the transmitted address matches the slave address
                                                     (SAR).                                                                    */
      __IOM uint32_t TX_EMPTY_CTRL : 1;         /*!< [8..8] This bit controls the generation of the TX_EMPTY interrupt,
                                                     as described in the IC_RAW_INTR_STAT register.
                                                     
                                                     Reset value: 0x0.                                                         */
      __IOM uint32_t RX_FIFO_FULL_HLD_CTRL : 1; /*!< [9..9] This bit controls whether DW_apb_i2c should hold the
                                                     bus when the Rx FIFO is physically full to its RX_BUFFER_DEPTH,
                                                     as described in the IC_RX_FULL_HLD_BUS_EN parameter.
                                                     
                                                     Reset value: 0x0.                                                         */
      __IM  uint32_t STOP_DET_IF_MASTER_ACTIVE : 1;/*!< [10..10] Master issues the STOP_DET interrupt irrespective of
                                                     whether master is active or not                                           */
            uint32_t            : 21;
    } bit;
  } IC_CON;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000004) I2C Target Address Register
                                                                    
                                                                    This register is 12 bits wide, and bits
                                                                    31:12 are reserved. This register can be
                                                                    written to only when IC_ENABLE[0] is set
                                                                    to 0.
                                                                    
                                                                    Note: If the software or application is
                                                                    aware that the DW_apb_i2c is not using the
                                                                    TAR address for the pending commands in
                                                                    the Tx FIFO, then it is possible to update
                                                                    the TAR address even while the Tx FIFO has
                                                                    entries (IC_STATUS[2]= 0). - It is not necessary
                                                                    to perform any write to this register if
                                                                    DW_ap                                                      */
    
    struct {
      __IOM uint32_t IC_TAR     : 10;           /*!< [9..0] This is the target address for any master transaction.
                                                     When transmitting a General Call, these bits are ignored.
                                                     To generate a START BYTE, the CPU needs to write only once
                                                     into these bits.
                                                     
                                                     If the IC_TAR and IC_SAR are the same, loopback exists
                                                     but the FIFOs are shared between master and slave, so full
                                                     loopback is not feasible. Only one direction loopback mode
                                                     is supported (simplex), not duplex. A master cannot transmit
                                                     to itself; it can transmit to only a slave.                               */
      __IOM uint32_t GC_OR_START : 1;           /*!< [10..10] If bit 11 (SPECIAL) is set to 1 and bit 13(Device-ID)
                                                     is set to 0, then this bit indicates whether a General
                                                     Call or START byte command is to be performed by the DW_apb_i2c.
                                                     - 0: General Call Address - after issuing a General Call,
                                                     only writes may be performed. Attempting to issue a read
                                                     command results in setting bit 6 (TX_ABRT) of the IC_RAW_INTR_STAT
                                                     register. The DW_apb_i2c remains in General Call mode until
                                                     the SPECIAL bit value (bit 11) is cleared. - 1: START BYTE
                                                     Reset value: 0x0                                                          */
      __IOM uint32_t SPECIAL    : 1;            /*!< [11..11] This bit indicates whether software performs a Device-ID
                                                     or General Call or START BYTE command. - 0: ignore bit
                                                     10 GC_OR_START and use IC_TAR normally - 1: perform special
                                                     I2C command as specified in Device_ID or GC_OR_START bit
                                                     Reset value: 0x0                                                          */
            uint32_t            : 20;
    } bit;
  } IC_TAR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000008) I2C Slave Address Register                                 */
    
    struct {
      __IOM uint32_t IC_SAR     : 10;           /*!< [9..0] The IC_SAR holds the slave address when the I2C is operating
                                                     as a slave. For 7-bit addressing, only IC_SAR[6:0] is used.
                                                     
                                                     This register can be written only when the I2C interface
                                                     is disabled, which corresponds to the IC_ENABLE[0] register
                                                     being set to 0. Writes at other times have no effect.
                                                     
                                                     Note: The default values cannot be any of the reserved
                                                     address locations: that is, 0x00 to 0x07, or 0x78 to 0x7f.
                                                     The correct operation of the device is not guaranteed if
                                                     you                                                                       */
            uint32_t            : 22;
    } bit;
  } IC_SAR;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000010) I2C Rx/Tx Data Buffer and Command Register; this
                                                                    is the register the CPU writes to when filling
                                                                    the TX FIFO and the CPU reads from when
                                                                    retrieving bytes from RX FIFO.
                                                                    
                                                                    The size of the register changes as follows:
                                                                    
                                                                    Write: - 11 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=1
                                                                    - 9 bits when IC_EMPTYFIFO_HOLD_MASTER_EN=0
                                                                    Read: - 12 bits when IC_FIRST_DATA_BYTE_STATUS
                                                                    = 1 - 8 bits when IC_FIRST_DATA_BYTE_STATUS
                                                                    = 0 Note: In order for the DW_apb_i2c to
                                                                    continue acknowledgi                                       */
    
    struct {
      __IOM uint32_t DAT        : 8;            /*!< [7..0] This register contains the data to be transmitted or
                                                     received on the I2C bus. If you are writing to this register
                                                     and want to perform a read, bits 7:0 (DAT) are ignored
                                                     by the DW_apb_i2c. However, when you read this register,
                                                     these bits return the value of data received on the DW_apb_i2c
                                                     interface.
                                                     
                                                     Reset value: 0x0                                                          */
      __IOM uint32_t CMD        : 1;            /*!< [8..8] This bit controls whether a read or a write is performed.
                                                     This bit does not control the direction when the DW_apb_i2con
                                                     acts as a slave. It controls only the direction when it
                                                     acts as a master.
                                                     
                                                     When a command is entered in the TX FIFO, this bit distinguishes
                                                     the write and read commands. In slave-receiver mode, this
                                                     bit is a 'don't care' because writes to this register are
                                                     not required. In slave-transmitter mode, a '0' indicates
                                                     that the data in IC_DATA_CMD is to be transmitted.
                                                     
                                                                                                                               */
      __IOM uint32_t STOP       : 1;            /*!< [9..9] This bit controls whether a STOP is issued after the
                                                     byte is sent or received.
                                                     
                                                     - 1 - STOP is issued after this byte, regardless of whether
                                                     or not the Tx FIFO is empty. If the Tx FIFO is not empty,
                                                     the master immediately tries to start a new transfer by
                                                     issuing a START and arbitrating for the bus. - 0 - STOP
                                                     is not issued after this byte, regardless of whether or
                                                     not the Tx FIFO is empty. If the Tx FIFO is not empty,
                                                     the master continues the current transfer by sending/receiving
                                                     data                                                                      */
      __IOM uint32_t RESTART    : 1;            /*!< [10..10] This bit controls whether a RESTART is issued before
                                                     the byte is sent or received.
                                                     
                                                     1 - If IC_RESTART_EN is 1, a RESTART is issued before the
                                                     data is sent/received (according to the value of CMD),
                                                     regardless of whether or not the transfer direction is
                                                     changing from the previous command; if IC_RESTART_EN is
                                                     0, a STOP followed by a START is issued instead.
                                                     
                                                     0 - If IC_RESTART_EN is 1, a RESTART is issued only if
                                                     the transfer direction is changing from the previous com                  */
      __IM  uint32_t FIRST_DATA_BYTE : 1;       /*!< [11..11] Indicates the first data byte received after the address
                                                     phase for receive transfer in Master receiver or Slave
                                                     receiver mode.
                                                     
                                                     Reset value : 0x0
                                                     
                                                     NOTE: In case of APB_DATA_WIDTH=8,
                                                     
                                                     1. The user has to perform two APB Reads to IC_DATA_CMD
                                                     in order to get status on 11 bit.
                                                     
                                                     2. In order to read the 11 bit, the user has to perform
                                                     the first data byte read [7:0] (offset 0x10) and then perform
                                                     the second read [15:8] (offset 0x11)                                      */
            uint32_t            : 20;
    } bit;
  } IC_DATA_CMD;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000014) Standard Speed I2C Clock SCL High Count Register           */
    
    struct {
      __IOM uint32_t IC_SS_SCL_HCNT : 16;       /*!< [15..0] This register must be set before any I2C bus transaction
                                                     can take place to ensure proper I/O timing. This register
                                                     sets the SCL clock high-period count for standard speed.
                                                     For more information, refer to 'IC_CLK Frequency Configuration'.
                                                     
                                                     This register can be written only when the I2C interface
                                                     is disabled which corresponds to the IC_ENABLE[0] register
                                                     being set to 0. Writes at other times have no effect.
                                                     
                                                     The minimum valid value is 6; hardware prevents values
                                                     less                                                                      */
            uint32_t            : 16;
    } bit;
  } IC_SS_SCL_HCNT;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000018) Standard Speed I2C Clock SCL Low Count Register            */
    
    struct {
      __IOM uint32_t IC_SS_SCL_LCNT : 16;       /*!< [15..0] This register must be set before any I2C bus transaction
                                                     can take place to ensure proper I/O timing. This register
                                                     sets the SCL clock low period count for standard speed.
                                                     For more information, refer to 'IC_CLK Frequency Configuration'
                                                     
                                                     This register can be written only when the I2C interface
                                                     is disabled which corresponds to the IC_ENABLE[0] register
                                                     being set to 0. Writes at other times have no effect.
                                                     
                                                     The minimum valid value is 8; hardware prevents values
                                                     less th                                                                   */
            uint32_t            : 16;
    } bit;
  } IC_SS_SCL_LCNT;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000001C) Fast Mode or Fast Mode Plus I2C Clock SCL High
                                                                    Count Register                                             */
    
    struct {
      __IOM uint32_t IC_FS_SCL_HCNT : 16;       /*!< [15..0] This register must be set before any I2C bus transaction
                                                     can take place to ensure proper I/O timing. This register
                                                     sets the SCL clock high-period count for fast mode or fast
                                                     mode plus. It is used in high-speed mode to send the Master
                                                     Code and START BYTE or General CALL. For more information,
                                                     refer to 'IC_CLK Frequency Configuration'.
                                                     
                                                     This register goes away and becomes read-only returning
                                                     0s if IC_MAX_SPEED_MODE = standard. This register can be
                                                     written only when the I2C interface is                                    */
            uint32_t            : 16;
    } bit;
  } IC_FS_SCL_HCNT;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000020) Fast Mode or Fast Mode Plus I2C Clock SCL Low
                                                                    Count Register                                             */
    
    struct {
      __IOM uint32_t IC_FS_SCL_LCNT : 16;       /*!< [15..0] This register must be set before any I2C bus transaction
                                                     can take place to ensure proper I/O timing. This register
                                                     sets the SCL clock low period count for fast speed. It
                                                     is used in high-speed mode to send the Master Code and
                                                     START BYTE or General CALL. For more information, refer
                                                     to 'IC_CLK Frequency Configuration'.
                                                     
                                                     This register goes away and becomes read-only returning
                                                     0s if IC_MAX_SPEED_MODE = standard.
                                                     
                                                     This register can be written only when the I2C interface
                                                                                                                               */
            uint32_t            : 16;
    } bit;
  } IC_FS_SCL_LCNT;
  __IM  uint32_t  RESERVED1[2];
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000002C) I2C Interrupt Status Register
                                                                    
                                                                    Each bit in this register has a corresponding
                                                                    mask bit in the IC_INTR_MASK register. These
                                                                    bits are cleared by reading the matching
                                                                    interrupt clear register. The unmasked raw
                                                                    versions of these bits are available in
                                                                    the IC_RAW_INTR_STAT register.                             */
    
    struct {
      __IM  uint32_t R_RX_UNDER : 1;            /*!< [0..0] See IC_RAW_INTR_STAT for a detailed description of R_RX_UNDER
                                                     bit.
                                                     
                                                     Reset value: 0x0                                                          */
      __IM  uint32_t R_RX_OVER  : 1;            /*!< [1..1] See IC_RAW_INTR_STAT for a detailed description of R_RX_OVER
                                                     bit.
                                                     
                                                     Reset value: 0x0                                                          */
      __IM  uint32_t R_RX_FULL  : 1;            /*!< [2..2] See IC_RAW_INTR_STAT for a detailed description of R_RX_FULL
                                                     bit.
                                                     
                                                     Reset value: 0x0                                                          */
      __IM  uint32_t R_TX_OVER  : 1;            /*!< [3..3] See IC_RAW_INTR_STAT for a detailed description of R_TX_OVER
                                                     bit.
                                                     
                                                     Reset value: 0x0                                                          */
      __IM  uint32_t R_TX_EMPTY : 1;            /*!< [4..4] See IC_RAW_INTR_STAT for a detailed description of R_TX_EMPTY
                                                     bit.
                                                     
                                                     Reset value: 0x0                                                          */
      __IM  uint32_t R_RD_REQ   : 1;            /*!< [5..5] See IC_RAW_INTR_STAT for a detailed description of R_RD_REQ
                                                     bit.
                                                     
                                                     Reset value: 0x0                                                          */
      __IM  uint32_t R_TX_ABRT  : 1;            /*!< [6..6] See IC_RAW_INTR_STAT for a detailed description of R_TX_ABRT
                                                     bit.
                                                     
                                                     Reset value: 0x0                                                          */
      __IM  uint32_t R_RX_DONE  : 1;            /*!< [7..7] See IC_RAW_INTR_STAT for a detailed description of R_RX_DONE
                                                     bit.
                                                     
                                                     Reset value: 0x0                                                          */
      __IM  uint32_t R_ACTIVITY : 1;            /*!< [8..8] See IC_RAW_INTR_STAT for a detailed description of R_ACTIVITY
                                                     bit.
                                                     
                                                     Reset value: 0x0                                                          */
      __IM  uint32_t R_STOP_DET : 1;            /*!< [9..9] See IC_RAW_INTR_STAT for a detailed description of R_STOP_DET
                                                     bit.
                                                     
                                                     Reset value: 0x0                                                          */
      __IM  uint32_t R_START_DET : 1;           /*!< [10..10] See IC_RAW_INTR_STAT for a detailed description of
                                                     R_START_DET bit.
                                                     
                                                     Reset value: 0x0                                                          */
      __IM  uint32_t R_GEN_CALL : 1;            /*!< [11..11] See IC_RAW_INTR_STAT for a detailed description of
                                                     R_GEN_CALL bit.
                                                     
                                                     Reset value: 0x0                                                          */
      __IM  uint32_t R_RESTART_DET : 1;         /*!< [12..12] See IC_RAW_INTR_STAT for a detailed description of
                                                     R_RESTART_DET bit.
                                                     
                                                     Reset value: 0x0                                                          */
      __IM  uint32_t R_MASTER_ON_HOLD : 1;      /*!< [13..13] See IC_RAW_INTR_STAT for a detailed description of
                                                     R_MASTER_ON_HOLD bit.
                                                     
                                                     Reset value: 0x0                                                          */
            uint32_t            : 18;
    } bit;
  } IC_INTR_STAT;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000030) I2C Interrupt Mask Register.
                                                                    
                                                                    These bits mask their corresponding interrupt
                                                                    status bits. This register is active low;
                                                                    a value of 0 masks the interrupt, whereas
                                                                    a value of 1 unmasks the interrupt.                        */
    
    struct {
      __IOM uint32_t M_RX_UNDER : 1;            /*!< [0..0] This bit masks the R_RX_UNDER interrupt in IC_INTR_STAT
                                                     register.
                                                     
                                                     Reset value: 0x1                                                          */
      __IOM uint32_t M_RX_OVER  : 1;            /*!< [1..1] This bit masks the R_RX_OVER interrupt in IC_INTR_STAT
                                                     register.
                                                     
                                                     Reset value: 0x1                                                          */
      __IOM uint32_t M_RX_FULL  : 1;            /*!< [2..2] This bit masks the R_RX_FULL interrupt in IC_INTR_STAT
                                                     register.
                                                     
                                                     Reset value: 0x1                                                          */
      __IOM uint32_t M_TX_OVER  : 1;            /*!< [3..3] This bit masks the R_TX_OVER interrupt in IC_INTR_STAT
                                                     register.
                                                     
                                                     Reset value: 0x1                                                          */
      __IOM uint32_t M_TX_EMPTY : 1;            /*!< [4..4] This bit masks the R_TX_EMPTY interrupt in IC_INTR_STAT
                                                     register.
                                                     
                                                     Reset value: 0x1                                                          */
      __IOM uint32_t M_RD_REQ   : 1;            /*!< [5..5] This bit masks the R_RD_REQ interrupt in IC_INTR_STAT
                                                     register.
                                                     
                                                     Reset value: 0x1                                                          */
      __IOM uint32_t M_TX_ABRT  : 1;            /*!< [6..6] This bit masks the R_TX_ABRT interrupt in IC_INTR_STAT
                                                     register.
                                                     
                                                     Reset value: 0x1                                                          */
      __IOM uint32_t M_RX_DONE  : 1;            /*!< [7..7] This bit masks the R_RX_DONE interrupt in IC_INTR_STAT
                                                     register.
                                                     
                                                     Reset value: 0x1                                                          */
      __IOM uint32_t M_ACTIVITY : 1;            /*!< [8..8] This bit masks the R_ACTIVITY interrupt in IC_INTR_STAT
                                                     register.
                                                     
                                                     Reset value: 0x0                                                          */
      __IOM uint32_t M_STOP_DET : 1;            /*!< [9..9] This bit masks the R_STOP_DET interrupt in IC_INTR_STAT
                                                     register.
                                                     
                                                     Reset value: 0x0                                                          */
      __IOM uint32_t M_START_DET : 1;           /*!< [10..10] This bit masks the R_START_DET interrupt in IC_INTR_STAT
                                                     register.
                                                     
                                                     Reset value: 0x0                                                          */
      __IOM uint32_t M_GEN_CALL : 1;            /*!< [11..11] This bit masks the R_GEN_CALL interrupt in IC_INTR_STAT
                                                     register.
                                                     
                                                     Reset value: 0x1                                                          */
      __IOM uint32_t M_RESTART_DET : 1;         /*!< [12..12] This bit masks the R_RESTART_DET interrupt in IC_INTR_STAT
                                                     register.
                                                     
                                                     Reset value: 0x0                                                          */
      __IM  uint32_t M_MASTER_ON_HOLD_READ_ONLY : 1;/*!< [13..13] This M_MASTER_ON_HOLD_read_only bit masks the R_MASTER_ON_HOLD
                                                     interrupt in IC_INTR_STAT register.
                                                     
                                                     Reset value: 0x0                                                          */
            uint32_t            : 18;
    } bit;
  } IC_INTR_MASK;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000034) I2C Raw Interrupt Status Register
                                                                    
                                                                    Unlike the IC_INTR_STAT register, these
                                                                    bits are not masked so they always show
                                                                    the true status of the DW_apb_i2c.                         */
    
    struct {
      __IM  uint32_t RX_UNDER   : 1;            /*!< [0..0] Set if the processor attempts to read the receive buffer
                                                     when it is empty by reading from the IC_DATA_CMD register.
                                                     If the module is disabled (IC_ENABLE[0]=0), this bit keeps
                                                     its level until the master or slave state machines go into
                                                     idle, and when ic_en goes to 0, this interrupt is cleared.
                                                     
                                                     Reset value: 0x0                                                          */
      __IM  uint32_t RX_OVER    : 1;            /*!< [1..1] Set if the receive buffer is completely filled to IC_RX_BUFFER_DEPTH
                                                     and an additional byte is received from an external I2C
                                                     device. The DW_apb_i2c acknowledges this, but any data
                                                     bytes received after the FIFO is full are lost. If the
                                                     module is disabled (IC_ENABLE[0]=0), this bit keeps its
                                                     level until the master or slave state machines go into
                                                     idle, and when ic_en goes to 0, this interrupt is cleared.
                                                     
                                                     Note: If bit 9 of the IC_CON register (RX_FIFO_FULL_HLD_CTRL)
                                                     is programmed to HIG                                                      */
      __IM  uint32_t RX_FULL    : 1;            /*!< [2..2] Set when the receive buffer reaches or goes above the
                                                     RX_TL threshold in the IC_RX_TL register. It is automatically
                                                     cleared by hardware when buffer level goes below the threshold.
                                                     If the module is disabled (IC_ENABLE[0]=0), the RX FIFO
                                                     is flushed and held in reset; therefore the RX FIFO is
                                                     not full. So this bit is cleared once the IC_ENABLE bit
                                                     0 is programmed with a 0, regardless of the activity that
                                                     continues.
                                                     
                                                     Reset value: 0x0                                                          */
      __IM  uint32_t TX_OVER    : 1;            /*!< [3..3] Set during transmit if the transmit buffer is filled
                                                     to IC_TX_BUFFER_DEPTH and the processor attempts to issue
                                                     another I2C command by writing to the IC_DATA_CMD register.
                                                     When the module is disabled, this bit keeps its level until
                                                     the master or slave state machines go into idle, and when
                                                     ic_en goes to 0, this interrupt is cleared.
                                                     
                                                     Reset value: 0x0                                                          */
      __IM  uint32_t TX_EMPTY   : 1;            /*!< [4..4] The behavior of the TX_EMPTY interrupt status differs
                                                     based on the TX_EMPTY_CTRL selection in the IC_CON register.
                                                     - When TX_EMPTY_CTRL = 0: This bit is set to 1 when the
                                                     transmit buffer is at or below the threshold value set
                                                     in the IC_TX_TL register. - When TX_EMPTY_CTRL = 1: This
                                                     bit is set to 1 when the transmit buffer is at or below
                                                     the threshold value set in the IC_TX_TL register and the
                                                     transmission of the address/data from the internal shift
                                                     register for the most recently popped command is complet                  */
      __IM  uint32_t RD_REQ     : 1;            /*!< [5..5] This bit is set to 1 when DW_apb_i2c is acting as a slave
                                                     and another I2C master is attempting to read data from
                                                     DW_apb_i2c. The DW_apb_i2c holds the I2C bus in a wait
                                                     state (SCL=0) until this interrupt is serviced, which means
                                                     that the slave has been addressed by a remote master that
                                                     is asking for data to be transferred. The processor must
                                                     respond to this interrupt and then write the requested
                                                     data to the IC_DATA_CMD register. This bit is set to 0
                                                     just after the processor reads the IC_CLR_RD_REQ registe                  */
      __IM  uint32_t TX_ABRT    : 1;            /*!< [6..6] This bit indicates if DW_apb_i2c, as an I2C transmitter,
                                                     is unable to complete the intended actions on the contents
                                                     of the transmit FIFO. This situation can occur both as
                                                     an I2C master or an I2C slave, and is referred to as a
                                                     'transmit abort'. When this bit is set to 1, the IC_TX_ABRT_SOURCE
                                                     register indicates the reason why the transmit abort takes
                                                     places.
                                                     
                                                     Note: The DW_apb_i2c flushes/resets/empties the TX_FIFO
                                                     and RX_FIFO whenever there is a transmit abort caused by
                                                     any of the eve                                                            */
      __IM  uint32_t RX_DONE    : 1;            /*!< [7..7] When the DW_apb_i2c is acting as a slave-transmitter,
                                                     this bit is set to 1 if the master does not acknowledge
                                                     a transmitted byte. This occurs on the last byte of the
                                                     transmission, indicating that the transmission is done.
                                                     
                                                     Reset value: 0x0                                                          */
      __IM  uint32_t ACTIVITY   : 1;            /*!< [8..8] This bit captures DW_apb_i2c activity and stays set until
                                                     it is cleared. There are four ways to clear it: - Disabling
                                                     the DW_apb_i2c - Reading the IC_CLR_ACTIVITY register -
                                                     Reading the IC_CLR_INTR register - System reset Once this
                                                     bit is set, it stays set unless one of the four methods
                                                     is used to clear it. Even if the DW_apb_i2c module is idle,
                                                     this bit remains set until cleared, indicating that there
                                                     was activity on the bus.
                                                     
                                                     Reset value: 0x0                                                          */
      __IM  uint32_t STOP_DET   : 1;            /*!< [9..9] Indicates whether a STOP condition has occurred on the
                                                     I2C interface regardless of whether DW_apb_i2c is operating
                                                     in slave or master mode.
                                                     
                                                     In Slave Mode: - If IC_CON[7]=1'b1 (STOP_DET_IFADDRESSED),
                                                     the STOP_DET interrupt will be issued only if slave is
                                                     addressed. Note: During a general call address, this slave
                                                     does not issue a STOP_DET interrupt if STOP_DET_IF_ADDRESSED=1'b1,
                                                     even if the slave responds to the general call address
                                                     by generating ACK. The STOP_DET interrupt is generat                      */
      __IM  uint32_t START_DET  : 1;            /*!< [10..10] Indicates whether a START or RESTART condition has
                                                     occurred on the I2C interface regardless of whether DW_apb_i2c
                                                     is operating in slave or master mode.
                                                     
                                                     Reset value: 0x0                                                          */
      __IM  uint32_t GEN_CALL   : 1;            /*!< [11..11] Set only when a General Call address is received and
                                                     it is acknowledged. It stays set until it is cleared either
                                                     by disabling DW_apb_i2c or when the CPU reads bit 0 of
                                                     the IC_CLR_GEN_CALL register. DW_apb_i2c stores the received
                                                     data in the Rx buffer.
                                                     
                                                     Reset value: 0x0                                                          */
      __IM  uint32_t RESTART_DET : 1;           /*!< [12..12] Indicates whether a RESTART condition has occurred
                                                     on the I2C interface when DW_apb_i2c is operating in Slave
                                                     mode and the slave is being addressed. Enabled only when
                                                     IC_SLV_RESTART_DET_EN=1.
                                                     
                                                     Note: However, in high-speed mode or during a START BYTE
                                                     transfer, the RESTART comes before the address field as
                                                     per the I2C protocol. In this case, the slave is not the
                                                     addressed slave when the RESTART is issued, therefore DW_apb_i2c
                                                     does not generate the RESTART_DET interrupt.
                                                     
                                                                                                                               */
      __IM  uint32_t MASTER_ON_HOLD : 1;        /*!< [13..13] Indicates whether master is holding the bus and TX
                                                     FIFO is empty. Enabled only when I2C_DYNAMIC_TAR_UPDATE=1
                                                     and IC_EMPTYFIFO_HOLD_MASTER_EN=1.
                                                     
                                                     Reset value: 0x0                                                          */
            uint32_t            : 18;
    } bit;
  } IC_RAW_INTR_STAT;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000038) I2C Receive FIFO Threshold Register                        */
    
    struct {
      __IOM uint32_t RX_TL      : 8;            /*!< [7..0] Receive FIFO Threshold Level.
                                                     
                                                     Controls the level of entries (or above) that triggers
                                                     the RX_FULL interrupt (bit 2 in IC_RAW_INTR_STAT register).
                                                     The valid range is 0-255, with the additional restriction
                                                     that hardware does not allow this value to be set to a
                                                     value larger than the depth of the buffer. If an attempt
                                                     is made to do that, the actual value set will be the maximum
                                                     depth of the buffer. A value of 0 sets the threshold for
                                                     1 entry, and a value of 255 sets the threshold for 256
                                                                                                                               */
            uint32_t            : 24;
    } bit;
  } IC_RX_TL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000003C) I2C Transmit FIFO Threshold Register                       */
    
    struct {
      __IOM uint32_t TX_TL      : 8;            /*!< [7..0] Transmit FIFO Threshold Level.
                                                     
                                                     Controls the level of entries (or below) that trigger the
                                                     TX_EMPTY interrupt (bit 4 in IC_RAW_INTR_STAT register).
                                                     The valid range is 0-255, with the additional restriction
                                                     that it may not be set to value larger than the depth of
                                                     the buffer. If an attempt is made to do that, the actual
                                                     value set will be the maximum depth of the buffer. A value
                                                     of 0 sets the threshold for 0 entries, and a value of 255
                                                     sets the threshold for 255 entries.                                       */
            uint32_t            : 24;
    } bit;
  } IC_TX_TL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000040) Clear Combined and Individual Interrupt Register           */
    
    struct {
      __IM  uint32_t CLR_INTR   : 1;            /*!< [0..0] Read this register to clear the combined interrupt, all
                                                     individual interrupts, and the IC_TX_ABRT_SOURCE register.
                                                     This bit does not clear hardware clearable interrupts but
                                                     software clearable interrupts. Refer to Bit 9 of the IC_TX_ABRT_SOURCE
                                                     register for an exception to clearing IC_TX_ABRT_SOURCE.
                                                     
                                                     Reset value: 0x0                                                          */
            uint32_t            : 31;
    } bit;
  } IC_CLR_INTR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000044) Clear RX_UNDER Interrupt Register                          */
    
    struct {
      __IM  uint32_t CLR_RX_UNDER : 1;          /*!< [0..0] Read this register to clear the RX_UNDER interrupt (bit
                                                     0) of the IC_RAW_INTR_STAT register.
                                                     
                                                     Reset value: 0x0                                                          */
            uint32_t            : 31;
    } bit;
  } IC_CLR_RX_UNDER;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000048) Clear RX_OVER Interrupt Register                           */
    
    struct {
      __IM  uint32_t CLR_RX_OVER : 1;           /*!< [0..0] Read this register to clear the RX_OVER interrupt (bit
                                                     1) of the IC_RAW_INTR_STAT register.
                                                     
                                                     Reset value: 0x0                                                          */
            uint32_t            : 31;
    } bit;
  } IC_CLR_RX_OVER;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000004C) Clear TX_OVER Interrupt Register                           */
    
    struct {
      __IM  uint32_t CLR_TX_OVER : 1;           /*!< [0..0] Read this register to clear the TX_OVER interrupt (bit
                                                     3) of the IC_RAW_INTR_STAT register.
                                                     
                                                     Reset value: 0x0                                                          */
            uint32_t            : 31;
    } bit;
  } IC_CLR_TX_OVER;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000050) Clear RD_REQ Interrupt Register                            */
    
    struct {
      __IM  uint32_t CLR_RD_REQ : 1;            /*!< [0..0] Read this register to clear the RD_REQ interrupt (bit
                                                     5) of the IC_RAW_INTR_STAT register.
                                                     
                                                     Reset value: 0x0                                                          */
            uint32_t            : 31;
    } bit;
  } IC_CLR_RD_REQ;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000054) Clear TX_ABRT Interrupt Register                           */
    
    struct {
      __IM  uint32_t CLR_TX_ABRT : 1;           /*!< [0..0] Read this register to clear the TX_ABRT interrupt (bit
                                                     6) of the IC_RAW_INTR_STAT register, and the IC_TX_ABRT_SOURCE
                                                     register. This also releases the TX FIFO from the flushed/reset
                                                     state, allowing more writes to the TX FIFO. Refer to Bit
                                                     9 of the IC_TX_ABRT_SOURCE register for an exception to
                                                     clearing IC_TX_ABRT_SOURCE.
                                                     
                                                     Reset value: 0x0                                                          */
            uint32_t            : 31;
    } bit;
  } IC_CLR_TX_ABRT;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000058) Clear RX_DONE Interrupt Register                           */
    
    struct {
      __IM  uint32_t CLR_RX_DONE : 1;           /*!< [0..0] Read this register to clear the RX_DONE interrupt (bit
                                                     7) of the IC_RAW_INTR_STAT register.
                                                     
                                                     Reset value: 0x0                                                          */
            uint32_t            : 31;
    } bit;
  } IC_CLR_RX_DONE;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000005C) Clear ACTIVITY Interrupt Register                          */
    
    struct {
      __IM  uint32_t CLR_ACTIVITY : 1;          /*!< [0..0] Reading this register clears the ACTIVITY interrupt if
                                                     the I2C is not active anymore. If the I2C module is still
                                                     active on the bus, the ACTIVITY interrupt bit continues
                                                     to be set. It is automatically cleared by hardware if the
                                                     module is disabled and if there is no further activity
                                                     on the bus. The value read from this register to get status
                                                     of the ACTIVITY interrupt (bit 8) of the IC_RAW_INTR_STAT
                                                     register.
                                                     
                                                     Reset value: 0x0                                                          */
            uint32_t            : 31;
    } bit;
  } IC_CLR_ACTIVITY;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000060) Clear STOP_DET Interrupt Register                          */
    
    struct {
      __IM  uint32_t CLR_STOP_DET : 1;          /*!< [0..0] Read this register to clear the STOP_DET interrupt (bit
                                                     9) of the IC_RAW_INTR_STAT register.
                                                     
                                                     Reset value: 0x0                                                          */
            uint32_t            : 31;
    } bit;
  } IC_CLR_STOP_DET;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000064) Clear START_DET Interrupt Register                         */
    
    struct {
      __IM  uint32_t CLR_START_DET : 1;         /*!< [0..0] Read this register to clear the START_DET interrupt (bit
                                                     10) of the IC_RAW_INTR_STAT register.
                                                     
                                                     Reset value: 0x0                                                          */
            uint32_t            : 31;
    } bit;
  } IC_CLR_START_DET;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000068) Clear GEN_CALL Interrupt Register                          */
    
    struct {
      __IM  uint32_t CLR_GEN_CALL : 1;          /*!< [0..0] Read this register to clear the GEN_CALL interrupt (bit
                                                     11) of IC_RAW_INTR_STAT register.
                                                     
                                                     Reset value: 0x0                                                          */
            uint32_t            : 31;
    } bit;
  } IC_CLR_GEN_CALL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000006C) I2C Enable Register                                        */
    
    struct {
      __IOM uint32_t ENABLE     : 1;            /*!< [0..0] Controls whether the DW_apb_i2c is enabled. - 0: Disables
                                                     DW_apb_i2c (TX and RX FIFOs are held in an erased state)
                                                     - 1: Enables DW_apb_i2c Software can disable DW_apb_i2c
                                                     while it is active. However, it is important that care
                                                     be taken to ensure that DW_apb_i2c is disabled properly.
                                                     A recommended procedure is described in 'Disabling DW_apb_i2c'.
                                                     
                                                     When DW_apb_i2c is disabled, the following occurs: - The
                                                     TX FIFO and RX FIFO get flushed. - Status bits in the IC_INTR_STAT
                                                     register are stil                                                         */
      __IOM uint32_t ABORT      : 1;            /*!< [1..1] When set, the controller initiates the transfer abort.
                                                     - 0: ABORT not initiated or ABORT done - 1: ABORT operation
                                                     in progress The software can abort the I2C transfer in
                                                     master mode by setting this bit. The software can set this
                                                     bit only when ENABLE is already set; otherwise, the controller
                                                     ignores any write to ABORT bit. The software cannot clear
                                                     the ABORT bit once set. In response to an ABORT, the controller
                                                     issues a STOP and flushes the Tx FIFO after completing
                                                     the current transfer, then sets the TX_A                                  */
      __IOM uint32_t TX_CMD_BLOCK : 1;          /*!< [2..2] In Master mode: - 1'b1: Blocks the transmission of data
                                                     on I2C bus even if Tx FIFO has data to transmit. - 1'b0:
                                                     The transmission of data starts on I2C bus automatically,
                                                     as soon as the first data is available in the Tx FIFO.
                                                     Note: To block the execution of Master commands, set the
                                                     TX_CMD_BLOCK bit only when Tx FIFO is empty (IC_STATUS[2]==1)
                                                     and Master is in Idle state (IC_STATUS[5] == 0). Any further
                                                     commands put in the Tx FIFO are not executed until TX_CMD_BLOCK
                                                     bit is unset. Reset value: IC_TX_CMD_B                                    */
            uint32_t            : 29;
    } bit;
  } IC_ENABLE;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000070) I2C Status Register
                                                                    
                                                                    This is a read-only register used to indicate
                                                                    the current transfer status and FIFO status.
                                                                    The status register may be read at any time.
                                                                    None of the bits in this register request
                                                                    an interrupt.
                                                                    
                                                                    When the I2C is disabled by writing 0 in
                                                                    bit 0 of the IC_ENABLE register: - Bits
                                                                    1 and 2 are set to 1 - Bits 3 and 10 are
                                                                    set to 0 When the master or slave state
                                                                    machines goes to idle and ic_en=0: - Bits
                                                                    5 and 6 are set to 0                                       */
    
    struct {
      __IM  uint32_t ACTIVITY   : 1;            /*!< [0..0] I2C Activity Status. Reset value: 0x0                              */
      __IM  uint32_t TFNF       : 1;            /*!< [1..1] Transmit FIFO Not Full. Set when the transmit FIFO contains
                                                     one or more empty locations, and is cleared when the FIFO
                                                     is full. - 0: Transmit FIFO is full - 1: Transmit FIFO
                                                     is not full Reset value: 0x1                                              */
      __IM  uint32_t TFE        : 1;            /*!< [2..2] Transmit FIFO Completely Empty. When the transmit FIFO
                                                     is completely empty, this bit is set. When it contains
                                                     one or more valid entries, this bit is cleared. This bit
                                                     field does not request an interrupt. - 0: Transmit FIFO
                                                     is not empty - 1: Transmit FIFO is empty Reset value: 0x1                 */
      __IM  uint32_t RFNE       : 1;            /*!< [3..3] Receive FIFO Not Empty. This bit is set when the receive
                                                     FIFO contains one or more entries; it is cleared when the
                                                     receive FIFO is empty. - 0: Receive FIFO is empty - 1:
                                                     Receive FIFO is not empty Reset value: 0x0                                */
      __IM  uint32_t RFF        : 1;            /*!< [4..4] Receive FIFO Completely Full. When the receive FIFO is
                                                     completely full, this bit is set. When the receive FIFO
                                                     contains one or more empty location, this bit is cleared.
                                                     - 0: Receive FIFO is not full - 1: Receive FIFO is full
                                                     Reset value: 0x0                                                          */
      __IM  uint32_t MST_ACTIVITY : 1;          /*!< [5..5] Master FSM Activity Status. When the Master Finite State
                                                     Machine (FSM) is not in the IDLE state, this bit is set.
                                                     - 0: Master FSM is in IDLE state so the Master part of
                                                     DW_apb_i2c is not Active - 1: Master FSM is not in IDLE
                                                     state so the Master part of DW_apb_i2c is Active Note:
                                                     IC_STATUS[0]-that is, ACTIVITY bit-is the OR of SLV_ACTIVITY
                                                     and MST_ACTIVITY bits.
                                                     
                                                     Reset value: 0x0                                                          */
      __IM  uint32_t SLV_ACTIVITY : 1;          /*!< [6..6] Slave FSM Activity Status. When the Slave Finite State
                                                     Machine (FSM) is not in the IDLE state, this bit is set.
                                                     - 0: Slave FSM is in IDLE state so the Slave part of DW_apb_i2c
                                                     is not Active - 1: Slave FSM is not in IDLE state so the
                                                     Slave part of DW_apb_i2c is Active Reset value: 0x0                       */
            uint32_t            : 25;
    } bit;
  } IC_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000074) I2C Transmit FIFO Level Register This register
                                                                    contains the number of valid data entries
                                                                    in the transmit FIFO buffer. It is cleared
                                                                    whenever: - The I2C is disabled - There
                                                                    is a transmit abort - that is, TX_ABRT bit
                                                                    is set in the IC_RAW_INTR_STAT register
                                                                    - The slave bulk transmit mode is aborted
                                                                    The register increments whenever data is
                                                                    placed into the transmit FIFO and decrements
                                                                    when data is taken from the transmit FIFO.                 */
    
    struct {
      __IM  uint32_t TXFLR      : 5;            /*!< [4..0] Transmit FIFO Level. Contains the number of valid data
                                                     entries in the transmit FIFO.
                                                     
                                                     Reset value: 0x0                                                          */
            uint32_t            : 27;
    } bit;
  } IC_TXFLR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000078) I2C Receive FIFO Level Register This register
                                                                    contains the number of valid data entries
                                                                    in the receive FIFO buffer. It is cleared
                                                                    whenever: - The I2C is disabled - Whenever
                                                                    there is a transmit abort caused by any
                                                                    of the events tracked in IC_TX_ABRT_SOURCE
                                                                    The register increments whenever data is
                                                                    placed into the receive FIFO and decrements
                                                                    when data is taken from the receive FIFO.                  */
    
    struct {
      __IM  uint32_t RXFLR      : 5;            /*!< [4..0] Receive FIFO Level. Contains the number of valid data
                                                     entries in the receive FIFO.
                                                     
                                                     Reset value: 0x0                                                          */
            uint32_t            : 27;
    } bit;
  } IC_RXFLR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000007C) I2C SDA Hold Time Length Register
                                                                    
                                                                    The bits [15:0] of this register are used
                                                                    to control the hold time of SDA during transmit
                                                                    in both slave and master mode (after SCL
                                                                    goes from HIGH to LOW).
                                                                    
                                                                    The bits [23:16] of this register are used
                                                                    to extend the SDA transition (if any) whenever
                                                                    SCL is HIGH in the receiver in either master
                                                                    or slave mode.
                                                                    
                                                                    Writes to this register succeed only when
                                                                    IC_ENABLE[0]=0.
                                                                    
                                                                    The values in this register a                              */
    
    struct {
      __IOM uint32_t IC_SDA_TX_HOLD : 16;       /*!< [15..0] Sets the required SDA hold time in units of ic_clk period,
                                                     when DW_apb_i2c acts as a transmitter.
                                                     
                                                     Reset value: IC_DEFAULT_SDA_HOLD[15:0].                                   */
      __IOM uint32_t IC_SDA_RX_HOLD : 8;        /*!< [23..16] Sets the required SDA hold time in units of ic_clk
                                                     period, when DW_apb_i2c acts as a receiver.
                                                     
                                                     Reset value: IC_DEFAULT_SDA_HOLD[23:16].                                  */
            uint32_t            : 8;
    } bit;
  } IC_SDA_HOLD;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000080) I2C Transmit Abort Source Register
                                                                    
                                                                    This register has 32 bits that indicate
                                                                    the source of the TX_ABRT bit. Except for
                                                                    Bit 9, this register is cleared whenever
                                                                    the IC_CLR_TX_ABRT register or the IC_CLR_INTR
                                                                    register is read. To clear Bit 9, the source
                                                                    of the ABRT_SBYTE_NORSTRT must be fixed
                                                                    first; RESTART must be enabled (IC_CON[5]=1),
                                                                    the SPECIAL bit must be cleared (IC_TAR[11]),
                                                                    or the GC_OR_START bit must be cleared (IC_TAR[10]).
                                                                    
                                                                    Once the source of the AB                                  */
    
    struct {
      __IM  uint32_t ABRT_7B_ADDR_NOACK : 1;    /*!< [0..0] This field indicates that the Master is in 7-bit addressing
                                                     mode and the address sent was not acknowledged by any slave.
                                                     
                                                     Reset value: 0x0
                                                     
                                                     Role of DW_apb_i2c: Master-Transmitter or Master-Receiver                 */
      __IM  uint32_t ABRT_10ADDR1_NOACK : 1;    /*!< [1..1] This field indicates that the Master is in 10-bit address
                                                     mode and the first 10-bit address byte was not acknowledged
                                                     by any slave.
                                                     
                                                     Reset value: 0x0
                                                     
                                                     Role of DW_apb_i2c: Master-Transmitter or Master-Receiver                 */
      __IM  uint32_t ABRT_10ADDR2_NOACK : 1;    /*!< [2..2] This field indicates that the Master is in 10-bit address
                                                     mode and that the second address byte of the 10-bit address
                                                     was not acknowledged by any slave.
                                                     
                                                     Reset value: 0x0
                                                     
                                                     Role of DW_apb_i2c: Master-Transmitter or Master-Receiver                 */
      __IM  uint32_t ABRT_TXDATA_NOACK : 1;     /*!< [3..3] This field indicates the master-mode only bit. When the
                                                     master receives an acknowledgement for the address, but
                                                     when it sends data byte(s) following the address, it did
                                                     not receive an acknowledge from the remote slave(s).
                                                     
                                                     Reset value: 0x0
                                                     
                                                     Role of DW_apb_i2c: Master-Transmitter                                    */
      __IM  uint32_t ABRT_GCALL_NOACK : 1;      /*!< [4..4] This field indicates that DW_apb_i2c in master mode has
                                                     sent a General Call and no slave on the bus acknowledged
                                                     the General Call.
                                                     
                                                     Reset value: 0x0
                                                     
                                                     Role of DW_apb_i2c: Master-Transmitter                                    */
      __IM  uint32_t ABRT_GCALL_READ : 1;       /*!< [5..5] This field indicates that DW_apb_i2c in the master mode
                                                     has sent a General Call but the user programmed the byte
                                                     following the General Call to be a read from the bus (IC_DATA_CMD[9]
                                                     is set to 1).
                                                     
                                                     Reset value: 0x0
                                                     
                                                     Role of DW_apb_i2c: Master-Transmitter                                    */
      __IM  uint32_t ABRT_HS_ACKDET : 1;        /*!< [6..6] This field indicates that the Master is in High Speed
                                                     mode and the High Speed Master code was acknowledged (wrong
                                                     behavior).
                                                     
                                                     Reset value: 0x0
                                                     
                                                     Role of DW_apb_i2c: Master                                                */
      __IM  uint32_t ABRT_SBYTE_ACKDET : 1;     /*!< [7..7] This field indicates that the Master has sent a START
                                                     Byte and the START Byte was acknowledged (wrong behavior).
                                                     
                                                     Reset value: 0x0
                                                     
                                                     Role of DW_apb_i2c: Master                                                */
      __IM  uint32_t ABRT_HS_NORSTRT : 1;       /*!< [8..8] This field indicates that the restart is disabled (IC_RESTART_EN
                                                     bit (IC_CON[5]) =0) and the user is trying to use the master
                                                     to transfer data in High Speed mode.
                                                     
                                                     Reset value: 0x0
                                                     
                                                     Role of DW_apb_i2c: Master-Transmitter or Master-Receiver                 */
      __IM  uint32_t ABRT_SBYTE_NORSTRT : 1;    /*!< [9..9] To clear Bit 9, the source of the ABRT_SBYTE_NORSTRT
                                                     must be fixed first; restart must be enabled (IC_CON[5]=1),
                                                     the SPECIAL bit must be cleared (IC_TAR[11]), or the GC_OR_START
                                                     bit must be cleared (IC_TAR[10]). Once the source of the
                                                     ABRT_SBYTE_NORSTRT is fixed, then this bit can be cleared
                                                     in the same manner as other bits in this register. If the
                                                     source of the ABRT_SBYTE_NORSTRT is not fixed before attempting
                                                     to clear this bit, bit 9 clears for one cycle and then
                                                     gets reasserted. When this field is set                                   */
      __IM  uint32_t ABRT_10B_RD_NORSTRT : 1;   /*!< [10..10] This field indicates that the restart is disabled (IC_RESTART_EN
                                                     bit (IC_CON[5]) =0) and the master sends a read command
                                                     in 10-bit addressing mode.
                                                     
                                                     Reset value: 0x0
                                                     
                                                     Role of DW_apb_i2c: Master-Receiver                                       */
      __IM  uint32_t ABRT_MASTER_DIS : 1;       /*!< [11..11] This field indicates that the User tries to initiate
                                                     a Master operation with the Master mode disabled.
                                                     
                                                     Reset value: 0x0
                                                     
                                                     Role of DW_apb_i2c: Master-Transmitter or Master-Receiver                 */
      __IM  uint32_t ARB_LOST   : 1;            /*!< [12..12] This field specifies that the Master has lost arbitration,
                                                     or if IC_TX_ABRT_SOURCE[14] is also set, then the slave
                                                     transmitter has lost arbitration.
                                                     
                                                     Reset value: 0x0
                                                     
                                                     Role of DW_apb_i2c: Master-Transmitter or Slave-Transmitter               */
      __IM  uint32_t ABRT_SLVFLUSH_TXFIFO : 1;  /*!< [13..13] This field specifies that the Slave has received a
                                                     read command and some data exists in the TX FIFO, so the
                                                     slave issues a TX_ABRT interrupt to flush old data in TX
                                                     FIFO.
                                                     
                                                     Reset value: 0x0
                                                     
                                                     Role of DW_apb_i2c: Slave-Transmitter                                     */
      __IM  uint32_t ABRT_SLV_ARBLOST : 1;      /*!< [14..14] This field indicates that a Slave has lost the bus
                                                     while transmitting data to a remote master. IC_TX_ABRT_SOURCE[12]
                                                     is set at the same time. Note: Even though the slave never
                                                     'owns' the bus, something could go wrong on the bus. This
                                                     is a fail safe check. For instance, during a data transmission
                                                     at the low-to-high transition of SCL, if what is on the
                                                     data bus is not what is supposed to be transmitted, then
                                                     DW_apb_i2c no longer own the bus.
                                                     
                                                     Reset value: 0x0
                                                     
                                                     Role                                                                      */
      __IM  uint32_t ABRT_SLVRD_INTX : 1;       /*!< [15..15] 1: When the processor side responds to a slave mode
                                                     request for data to be transmitted to a remote master and
                                                     user writes a 1 in CMD (bit 8) of IC_DATA_CMD register.
                                                     
                                                     Reset value: 0x0
                                                     
                                                     Role of DW_apb_i2c: Slave-Transmitter                                     */
      __IM  uint32_t ABRT_USER_ABRT : 1;        /*!< [16..16] This is a master-mode-only bit. Master has detected
                                                     the transfer abort (IC_ENABLE[1])
                                                     
                                                     Reset value: 0x0
                                                     
                                                     Role of DW_apb_i2c: Master-Transmitter                                    */
            uint32_t            : 6;
      __IM  uint32_t TX_FLUSH_CNT : 9;          /*!< [31..23] This field indicates the number of Tx FIFO Data Commands
                                                     which are flushed due to TX_ABRT interrupt. It is cleared
                                                     whenever I2C is disabled.
                                                     
                                                     Reset value: 0x0
                                                     
                                                     Role of DW_apb_i2c: Master-Transmitter or Slave-Transmitter               */
    } bit;
  } IC_TX_ABRT_SOURCE;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000084) Generate Slave Data NACK Register
                                                                    
                                                                    The register is used to generate a NACK
                                                                    for the data part of a transfer when DW_apb_i2c
                                                                    is acting as a slave-receiver. This register
                                                                    only exists when the IC_SLV_DATA_NACK_ONLY
                                                                    parameter is set to 1. When this parameter
                                                                    disabled, this register does not exist and
                                                                    writing to the register's address has no
                                                                    effect.
                                                                    
                                                                    A write can occur on this register if both
                                                                    of the following conditions are met: - DW_apb_i2c
                                                                    is disabled (IC_ENABLE                                     */
    
    struct {
      __IOM uint32_t NACK       : 1;            /*!< [0..0] Generate NACK. This NACK generation only occurs when
                                                     DW_apb_i2c is a slave-receiver. If this register is set
                                                     to a value of 1, it can only generate a NACK after a data
                                                     byte is received; hence, the data transfer is aborted and
                                                     the data received is not pushed to the receive buffer.
                                                     
                                                     When the register is set to a value of 0, it generates
                                                     NACK/ACK, depending on normal criteria. - 1: generate NACK
                                                     after data byte received - 0: generate NACK/ACK normally
                                                     Reset value: 0x0                                                          */
            uint32_t            : 31;
    } bit;
  } IC_SLV_DATA_NACK_ONLY;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000088) DMA Control Register
                                                                    
                                                                    The register is used to enable the DMA Controller
                                                                    interface operation. There is a separate
                                                                    bit for transmit and receive. This can be
                                                                    programmed regardless of the state of IC_ENABLE.           */
    
    struct {
      __IOM uint32_t RDMAE      : 1;            /*!< [0..0] Receive DMA Enable. This bit enables/disables the receive
                                                     FIFO DMA channel. Reset value: 0x0                                        */
      __IOM uint32_t TDMAE      : 1;            /*!< [1..1] Transmit DMA Enable. This bit enables/disables the transmit
                                                     FIFO DMA channel. Reset value: 0x0                                        */
            uint32_t            : 30;
    } bit;
  } IC_DMA_CR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000008C) DMA Transmit Data Level Register                           */
    
    struct {
      __IOM uint32_t DMATDL     : 4;            /*!< [3..0] Transmit Data Level. This bit field controls the level
                                                     at which a DMA request is made by the transmit logic. It
                                                     is equal to the watermark level; that is, the dma_tx_req
                                                     signal is generated when the number of valid data entries
                                                     in the transmit FIFO is equal to or below this field value,
                                                     and TDMAE = 1.
                                                     
                                                     Reset value: 0x0                                                          */
            uint32_t            : 28;
    } bit;
  } IC_DMA_TDLR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000090) I2C Receive Data Level Register                            */
    
    struct {
      __IOM uint32_t DMARDL     : 4;            /*!< [3..0] Receive Data Level. This bit field controls the level
                                                     at which a DMA request is made by the receive logic. The
                                                     watermark level = DMARDL+1; that is, dma_rx_req is generated
                                                     when the number of valid data entries in the receive FIFO
                                                     is equal to or more than this field value + 1, and RDMAE
                                                     =1. For instance, when DMARDL is 0, then dma_rx_req is
                                                     asserted when 1 or more data entries are present in the
                                                     receive FIFO.
                                                     
                                                     Reset value: 0x0                                                          */
            uint32_t            : 28;
    } bit;
  } IC_DMA_RDLR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000094) I2C SDA Setup Register
                                                                    
                                                                    This register controls the amount of time
                                                                    delay (in terms of number of ic_clk clock
                                                                    periods) introduced in the rising edge of
                                                                    SCL - relative to SDA changing - when DW_apb_i2c
                                                                    services a read request in a slave-transmitter
                                                                    operation. The relevant I2C requirement
                                                                    is tSU:DAT (note 4) as detailed in the I2C
                                                                    Bus Specification. This register must be
                                                                    programmed with a value equal to or greater
                                                                    than 2.
                                                                    
                                                                    Writes to this register succeed only wh                    */
    
    struct {
      __IOM uint32_t SDA_SETUP  : 8;            /*!< [7..0] SDA Setup. It is recommended that if the required delay
                                                     is 1000ns, then for an ic_clk frequency of 10 MHz, IC_SDA_SETUP
                                                     should be programmed to a value of 11. IC_SDA_SETUP must
                                                     be programmed with a minimum value of 2.                                  */
            uint32_t            : 24;
    } bit;
  } IC_SDA_SETUP;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000098) I2C ACK General Call Register
                                                                    
                                                                    The register controls whether DW_apb_i2c
                                                                    responds with a ACK or NACK when it receives
                                                                    an I2C General Call address.
                                                                    
                                                                    This register is applicable only when the
                                                                    DW_apb_i2c is in slave mode.                               */
    
    struct {
      __IOM uint32_t ACK_GEN_CALL : 1;          /*!< [0..0] ACK General Call. When set to 1, DW_apb_i2c responds
                                                     with a ACK (by asserting ic_data_oe) when it receives a
                                                     General Call. Otherwise, DW_apb_i2c responds with a NACK
                                                     (by negating ic_data_oe).                                                 */
            uint32_t            : 31;
    } bit;
  } IC_ACK_GENERAL_CALL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000009C) I2C Enable Status Register
                                                                    
                                                                    The register is used to report the DW_apb_i2c
                                                                    hardware status when the IC_ENABLE[0] register
                                                                    is set from 1 to 0; that is, when DW_apb_i2c
                                                                    is disabled.
                                                                    
                                                                    If IC_ENABLE[0] has been set to 1, bits
                                                                    2:1 are forced to 0, and bit 0 is forced
                                                                    to 1.
                                                                    
                                                                    If IC_ENABLE[0] has been set to 0, bits
                                                                    2:1 is only be valid as soon as bit 0 is
                                                                    read as '0'.
                                                                    
                                                                    Note: When IC_ENABLE[0] has been set to
                                                                    0, a delay occurs for bit 0                                */
    
    struct {
      __IM  uint32_t IC_EN      : 1;            /*!< [0..0] ic_en Status. This bit always reflects the value driven
                                                     on the output port ic_en. - When read as 1, DW_apb_i2c
                                                     is deemed to be in an enabled state. - When read as 0,
                                                     DW_apb_i2c is deemed completely inactive. Note: The CPU
                                                     can safely read this bit anytime. When this bit is read
                                                     as 0, the CPU can safely read SLV_RX_DATA_LOST (bit 2)
                                                     and SLV_DISABLED_WHILE_BUSY (bit 1).
                                                     
                                                     Reset value: 0x0                                                          */
      __IM  uint32_t SLV_DISABLED_WHILE_BUSY : 1;/*!< [1..1] Slave Disabled While Busy (Transmit, Receive). This bit
                                                     indicates if a potential or active Slave operation has
                                                     been aborted due to the setting bit 0 of the IC_ENABLE
                                                     register from 1 to 0. This bit is set when the CPU writes
                                                     a 0 to the IC_ENABLE register while:
                                                     
                                                     (a) DW_apb_i2c is receiving the address byte of the Slave-Transmitter
                                                     operation from a remote master;
                                                     
                                                     OR,
                                                     
                                                     (b) address and data bytes of the Slave-Receiver operation
                                                     from a remote master                                                      */
      __IM  uint32_t SLV_RX_DATA_LOST : 1;      /*!< [2..2] Slave Received Data Lost. This bit indicates if a Slave-Receiver
                                                     operation has been aborted with at least one data byte
                                                     received from an I2C transfer due to the setting bit 0
                                                     of IC_ENABLE from 1 to 0. When read as 1, DW_apb_i2c is
                                                     deemed to have been actively engaged in an aborted I2C
                                                     transfer (with matching address) and the data phase of
                                                     the I2C transfer has been entered, even though a data byte
                                                     has been responded with a NACK.
                                                     
                                                     Note: If the remote I2C master terminates the transfer
                                                                                                                               */
            uint32_t            : 29;
    } bit;
  } IC_ENABLE_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000A0) I2C SS, FS or FM+ spike suppression limit
                                                                    
                                                                    This register is used to store the duration,
                                                                    measured in ic_clk cycles, of the longest
                                                                    spike that is filtered out by the spike
                                                                    suppression logic when the component is
                                                                    operating in SS, FS or FM+ modes. The relevant
                                                                    I2C requirement is tSP (table 4) as detailed
                                                                    in the I2C Bus Specification. This register
                                                                    must be programmed with a minimum value
                                                                    of 1.                                                      */
    
    struct {
      __IOM uint32_t IC_FS_SPKLEN : 8;          /*!< [7..0] This register must be set before any I2C bus transaction
                                                     can take place to ensure stable operation. This register
                                                     sets the duration, measured in ic_clk cycles, of the longest
                                                     spike in the SCL or SDA lines that will be filtered out
                                                     by the spike suppression logic. This register can be written
                                                     only when the I2C interface is disabled which corresponds
                                                     to the IC_ENABLE[0] register being set to 0. Writes at
                                                     other times have no effect. The minimum valid value is
                                                     1; hardware prevents values less than this being                          */
            uint32_t            : 24;
    } bit;
  } IC_FS_SPKLEN;
  __IM  uint32_t  RESERVED2;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000A8) Clear RESTART_DET Interrupt Register                       */
    
    struct {
      __IM  uint32_t CLR_RESTART_DET : 1;       /*!< [0..0] Read this register to clear the RESTART_DET interrupt
                                                     (bit 12) of IC_RAW_INTR_STAT register.
                                                     
                                                     Reset value: 0x0                                                          */
            uint32_t            : 31;
    } bit;
  } IC_CLR_RESTART_DET;
  __IM  uint32_t  RESERVED3[18];
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000F4) Component Parameter Register 1
                                                                    
                                                                    Note This register is not implemented and
                                                                    therefore reads as 0. If it was implemented
                                                                    it would be a constant read-only register
                                                                    that contains encoded information about
                                                                    the component's parameter settings. Fields
                                                                    shown below are the settings for those parameters          */
    
    struct {
      __IM  uint32_t APB_DATA_WIDTH : 2;        /*!< [1..0] APB data bus width is 32 bits                                      */
      __IM  uint32_t MAX_SPEED_MODE : 2;        /*!< [3..2] MAX SPEED MODE = FAST MODE                                         */
      __IM  uint32_t HC_COUNT_VALUES : 1;       /*!< [4..4] Programmable count values for each mode.                           */
      __IM  uint32_t INTR_IO    : 1;            /*!< [5..5] COMBINED Interrupt outputs                                         */
      __IM  uint32_t HAS_DMA    : 1;            /*!< [6..6] DMA handshaking signals are enabled                                */
      __IM  uint32_t ADD_ENCODED_PARAMS : 1;    /*!< [7..7] Encoded parameters not visible                                     */
      __IM  uint32_t RX_BUFFER_DEPTH : 8;       /*!< [15..8] RX Buffer Depth = 16                                              */
      __IM  uint32_t TX_BUFFER_DEPTH : 8;       /*!< [23..16] TX Buffer Depth = 16                                             */
            uint32_t            : 8;
    } bit;
  } IC_COMP_PARAM_1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000F8) I2C Component Version Register                             */
    
    struct {
      __IM  uint32_t IC_COMP_VERSION : 32;      /*!< [31..0] IC_COMP_VERSION                                                   */
    } bit;
  } IC_COMP_VERSION;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000FC) I2C Component Type Register                                */
    
    struct {
      __IM  uint32_t IC_COMP_TYPE : 32;         /*!< [31..0] Designware Component Type number = 0x44_57_01_40. This
                                                     assigned unique hex value is constant and is derived from
                                                     the two ASCII letters 'DW' followed by a 16-bit unsigned
                                                     number.                                                                   */
    } bit;
  } IC_COMP_TYPE;
} I2C0_Type;                                    /*!< Size = 256 (0x100)                                                        */



/* =========================================================================================================================== */
/* ================                                            ADC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Control and data interface to SAR ADC (ADC)
  */

typedef struct {                                /*!< (@ 0x4004C000) ADC Structure                                              */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000000) ADC Control and Status                                     */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Power on ADC and enable its clock.
                                                     1 - enabled. 0 - disabled.                                                */
      __IOM uint32_t TS_EN      : 1;            /*!< [1..1] Power on temperature sensor. 1 - enabled. 0 - disabled.            */
      __IOM uint32_t START_ONCE : 1;            /*!< [2..2] Start a single conversion. Self-clearing. Ignored if
                                                     start_many is asserted.                                                   */
      __IOM uint32_t START_MANY : 1;            /*!< [3..3] Continuously perform conversions whilst this bit is 1.
                                                     A new conversion will start immediately after the previous
                                                     finishes.                                                                 */
            uint32_t            : 4;
      __IM  uint32_t READY      : 1;            /*!< [8..8] 1 if the ADC is ready to start a new conversion. Implies
                                                     any previous conversion has completed.
                                                     0 whilst conversion in progress.                                          */
      __IM  uint32_t ERR        : 1;            /*!< [9..9] The most recent ADC conversion encountered an error;
                                                     result is undefined or noisy.                                             */
      __IOM uint32_t ERR_STICKY : 1;            /*!< [10..10] Some past ADC conversion encountered an error. Write
                                                     1 to clear.                                                               */
            uint32_t            : 1;
      __IOM uint32_t AINSEL     : 3;            /*!< [14..12] Select analog mux input. Updated automatically in round-robin
                                                     mode.                                                                     */
            uint32_t            : 1;
      __IOM uint32_t RROBIN     : 5;            /*!< [20..16] Round-robin sampling. 1 bit per channel. Set all bits
                                                     to 0 to disable.
                                                     Otherwise, the ADC will cycle through each enabled channel
                                                     in a round-robin fashion.
                                                     The first channel to be sampled will be the one currently
                                                     indicated by AINSEL.
                                                     AINSEL will be updated after each conversion with the newly-selected
                                                     channel.                                                                  */
            uint32_t            : 11;
    } bit;
  } CS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000004) Result of most recent ADC conversion                       */
    
    struct {
      __IM  uint32_t RESULT     : 12;           /*!< [11..0] RESULT                                                            */
            uint32_t            : 20;
    } bit;
  } RESULT;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000008) FIFO control and status                                    */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] If 1: write result to the FIFO after each conversion.              */
      __IOM uint32_t SHIFT      : 1;            /*!< [1..1] If 1: FIFO results are right-shifted to be one byte in
                                                     size. Enables DMA to byte buffers.                                        */
      __IOM uint32_t ERR        : 1;            /*!< [2..2] If 1: conversion error bit appears in the FIFO alongside
                                                     the result                                                                */
      __IOM uint32_t DREQ_EN    : 1;            /*!< [3..3] If 1: assert DMA requests when FIFO contains data                  */
            uint32_t            : 4;
      __IM  uint32_t EMPTY      : 1;            /*!< [8..8] EMPTY                                                              */
      __IM  uint32_t FULL       : 1;            /*!< [9..9] FULL                                                               */
      __IOM uint32_t UNDER      : 1;            /*!< [10..10] 1 if the FIFO has been underflowed. Write 1 to clear.            */
      __IOM uint32_t OVER       : 1;            /*!< [11..11] 1 if the FIFO has been overflowed. Write 1 to clear.             */
            uint32_t            : 4;
      __IM  uint32_t LEVEL      : 4;            /*!< [19..16] The number of conversion results currently waiting
                                                     in the FIFO                                                               */
            uint32_t            : 4;
      __IOM uint32_t THRESH     : 4;            /*!< [27..24] DREQ/IRQ asserted when level >= threshold                        */
            uint32_t            : 4;
    } bit;
  } FCS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000000C) Conversion result FIFO                                     */
    
    struct {
      __IM  uint32_t VAL        : 12;           /*!< [11..0] VAL                                                               */
            uint32_t            : 3;
      __IM  uint32_t ERR        : 1;            /*!< [15..15] 1 if this particular sample experienced a conversion
                                                     error. Remains in the same location if the sample is shifted.             */
            uint32_t            : 16;
    } bit;
  } FIFO;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000010) Clock divider. If non-zero, CS_START_MANY will
                                                                    start conversions
                                                                    at regular intervals rather than back-to-back.
                                                                    The divider is reset when either of these
                                                                    fields are written.
                                                                    Total period is 1 + INT + FRAC / 256                       */
    
    struct {
      __IOM uint32_t FRAC       : 8;            /*!< [7..0] Fractional part of clock divisor. First-order delta-sigma.         */
      __IOM uint32_t INT        : 16;           /*!< [23..8] Integer part of clock divisor.                                    */
            uint32_t            : 8;
    } bit;
  } DIV;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000014) Raw Interrupts                                             */
    
    struct {
      __IM  uint32_t FIFO       : 1;            /*!< [0..0] Triggered when the sample FIFO reaches a certain level.
                                                     This level can be programmed via the FCS_THRESH field.                    */
            uint32_t            : 31;
    } bit;
  } INTR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000018) Interrupt Enable                                           */
    
    struct {
      __IOM uint32_t FIFO       : 1;            /*!< [0..0] Triggered when the sample FIFO reaches a certain level.
                                                     This level can be programmed via the FCS_THRESH field.                    */
            uint32_t            : 31;
    } bit;
  } INTE;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000001C) Interrupt Force                                            */
    
    struct {
      __IOM uint32_t FIFO       : 1;            /*!< [0..0] Triggered when the sample FIFO reaches a certain level.
                                                     This level can be programmed via the FCS_THRESH field.                    */
            uint32_t            : 31;
    } bit;
  } INTF;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000020) Interrupt status after masking & forcing                   */
    
    struct {
      __IM  uint32_t FIFO       : 1;            /*!< [0..0] Triggered when the sample FIFO reaches a certain level.
                                                     This level can be programmed via the FCS_THRESH field.                    */
            uint32_t            : 31;
    } bit;
  } INTS;
} ADC_Type;                                     /*!< Size = 36 (0x24)                                                          */



/* =========================================================================================================================== */
/* ================                                            PWM                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Simple PWM (PWM)
  */

typedef struct {                                /*!< (@ 0x40050000) PWM Structure                                              */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000000) Control and status register                                */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Enable the PWM channel.                                            */
      __IOM uint32_t PH_CORRECT : 1;            /*!< [1..1] 1: Enable phase-correct modulation. 0: Trailing-edge               */
      __IOM uint32_t A_INV      : 1;            /*!< [2..2] Invert output A                                                    */
      __IOM uint32_t B_INV      : 1;            /*!< [3..3] Invert output B                                                    */
      __IOM uint32_t DIVMODE    : 2;            /*!< [5..4] DIVMODE                                                            */
      __IOM uint32_t PH_RET     : 1;            /*!< [6..6] Retard the phase of the counter by 1 count, while it
                                                     is running.
                                                     Self-clearing. Write a 1, and poll until low. Counter must
                                                     be running.                                                               */
      __IOM uint32_t PH_ADV     : 1;            /*!< [7..7] Advance the phase of the counter by 1 count, while it
                                                     is running.
                                                     Self-clearing. Write a 1, and poll until low. Counter must
                                                     be running
                                                     at less than full speed (div_int + div_frac / 16 > 1)                     */
            uint32_t            : 24;
    } bit;
  } CH0_CSR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000004) INT and FRAC form a fixed-point fractional number.
                                                                    Counting rate is system clock frequency
                                                                    divided by this number.
                                                                    Fractional division uses simple 1st-order
                                                                    sigma-delta.                                               */
    
    struct {
      __IOM uint32_t FRAC       : 4;            /*!< [3..0] FRAC                                                               */
      __IOM uint32_t INT        : 8;            /*!< [11..4] INT                                                               */
            uint32_t            : 20;
    } bit;
  } CH0_DIV;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000008) Direct access to the PWM counter                           */
    
    struct {
      __IOM uint32_t CH0_CTR    : 16;           /*!< [15..0] CH0_CTR                                                           */
            uint32_t            : 16;
    } bit;
  } CH0_CTR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000000C) Counter compare values                                     */
    
    struct {
      __IOM uint32_t A          : 16;           /*!< [15..0] A                                                                 */
      __IOM uint32_t B          : 16;           /*!< [31..16] B                                                                */
    } bit;
  } CH0_CC;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000010) Counter wrap value                                         */
    
    struct {
      __IOM uint32_t CH0_TOP    : 16;           /*!< [15..0] CH0_TOP                                                           */
            uint32_t            : 16;
    } bit;
  } CH0_TOP;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000014) Control and status register                                */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Enable the PWM channel.                                            */
      __IOM uint32_t PH_CORRECT : 1;            /*!< [1..1] 1: Enable phase-correct modulation. 0: Trailing-edge               */
      __IOM uint32_t A_INV      : 1;            /*!< [2..2] Invert output A                                                    */
      __IOM uint32_t B_INV      : 1;            /*!< [3..3] Invert output B                                                    */
      __IOM uint32_t DIVMODE    : 2;            /*!< [5..4] DIVMODE                                                            */
      __IOM uint32_t PH_RET     : 1;            /*!< [6..6] Retard the phase of the counter by 1 count, while it
                                                     is running.
                                                     Self-clearing. Write a 1, and poll until low. Counter must
                                                     be running.                                                               */
      __IOM uint32_t PH_ADV     : 1;            /*!< [7..7] Advance the phase of the counter by 1 count, while it
                                                     is running.
                                                     Self-clearing. Write a 1, and poll until low. Counter must
                                                     be running
                                                     at less than full speed (div_int + div_frac / 16 > 1)                     */
            uint32_t            : 24;
    } bit;
  } CH1_CSR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000018) INT and FRAC form a fixed-point fractional number.
                                                                    Counting rate is system clock frequency
                                                                    divided by this number.
                                                                    Fractional division uses simple 1st-order
                                                                    sigma-delta.                                               */
    
    struct {
      __IOM uint32_t FRAC       : 4;            /*!< [3..0] FRAC                                                               */
      __IOM uint32_t INT        : 8;            /*!< [11..4] INT                                                               */
            uint32_t            : 20;
    } bit;
  } CH1_DIV;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000001C) Direct access to the PWM counter                           */
    
    struct {
      __IOM uint32_t CH1_CTR    : 16;           /*!< [15..0] CH1_CTR                                                           */
            uint32_t            : 16;
    } bit;
  } CH1_CTR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000020) Counter compare values                                     */
    
    struct {
      __IOM uint32_t A          : 16;           /*!< [15..0] A                                                                 */
      __IOM uint32_t B          : 16;           /*!< [31..16] B                                                                */
    } bit;
  } CH1_CC;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000024) Counter wrap value                                         */
    
    struct {
      __IOM uint32_t CH1_TOP    : 16;           /*!< [15..0] CH1_TOP                                                           */
            uint32_t            : 16;
    } bit;
  } CH1_TOP;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000028) Control and status register                                */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Enable the PWM channel.                                            */
      __IOM uint32_t PH_CORRECT : 1;            /*!< [1..1] 1: Enable phase-correct modulation. 0: Trailing-edge               */
      __IOM uint32_t A_INV      : 1;            /*!< [2..2] Invert output A                                                    */
      __IOM uint32_t B_INV      : 1;            /*!< [3..3] Invert output B                                                    */
      __IOM uint32_t DIVMODE    : 2;            /*!< [5..4] DIVMODE                                                            */
      __IOM uint32_t PH_RET     : 1;            /*!< [6..6] Retard the phase of the counter by 1 count, while it
                                                     is running.
                                                     Self-clearing. Write a 1, and poll until low. Counter must
                                                     be running.                                                               */
      __IOM uint32_t PH_ADV     : 1;            /*!< [7..7] Advance the phase of the counter by 1 count, while it
                                                     is running.
                                                     Self-clearing. Write a 1, and poll until low. Counter must
                                                     be running
                                                     at less than full speed (div_int + div_frac / 16 > 1)                     */
            uint32_t            : 24;
    } bit;
  } CH2_CSR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000002C) INT and FRAC form a fixed-point fractional number.
                                                                    Counting rate is system clock frequency
                                                                    divided by this number.
                                                                    Fractional division uses simple 1st-order
                                                                    sigma-delta.                                               */
    
    struct {
      __IOM uint32_t FRAC       : 4;            /*!< [3..0] FRAC                                                               */
      __IOM uint32_t INT        : 8;            /*!< [11..4] INT                                                               */
            uint32_t            : 20;
    } bit;
  } CH2_DIV;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000030) Direct access to the PWM counter                           */
    
    struct {
      __IOM uint32_t CH2_CTR    : 16;           /*!< [15..0] CH2_CTR                                                           */
            uint32_t            : 16;
    } bit;
  } CH2_CTR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000034) Counter compare values                                     */
    
    struct {
      __IOM uint32_t A          : 16;           /*!< [15..0] A                                                                 */
      __IOM uint32_t B          : 16;           /*!< [31..16] B                                                                */
    } bit;
  } CH2_CC;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000038) Counter wrap value                                         */
    
    struct {
      __IOM uint32_t CH2_TOP    : 16;           /*!< [15..0] CH2_TOP                                                           */
            uint32_t            : 16;
    } bit;
  } CH2_TOP;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000003C) Control and status register                                */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Enable the PWM channel.                                            */
      __IOM uint32_t PH_CORRECT : 1;            /*!< [1..1] 1: Enable phase-correct modulation. 0: Trailing-edge               */
      __IOM uint32_t A_INV      : 1;            /*!< [2..2] Invert output A                                                    */
      __IOM uint32_t B_INV      : 1;            /*!< [3..3] Invert output B                                                    */
      __IOM uint32_t DIVMODE    : 2;            /*!< [5..4] DIVMODE                                                            */
      __IOM uint32_t PH_RET     : 1;            /*!< [6..6] Retard the phase of the counter by 1 count, while it
                                                     is running.
                                                     Self-clearing. Write a 1, and poll until low. Counter must
                                                     be running.                                                               */
      __IOM uint32_t PH_ADV     : 1;            /*!< [7..7] Advance the phase of the counter by 1 count, while it
                                                     is running.
                                                     Self-clearing. Write a 1, and poll until low. Counter must
                                                     be running
                                                     at less than full speed (div_int + div_frac / 16 > 1)                     */
            uint32_t            : 24;
    } bit;
  } CH3_CSR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000040) INT and FRAC form a fixed-point fractional number.
                                                                    Counting rate is system clock frequency
                                                                    divided by this number.
                                                                    Fractional division uses simple 1st-order
                                                                    sigma-delta.                                               */
    
    struct {
      __IOM uint32_t FRAC       : 4;            /*!< [3..0] FRAC                                                               */
      __IOM uint32_t INT        : 8;            /*!< [11..4] INT                                                               */
            uint32_t            : 20;
    } bit;
  } CH3_DIV;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000044) Direct access to the PWM counter                           */
    
    struct {
      __IOM uint32_t CH3_CTR    : 16;           /*!< [15..0] CH3_CTR                                                           */
            uint32_t            : 16;
    } bit;
  } CH3_CTR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000048) Counter compare values                                     */
    
    struct {
      __IOM uint32_t A          : 16;           /*!< [15..0] A                                                                 */
      __IOM uint32_t B          : 16;           /*!< [31..16] B                                                                */
    } bit;
  } CH3_CC;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000004C) Counter wrap value                                         */
    
    struct {
      __IOM uint32_t CH3_TOP    : 16;           /*!< [15..0] CH3_TOP                                                           */
            uint32_t            : 16;
    } bit;
  } CH3_TOP;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000050) Control and status register                                */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Enable the PWM channel.                                            */
      __IOM uint32_t PH_CORRECT : 1;            /*!< [1..1] 1: Enable phase-correct modulation. 0: Trailing-edge               */
      __IOM uint32_t A_INV      : 1;            /*!< [2..2] Invert output A                                                    */
      __IOM uint32_t B_INV      : 1;            /*!< [3..3] Invert output B                                                    */
      __IOM uint32_t DIVMODE    : 2;            /*!< [5..4] DIVMODE                                                            */
      __IOM uint32_t PH_RET     : 1;            /*!< [6..6] Retard the phase of the counter by 1 count, while it
                                                     is running.
                                                     Self-clearing. Write a 1, and poll until low. Counter must
                                                     be running.                                                               */
      __IOM uint32_t PH_ADV     : 1;            /*!< [7..7] Advance the phase of the counter by 1 count, while it
                                                     is running.
                                                     Self-clearing. Write a 1, and poll until low. Counter must
                                                     be running
                                                     at less than full speed (div_int + div_frac / 16 > 1)                     */
            uint32_t            : 24;
    } bit;
  } CH4_CSR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000054) INT and FRAC form a fixed-point fractional number.
                                                                    Counting rate is system clock frequency
                                                                    divided by this number.
                                                                    Fractional division uses simple 1st-order
                                                                    sigma-delta.                                               */
    
    struct {
      __IOM uint32_t FRAC       : 4;            /*!< [3..0] FRAC                                                               */
      __IOM uint32_t INT        : 8;            /*!< [11..4] INT                                                               */
            uint32_t            : 20;
    } bit;
  } CH4_DIV;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000058) Direct access to the PWM counter                           */
    
    struct {
      __IOM uint32_t CH4_CTR    : 16;           /*!< [15..0] CH4_CTR                                                           */
            uint32_t            : 16;
    } bit;
  } CH4_CTR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000005C) Counter compare values                                     */
    
    struct {
      __IOM uint32_t A          : 16;           /*!< [15..0] A                                                                 */
      __IOM uint32_t B          : 16;           /*!< [31..16] B                                                                */
    } bit;
  } CH4_CC;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000060) Counter wrap value                                         */
    
    struct {
      __IOM uint32_t CH4_TOP    : 16;           /*!< [15..0] CH4_TOP                                                           */
            uint32_t            : 16;
    } bit;
  } CH4_TOP;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000064) Control and status register                                */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Enable the PWM channel.                                            */
      __IOM uint32_t PH_CORRECT : 1;            /*!< [1..1] 1: Enable phase-correct modulation. 0: Trailing-edge               */
      __IOM uint32_t A_INV      : 1;            /*!< [2..2] Invert output A                                                    */
      __IOM uint32_t B_INV      : 1;            /*!< [3..3] Invert output B                                                    */
      __IOM uint32_t DIVMODE    : 2;            /*!< [5..4] DIVMODE                                                            */
      __IOM uint32_t PH_RET     : 1;            /*!< [6..6] Retard the phase of the counter by 1 count, while it
                                                     is running.
                                                     Self-clearing. Write a 1, and poll until low. Counter must
                                                     be running.                                                               */
      __IOM uint32_t PH_ADV     : 1;            /*!< [7..7] Advance the phase of the counter by 1 count, while it
                                                     is running.
                                                     Self-clearing. Write a 1, and poll until low. Counter must
                                                     be running
                                                     at less than full speed (div_int + div_frac / 16 > 1)                     */
            uint32_t            : 24;
    } bit;
  } CH5_CSR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000068) INT and FRAC form a fixed-point fractional number.
                                                                    Counting rate is system clock frequency
                                                                    divided by this number.
                                                                    Fractional division uses simple 1st-order
                                                                    sigma-delta.                                               */
    
    struct {
      __IOM uint32_t FRAC       : 4;            /*!< [3..0] FRAC                                                               */
      __IOM uint32_t INT        : 8;            /*!< [11..4] INT                                                               */
            uint32_t            : 20;
    } bit;
  } CH5_DIV;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000006C) Direct access to the PWM counter                           */
    
    struct {
      __IOM uint32_t CH5_CTR    : 16;           /*!< [15..0] CH5_CTR                                                           */
            uint32_t            : 16;
    } bit;
  } CH5_CTR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000070) Counter compare values                                     */
    
    struct {
      __IOM uint32_t A          : 16;           /*!< [15..0] A                                                                 */
      __IOM uint32_t B          : 16;           /*!< [31..16] B                                                                */
    } bit;
  } CH5_CC;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000074) Counter wrap value                                         */
    
    struct {
      __IOM uint32_t CH5_TOP    : 16;           /*!< [15..0] CH5_TOP                                                           */
            uint32_t            : 16;
    } bit;
  } CH5_TOP;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000078) Control and status register                                */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Enable the PWM channel.                                            */
      __IOM uint32_t PH_CORRECT : 1;            /*!< [1..1] 1: Enable phase-correct modulation. 0: Trailing-edge               */
      __IOM uint32_t A_INV      : 1;            /*!< [2..2] Invert output A                                                    */
      __IOM uint32_t B_INV      : 1;            /*!< [3..3] Invert output B                                                    */
      __IOM uint32_t DIVMODE    : 2;            /*!< [5..4] DIVMODE                                                            */
      __IOM uint32_t PH_RET     : 1;            /*!< [6..6] Retard the phase of the counter by 1 count, while it
                                                     is running.
                                                     Self-clearing. Write a 1, and poll until low. Counter must
                                                     be running.                                                               */
      __IOM uint32_t PH_ADV     : 1;            /*!< [7..7] Advance the phase of the counter by 1 count, while it
                                                     is running.
                                                     Self-clearing. Write a 1, and poll until low. Counter must
                                                     be running
                                                     at less than full speed (div_int + div_frac / 16 > 1)                     */
            uint32_t            : 24;
    } bit;
  } CH6_CSR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000007C) INT and FRAC form a fixed-point fractional number.
                                                                    Counting rate is system clock frequency
                                                                    divided by this number.
                                                                    Fractional division uses simple 1st-order
                                                                    sigma-delta.                                               */
    
    struct {
      __IOM uint32_t FRAC       : 4;            /*!< [3..0] FRAC                                                               */
      __IOM uint32_t INT        : 8;            /*!< [11..4] INT                                                               */
            uint32_t            : 20;
    } bit;
  } CH6_DIV;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000080) Direct access to the PWM counter                           */
    
    struct {
      __IOM uint32_t CH6_CTR    : 16;           /*!< [15..0] CH6_CTR                                                           */
            uint32_t            : 16;
    } bit;
  } CH6_CTR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000084) Counter compare values                                     */
    
    struct {
      __IOM uint32_t A          : 16;           /*!< [15..0] A                                                                 */
      __IOM uint32_t B          : 16;           /*!< [31..16] B                                                                */
    } bit;
  } CH6_CC;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000088) Counter wrap value                                         */
    
    struct {
      __IOM uint32_t CH6_TOP    : 16;           /*!< [15..0] CH6_TOP                                                           */
            uint32_t            : 16;
    } bit;
  } CH6_TOP;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000008C) Control and status register                                */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Enable the PWM channel.                                            */
      __IOM uint32_t PH_CORRECT : 1;            /*!< [1..1] 1: Enable phase-correct modulation. 0: Trailing-edge               */
      __IOM uint32_t A_INV      : 1;            /*!< [2..2] Invert output A                                                    */
      __IOM uint32_t B_INV      : 1;            /*!< [3..3] Invert output B                                                    */
      __IOM uint32_t DIVMODE    : 2;            /*!< [5..4] DIVMODE                                                            */
      __IOM uint32_t PH_RET     : 1;            /*!< [6..6] Retard the phase of the counter by 1 count, while it
                                                     is running.
                                                     Self-clearing. Write a 1, and poll until low. Counter must
                                                     be running.                                                               */
      __IOM uint32_t PH_ADV     : 1;            /*!< [7..7] Advance the phase of the counter by 1 count, while it
                                                     is running.
                                                     Self-clearing. Write a 1, and poll until low. Counter must
                                                     be running
                                                     at less than full speed (div_int + div_frac / 16 > 1)                     */
            uint32_t            : 24;
    } bit;
  } CH7_CSR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000090) INT and FRAC form a fixed-point fractional number.
                                                                    Counting rate is system clock frequency
                                                                    divided by this number.
                                                                    Fractional division uses simple 1st-order
                                                                    sigma-delta.                                               */
    
    struct {
      __IOM uint32_t FRAC       : 4;            /*!< [3..0] FRAC                                                               */
      __IOM uint32_t INT        : 8;            /*!< [11..4] INT                                                               */
            uint32_t            : 20;
    } bit;
  } CH7_DIV;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000094) Direct access to the PWM counter                           */
    
    struct {
      __IOM uint32_t CH7_CTR    : 16;           /*!< [15..0] CH7_CTR                                                           */
            uint32_t            : 16;
    } bit;
  } CH7_CTR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000098) Counter compare values                                     */
    
    struct {
      __IOM uint32_t A          : 16;           /*!< [15..0] A                                                                 */
      __IOM uint32_t B          : 16;           /*!< [31..16] B                                                                */
    } bit;
  } CH7_CC;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000009C) Counter wrap value                                         */
    
    struct {
      __IOM uint32_t CH7_TOP    : 16;           /*!< [15..0] CH7_TOP                                                           */
            uint32_t            : 16;
    } bit;
  } CH7_TOP;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000A0) This register aliases the CSR_EN bits for all
                                                                    channels.
                                                                    Writing to this register allows multiple
                                                                    channels to be enabled
                                                                    or disabled simultaneously, so they can
                                                                    run in perfect sync.
                                                                    For each channel, there is only one physical
                                                                    EN register bit,
                                                                    which can be accessed through here or CHx_CSR.             */
    
    struct {
      __IOM uint32_t CH0        : 1;            /*!< [0..0] CH0                                                                */
      __IOM uint32_t CH1        : 1;            /*!< [1..1] CH1                                                                */
      __IOM uint32_t CH2        : 1;            /*!< [2..2] CH2                                                                */
      __IOM uint32_t CH3        : 1;            /*!< [3..3] CH3                                                                */
      __IOM uint32_t CH4        : 1;            /*!< [4..4] CH4                                                                */
      __IOM uint32_t CH5        : 1;            /*!< [5..5] CH5                                                                */
      __IOM uint32_t CH6        : 1;            /*!< [6..6] CH6                                                                */
      __IOM uint32_t CH7        : 1;            /*!< [7..7] CH7                                                                */
            uint32_t            : 24;
    } bit;
  } EN;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000A4) Raw Interrupts                                             */
    
    struct {
      __IOM uint32_t CH0        : 1;            /*!< [0..0] CH0                                                                */
      __IOM uint32_t CH1        : 1;            /*!< [1..1] CH1                                                                */
      __IOM uint32_t CH2        : 1;            /*!< [2..2] CH2                                                                */
      __IOM uint32_t CH3        : 1;            /*!< [3..3] CH3                                                                */
      __IOM uint32_t CH4        : 1;            /*!< [4..4] CH4                                                                */
      __IOM uint32_t CH5        : 1;            /*!< [5..5] CH5                                                                */
      __IOM uint32_t CH6        : 1;            /*!< [6..6] CH6                                                                */
      __IOM uint32_t CH7        : 1;            /*!< [7..7] CH7                                                                */
            uint32_t            : 24;
    } bit;
  } INTR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000A8) Interrupt Enable                                           */
    
    struct {
      __IOM uint32_t CH0        : 1;            /*!< [0..0] CH0                                                                */
      __IOM uint32_t CH1        : 1;            /*!< [1..1] CH1                                                                */
      __IOM uint32_t CH2        : 1;            /*!< [2..2] CH2                                                                */
      __IOM uint32_t CH3        : 1;            /*!< [3..3] CH3                                                                */
      __IOM uint32_t CH4        : 1;            /*!< [4..4] CH4                                                                */
      __IOM uint32_t CH5        : 1;            /*!< [5..5] CH5                                                                */
      __IOM uint32_t CH6        : 1;            /*!< [6..6] CH6                                                                */
      __IOM uint32_t CH7        : 1;            /*!< [7..7] CH7                                                                */
            uint32_t            : 24;
    } bit;
  } INTE;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000AC) Interrupt Force                                            */
    
    struct {
      __IOM uint32_t CH0        : 1;            /*!< [0..0] CH0                                                                */
      __IOM uint32_t CH1        : 1;            /*!< [1..1] CH1                                                                */
      __IOM uint32_t CH2        : 1;            /*!< [2..2] CH2                                                                */
      __IOM uint32_t CH3        : 1;            /*!< [3..3] CH3                                                                */
      __IOM uint32_t CH4        : 1;            /*!< [4..4] CH4                                                                */
      __IOM uint32_t CH5        : 1;            /*!< [5..5] CH5                                                                */
      __IOM uint32_t CH6        : 1;            /*!< [6..6] CH6                                                                */
      __IOM uint32_t CH7        : 1;            /*!< [7..7] CH7                                                                */
            uint32_t            : 24;
    } bit;
  } INTF;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000B0) Interrupt status after masking & forcing                   */
    
    struct {
      __IM  uint32_t CH0        : 1;            /*!< [0..0] CH0                                                                */
      __IM  uint32_t CH1        : 1;            /*!< [1..1] CH1                                                                */
      __IM  uint32_t CH2        : 1;            /*!< [2..2] CH2                                                                */
      __IM  uint32_t CH3        : 1;            /*!< [3..3] CH3                                                                */
      __IM  uint32_t CH4        : 1;            /*!< [4..4] CH4                                                                */
      __IM  uint32_t CH5        : 1;            /*!< [5..5] CH5                                                                */
      __IM  uint32_t CH6        : 1;            /*!< [6..6] CH6                                                                */
      __IM  uint32_t CH7        : 1;            /*!< [7..7] CH7                                                                */
            uint32_t            : 24;
    } bit;
  } INTS;
} PWM_Type;                                     /*!< Size = 180 (0xb4)                                                         */



/* =========================================================================================================================== */
/* ================                                           TIMER                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Controls time and alarms\n
        time is a 64 bit value indicating the time in usec since power-on\n
        timeh is the top 32 bits of time & timel is the bottom 32 bits\n
        to change time write to timelw before timehw\n
        to read time read from timelr before timehr\n
        An alarm is set by setting alarm_enable and writing to the corresponding alarm register\n
        When an alarm is pending, the corresponding alarm_running signal will be high\n
        An alarm can be cancelled before it has finished by clearing the alarm_enable\n
        When an alarm fires, the corresponding alarm_irq is set and alarm_running is cleared\n
        To clear the interrupt write a 1 to the corresponding alarm_irq (TIMER)
  */

typedef struct {                                /*!< (@ 0x40054000) TIMER Structure                                            */
  __OM  uint32_t  TIMEHW;                       /*!< (@ 0x00000000) Write to bits 63:32 of time
                                                                    always write timelw before timehw                          */
  __OM  uint32_t  TIMELW;                       /*!< (@ 0x00000004) Write to bits 31:0 of time
                                                                    writes do not get copied to time until timehw
                                                                    is written                                                 */
  __IM  uint32_t  TIMEHR;                       /*!< (@ 0x00000008) Read from bits 63:32 of time
                                                                    always read timelr before timehr                           */
  __IM  uint32_t  TIMELR;                       /*!< (@ 0x0000000C) Read from bits 31:0 of time                                */
  __IOM uint32_t  ALARM0;                       /*!< (@ 0x00000010) Arm alarm 0, and configure the time it will fire.
                                                                    Once armed, the alarm fires when TIMER_ALARM0
                                                                    == TIMELR.
                                                                    The alarm will disarm itself once it fires,
                                                                    and can
                                                                    be disarmed early using the ARMED status
                                                                    register.                                                  */
  __IOM uint32_t  ALARM1;                       /*!< (@ 0x00000014) Arm alarm 1, and configure the time it will fire.
                                                                    Once armed, the alarm fires when TIMER_ALARM1
                                                                    == TIMELR.
                                                                    The alarm will disarm itself once it fires,
                                                                    and can
                                                                    be disarmed early using the ARMED status
                                                                    register.                                                  */
  __IOM uint32_t  ALARM2;                       /*!< (@ 0x00000018) Arm alarm 2, and configure the time it will fire.
                                                                    Once armed, the alarm fires when TIMER_ALARM2
                                                                    == TIMELR.
                                                                    The alarm will disarm itself once it fires,
                                                                    and can
                                                                    be disarmed early using the ARMED status
                                                                    register.                                                  */
  __IOM uint32_t  ALARM3;                       /*!< (@ 0x0000001C) Arm alarm 3, and configure the time it will fire.
                                                                    Once armed, the alarm fires when TIMER_ALARM3
                                                                    == TIMELR.
                                                                    The alarm will disarm itself once it fires,
                                                                    and can
                                                                    be disarmed early using the ARMED status
                                                                    register.                                                  */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000020) Indicates the armed/disarmed status of each alarm.
                                                                    A write to the corresponding ALARMx register
                                                                    arms the alarm.
                                                                    Alarms automatically disarm upon firing,
                                                                    but writing ones here
                                                                    will disarm immediately without waiting
                                                                    to fire.                                                   */
    
    struct {
      __IOM uint32_t ARMED      : 4;            /*!< [3..0] ARMED                                                              */
            uint32_t            : 28;
    } bit;
  } ARMED;
  __IM  uint32_t  TIMERAWH;                     /*!< (@ 0x00000024) Raw read from bits 63:32 of time (no side effects)         */
  __IM  uint32_t  TIMERAWL;                     /*!< (@ 0x00000028) Raw read from bits 31:0 of time (no side effects)          */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000002C) Set bits high to enable pause when the corresponding
                                                                    debug ports are active                                     */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t DBG0       : 1;            /*!< [1..1] Pause when processor 0 is in debug mode                            */
      __IOM uint32_t DBG1       : 1;            /*!< [2..2] Pause when processor 1 is in debug mode                            */
            uint32_t            : 29;
    } bit;
  } DBGPAUSE;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000030) Set high to pause the timer                                */
    
    struct {
      __IOM uint32_t PAUSE      : 1;            /*!< [0..0] PAUSE                                                              */
            uint32_t            : 31;
    } bit;
  } PAUSE;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000034) Raw Interrupts                                             */
    
    struct {
      __IOM uint32_t ALARM_0    : 1;            /*!< [0..0] ALARM_0                                                            */
      __IOM uint32_t ALARM_1    : 1;            /*!< [1..1] ALARM_1                                                            */
      __IOM uint32_t ALARM_2    : 1;            /*!< [2..2] ALARM_2                                                            */
      __IOM uint32_t ALARM_3    : 1;            /*!< [3..3] ALARM_3                                                            */
            uint32_t            : 28;
    } bit;
  } INTR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000038) Interrupt Enable                                           */
    
    struct {
      __IOM uint32_t ALARM_0    : 1;            /*!< [0..0] ALARM_0                                                            */
      __IOM uint32_t ALARM_1    : 1;            /*!< [1..1] ALARM_1                                                            */
      __IOM uint32_t ALARM_2    : 1;            /*!< [2..2] ALARM_2                                                            */
      __IOM uint32_t ALARM_3    : 1;            /*!< [3..3] ALARM_3                                                            */
            uint32_t            : 28;
    } bit;
  } INTE;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000003C) Interrupt Force                                            */
    
    struct {
      __IOM uint32_t ALARM_0    : 1;            /*!< [0..0] ALARM_0                                                            */
      __IOM uint32_t ALARM_1    : 1;            /*!< [1..1] ALARM_1                                                            */
      __IOM uint32_t ALARM_2    : 1;            /*!< [2..2] ALARM_2                                                            */
      __IOM uint32_t ALARM_3    : 1;            /*!< [3..3] ALARM_3                                                            */
            uint32_t            : 28;
    } bit;
  } INTF;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000040) Interrupt status after masking & forcing                   */
    
    struct {
      __IM  uint32_t ALARM_0    : 1;            /*!< [0..0] ALARM_0                                                            */
      __IM  uint32_t ALARM_1    : 1;            /*!< [1..1] ALARM_1                                                            */
      __IM  uint32_t ALARM_2    : 1;            /*!< [2..2] ALARM_2                                                            */
      __IM  uint32_t ALARM_3    : 1;            /*!< [3..3] ALARM_3                                                            */
            uint32_t            : 28;
    } bit;
  } INTS;
} TIMER_Type;                                   /*!< Size = 68 (0x44)                                                          */



/* =========================================================================================================================== */
/* ================                                         WATCHDOG                                          ================ */
/* =========================================================================================================================== */


/**
  * @brief WATCHDOG (WATCHDOG)
  */

typedef struct {                                /*!< (@ 0x40058000) WATCHDOG Structure                                         */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000000) Watchdog control
                                                                    The rst_wdsel register determines which
                                                                    subsystems are reset when the watchdog is
                                                                    triggered.
                                                                    The watchdog can be triggered in software.                 */
    
    struct {
      __IM  uint32_t TIME       : 24;           /*!< [23..0] Indicates the number of ticks / 2 (see errata RP2040-E1)
                                                     before a watchdog reset will be triggered                                 */
      __IOM uint32_t PAUSE_JTAG : 1;            /*!< [24..24] Pause the watchdog timer when JTAG is accessing the
                                                     bus fabric                                                                */
      __IOM uint32_t PAUSE_DBG0 : 1;            /*!< [25..25] Pause the watchdog timer when processor 0 is in debug
                                                     mode                                                                      */
      __IOM uint32_t PAUSE_DBG1 : 1;            /*!< [26..26] Pause the watchdog timer when processor 1 is in debug
                                                     mode                                                                      */
            uint32_t            : 3;
      __IOM uint32_t ENABLE     : 1;            /*!< [30..30] When not enabled the watchdog timer is paused                    */
      __IOM uint32_t TRIGGER    : 1;            /*!< [31..31] Trigger a watchdog reset                                         */
    } bit;
  } CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000004) Load the watchdog timer. The maximum setting
                                                                    is 0xffffff which corresponds to 0xffffff
                                                                    / 2 ticks before triggering a watchdog reset
                                                                    (see errata RP2040-E1).                                    */
    
    struct {
      __OM  uint32_t LOAD       : 24;           /*!< [23..0] LOAD                                                              */
            uint32_t            : 8;
    } bit;
  } LOAD;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000008) Logs the reason for the last reset. Both bits
                                                                    are zero for the case of a hardware reset.                 */
    
    struct {
      __IM  uint32_t TIMER      : 1;            /*!< [0..0] TIMER                                                              */
      __IM  uint32_t FORCE      : 1;            /*!< [1..1] FORCE                                                              */
            uint32_t            : 30;
    } bit;
  } REASON;
  __IOM uint32_t  SCRATCH0;                     /*!< (@ 0x0000000C) Scratch register. Information persists through
                                                                    soft reset of the chip.                                    */
  __IOM uint32_t  SCRATCH1;                     /*!< (@ 0x00000010) Scratch register. Information persists through
                                                                    soft reset of the chip.                                    */
  __IOM uint32_t  SCRATCH2;                     /*!< (@ 0x00000014) Scratch register. Information persists through
                                                                    soft reset of the chip.                                    */
  __IOM uint32_t  SCRATCH3;                     /*!< (@ 0x00000018) Scratch register. Information persists through
                                                                    soft reset of the chip.                                    */
  __IOM uint32_t  SCRATCH4;                     /*!< (@ 0x0000001C) Scratch register. Information persists through
                                                                    soft reset of the chip.                                    */
  __IOM uint32_t  SCRATCH5;                     /*!< (@ 0x00000020) Scratch register. Information persists through
                                                                    soft reset of the chip.                                    */
  __IOM uint32_t  SCRATCH6;                     /*!< (@ 0x00000024) Scratch register. Information persists through
                                                                    soft reset of the chip.                                    */
  __IOM uint32_t  SCRATCH7;                     /*!< (@ 0x00000028) Scratch register. Information persists through
                                                                    soft reset of the chip.                                    */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000002C) Controls the tick generator                                */
    
    struct {
      __IOM uint32_t CYCLES     : 9;            /*!< [8..0] Total number of clk_tick cycles before the next tick.              */
      __IOM uint32_t ENABLE     : 1;            /*!< [9..9] start / stop tick generation                                       */
      __IM  uint32_t RUNNING    : 1;            /*!< [10..10] Is the tick generator running?                                   */
      __IM  uint32_t COUNT      : 9;            /*!< [19..11] Count down timer: the remaining number clk_tick cycles
                                                     before the next tick is generated.                                        */
            uint32_t            : 12;
    } bit;
  } TICK;
} WATCHDOG_Type;                                /*!< Size = 48 (0x30)                                                          */



/* =========================================================================================================================== */
/* ================                                            RTC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Register block to control RTC (RTC)
  */

typedef struct {                                /*!< (@ 0x4005C000) RTC Structure                                              */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000000) Divider minus 1 for the 1 second counter. Safe
                                                                    to change the value when RTC is not enabled.               */
    
    struct {
      __IOM uint32_t CLKDIV_M1  : 16;           /*!< [15..0] CLKDIV_M1                                                         */
            uint32_t            : 16;
    } bit;
  } CLKDIV_M1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000004) RTC setup register 0                                       */
    
    struct {
      __IOM uint32_t DAY        : 5;            /*!< [4..0] Day of the month (1..31)                                           */
            uint32_t            : 3;
      __IOM uint32_t MONTH      : 4;            /*!< [11..8] Month (1..12)                                                     */
      __IOM uint32_t YEAR       : 12;           /*!< [23..12] Year                                                             */
            uint32_t            : 8;
    } bit;
  } SETUP_0;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000008) RTC setup register 1                                       */
    
    struct {
      __IOM uint32_t SEC        : 6;            /*!< [5..0] Seconds                                                            */
            uint32_t            : 2;
      __IOM uint32_t MIN        : 6;            /*!< [13..8] Minutes                                                           */
            uint32_t            : 2;
      __IOM uint32_t HOUR       : 5;            /*!< [20..16] Hours                                                            */
            uint32_t            : 3;
      __IOM uint32_t DOTW       : 3;            /*!< [26..24] Day of the week: 1-Monday...0-Sunday ISO 8601 mod 7              */
            uint32_t            : 5;
    } bit;
  } SETUP_1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000000C) RTC Control and status                                     */
    
    struct {
      __IOM uint32_t RTC_ENABLE : 1;            /*!< [0..0] Enable RTC                                                         */
      __IM  uint32_t RTC_ACTIVE : 1;            /*!< [1..1] RTC enabled (running)                                              */
            uint32_t            : 2;
      __IOM uint32_t LOAD       : 1;            /*!< [4..4] Load RTC                                                           */
            uint32_t            : 3;
      __IOM uint32_t FORCE_NOTLEAPYEAR : 1;     /*!< [8..8] If set, leapyear is forced off.
                                                     Useful for years divisible by 100 but not by 400                          */
            uint32_t            : 23;
    } bit;
  } CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000010) Interrupt setup register 0                                 */
    
    struct {
      __IOM uint32_t DAY        : 5;            /*!< [4..0] Day of the month (1..31)                                           */
            uint32_t            : 3;
      __IOM uint32_t MONTH      : 4;            /*!< [11..8] Month (1..12)                                                     */
      __IOM uint32_t YEAR       : 12;           /*!< [23..12] Year                                                             */
      __IOM uint32_t DAY_ENA    : 1;            /*!< [24..24] Enable day matching                                              */
      __IOM uint32_t MONTH_ENA  : 1;            /*!< [25..25] Enable month matching                                            */
      __IOM uint32_t YEAR_ENA   : 1;            /*!< [26..26] Enable year matching                                             */
            uint32_t            : 1;
      __IOM uint32_t MATCH_ENA  : 1;            /*!< [28..28] Global match enable. Don't change any other value while
                                                     this one is enabled                                                       */
      __IM  uint32_t MATCH_ACTIVE : 1;          /*!< [29..29] MATCH_ACTIVE                                                     */
            uint32_t            : 2;
    } bit;
  } IRQ_SETUP_0;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000014) Interrupt setup register 1                                 */
    
    struct {
      __IOM uint32_t SEC        : 6;            /*!< [5..0] Seconds                                                            */
            uint32_t            : 2;
      __IOM uint32_t MIN        : 6;            /*!< [13..8] Minutes                                                           */
            uint32_t            : 2;
      __IOM uint32_t HOUR       : 5;            /*!< [20..16] Hours                                                            */
            uint32_t            : 3;
      __IOM uint32_t DOTW       : 3;            /*!< [26..24] Day of the week                                                  */
            uint32_t            : 1;
      __IOM uint32_t SEC_ENA    : 1;            /*!< [28..28] Enable second matching                                           */
      __IOM uint32_t MIN_ENA    : 1;            /*!< [29..29] Enable minute matching                                           */
      __IOM uint32_t HOUR_ENA   : 1;            /*!< [30..30] Enable hour matching                                             */
      __IOM uint32_t DOTW_ENA   : 1;            /*!< [31..31] Enable day of the week matching                                  */
    } bit;
  } IRQ_SETUP_1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000018) RTC register 1.                                            */
    
    struct {
      __IM  uint32_t DAY        : 5;            /*!< [4..0] Day of the month (1..31)                                           */
            uint32_t            : 3;
      __IM  uint32_t MONTH      : 4;            /*!< [11..8] Month (1..12)                                                     */
      __IM  uint32_t YEAR       : 12;           /*!< [23..12] Year                                                             */
            uint32_t            : 8;
    } bit;
  } RTC_1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000001C) RTC register 0
                                                                    Read this before RTC 1!                                    */
    
    struct {
      __IM  uint32_t SEC        : 6;            /*!< [5..0] Seconds                                                            */
            uint32_t            : 2;
      __IM  uint32_t MIN        : 6;            /*!< [13..8] Minutes                                                           */
            uint32_t            : 2;
      __IM  uint32_t HOUR       : 5;            /*!< [20..16] Hours                                                            */
            uint32_t            : 3;
      __IM  uint32_t DOTW       : 3;            /*!< [26..24] Day of the week                                                  */
            uint32_t            : 5;
    } bit;
  } RTC_0;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000020) Raw Interrupts                                             */
    
    struct {
      __IM  uint32_t RTC        : 1;            /*!< [0..0] RTC                                                                */
            uint32_t            : 31;
    } bit;
  } INTR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000024) Interrupt Enable                                           */
    
    struct {
      __IOM uint32_t RTC        : 1;            /*!< [0..0] RTC                                                                */
            uint32_t            : 31;
    } bit;
  } INTE;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000028) Interrupt Force                                            */
    
    struct {
      __IOM uint32_t RTC        : 1;            /*!< [0..0] RTC                                                                */
            uint32_t            : 31;
    } bit;
  } INTF;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000002C) Interrupt status after masking & forcing                   */
    
    struct {
      __IM  uint32_t RTC        : 1;            /*!< [0..0] RTC                                                                */
            uint32_t            : 31;
    } bit;
  } INTS;
} RTC_Type;                                     /*!< Size = 48 (0x30)                                                          */



/* =========================================================================================================================== */
/* ================                                           ROSC                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief ROSC (ROSC)
  */

typedef struct {                                /*!< (@ 0x40060000) ROSC Structure                                             */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000000) Ring Oscillator control                                    */
    
    struct {
      __IOM uint32_t FREQ_RANGE : 12;           /*!< [11..0] Controls the number of delay stages in the ROSC ring
                                                     LOW uses stages 0 to 7
                                                     MEDIUM uses stages 0 to 5
                                                     HIGH uses stages 0 to 3
                                                     TOOHIGH uses stages 0 to 1 and should not be used because
                                                     its frequency exceeds design specifications
                                                     The clock output will not glitch when changing the range
                                                     up one step at a time
                                                     The clock output will glitch when changing the range down
                                                     Note: the v                                                               */
      __IOM uint32_t ENABLE     : 12;           /*!< [23..12] On power-up this field is initialised to ENABLE
                                                     The system clock must be switched to another source before
                                                     setting this field to DISABLE otherwise the chip will lock
                                                     up
                                                     The 12-bit code is intended to give some protection against
                                                     accidental writes. An invalid setting will enable the oscillator.         */
            uint32_t            : 8;
    } bit;
  } CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000004) The FREQA & FREQB registers control the frequency
                                                                    by controlling the drive strength of each
                                                                    stage
                                                                    The drive strength has 4 levels determined
                                                                    by the number of bits set
                                                                    Increasing the number of bits set increases
                                                                    the drive strength and increases the oscillation
                                                                    frequency
                                                                    0 bits set is the default drive strength
                                                                    1 bit set doubles the drive strength
                                                                    2 bits set triples drive strength
                                                                    3 bits set quadruples                                      */
    
    struct {
      __IOM uint32_t DS0        : 3;            /*!< [2..0] Stage 0 drive strength                                             */
            uint32_t            : 1;
      __IOM uint32_t DS1        : 3;            /*!< [6..4] Stage 1 drive strength                                             */
            uint32_t            : 1;
      __IOM uint32_t DS2        : 3;            /*!< [10..8] Stage 2 drive strength                                            */
            uint32_t            : 1;
      __IOM uint32_t DS3        : 3;            /*!< [14..12] Stage 3 drive strength                                           */
            uint32_t            : 1;
      __IOM uint32_t PASSWD     : 16;           /*!< [31..16] Set to 0x9696 to apply the settings
                                                     Any other value in this field will set all drive strengths
                                                     to 0                                                                      */
    } bit;
  } FREQA;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000008) For a detailed description see freqa register              */
    
    struct {
      __IOM uint32_t DS4        : 3;            /*!< [2..0] Stage 4 drive strength                                             */
            uint32_t            : 1;
      __IOM uint32_t DS5        : 3;            /*!< [6..4] Stage 5 drive strength                                             */
            uint32_t            : 1;
      __IOM uint32_t DS6        : 3;            /*!< [10..8] Stage 6 drive strength                                            */
            uint32_t            : 1;
      __IOM uint32_t DS7        : 3;            /*!< [14..12] Stage 7 drive strength                                           */
            uint32_t            : 1;
      __IOM uint32_t PASSWD     : 16;           /*!< [31..16] Set to 0x9696 to apply the settings
                                                     Any other value in this field will set all drive strengths
                                                     to 0                                                                      */
    } bit;
  } FREQB;
  __IOM uint32_t  DORMANT;                      /*!< (@ 0x0000000C) Ring Oscillator pause control
                                                                    This is used to save power by pausing the
                                                                    ROSC
                                                                    On power-up this field is initialised to
                                                                    WAKE
                                                                    An invalid write will also select WAKE
                                                                    Warning: setup the irq before selecting
                                                                    dormant mode                                               */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000010) Controls the output divider                                */
    
    struct {
      __IOM uint32_t DIV        : 12;           /*!< [11..0] set to 0xaa0 + div where
                                                     div = 0 divides by 32
                                                     div = 1-31 divides by div
                                                     any other value sets div=0 and therefore divides by 32
                                                     this register resets to div=16                                            */
            uint32_t            : 20;
    } bit;
  } DIV;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000014) Controls the phase shifted output                          */
    
    struct {
      __IOM uint32_t SHIFT      : 2;            /*!< [1..0] phase shift the phase-shifted output by SHIFT input clocks
                                                     this can be changed on-the-fly
                                                     must be set to 0 before setting div=1                                     */
      __IOM uint32_t FLIP       : 1;            /*!< [2..2] invert the phase-shifted output
                                                     this is ignored when div=1                                                */
      __IOM uint32_t ENABLE     : 1;            /*!< [3..3] enable the phase-shifted output
                                                     this can be changed on-the-fly                                            */
      __IOM uint32_t PASSWD     : 8;            /*!< [11..4] set to 0xaa0
                                                     any other value enables the output with shift=0                           */
            uint32_t            : 20;
    } bit;
  } PHASE;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000018) Ring Oscillator Status                                     */
    
    struct {
            uint32_t            : 12;
      __IM  uint32_t ENABLED    : 1;            /*!< [12..12] Oscillator is enabled but not necessarily running and
                                                     stable
                                                     this resets to 0 but transitions to 1 during chip startup                 */
            uint32_t            : 3;
      __IM  uint32_t DIV_RUNNING : 1;           /*!< [16..16] post-divider is running
                                                     this resets to 0 but transitions to 1 during chip startup                 */
            uint32_t            : 7;
      __IOM uint32_t BADWRITE   : 1;            /*!< [24..24] An invalid value has been written to CTRL_ENABLE or
                                                     CTRL_FREQ_RANGE or FRFEQA or FREQB or DORMANT                             */
            uint32_t            : 6;
      __IM  uint32_t STABLE     : 1;            /*!< [31..31] Oscillator is running and stable                                 */
    } bit;
  } STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000001C) This just reads the state of the oscillator output
                                                                    so randomness is compromised if the ring
                                                                    oscillator is stopped or run at a harmonic
                                                                    of the bus frequency                                       */
    
    struct {
      __IM  uint32_t RANDOMBIT  : 1;            /*!< [0..0] RANDOMBIT                                                          */
            uint32_t            : 31;
    } bit;
  } RANDOMBIT;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000020) A down counter running at the ROSC frequency
                                                                    which counts to zero and stops.
                                                                    To start the counter write a non-zero value.
                                                                    Can be used for short software pauses when
                                                                    setting up time sensitive hardware.                        */
    
    struct {
      __IOM uint32_t COUNT      : 8;            /*!< [7..0] COUNT                                                              */
            uint32_t            : 24;
    } bit;
  } COUNT;
} ROSC_Type;                                    /*!< Size = 36 (0x24)                                                          */



/* =========================================================================================================================== */
/* ================                                    VREG_AND_CHIP_RESET                                    ================ */
/* =========================================================================================================================== */


/**
  * @brief control and status for on-chip voltage regulator and chip level reset subsystem (VREG_AND_CHIP_RESET)
  */

typedef struct {                                /*!< (@ 0x40064000) VREG_AND_CHIP_RESET Structure                              */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000000) Voltage regulator control and status                       */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] enable
                                                     0=not enabled, 1=enabled                                                  */
      __IOM uint32_t HIZ        : 1;            /*!< [1..1] high impedance mode select
                                                     0=not in high impedance mode, 1=in high impedance mode                    */
            uint32_t            : 2;
      __IOM uint32_t VSEL       : 4;            /*!< [7..4] output voltage select
                                                     0000 to 0101 - 0.80V
                                                     0110 - 0.85V
                                                     0111 - 0.90V
                                                     1000 - 0.95V
                                                     1001 - 1.00V
                                                     1010 - 1.05V
                                                     1011 - 1.10V (default)
                                                     1100 - 1.15V
                                                     1101 - 1.20V
                                                     1110 - 1.25V
                                                     1111 - 1.30V                                                              */
            uint32_t            : 4;
      __IM  uint32_t ROK        : 1;            /*!< [12..12] regulation status
                                                     0=not in regulation, 1=in regulation                                      */
            uint32_t            : 19;
    } bit;
  } VREG;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000004) brown-out detection control                                */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] enable
                                                     0=not enabled, 1=enabled                                                  */
            uint32_t            : 3;
      __IOM uint32_t VSEL       : 4;            /*!< [7..4] threshold select
                                                     0000 - 0.473V
                                                     0001 - 0.516V
                                                     0010 - 0.559V
                                                     0011 - 0.602V
                                                     0100 - 0.645V
                                                     0101 - 0.688V
                                                     0110 - 0.731V
                                                     0111 - 0.774V
                                                     1000 - 0.817V
                                                     1001 - 0.860V (default)
                                                     1010 - 0.903V
                                                     1011 - 0.946V
                                                     1100 - 0.989V
                                                     1101 - 1.032V
                                                     1                                                                         */
            uint32_t            : 24;
    } bit;
  } BOD;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000008) Chip reset control and status                              */
    
    struct {
            uint32_t            : 8;
      __IM  uint32_t HAD_POR    : 1;            /*!< [8..8] Last reset was from the power-on reset or brown-out detection
                                                     blocks                                                                    */
            uint32_t            : 7;
      __IM  uint32_t HAD_RUN    : 1;            /*!< [16..16] Last reset was from the RUN pin                                  */
            uint32_t            : 3;
      __IM  uint32_t HAD_PSM_RESTART : 1;       /*!< [20..20] Last reset was from the debug port                               */
            uint32_t            : 3;
      __IOM uint32_t PSM_RESTART_FLAG : 1;      /*!< [24..24] This is set by psm_restart from the debugger.
                                                     Its purpose is to branch bootcode to a safe mode when the
                                                     debugger has issued a psm_restart in order to recover from
                                                     a boot lock-up.
                                                     In the safe mode the debugger can repair the boot code,
                                                     clear this flag then reboot the processor.                                */
            uint32_t            : 7;
    } bit;
  } CHIP_RESET;
} VREG_AND_CHIP_RESET_Type;                     /*!< Size = 12 (0xc)                                                           */



/* =========================================================================================================================== */
/* ================                                           TBMAN                                           ================ */
/* =========================================================================================================================== */


/**
  * @brief Testbench manager. Allows the programmer to know what platform their software is running on. (TBMAN)
  */

typedef struct {                                /*!< (@ 0x4006C000) TBMAN Structure                                            */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000000) Indicates the type of platform in use                      */
    
    struct {
      __IM  uint32_t ASIC       : 1;            /*!< [0..0] Indicates the platform is an ASIC                                  */
      __IM  uint32_t FPGA       : 1;            /*!< [1..1] Indicates the platform is an FPGA                                  */
            uint32_t            : 30;
    } bit;
  } PLATFORM;
} TBMAN_Type;                                   /*!< Size = 4 (0x4)                                                            */



/* =========================================================================================================================== */
/* ================                                            DMA                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief DMA with separate read and write masters (DMA)
  */

typedef struct {                                /*!< (@ 0x50000000) DMA Structure                                              */
  __IOM uint32_t  CH0_READ_ADDR;                /*!< (@ 0x00000000) DMA Channel 0 Read Address pointer
                                                                    This register updates automatically each
                                                                    time a read completes. The current value
                                                                    is the next address to be read by this channel.            */
  __IOM uint32_t  CH0_WRITE_ADDR;               /*!< (@ 0x00000004) DMA Channel 0 Write Address pointer
                                                                    This register updates automatically each
                                                                    time a write completes. The current value
                                                                    is the next address to be written by this
                                                                    channel.                                                   */
  __IOM uint32_t  CH0_TRANS_COUNT;              /*!< (@ 0x00000008) DMA Channel 0 Transfer Count
                                                                    Program the number of bus transfers a channel
                                                                    will perform before halting. Note that,
                                                                    if transfers are larger than one byte in
                                                                    size, this is not equal to the number of
                                                                    bytes transferred (see CTRL_DATA_SIZE).
                                                                    
                                                                    When the channel is active, reading this
                                                                    register shows the number of transfers remaining,
                                                                    updating automatically each time a write
                                                                    transfer completes.
                                                                    
                                                                    Writing this register sets the RELOAD value
                                                                    for the tran                                               */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000000C) DMA Channel 0 Control and Status                           */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] DMA Channel Enable.
                                                     When 1, the channel will respond to triggering events,
                                                     which will cause it to become BUSY and start transferring
                                                     data. When 0, the channel will ignore triggers, stop issuing
                                                     transfers, and pause the current transfer sequence (i.e.
                                                     BUSY will remain high if already high)                                    */
      __IOM uint32_t HIGH_PRIORITY : 1;         /*!< [1..1] HIGH_PRIORITY gives a channel preferential treatment
                                                     in issue scheduling: in each scheduling round, all high
                                                     priority channels are considered first, and then only a
                                                     single low priority channel, before returning to the high
                                                     priority channels.
                                                     
                                                     This only affects the order in which the DMA schedules
                                                     channels. The DMA's bus priority is not changed. If the
                                                     DMA is not saturated then a low priority channel will see
                                                     no loss of throughput.                                                    */
      __IOM uint32_t DATA_SIZE  : 2;            /*!< [3..2] Set the size of each bus transfer (byte/halfword/word).
                                                     READ_ADDR and WRITE_ADDR advance by this amount (1/2/4
                                                     bytes) with each transfer.                                                */
      __IOM uint32_t INCR_READ  : 1;            /*!< [4..4] If 1, the read address increments with each transfer.
                                                     If 0, each read is directed to the same, initial address.
                                                     
                                                     Generally this should be disabled for peripheral-to-memory
                                                     transfers.                                                                */
      __IOM uint32_t INCR_WRITE : 1;            /*!< [5..5] If 1, the write address increments with each transfer.
                                                     If 0, each write is directed to the same, initial address.
                                                     
                                                     Generally this should be disabled for memory-to-peripheral
                                                     transfers.                                                                */
      __IOM uint32_t RING_SIZE  : 4;            /*!< [9..6] Size of address wrap region. If 0, don't wrap. For values
                                                     n > 0, only the lower n bits of the address will change.
                                                     This wraps the address on a (1 << n) byte boundary, facilitating
                                                     access to naturally-aligned ring buffers.
                                                     
                                                     Ring sizes between 2 and 32768 bytes are possible. This
                                                     can apply to either read or write addresses, based on value
                                                     of RING_SEL.                                                              */
      __IOM uint32_t RING_SEL   : 1;            /*!< [10..10] Select whether RING_SIZE applies to read or write addresses.
                                                     If 0, read addresses are wrapped on a (1 << RING_SIZE)
                                                     boundary. If 1, write addresses are wrapped.                              */
      __IOM uint32_t CHAIN_TO   : 4;            /*!< [14..11] When this channel completes, it will trigger the channel
                                                     indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this
                                                     channel)_.
                                                     Reset value is equal to channel number (0).                               */
      __IOM uint32_t TREQ_SEL   : 6;            /*!< [20..15] Select a Transfer Request signal.
                                                     The channel uses the transfer request signal to pace its
                                                     data transfer rate. Sources for TREQ signals are internal
                                                     (TIMERS) or external (DREQ, a Data Request from the system).
                                                     0x0 to 0x3a -> select DREQ n as TREQ                                      */
      __IOM uint32_t IRQ_QUIET  : 1;            /*!< [21..21] In QUIET mode, the channel does not generate IRQs at
                                                     the end of every transfer block. Instead, an IRQ is raised
                                                     when NULL is written to a trigger register, indicating
                                                     the end of a control block chain.
                                                     
                                                     This reduces the number of interrupts to be serviced by
                                                     the CPU when transferring a DMA chain of many small control
                                                     blocks.                                                                   */
      __IOM uint32_t BSWAP      : 1;            /*!< [22..22] Apply byte-swap transformation to DMA data.
                                                     For byte data, this has no effect. For halfword data, the
                                                     two bytes of each halfword are swapped. For word data,
                                                     the four bytes of each word are swapped to reverse order.                 */
      __IOM uint32_t SNIFF_EN   : 1;            /*!< [23..23] If 1, this channel's data transfers are visible to
                                                     the sniff hardware, and each transfer will advance the
                                                     state of the checksum. This only applies if the sniff hardware
                                                     is enabled, and has this channel selected.
                                                     
                                                     This allows checksum to be enabled or disabled on a per-control-
                                                     block basis.                                                              */
      __IM  uint32_t BUSY       : 1;            /*!< [24..24] This flag goes high when the channel starts a new transfer
                                                     sequence, and low when the last transfer of that sequence
                                                     completes. Clearing EN while BUSY is high pauses the channel,
                                                     and BUSY will stay high while paused.
                                                     
                                                     To terminate a sequence early (and clear the BUSY flag),
                                                     see CHAN_ABORT.                                                           */
            uint32_t            : 4;
      __IOM uint32_t WRITE_ERROR : 1;           /*!< [29..29] If 1, the channel received a write bus error. Write
                                                     one to clear.
                                                     WRITE_ADDR shows the approximate address where the bus
                                                     error was encountered (will not to be earlier, or more
                                                     than 5 transfers later)                                                   */
      __IOM uint32_t READ_ERROR : 1;            /*!< [30..30] If 1, the channel received a read bus error. Write
                                                     one to clear.
                                                     READ_ADDR shows the approximate address where the bus error
                                                     was encountered (will not to be earlier, or more than 3
                                                     transfers later)                                                          */
      __IM  uint32_t AHB_ERROR  : 1;            /*!< [31..31] Logical OR of the READ_ERROR and WRITE_ERROR flags.
                                                     The channel halts when it encounters any bus error, and
                                                     always raises its channel IRQ flag.                                       */
    } bit;
  } CH0_CTRL_TRIG;
  __IM  uint32_t  CH0_AL1_CTRL;                 /*!< (@ 0x00000010) Alias for channel 0 CTRL register                          */
  __IM  uint32_t  CH0_AL1_READ_ADDR;            /*!< (@ 0x00000014) Alias for channel 0 READ_ADDR register                     */
  __IM  uint32_t  CH0_AL1_WRITE_ADDR;           /*!< (@ 0x00000018) Alias for channel 0 WRITE_ADDR register                    */
  __IM  uint32_t  CH0_AL1_TRANS_COUNT_TRIG;     /*!< (@ 0x0000001C) Alias for channel 0 TRANS_COUNT register
                                                                    This is a trigger register (0xc). Writing
                                                                    a nonzero value will
                                                                    reload the channel counter and start the
                                                                    channel.                                                   */
  __IM  uint32_t  CH0_AL2_CTRL;                 /*!< (@ 0x00000020) Alias for channel 0 CTRL register                          */
  __IM  uint32_t  CH0_AL2_TRANS_COUNT;          /*!< (@ 0x00000024) Alias for channel 0 TRANS_COUNT register                   */
  __IM  uint32_t  CH0_AL2_READ_ADDR;            /*!< (@ 0x00000028) Alias for channel 0 READ_ADDR register                     */
  __IM  uint32_t  CH0_AL2_WRITE_ADDR_TRIG;      /*!< (@ 0x0000002C) Alias for channel 0 WRITE_ADDR register
                                                                    This is a trigger register (0xc). Writing
                                                                    a nonzero value will
                                                                    reload the channel counter and start the
                                                                    channel.                                                   */
  __IM  uint32_t  CH0_AL3_CTRL;                 /*!< (@ 0x00000030) Alias for channel 0 CTRL register                          */
  __IM  uint32_t  CH0_AL3_WRITE_ADDR;           /*!< (@ 0x00000034) Alias for channel 0 WRITE_ADDR register                    */
  __IM  uint32_t  CH0_AL3_TRANS_COUNT;          /*!< (@ 0x00000038) Alias for channel 0 TRANS_COUNT register                   */
  __IM  uint32_t  CH0_AL3_READ_ADDR_TRIG;       /*!< (@ 0x0000003C) Alias for channel 0 READ_ADDR register
                                                                    This is a trigger register (0xc). Writing
                                                                    a nonzero value will
                                                                    reload the channel counter and start the
                                                                    channel.                                                   */
  __IOM uint32_t  CH1_READ_ADDR;                /*!< (@ 0x00000040) DMA Channel 1 Read Address pointer
                                                                    This register updates automatically each
                                                                    time a read completes. The current value
                                                                    is the next address to be read by this channel.            */
  __IOM uint32_t  CH1_WRITE_ADDR;               /*!< (@ 0x00000044) DMA Channel 1 Write Address pointer
                                                                    This register updates automatically each
                                                                    time a write completes. The current value
                                                                    is the next address to be written by this
                                                                    channel.                                                   */
  __IOM uint32_t  CH1_TRANS_COUNT;              /*!< (@ 0x00000048) DMA Channel 1 Transfer Count
                                                                    Program the number of bus transfers a channel
                                                                    will perform before halting. Note that,
                                                                    if transfers are larger than one byte in
                                                                    size, this is not equal to the number of
                                                                    bytes transferred (see CTRL_DATA_SIZE).
                                                                    
                                                                    When the channel is active, reading this
                                                                    register shows the number of transfers remaining,
                                                                    updating automatically each time a write
                                                                    transfer completes.
                                                                    
                                                                    Writing this register sets the RELOAD value
                                                                    for the tran                                               */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000004C) DMA Channel 1 Control and Status                           */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] DMA Channel Enable.
                                                     When 1, the channel will respond to triggering events,
                                                     which will cause it to become BUSY and start transferring
                                                     data. When 0, the channel will ignore triggers, stop issuing
                                                     transfers, and pause the current transfer sequence (i.e.
                                                     BUSY will remain high if already high)                                    */
      __IOM uint32_t HIGH_PRIORITY : 1;         /*!< [1..1] HIGH_PRIORITY gives a channel preferential treatment
                                                     in issue scheduling: in each scheduling round, all high
                                                     priority channels are considered first, and then only a
                                                     single low priority channel, before returning to the high
                                                     priority channels.
                                                     
                                                     This only affects the order in which the DMA schedules
                                                     channels. The DMA's bus priority is not changed. If the
                                                     DMA is not saturated then a low priority channel will see
                                                     no loss of throughput.                                                    */
      __IOM uint32_t DATA_SIZE  : 2;            /*!< [3..2] Set the size of each bus transfer (byte/halfword/word).
                                                     READ_ADDR and WRITE_ADDR advance by this amount (1/2/4
                                                     bytes) with each transfer.                                                */
      __IOM uint32_t INCR_READ  : 1;            /*!< [4..4] If 1, the read address increments with each transfer.
                                                     If 0, each read is directed to the same, initial address.
                                                     
                                                     Generally this should be disabled for peripheral-to-memory
                                                     transfers.                                                                */
      __IOM uint32_t INCR_WRITE : 1;            /*!< [5..5] If 1, the write address increments with each transfer.
                                                     If 0, each write is directed to the same, initial address.
                                                     
                                                     Generally this should be disabled for memory-to-peripheral
                                                     transfers.                                                                */
      __IOM uint32_t RING_SIZE  : 4;            /*!< [9..6] Size of address wrap region. If 0, don't wrap. For values
                                                     n > 0, only the lower n bits of the address will change.
                                                     This wraps the address on a (1 << n) byte boundary, facilitating
                                                     access to naturally-aligned ring buffers.
                                                     
                                                     Ring sizes between 2 and 32768 bytes are possible. This
                                                     can apply to either read or write addresses, based on value
                                                     of RING_SEL.                                                              */
      __IOM uint32_t RING_SEL   : 1;            /*!< [10..10] Select whether RING_SIZE applies to read or write addresses.
                                                     If 0, read addresses are wrapped on a (1 << RING_SIZE)
                                                     boundary. If 1, write addresses are wrapped.                              */
      __IOM uint32_t CHAIN_TO   : 4;            /*!< [14..11] When this channel completes, it will trigger the channel
                                                     indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this
                                                     channel)_.
                                                     Reset value is equal to channel number (1).                               */
      __IOM uint32_t TREQ_SEL   : 6;            /*!< [20..15] Select a Transfer Request signal.
                                                     The channel uses the transfer request signal to pace its
                                                     data transfer rate. Sources for TREQ signals are internal
                                                     (TIMERS) or external (DREQ, a Data Request from the system).
                                                     0x0 to 0x3a -> select DREQ n as TREQ                                      */
      __IOM uint32_t IRQ_QUIET  : 1;            /*!< [21..21] In QUIET mode, the channel does not generate IRQs at
                                                     the end of every transfer block. Instead, an IRQ is raised
                                                     when NULL is written to a trigger register, indicating
                                                     the end of a control block chain.
                                                     
                                                     This reduces the number of interrupts to be serviced by
                                                     the CPU when transferring a DMA chain of many small control
                                                     blocks.                                                                   */
      __IOM uint32_t BSWAP      : 1;            /*!< [22..22] Apply byte-swap transformation to DMA data.
                                                     For byte data, this has no effect. For halfword data, the
                                                     two bytes of each halfword are swapped. For word data,
                                                     the four bytes of each word are swapped to reverse order.                 */
      __IOM uint32_t SNIFF_EN   : 1;            /*!< [23..23] If 1, this channel's data transfers are visible to
                                                     the sniff hardware, and each transfer will advance the
                                                     state of the checksum. This only applies if the sniff hardware
                                                     is enabled, and has this channel selected.
                                                     
                                                     This allows checksum to be enabled or disabled on a per-control-
                                                     block basis.                                                              */
      __IM  uint32_t BUSY       : 1;            /*!< [24..24] This flag goes high when the channel starts a new transfer
                                                     sequence, and low when the last transfer of that sequence
                                                     completes. Clearing EN while BUSY is high pauses the channel,
                                                     and BUSY will stay high while paused.
                                                     
                                                     To terminate a sequence early (and clear the BUSY flag),
                                                     see CHAN_ABORT.                                                           */
            uint32_t            : 4;
      __IOM uint32_t WRITE_ERROR : 1;           /*!< [29..29] If 1, the channel received a write bus error. Write
                                                     one to clear.
                                                     WRITE_ADDR shows the approximate address where the bus
                                                     error was encountered (will not to be earlier, or more
                                                     than 5 transfers later)                                                   */
      __IOM uint32_t READ_ERROR : 1;            /*!< [30..30] If 1, the channel received a read bus error. Write
                                                     one to clear.
                                                     READ_ADDR shows the approximate address where the bus error
                                                     was encountered (will not to be earlier, or more than 3
                                                     transfers later)                                                          */
      __IM  uint32_t AHB_ERROR  : 1;            /*!< [31..31] Logical OR of the READ_ERROR and WRITE_ERROR flags.
                                                     The channel halts when it encounters any bus error, and
                                                     always raises its channel IRQ flag.                                       */
    } bit;
  } CH1_CTRL_TRIG;
  __IM  uint32_t  CH1_AL1_CTRL;                 /*!< (@ 0x00000050) Alias for channel 1 CTRL register                          */
  __IM  uint32_t  CH1_AL1_READ_ADDR;            /*!< (@ 0x00000054) Alias for channel 1 READ_ADDR register                     */
  __IM  uint32_t  CH1_AL1_WRITE_ADDR;           /*!< (@ 0x00000058) Alias for channel 1 WRITE_ADDR register                    */
  __IM  uint32_t  CH1_AL1_TRANS_COUNT_TRIG;     /*!< (@ 0x0000005C) Alias for channel 1 TRANS_COUNT register
                                                                    This is a trigger register (0xc). Writing
                                                                    a nonzero value will
                                                                    reload the channel counter and start the
                                                                    channel.                                                   */
  __IM  uint32_t  CH1_AL2_CTRL;                 /*!< (@ 0x00000060) Alias for channel 1 CTRL register                          */
  __IM  uint32_t  CH1_AL2_TRANS_COUNT;          /*!< (@ 0x00000064) Alias for channel 1 TRANS_COUNT register                   */
  __IM  uint32_t  CH1_AL2_READ_ADDR;            /*!< (@ 0x00000068) Alias for channel 1 READ_ADDR register                     */
  __IM  uint32_t  CH1_AL2_WRITE_ADDR_TRIG;      /*!< (@ 0x0000006C) Alias for channel 1 WRITE_ADDR register
                                                                    This is a trigger register (0xc). Writing
                                                                    a nonzero value will
                                                                    reload the channel counter and start the
                                                                    channel.                                                   */
  __IM  uint32_t  CH1_AL3_CTRL;                 /*!< (@ 0x00000070) Alias for channel 1 CTRL register                          */
  __IM  uint32_t  CH1_AL3_WRITE_ADDR;           /*!< (@ 0x00000074) Alias for channel 1 WRITE_ADDR register                    */
  __IM  uint32_t  CH1_AL3_TRANS_COUNT;          /*!< (@ 0x00000078) Alias for channel 1 TRANS_COUNT register                   */
  __IM  uint32_t  CH1_AL3_READ_ADDR_TRIG;       /*!< (@ 0x0000007C) Alias for channel 1 READ_ADDR register
                                                                    This is a trigger register (0xc). Writing
                                                                    a nonzero value will
                                                                    reload the channel counter and start the
                                                                    channel.                                                   */
  __IOM uint32_t  CH2_READ_ADDR;                /*!< (@ 0x00000080) DMA Channel 2 Read Address pointer
                                                                    This register updates automatically each
                                                                    time a read completes. The current value
                                                                    is the next address to be read by this channel.            */
  __IOM uint32_t  CH2_WRITE_ADDR;               /*!< (@ 0x00000084) DMA Channel 2 Write Address pointer
                                                                    This register updates automatically each
                                                                    time a write completes. The current value
                                                                    is the next address to be written by this
                                                                    channel.                                                   */
  __IOM uint32_t  CH2_TRANS_COUNT;              /*!< (@ 0x00000088) DMA Channel 2 Transfer Count
                                                                    Program the number of bus transfers a channel
                                                                    will perform before halting. Note that,
                                                                    if transfers are larger than one byte in
                                                                    size, this is not equal to the number of
                                                                    bytes transferred (see CTRL_DATA_SIZE).
                                                                    
                                                                    When the channel is active, reading this
                                                                    register shows the number of transfers remaining,
                                                                    updating automatically each time a write
                                                                    transfer completes.
                                                                    
                                                                    Writing this register sets the RELOAD value
                                                                    for the tran                                               */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000008C) DMA Channel 2 Control and Status                           */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] DMA Channel Enable.
                                                     When 1, the channel will respond to triggering events,
                                                     which will cause it to become BUSY and start transferring
                                                     data. When 0, the channel will ignore triggers, stop issuing
                                                     transfers, and pause the current transfer sequence (i.e.
                                                     BUSY will remain high if already high)                                    */
      __IOM uint32_t HIGH_PRIORITY : 1;         /*!< [1..1] HIGH_PRIORITY gives a channel preferential treatment
                                                     in issue scheduling: in each scheduling round, all high
                                                     priority channels are considered first, and then only a
                                                     single low priority channel, before returning to the high
                                                     priority channels.
                                                     
                                                     This only affects the order in which the DMA schedules
                                                     channels. The DMA's bus priority is not changed. If the
                                                     DMA is not saturated then a low priority channel will see
                                                     no loss of throughput.                                                    */
      __IOM uint32_t DATA_SIZE  : 2;            /*!< [3..2] Set the size of each bus transfer (byte/halfword/word).
                                                     READ_ADDR and WRITE_ADDR advance by this amount (1/2/4
                                                     bytes) with each transfer.                                                */
      __IOM uint32_t INCR_READ  : 1;            /*!< [4..4] If 1, the read address increments with each transfer.
                                                     If 0, each read is directed to the same, initial address.
                                                     
                                                     Generally this should be disabled for peripheral-to-memory
                                                     transfers.                                                                */
      __IOM uint32_t INCR_WRITE : 1;            /*!< [5..5] If 1, the write address increments with each transfer.
                                                     If 0, each write is directed to the same, initial address.
                                                     
                                                     Generally this should be disabled for memory-to-peripheral
                                                     transfers.                                                                */
      __IOM uint32_t RING_SIZE  : 4;            /*!< [9..6] Size of address wrap region. If 0, don't wrap. For values
                                                     n > 0, only the lower n bits of the address will change.
                                                     This wraps the address on a (1 << n) byte boundary, facilitating
                                                     access to naturally-aligned ring buffers.
                                                     
                                                     Ring sizes between 2 and 32768 bytes are possible. This
                                                     can apply to either read or write addresses, based on value
                                                     of RING_SEL.                                                              */
      __IOM uint32_t RING_SEL   : 1;            /*!< [10..10] Select whether RING_SIZE applies to read or write addresses.
                                                     If 0, read addresses are wrapped on a (1 << RING_SIZE)
                                                     boundary. If 1, write addresses are wrapped.                              */
      __IOM uint32_t CHAIN_TO   : 4;            /*!< [14..11] When this channel completes, it will trigger the channel
                                                     indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this
                                                     channel)_.
                                                     Reset value is equal to channel number (2).                               */
      __IOM uint32_t TREQ_SEL   : 6;            /*!< [20..15] Select a Transfer Request signal.
                                                     The channel uses the transfer request signal to pace its
                                                     data transfer rate. Sources for TREQ signals are internal
                                                     (TIMERS) or external (DREQ, a Data Request from the system).
                                                     0x0 to 0x3a -> select DREQ n as TREQ                                      */
      __IOM uint32_t IRQ_QUIET  : 1;            /*!< [21..21] In QUIET mode, the channel does not generate IRQs at
                                                     the end of every transfer block. Instead, an IRQ is raised
                                                     when NULL is written to a trigger register, indicating
                                                     the end of a control block chain.
                                                     
                                                     This reduces the number of interrupts to be serviced by
                                                     the CPU when transferring a DMA chain of many small control
                                                     blocks.                                                                   */
      __IOM uint32_t BSWAP      : 1;            /*!< [22..22] Apply byte-swap transformation to DMA data.
                                                     For byte data, this has no effect. For halfword data, the
                                                     two bytes of each halfword are swapped. For word data,
                                                     the four bytes of each word are swapped to reverse order.                 */
      __IOM uint32_t SNIFF_EN   : 1;            /*!< [23..23] If 1, this channel's data transfers are visible to
                                                     the sniff hardware, and each transfer will advance the
                                                     state of the checksum. This only applies if the sniff hardware
                                                     is enabled, and has this channel selected.
                                                     
                                                     This allows checksum to be enabled or disabled on a per-control-
                                                     block basis.                                                              */
      __IM  uint32_t BUSY       : 1;            /*!< [24..24] This flag goes high when the channel starts a new transfer
                                                     sequence, and low when the last transfer of that sequence
                                                     completes. Clearing EN while BUSY is high pauses the channel,
                                                     and BUSY will stay high while paused.
                                                     
                                                     To terminate a sequence early (and clear the BUSY flag),
                                                     see CHAN_ABORT.                                                           */
            uint32_t            : 4;
      __IOM uint32_t WRITE_ERROR : 1;           /*!< [29..29] If 1, the channel received a write bus error. Write
                                                     one to clear.
                                                     WRITE_ADDR shows the approximate address where the bus
                                                     error was encountered (will not to be earlier, or more
                                                     than 5 transfers later)                                                   */
      __IOM uint32_t READ_ERROR : 1;            /*!< [30..30] If 1, the channel received a read bus error. Write
                                                     one to clear.
                                                     READ_ADDR shows the approximate address where the bus error
                                                     was encountered (will not to be earlier, or more than 3
                                                     transfers later)                                                          */
      __IM  uint32_t AHB_ERROR  : 1;            /*!< [31..31] Logical OR of the READ_ERROR and WRITE_ERROR flags.
                                                     The channel halts when it encounters any bus error, and
                                                     always raises its channel IRQ flag.                                       */
    } bit;
  } CH2_CTRL_TRIG;
  __IM  uint32_t  CH2_AL1_CTRL;                 /*!< (@ 0x00000090) Alias for channel 2 CTRL register                          */
  __IM  uint32_t  CH2_AL1_READ_ADDR;            /*!< (@ 0x00000094) Alias for channel 2 READ_ADDR register                     */
  __IM  uint32_t  CH2_AL1_WRITE_ADDR;           /*!< (@ 0x00000098) Alias for channel 2 WRITE_ADDR register                    */
  __IM  uint32_t  CH2_AL1_TRANS_COUNT_TRIG;     /*!< (@ 0x0000009C) Alias for channel 2 TRANS_COUNT register
                                                                    This is a trigger register (0xc). Writing
                                                                    a nonzero value will
                                                                    reload the channel counter and start the
                                                                    channel.                                                   */
  __IM  uint32_t  CH2_AL2_CTRL;                 /*!< (@ 0x000000A0) Alias for channel 2 CTRL register                          */
  __IM  uint32_t  CH2_AL2_TRANS_COUNT;          /*!< (@ 0x000000A4) Alias for channel 2 TRANS_COUNT register                   */
  __IM  uint32_t  CH2_AL2_READ_ADDR;            /*!< (@ 0x000000A8) Alias for channel 2 READ_ADDR register                     */
  __IM  uint32_t  CH2_AL2_WRITE_ADDR_TRIG;      /*!< (@ 0x000000AC) Alias for channel 2 WRITE_ADDR register
                                                                    This is a trigger register (0xc). Writing
                                                                    a nonzero value will
                                                                    reload the channel counter and start the
                                                                    channel.                                                   */
  __IM  uint32_t  CH2_AL3_CTRL;                 /*!< (@ 0x000000B0) Alias for channel 2 CTRL register                          */
  __IM  uint32_t  CH2_AL3_WRITE_ADDR;           /*!< (@ 0x000000B4) Alias for channel 2 WRITE_ADDR register                    */
  __IM  uint32_t  CH2_AL3_TRANS_COUNT;          /*!< (@ 0x000000B8) Alias for channel 2 TRANS_COUNT register                   */
  __IM  uint32_t  CH2_AL3_READ_ADDR_TRIG;       /*!< (@ 0x000000BC) Alias for channel 2 READ_ADDR register
                                                                    This is a trigger register (0xc). Writing
                                                                    a nonzero value will
                                                                    reload the channel counter and start the
                                                                    channel.                                                   */
  __IOM uint32_t  CH3_READ_ADDR;                /*!< (@ 0x000000C0) DMA Channel 3 Read Address pointer
                                                                    This register updates automatically each
                                                                    time a read completes. The current value
                                                                    is the next address to be read by this channel.            */
  __IOM uint32_t  CH3_WRITE_ADDR;               /*!< (@ 0x000000C4) DMA Channel 3 Write Address pointer
                                                                    This register updates automatically each
                                                                    time a write completes. The current value
                                                                    is the next address to be written by this
                                                                    channel.                                                   */
  __IOM uint32_t  CH3_TRANS_COUNT;              /*!< (@ 0x000000C8) DMA Channel 3 Transfer Count
                                                                    Program the number of bus transfers a channel
                                                                    will perform before halting. Note that,
                                                                    if transfers are larger than one byte in
                                                                    size, this is not equal to the number of
                                                                    bytes transferred (see CTRL_DATA_SIZE).
                                                                    
                                                                    When the channel is active, reading this
                                                                    register shows the number of transfers remaining,
                                                                    updating automatically each time a write
                                                                    transfer completes.
                                                                    
                                                                    Writing this register sets the RELOAD value
                                                                    for the tran                                               */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000CC) DMA Channel 3 Control and Status                           */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] DMA Channel Enable.
                                                     When 1, the channel will respond to triggering events,
                                                     which will cause it to become BUSY and start transferring
                                                     data. When 0, the channel will ignore triggers, stop issuing
                                                     transfers, and pause the current transfer sequence (i.e.
                                                     BUSY will remain high if already high)                                    */
      __IOM uint32_t HIGH_PRIORITY : 1;         /*!< [1..1] HIGH_PRIORITY gives a channel preferential treatment
                                                     in issue scheduling: in each scheduling round, all high
                                                     priority channels are considered first, and then only a
                                                     single low priority channel, before returning to the high
                                                     priority channels.
                                                     
                                                     This only affects the order in which the DMA schedules
                                                     channels. The DMA's bus priority is not changed. If the
                                                     DMA is not saturated then a low priority channel will see
                                                     no loss of throughput.                                                    */
      __IOM uint32_t DATA_SIZE  : 2;            /*!< [3..2] Set the size of each bus transfer (byte/halfword/word).
                                                     READ_ADDR and WRITE_ADDR advance by this amount (1/2/4
                                                     bytes) with each transfer.                                                */
      __IOM uint32_t INCR_READ  : 1;            /*!< [4..4] If 1, the read address increments with each transfer.
                                                     If 0, each read is directed to the same, initial address.
                                                     
                                                     Generally this should be disabled for peripheral-to-memory
                                                     transfers.                                                                */
      __IOM uint32_t INCR_WRITE : 1;            /*!< [5..5] If 1, the write address increments with each transfer.
                                                     If 0, each write is directed to the same, initial address.
                                                     
                                                     Generally this should be disabled for memory-to-peripheral
                                                     transfers.                                                                */
      __IOM uint32_t RING_SIZE  : 4;            /*!< [9..6] Size of address wrap region. If 0, don't wrap. For values
                                                     n > 0, only the lower n bits of the address will change.
                                                     This wraps the address on a (1 << n) byte boundary, facilitating
                                                     access to naturally-aligned ring buffers.
                                                     
                                                     Ring sizes between 2 and 32768 bytes are possible. This
                                                     can apply to either read or write addresses, based on value
                                                     of RING_SEL.                                                              */
      __IOM uint32_t RING_SEL   : 1;            /*!< [10..10] Select whether RING_SIZE applies to read or write addresses.
                                                     If 0, read addresses are wrapped on a (1 << RING_SIZE)
                                                     boundary. If 1, write addresses are wrapped.                              */
      __IOM uint32_t CHAIN_TO   : 4;            /*!< [14..11] When this channel completes, it will trigger the channel
                                                     indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this
                                                     channel)_.
                                                     Reset value is equal to channel number (3).                               */
      __IOM uint32_t TREQ_SEL   : 6;            /*!< [20..15] Select a Transfer Request signal.
                                                     The channel uses the transfer request signal to pace its
                                                     data transfer rate. Sources for TREQ signals are internal
                                                     (TIMERS) or external (DREQ, a Data Request from the system).
                                                     0x0 to 0x3a -> select DREQ n as TREQ                                      */
      __IOM uint32_t IRQ_QUIET  : 1;            /*!< [21..21] In QUIET mode, the channel does not generate IRQs at
                                                     the end of every transfer block. Instead, an IRQ is raised
                                                     when NULL is written to a trigger register, indicating
                                                     the end of a control block chain.
                                                     
                                                     This reduces the number of interrupts to be serviced by
                                                     the CPU when transferring a DMA chain of many small control
                                                     blocks.                                                                   */
      __IOM uint32_t BSWAP      : 1;            /*!< [22..22] Apply byte-swap transformation to DMA data.
                                                     For byte data, this has no effect. For halfword data, the
                                                     two bytes of each halfword are swapped. For word data,
                                                     the four bytes of each word are swapped to reverse order.                 */
      __IOM uint32_t SNIFF_EN   : 1;            /*!< [23..23] If 1, this channel's data transfers are visible to
                                                     the sniff hardware, and each transfer will advance the
                                                     state of the checksum. This only applies if the sniff hardware
                                                     is enabled, and has this channel selected.
                                                     
                                                     This allows checksum to be enabled or disabled on a per-control-
                                                     block basis.                                                              */
      __IM  uint32_t BUSY       : 1;            /*!< [24..24] This flag goes high when the channel starts a new transfer
                                                     sequence, and low when the last transfer of that sequence
                                                     completes. Clearing EN while BUSY is high pauses the channel,
                                                     and BUSY will stay high while paused.
                                                     
                                                     To terminate a sequence early (and clear the BUSY flag),
                                                     see CHAN_ABORT.                                                           */
            uint32_t            : 4;
      __IOM uint32_t WRITE_ERROR : 1;           /*!< [29..29] If 1, the channel received a write bus error. Write
                                                     one to clear.
                                                     WRITE_ADDR shows the approximate address where the bus
                                                     error was encountered (will not to be earlier, or more
                                                     than 5 transfers later)                                                   */
      __IOM uint32_t READ_ERROR : 1;            /*!< [30..30] If 1, the channel received a read bus error. Write
                                                     one to clear.
                                                     READ_ADDR shows the approximate address where the bus error
                                                     was encountered (will not to be earlier, or more than 3
                                                     transfers later)                                                          */
      __IM  uint32_t AHB_ERROR  : 1;            /*!< [31..31] Logical OR of the READ_ERROR and WRITE_ERROR flags.
                                                     The channel halts when it encounters any bus error, and
                                                     always raises its channel IRQ flag.                                       */
    } bit;
  } CH3_CTRL_TRIG;
  __IM  uint32_t  CH3_AL1_CTRL;                 /*!< (@ 0x000000D0) Alias for channel 3 CTRL register                          */
  __IM  uint32_t  CH3_AL1_READ_ADDR;            /*!< (@ 0x000000D4) Alias for channel 3 READ_ADDR register                     */
  __IM  uint32_t  CH3_AL1_WRITE_ADDR;           /*!< (@ 0x000000D8) Alias for channel 3 WRITE_ADDR register                    */
  __IM  uint32_t  CH3_AL1_TRANS_COUNT_TRIG;     /*!< (@ 0x000000DC) Alias for channel 3 TRANS_COUNT register
                                                                    This is a trigger register (0xc). Writing
                                                                    a nonzero value will
                                                                    reload the channel counter and start the
                                                                    channel.                                                   */
  __IM  uint32_t  CH3_AL2_CTRL;                 /*!< (@ 0x000000E0) Alias for channel 3 CTRL register                          */
  __IM  uint32_t  CH3_AL2_TRANS_COUNT;          /*!< (@ 0x000000E4) Alias for channel 3 TRANS_COUNT register                   */
  __IM  uint32_t  CH3_AL2_READ_ADDR;            /*!< (@ 0x000000E8) Alias for channel 3 READ_ADDR register                     */
  __IM  uint32_t  CH3_AL2_WRITE_ADDR_TRIG;      /*!< (@ 0x000000EC) Alias for channel 3 WRITE_ADDR register
                                                                    This is a trigger register (0xc). Writing
                                                                    a nonzero value will
                                                                    reload the channel counter and start the
                                                                    channel.                                                   */
  __IM  uint32_t  CH3_AL3_CTRL;                 /*!< (@ 0x000000F0) Alias for channel 3 CTRL register                          */
  __IM  uint32_t  CH3_AL3_WRITE_ADDR;           /*!< (@ 0x000000F4) Alias for channel 3 WRITE_ADDR register                    */
  __IM  uint32_t  CH3_AL3_TRANS_COUNT;          /*!< (@ 0x000000F8) Alias for channel 3 TRANS_COUNT register                   */
  __IM  uint32_t  CH3_AL3_READ_ADDR_TRIG;       /*!< (@ 0x000000FC) Alias for channel 3 READ_ADDR register
                                                                    This is a trigger register (0xc). Writing
                                                                    a nonzero value will
                                                                    reload the channel counter and start the
                                                                    channel.                                                   */
  __IOM uint32_t  CH4_READ_ADDR;                /*!< (@ 0x00000100) DMA Channel 4 Read Address pointer
                                                                    This register updates automatically each
                                                                    time a read completes. The current value
                                                                    is the next address to be read by this channel.            */
  __IOM uint32_t  CH4_WRITE_ADDR;               /*!< (@ 0x00000104) DMA Channel 4 Write Address pointer
                                                                    This register updates automatically each
                                                                    time a write completes. The current value
                                                                    is the next address to be written by this
                                                                    channel.                                                   */
  __IOM uint32_t  CH4_TRANS_COUNT;              /*!< (@ 0x00000108) DMA Channel 4 Transfer Count
                                                                    Program the number of bus transfers a channel
                                                                    will perform before halting. Note that,
                                                                    if transfers are larger than one byte in
                                                                    size, this is not equal to the number of
                                                                    bytes transferred (see CTRL_DATA_SIZE).
                                                                    
                                                                    When the channel is active, reading this
                                                                    register shows the number of transfers remaining,
                                                                    updating automatically each time a write
                                                                    transfer completes.
                                                                    
                                                                    Writing this register sets the RELOAD value
                                                                    for the tran                                               */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000010C) DMA Channel 4 Control and Status                           */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] DMA Channel Enable.
                                                     When 1, the channel will respond to triggering events,
                                                     which will cause it to become BUSY and start transferring
                                                     data. When 0, the channel will ignore triggers, stop issuing
                                                     transfers, and pause the current transfer sequence (i.e.
                                                     BUSY will remain high if already high)                                    */
      __IOM uint32_t HIGH_PRIORITY : 1;         /*!< [1..1] HIGH_PRIORITY gives a channel preferential treatment
                                                     in issue scheduling: in each scheduling round, all high
                                                     priority channels are considered first, and then only a
                                                     single low priority channel, before returning to the high
                                                     priority channels.
                                                     
                                                     This only affects the order in which the DMA schedules
                                                     channels. The DMA's bus priority is not changed. If the
                                                     DMA is not saturated then a low priority channel will see
                                                     no loss of throughput.                                                    */
      __IOM uint32_t DATA_SIZE  : 2;            /*!< [3..2] Set the size of each bus transfer (byte/halfword/word).
                                                     READ_ADDR and WRITE_ADDR advance by this amount (1/2/4
                                                     bytes) with each transfer.                                                */
      __IOM uint32_t INCR_READ  : 1;            /*!< [4..4] If 1, the read address increments with each transfer.
                                                     If 0, each read is directed to the same, initial address.
                                                     
                                                     Generally this should be disabled for peripheral-to-memory
                                                     transfers.                                                                */
      __IOM uint32_t INCR_WRITE : 1;            /*!< [5..5] If 1, the write address increments with each transfer.
                                                     If 0, each write is directed to the same, initial address.
                                                     
                                                     Generally this should be disabled for memory-to-peripheral
                                                     transfers.                                                                */
      __IOM uint32_t RING_SIZE  : 4;            /*!< [9..6] Size of address wrap region. If 0, don't wrap. For values
                                                     n > 0, only the lower n bits of the address will change.
                                                     This wraps the address on a (1 << n) byte boundary, facilitating
                                                     access to naturally-aligned ring buffers.
                                                     
                                                     Ring sizes between 2 and 32768 bytes are possible. This
                                                     can apply to either read or write addresses, based on value
                                                     of RING_SEL.                                                              */
      __IOM uint32_t RING_SEL   : 1;            /*!< [10..10] Select whether RING_SIZE applies to read or write addresses.
                                                     If 0, read addresses are wrapped on a (1 << RING_SIZE)
                                                     boundary. If 1, write addresses are wrapped.                              */
      __IOM uint32_t CHAIN_TO   : 4;            /*!< [14..11] When this channel completes, it will trigger the channel
                                                     indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this
                                                     channel)_.
                                                     Reset value is equal to channel number (4).                               */
      __IOM uint32_t TREQ_SEL   : 6;            /*!< [20..15] Select a Transfer Request signal.
                                                     The channel uses the transfer request signal to pace its
                                                     data transfer rate. Sources for TREQ signals are internal
                                                     (TIMERS) or external (DREQ, a Data Request from the system).
                                                     0x0 to 0x3a -> select DREQ n as TREQ                                      */
      __IOM uint32_t IRQ_QUIET  : 1;            /*!< [21..21] In QUIET mode, the channel does not generate IRQs at
                                                     the end of every transfer block. Instead, an IRQ is raised
                                                     when NULL is written to a trigger register, indicating
                                                     the end of a control block chain.
                                                     
                                                     This reduces the number of interrupts to be serviced by
                                                     the CPU when transferring a DMA chain of many small control
                                                     blocks.                                                                   */
      __IOM uint32_t BSWAP      : 1;            /*!< [22..22] Apply byte-swap transformation to DMA data.
                                                     For byte data, this has no effect. For halfword data, the
                                                     two bytes of each halfword are swapped. For word data,
                                                     the four bytes of each word are swapped to reverse order.                 */
      __IOM uint32_t SNIFF_EN   : 1;            /*!< [23..23] If 1, this channel's data transfers are visible to
                                                     the sniff hardware, and each transfer will advance the
                                                     state of the checksum. This only applies if the sniff hardware
                                                     is enabled, and has this channel selected.
                                                     
                                                     This allows checksum to be enabled or disabled on a per-control-
                                                     block basis.                                                              */
      __IM  uint32_t BUSY       : 1;            /*!< [24..24] This flag goes high when the channel starts a new transfer
                                                     sequence, and low when the last transfer of that sequence
                                                     completes. Clearing EN while BUSY is high pauses the channel,
                                                     and BUSY will stay high while paused.
                                                     
                                                     To terminate a sequence early (and clear the BUSY flag),
                                                     see CHAN_ABORT.                                                           */
            uint32_t            : 4;
      __IOM uint32_t WRITE_ERROR : 1;           /*!< [29..29] If 1, the channel received a write bus error. Write
                                                     one to clear.
                                                     WRITE_ADDR shows the approximate address where the bus
                                                     error was encountered (will not to be earlier, or more
                                                     than 5 transfers later)                                                   */
      __IOM uint32_t READ_ERROR : 1;            /*!< [30..30] If 1, the channel received a read bus error. Write
                                                     one to clear.
                                                     READ_ADDR shows the approximate address where the bus error
                                                     was encountered (will not to be earlier, or more than 3
                                                     transfers later)                                                          */
      __IM  uint32_t AHB_ERROR  : 1;            /*!< [31..31] Logical OR of the READ_ERROR and WRITE_ERROR flags.
                                                     The channel halts when it encounters any bus error, and
                                                     always raises its channel IRQ flag.                                       */
    } bit;
  } CH4_CTRL_TRIG;
  __IM  uint32_t  CH4_AL1_CTRL;                 /*!< (@ 0x00000110) Alias for channel 4 CTRL register                          */
  __IM  uint32_t  CH4_AL1_READ_ADDR;            /*!< (@ 0x00000114) Alias for channel 4 READ_ADDR register                     */
  __IM  uint32_t  CH4_AL1_WRITE_ADDR;           /*!< (@ 0x00000118) Alias for channel 4 WRITE_ADDR register                    */
  __IM  uint32_t  CH4_AL1_TRANS_COUNT_TRIG;     /*!< (@ 0x0000011C) Alias for channel 4 TRANS_COUNT register
                                                                    This is a trigger register (0xc). Writing
                                                                    a nonzero value will
                                                                    reload the channel counter and start the
                                                                    channel.                                                   */
  __IM  uint32_t  CH4_AL2_CTRL;                 /*!< (@ 0x00000120) Alias for channel 4 CTRL register                          */
  __IM  uint32_t  CH4_AL2_TRANS_COUNT;          /*!< (@ 0x00000124) Alias for channel 4 TRANS_COUNT register                   */
  __IM  uint32_t  CH4_AL2_READ_ADDR;            /*!< (@ 0x00000128) Alias for channel 4 READ_ADDR register                     */
  __IM  uint32_t  CH4_AL2_WRITE_ADDR_TRIG;      /*!< (@ 0x0000012C) Alias for channel 4 WRITE_ADDR register
                                                                    This is a trigger register (0xc). Writing
                                                                    a nonzero value will
                                                                    reload the channel counter and start the
                                                                    channel.                                                   */
  __IM  uint32_t  CH4_AL3_CTRL;                 /*!< (@ 0x00000130) Alias for channel 4 CTRL register                          */
  __IM  uint32_t  CH4_AL3_WRITE_ADDR;           /*!< (@ 0x00000134) Alias for channel 4 WRITE_ADDR register                    */
  __IM  uint32_t  CH4_AL3_TRANS_COUNT;          /*!< (@ 0x00000138) Alias for channel 4 TRANS_COUNT register                   */
  __IM  uint32_t  CH4_AL3_READ_ADDR_TRIG;       /*!< (@ 0x0000013C) Alias for channel 4 READ_ADDR register
                                                                    This is a trigger register (0xc). Writing
                                                                    a nonzero value will
                                                                    reload the channel counter and start the
                                                                    channel.                                                   */
  __IOM uint32_t  CH5_READ_ADDR;                /*!< (@ 0x00000140) DMA Channel 5 Read Address pointer
                                                                    This register updates automatically each
                                                                    time a read completes. The current value
                                                                    is the next address to be read by this channel.            */
  __IOM uint32_t  CH5_WRITE_ADDR;               /*!< (@ 0x00000144) DMA Channel 5 Write Address pointer
                                                                    This register updates automatically each
                                                                    time a write completes. The current value
                                                                    is the next address to be written by this
                                                                    channel.                                                   */
  __IOM uint32_t  CH5_TRANS_COUNT;              /*!< (@ 0x00000148) DMA Channel 5 Transfer Count
                                                                    Program the number of bus transfers a channel
                                                                    will perform before halting. Note that,
                                                                    if transfers are larger than one byte in
                                                                    size, this is not equal to the number of
                                                                    bytes transferred (see CTRL_DATA_SIZE).
                                                                    
                                                                    When the channel is active, reading this
                                                                    register shows the number of transfers remaining,
                                                                    updating automatically each time a write
                                                                    transfer completes.
                                                                    
                                                                    Writing this register sets the RELOAD value
                                                                    for the tran                                               */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000014C) DMA Channel 5 Control and Status                           */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] DMA Channel Enable.
                                                     When 1, the channel will respond to triggering events,
                                                     which will cause it to become BUSY and start transferring
                                                     data. When 0, the channel will ignore triggers, stop issuing
                                                     transfers, and pause the current transfer sequence (i.e.
                                                     BUSY will remain high if already high)                                    */
      __IOM uint32_t HIGH_PRIORITY : 1;         /*!< [1..1] HIGH_PRIORITY gives a channel preferential treatment
                                                     in issue scheduling: in each scheduling round, all high
                                                     priority channels are considered first, and then only a
                                                     single low priority channel, before returning to the high
                                                     priority channels.
                                                     
                                                     This only affects the order in which the DMA schedules
                                                     channels. The DMA's bus priority is not changed. If the
                                                     DMA is not saturated then a low priority channel will see
                                                     no loss of throughput.                                                    */
      __IOM uint32_t DATA_SIZE  : 2;            /*!< [3..2] Set the size of each bus transfer (byte/halfword/word).
                                                     READ_ADDR and WRITE_ADDR advance by this amount (1/2/4
                                                     bytes) with each transfer.                                                */
      __IOM uint32_t INCR_READ  : 1;            /*!< [4..4] If 1, the read address increments with each transfer.
                                                     If 0, each read is directed to the same, initial address.
                                                     
                                                     Generally this should be disabled for peripheral-to-memory
                                                     transfers.                                                                */
      __IOM uint32_t INCR_WRITE : 1;            /*!< [5..5] If 1, the write address increments with each transfer.
                                                     If 0, each write is directed to the same, initial address.
                                                     
                                                     Generally this should be disabled for memory-to-peripheral
                                                     transfers.                                                                */
      __IOM uint32_t RING_SIZE  : 4;            /*!< [9..6] Size of address wrap region. If 0, don't wrap. For values
                                                     n > 0, only the lower n bits of the address will change.
                                                     This wraps the address on a (1 << n) byte boundary, facilitating
                                                     access to naturally-aligned ring buffers.
                                                     
                                                     Ring sizes between 2 and 32768 bytes are possible. This
                                                     can apply to either read or write addresses, based on value
                                                     of RING_SEL.                                                              */
      __IOM uint32_t RING_SEL   : 1;            /*!< [10..10] Select whether RING_SIZE applies to read or write addresses.
                                                     If 0, read addresses are wrapped on a (1 << RING_SIZE)
                                                     boundary. If 1, write addresses are wrapped.                              */
      __IOM uint32_t CHAIN_TO   : 4;            /*!< [14..11] When this channel completes, it will trigger the channel
                                                     indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this
                                                     channel)_.
                                                     Reset value is equal to channel number (5).                               */
      __IOM uint32_t TREQ_SEL   : 6;            /*!< [20..15] Select a Transfer Request signal.
                                                     The channel uses the transfer request signal to pace its
                                                     data transfer rate. Sources for TREQ signals are internal
                                                     (TIMERS) or external (DREQ, a Data Request from the system).
                                                     0x0 to 0x3a -> select DREQ n as TREQ                                      */
      __IOM uint32_t IRQ_QUIET  : 1;            /*!< [21..21] In QUIET mode, the channel does not generate IRQs at
                                                     the end of every transfer block. Instead, an IRQ is raised
                                                     when NULL is written to a trigger register, indicating
                                                     the end of a control block chain.
                                                     
                                                     This reduces the number of interrupts to be serviced by
                                                     the CPU when transferring a DMA chain of many small control
                                                     blocks.                                                                   */
      __IOM uint32_t BSWAP      : 1;            /*!< [22..22] Apply byte-swap transformation to DMA data.
                                                     For byte data, this has no effect. For halfword data, the
                                                     two bytes of each halfword are swapped. For word data,
                                                     the four bytes of each word are swapped to reverse order.                 */
      __IOM uint32_t SNIFF_EN   : 1;            /*!< [23..23] If 1, this channel's data transfers are visible to
                                                     the sniff hardware, and each transfer will advance the
                                                     state of the checksum. This only applies if the sniff hardware
                                                     is enabled, and has this channel selected.
                                                     
                                                     This allows checksum to be enabled or disabled on a per-control-
                                                     block basis.                                                              */
      __IM  uint32_t BUSY       : 1;            /*!< [24..24] This flag goes high when the channel starts a new transfer
                                                     sequence, and low when the last transfer of that sequence
                                                     completes. Clearing EN while BUSY is high pauses the channel,
                                                     and BUSY will stay high while paused.
                                                     
                                                     To terminate a sequence early (and clear the BUSY flag),
                                                     see CHAN_ABORT.                                                           */
            uint32_t            : 4;
      __IOM uint32_t WRITE_ERROR : 1;           /*!< [29..29] If 1, the channel received a write bus error. Write
                                                     one to clear.
                                                     WRITE_ADDR shows the approximate address where the bus
                                                     error was encountered (will not to be earlier, or more
                                                     than 5 transfers later)                                                   */
      __IOM uint32_t READ_ERROR : 1;            /*!< [30..30] If 1, the channel received a read bus error. Write
                                                     one to clear.
                                                     READ_ADDR shows the approximate address where the bus error
                                                     was encountered (will not to be earlier, or more than 3
                                                     transfers later)                                                          */
      __IM  uint32_t AHB_ERROR  : 1;            /*!< [31..31] Logical OR of the READ_ERROR and WRITE_ERROR flags.
                                                     The channel halts when it encounters any bus error, and
                                                     always raises its channel IRQ flag.                                       */
    } bit;
  } CH5_CTRL_TRIG;
  __IM  uint32_t  CH5_AL1_CTRL;                 /*!< (@ 0x00000150) Alias for channel 5 CTRL register                          */
  __IM  uint32_t  CH5_AL1_READ_ADDR;            /*!< (@ 0x00000154) Alias for channel 5 READ_ADDR register                     */
  __IM  uint32_t  CH5_AL1_WRITE_ADDR;           /*!< (@ 0x00000158) Alias for channel 5 WRITE_ADDR register                    */
  __IM  uint32_t  CH5_AL1_TRANS_COUNT_TRIG;     /*!< (@ 0x0000015C) Alias for channel 5 TRANS_COUNT register
                                                                    This is a trigger register (0xc). Writing
                                                                    a nonzero value will
                                                                    reload the channel counter and start the
                                                                    channel.                                                   */
  __IM  uint32_t  CH5_AL2_CTRL;                 /*!< (@ 0x00000160) Alias for channel 5 CTRL register                          */
  __IM  uint32_t  CH5_AL2_TRANS_COUNT;          /*!< (@ 0x00000164) Alias for channel 5 TRANS_COUNT register                   */
  __IM  uint32_t  CH5_AL2_READ_ADDR;            /*!< (@ 0x00000168) Alias for channel 5 READ_ADDR register                     */
  __IM  uint32_t  CH5_AL2_WRITE_ADDR_TRIG;      /*!< (@ 0x0000016C) Alias for channel 5 WRITE_ADDR register
                                                                    This is a trigger register (0xc). Writing
                                                                    a nonzero value will
                                                                    reload the channel counter and start the
                                                                    channel.                                                   */
  __IM  uint32_t  CH5_AL3_CTRL;                 /*!< (@ 0x00000170) Alias for channel 5 CTRL register                          */
  __IM  uint32_t  CH5_AL3_WRITE_ADDR;           /*!< (@ 0x00000174) Alias for channel 5 WRITE_ADDR register                    */
  __IM  uint32_t  CH5_AL3_TRANS_COUNT;          /*!< (@ 0x00000178) Alias for channel 5 TRANS_COUNT register                   */
  __IM  uint32_t  CH5_AL3_READ_ADDR_TRIG;       /*!< (@ 0x0000017C) Alias for channel 5 READ_ADDR register
                                                                    This is a trigger register (0xc). Writing
                                                                    a nonzero value will
                                                                    reload the channel counter and start the
                                                                    channel.                                                   */
  __IOM uint32_t  CH6_READ_ADDR;                /*!< (@ 0x00000180) DMA Channel 6 Read Address pointer
                                                                    This register updates automatically each
                                                                    time a read completes. The current value
                                                                    is the next address to be read by this channel.            */
  __IOM uint32_t  CH6_WRITE_ADDR;               /*!< (@ 0x00000184) DMA Channel 6 Write Address pointer
                                                                    This register updates automatically each
                                                                    time a write completes. The current value
                                                                    is the next address to be written by this
                                                                    channel.                                                   */
  __IOM uint32_t  CH6_TRANS_COUNT;              /*!< (@ 0x00000188) DMA Channel 6 Transfer Count
                                                                    Program the number of bus transfers a channel
                                                                    will perform before halting. Note that,
                                                                    if transfers are larger than one byte in
                                                                    size, this is not equal to the number of
                                                                    bytes transferred (see CTRL_DATA_SIZE).
                                                                    
                                                                    When the channel is active, reading this
                                                                    register shows the number of transfers remaining,
                                                                    updating automatically each time a write
                                                                    transfer completes.
                                                                    
                                                                    Writing this register sets the RELOAD value
                                                                    for the tran                                               */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000018C) DMA Channel 6 Control and Status                           */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] DMA Channel Enable.
                                                     When 1, the channel will respond to triggering events,
                                                     which will cause it to become BUSY and start transferring
                                                     data. When 0, the channel will ignore triggers, stop issuing
                                                     transfers, and pause the current transfer sequence (i.e.
                                                     BUSY will remain high if already high)                                    */
      __IOM uint32_t HIGH_PRIORITY : 1;         /*!< [1..1] HIGH_PRIORITY gives a channel preferential treatment
                                                     in issue scheduling: in each scheduling round, all high
                                                     priority channels are considered first, and then only a
                                                     single low priority channel, before returning to the high
                                                     priority channels.
                                                     
                                                     This only affects the order in which the DMA schedules
                                                     channels. The DMA's bus priority is not changed. If the
                                                     DMA is not saturated then a low priority channel will see
                                                     no loss of throughput.                                                    */
      __IOM uint32_t DATA_SIZE  : 2;            /*!< [3..2] Set the size of each bus transfer (byte/halfword/word).
                                                     READ_ADDR and WRITE_ADDR advance by this amount (1/2/4
                                                     bytes) with each transfer.                                                */
      __IOM uint32_t INCR_READ  : 1;            /*!< [4..4] If 1, the read address increments with each transfer.
                                                     If 0, each read is directed to the same, initial address.
                                                     
                                                     Generally this should be disabled for peripheral-to-memory
                                                     transfers.                                                                */
      __IOM uint32_t INCR_WRITE : 1;            /*!< [5..5] If 1, the write address increments with each transfer.
                                                     If 0, each write is directed to the same, initial address.
                                                     
                                                     Generally this should be disabled for memory-to-peripheral
                                                     transfers.                                                                */
      __IOM uint32_t RING_SIZE  : 4;            /*!< [9..6] Size of address wrap region. If 0, don't wrap. For values
                                                     n > 0, only the lower n bits of the address will change.
                                                     This wraps the address on a (1 << n) byte boundary, facilitating
                                                     access to naturally-aligned ring buffers.
                                                     
                                                     Ring sizes between 2 and 32768 bytes are possible. This
                                                     can apply to either read or write addresses, based on value
                                                     of RING_SEL.                                                              */
      __IOM uint32_t RING_SEL   : 1;            /*!< [10..10] Select whether RING_SIZE applies to read or write addresses.
                                                     If 0, read addresses are wrapped on a (1 << RING_SIZE)
                                                     boundary. If 1, write addresses are wrapped.                              */
      __IOM uint32_t CHAIN_TO   : 4;            /*!< [14..11] When this channel completes, it will trigger the channel
                                                     indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this
                                                     channel)_.
                                                     Reset value is equal to channel number (6).                               */
      __IOM uint32_t TREQ_SEL   : 6;            /*!< [20..15] Select a Transfer Request signal.
                                                     The channel uses the transfer request signal to pace its
                                                     data transfer rate. Sources for TREQ signals are internal
                                                     (TIMERS) or external (DREQ, a Data Request from the system).
                                                     0x0 to 0x3a -> select DREQ n as TREQ                                      */
      __IOM uint32_t IRQ_QUIET  : 1;            /*!< [21..21] In QUIET mode, the channel does not generate IRQs at
                                                     the end of every transfer block. Instead, an IRQ is raised
                                                     when NULL is written to a trigger register, indicating
                                                     the end of a control block chain.
                                                     
                                                     This reduces the number of interrupts to be serviced by
                                                     the CPU when transferring a DMA chain of many small control
                                                     blocks.                                                                   */
      __IOM uint32_t BSWAP      : 1;            /*!< [22..22] Apply byte-swap transformation to DMA data.
                                                     For byte data, this has no effect. For halfword data, the
                                                     two bytes of each halfword are swapped. For word data,
                                                     the four bytes of each word are swapped to reverse order.                 */
      __IOM uint32_t SNIFF_EN   : 1;            /*!< [23..23] If 1, this channel's data transfers are visible to
                                                     the sniff hardware, and each transfer will advance the
                                                     state of the checksum. This only applies if the sniff hardware
                                                     is enabled, and has this channel selected.
                                                     
                                                     This allows checksum to be enabled or disabled on a per-control-
                                                     block basis.                                                              */
      __IM  uint32_t BUSY       : 1;            /*!< [24..24] This flag goes high when the channel starts a new transfer
                                                     sequence, and low when the last transfer of that sequence
                                                     completes. Clearing EN while BUSY is high pauses the channel,
                                                     and BUSY will stay high while paused.
                                                     
                                                     To terminate a sequence early (and clear the BUSY flag),
                                                     see CHAN_ABORT.                                                           */
            uint32_t            : 4;
      __IOM uint32_t WRITE_ERROR : 1;           /*!< [29..29] If 1, the channel received a write bus error. Write
                                                     one to clear.
                                                     WRITE_ADDR shows the approximate address where the bus
                                                     error was encountered (will not to be earlier, or more
                                                     than 5 transfers later)                                                   */
      __IOM uint32_t READ_ERROR : 1;            /*!< [30..30] If 1, the channel received a read bus error. Write
                                                     one to clear.
                                                     READ_ADDR shows the approximate address where the bus error
                                                     was encountered (will not to be earlier, or more than 3
                                                     transfers later)                                                          */
      __IM  uint32_t AHB_ERROR  : 1;            /*!< [31..31] Logical OR of the READ_ERROR and WRITE_ERROR flags.
                                                     The channel halts when it encounters any bus error, and
                                                     always raises its channel IRQ flag.                                       */
    } bit;
  } CH6_CTRL_TRIG;
  __IM  uint32_t  CH6_AL1_CTRL;                 /*!< (@ 0x00000190) Alias for channel 6 CTRL register                          */
  __IM  uint32_t  CH6_AL1_READ_ADDR;            /*!< (@ 0x00000194) Alias for channel 6 READ_ADDR register                     */
  __IM  uint32_t  CH6_AL1_WRITE_ADDR;           /*!< (@ 0x00000198) Alias for channel 6 WRITE_ADDR register                    */
  __IM  uint32_t  CH6_AL1_TRANS_COUNT_TRIG;     /*!< (@ 0x0000019C) Alias for channel 6 TRANS_COUNT register
                                                                    This is a trigger register (0xc). Writing
                                                                    a nonzero value will
                                                                    reload the channel counter and start the
                                                                    channel.                                                   */
  __IM  uint32_t  CH6_AL2_CTRL;                 /*!< (@ 0x000001A0) Alias for channel 6 CTRL register                          */
  __IM  uint32_t  CH6_AL2_TRANS_COUNT;          /*!< (@ 0x000001A4) Alias for channel 6 TRANS_COUNT register                   */
  __IM  uint32_t  CH6_AL2_READ_ADDR;            /*!< (@ 0x000001A8) Alias for channel 6 READ_ADDR register                     */
  __IM  uint32_t  CH6_AL2_WRITE_ADDR_TRIG;      /*!< (@ 0x000001AC) Alias for channel 6 WRITE_ADDR register
                                                                    This is a trigger register (0xc). Writing
                                                                    a nonzero value will
                                                                    reload the channel counter and start the
                                                                    channel.                                                   */
  __IM  uint32_t  CH6_AL3_CTRL;                 /*!< (@ 0x000001B0) Alias for channel 6 CTRL register                          */
  __IM  uint32_t  CH6_AL3_WRITE_ADDR;           /*!< (@ 0x000001B4) Alias for channel 6 WRITE_ADDR register                    */
  __IM  uint32_t  CH6_AL3_TRANS_COUNT;          /*!< (@ 0x000001B8) Alias for channel 6 TRANS_COUNT register                   */
  __IM  uint32_t  CH6_AL3_READ_ADDR_TRIG;       /*!< (@ 0x000001BC) Alias for channel 6 READ_ADDR register
                                                                    This is a trigger register (0xc). Writing
                                                                    a nonzero value will
                                                                    reload the channel counter and start the
                                                                    channel.                                                   */
  __IOM uint32_t  CH7_READ_ADDR;                /*!< (@ 0x000001C0) DMA Channel 7 Read Address pointer
                                                                    This register updates automatically each
                                                                    time a read completes. The current value
                                                                    is the next address to be read by this channel.            */
  __IOM uint32_t  CH7_WRITE_ADDR;               /*!< (@ 0x000001C4) DMA Channel 7 Write Address pointer
                                                                    This register updates automatically each
                                                                    time a write completes. The current value
                                                                    is the next address to be written by this
                                                                    channel.                                                   */
  __IOM uint32_t  CH7_TRANS_COUNT;              /*!< (@ 0x000001C8) DMA Channel 7 Transfer Count
                                                                    Program the number of bus transfers a channel
                                                                    will perform before halting. Note that,
                                                                    if transfers are larger than one byte in
                                                                    size, this is not equal to the number of
                                                                    bytes transferred (see CTRL_DATA_SIZE).
                                                                    
                                                                    When the channel is active, reading this
                                                                    register shows the number of transfers remaining,
                                                                    updating automatically each time a write
                                                                    transfer completes.
                                                                    
                                                                    Writing this register sets the RELOAD value
                                                                    for the tran                                               */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000001CC) DMA Channel 7 Control and Status                           */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] DMA Channel Enable.
                                                     When 1, the channel will respond to triggering events,
                                                     which will cause it to become BUSY and start transferring
                                                     data. When 0, the channel will ignore triggers, stop issuing
                                                     transfers, and pause the current transfer sequence (i.e.
                                                     BUSY will remain high if already high)                                    */
      __IOM uint32_t HIGH_PRIORITY : 1;         /*!< [1..1] HIGH_PRIORITY gives a channel preferential treatment
                                                     in issue scheduling: in each scheduling round, all high
                                                     priority channels are considered first, and then only a
                                                     single low priority channel, before returning to the high
                                                     priority channels.
                                                     
                                                     This only affects the order in which the DMA schedules
                                                     channels. The DMA's bus priority is not changed. If the
                                                     DMA is not saturated then a low priority channel will see
                                                     no loss of throughput.                                                    */
      __IOM uint32_t DATA_SIZE  : 2;            /*!< [3..2] Set the size of each bus transfer (byte/halfword/word).
                                                     READ_ADDR and WRITE_ADDR advance by this amount (1/2/4
                                                     bytes) with each transfer.                                                */
      __IOM uint32_t INCR_READ  : 1;            /*!< [4..4] If 1, the read address increments with each transfer.
                                                     If 0, each read is directed to the same, initial address.
                                                     
                                                     Generally this should be disabled for peripheral-to-memory
                                                     transfers.                                                                */
      __IOM uint32_t INCR_WRITE : 1;            /*!< [5..5] If 1, the write address increments with each transfer.
                                                     If 0, each write is directed to the same, initial address.
                                                     
                                                     Generally this should be disabled for memory-to-peripheral
                                                     transfers.                                                                */
      __IOM uint32_t RING_SIZE  : 4;            /*!< [9..6] Size of address wrap region. If 0, don't wrap. For values
                                                     n > 0, only the lower n bits of the address will change.
                                                     This wraps the address on a (1 << n) byte boundary, facilitating
                                                     access to naturally-aligned ring buffers.
                                                     
                                                     Ring sizes between 2 and 32768 bytes are possible. This
                                                     can apply to either read or write addresses, based on value
                                                     of RING_SEL.                                                              */
      __IOM uint32_t RING_SEL   : 1;            /*!< [10..10] Select whether RING_SIZE applies to read or write addresses.
                                                     If 0, read addresses are wrapped on a (1 << RING_SIZE)
                                                     boundary. If 1, write addresses are wrapped.                              */
      __IOM uint32_t CHAIN_TO   : 4;            /*!< [14..11] When this channel completes, it will trigger the channel
                                                     indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this
                                                     channel)_.
                                                     Reset value is equal to channel number (7).                               */
      __IOM uint32_t TREQ_SEL   : 6;            /*!< [20..15] Select a Transfer Request signal.
                                                     The channel uses the transfer request signal to pace its
                                                     data transfer rate. Sources for TREQ signals are internal
                                                     (TIMERS) or external (DREQ, a Data Request from the system).
                                                     0x0 to 0x3a -> select DREQ n as TREQ                                      */
      __IOM uint32_t IRQ_QUIET  : 1;            /*!< [21..21] In QUIET mode, the channel does not generate IRQs at
                                                     the end of every transfer block. Instead, an IRQ is raised
                                                     when NULL is written to a trigger register, indicating
                                                     the end of a control block chain.
                                                     
                                                     This reduces the number of interrupts to be serviced by
                                                     the CPU when transferring a DMA chain of many small control
                                                     blocks.                                                                   */
      __IOM uint32_t BSWAP      : 1;            /*!< [22..22] Apply byte-swap transformation to DMA data.
                                                     For byte data, this has no effect. For halfword data, the
                                                     two bytes of each halfword are swapped. For word data,
                                                     the four bytes of each word are swapped to reverse order.                 */
      __IOM uint32_t SNIFF_EN   : 1;            /*!< [23..23] If 1, this channel's data transfers are visible to
                                                     the sniff hardware, and each transfer will advance the
                                                     state of the checksum. This only applies if the sniff hardware
                                                     is enabled, and has this channel selected.
                                                     
                                                     This allows checksum to be enabled or disabled on a per-control-
                                                     block basis.                                                              */
      __IM  uint32_t BUSY       : 1;            /*!< [24..24] This flag goes high when the channel starts a new transfer
                                                     sequence, and low when the last transfer of that sequence
                                                     completes. Clearing EN while BUSY is high pauses the channel,
                                                     and BUSY will stay high while paused.
                                                     
                                                     To terminate a sequence early (and clear the BUSY flag),
                                                     see CHAN_ABORT.                                                           */
            uint32_t            : 4;
      __IOM uint32_t WRITE_ERROR : 1;           /*!< [29..29] If 1, the channel received a write bus error. Write
                                                     one to clear.
                                                     WRITE_ADDR shows the approximate address where the bus
                                                     error was encountered (will not to be earlier, or more
                                                     than 5 transfers later)                                                   */
      __IOM uint32_t READ_ERROR : 1;            /*!< [30..30] If 1, the channel received a read bus error. Write
                                                     one to clear.
                                                     READ_ADDR shows the approximate address where the bus error
                                                     was encountered (will not to be earlier, or more than 3
                                                     transfers later)                                                          */
      __IM  uint32_t AHB_ERROR  : 1;            /*!< [31..31] Logical OR of the READ_ERROR and WRITE_ERROR flags.
                                                     The channel halts when it encounters any bus error, and
                                                     always raises its channel IRQ flag.                                       */
    } bit;
  } CH7_CTRL_TRIG;
  __IM  uint32_t  CH7_AL1_CTRL;                 /*!< (@ 0x000001D0) Alias for channel 7 CTRL register                          */
  __IM  uint32_t  CH7_AL1_READ_ADDR;            /*!< (@ 0x000001D4) Alias for channel 7 READ_ADDR register                     */
  __IM  uint32_t  CH7_AL1_WRITE_ADDR;           /*!< (@ 0x000001D8) Alias for channel 7 WRITE_ADDR register                    */
  __IM  uint32_t  CH7_AL1_TRANS_COUNT_TRIG;     /*!< (@ 0x000001DC) Alias for channel 7 TRANS_COUNT register
                                                                    This is a trigger register (0xc). Writing
                                                                    a nonzero value will
                                                                    reload the channel counter and start the
                                                                    channel.                                                   */
  __IM  uint32_t  CH7_AL2_CTRL;                 /*!< (@ 0x000001E0) Alias for channel 7 CTRL register                          */
  __IM  uint32_t  CH7_AL2_TRANS_COUNT;          /*!< (@ 0x000001E4) Alias for channel 7 TRANS_COUNT register                   */
  __IM  uint32_t  CH7_AL2_READ_ADDR;            /*!< (@ 0x000001E8) Alias for channel 7 READ_ADDR register                     */
  __IM  uint32_t  CH7_AL2_WRITE_ADDR_TRIG;      /*!< (@ 0x000001EC) Alias for channel 7 WRITE_ADDR register
                                                                    This is a trigger register (0xc). Writing
                                                                    a nonzero value will
                                                                    reload the channel counter and start the
                                                                    channel.                                                   */
  __IM  uint32_t  CH7_AL3_CTRL;                 /*!< (@ 0x000001F0) Alias for channel 7 CTRL register                          */
  __IM  uint32_t  CH7_AL3_WRITE_ADDR;           /*!< (@ 0x000001F4) Alias for channel 7 WRITE_ADDR register                    */
  __IM  uint32_t  CH7_AL3_TRANS_COUNT;          /*!< (@ 0x000001F8) Alias for channel 7 TRANS_COUNT register                   */
  __IM  uint32_t  CH7_AL3_READ_ADDR_TRIG;       /*!< (@ 0x000001FC) Alias for channel 7 READ_ADDR register
                                                                    This is a trigger register (0xc). Writing
                                                                    a nonzero value will
                                                                    reload the channel counter and start the
                                                                    channel.                                                   */
  __IOM uint32_t  CH8_READ_ADDR;                /*!< (@ 0x00000200) DMA Channel 8 Read Address pointer
                                                                    This register updates automatically each
                                                                    time a read completes. The current value
                                                                    is the next address to be read by this channel.            */
  __IOM uint32_t  CH8_WRITE_ADDR;               /*!< (@ 0x00000204) DMA Channel 8 Write Address pointer
                                                                    This register updates automatically each
                                                                    time a write completes. The current value
                                                                    is the next address to be written by this
                                                                    channel.                                                   */
  __IOM uint32_t  CH8_TRANS_COUNT;              /*!< (@ 0x00000208) DMA Channel 8 Transfer Count
                                                                    Program the number of bus transfers a channel
                                                                    will perform before halting. Note that,
                                                                    if transfers are larger than one byte in
                                                                    size, this is not equal to the number of
                                                                    bytes transferred (see CTRL_DATA_SIZE).
                                                                    
                                                                    When the channel is active, reading this
                                                                    register shows the number of transfers remaining,
                                                                    updating automatically each time a write
                                                                    transfer completes.
                                                                    
                                                                    Writing this register sets the RELOAD value
                                                                    for the tran                                               */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000020C) DMA Channel 8 Control and Status                           */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] DMA Channel Enable.
                                                     When 1, the channel will respond to triggering events,
                                                     which will cause it to become BUSY and start transferring
                                                     data. When 0, the channel will ignore triggers, stop issuing
                                                     transfers, and pause the current transfer sequence (i.e.
                                                     BUSY will remain high if already high)                                    */
      __IOM uint32_t HIGH_PRIORITY : 1;         /*!< [1..1] HIGH_PRIORITY gives a channel preferential treatment
                                                     in issue scheduling: in each scheduling round, all high
                                                     priority channels are considered first, and then only a
                                                     single low priority channel, before returning to the high
                                                     priority channels.
                                                     
                                                     This only affects the order in which the DMA schedules
                                                     channels. The DMA's bus priority is not changed. If the
                                                     DMA is not saturated then a low priority channel will see
                                                     no loss of throughput.                                                    */
      __IOM uint32_t DATA_SIZE  : 2;            /*!< [3..2] Set the size of each bus transfer (byte/halfword/word).
                                                     READ_ADDR and WRITE_ADDR advance by this amount (1/2/4
                                                     bytes) with each transfer.                                                */
      __IOM uint32_t INCR_READ  : 1;            /*!< [4..4] If 1, the read address increments with each transfer.
                                                     If 0, each read is directed to the same, initial address.
                                                     
                                                     Generally this should be disabled for peripheral-to-memory
                                                     transfers.                                                                */
      __IOM uint32_t INCR_WRITE : 1;            /*!< [5..5] If 1, the write address increments with each transfer.
                                                     If 0, each write is directed to the same, initial address.
                                                     
                                                     Generally this should be disabled for memory-to-peripheral
                                                     transfers.                                                                */
      __IOM uint32_t RING_SIZE  : 4;            /*!< [9..6] Size of address wrap region. If 0, don't wrap. For values
                                                     n > 0, only the lower n bits of the address will change.
                                                     This wraps the address on a (1 << n) byte boundary, facilitating
                                                     access to naturally-aligned ring buffers.
                                                     
                                                     Ring sizes between 2 and 32768 bytes are possible. This
                                                     can apply to either read or write addresses, based on value
                                                     of RING_SEL.                                                              */
      __IOM uint32_t RING_SEL   : 1;            /*!< [10..10] Select whether RING_SIZE applies to read or write addresses.
                                                     If 0, read addresses are wrapped on a (1 << RING_SIZE)
                                                     boundary. If 1, write addresses are wrapped.                              */
      __IOM uint32_t CHAIN_TO   : 4;            /*!< [14..11] When this channel completes, it will trigger the channel
                                                     indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this
                                                     channel)_.
                                                     Reset value is equal to channel number (8).                               */
      __IOM uint32_t TREQ_SEL   : 6;            /*!< [20..15] Select a Transfer Request signal.
                                                     The channel uses the transfer request signal to pace its
                                                     data transfer rate. Sources for TREQ signals are internal
                                                     (TIMERS) or external (DREQ, a Data Request from the system).
                                                     0x0 to 0x3a -> select DREQ n as TREQ                                      */
      __IOM uint32_t IRQ_QUIET  : 1;            /*!< [21..21] In QUIET mode, the channel does not generate IRQs at
                                                     the end of every transfer block. Instead, an IRQ is raised
                                                     when NULL is written to a trigger register, indicating
                                                     the end of a control block chain.
                                                     
                                                     This reduces the number of interrupts to be serviced by
                                                     the CPU when transferring a DMA chain of many small control
                                                     blocks.                                                                   */
      __IOM uint32_t BSWAP      : 1;            /*!< [22..22] Apply byte-swap transformation to DMA data.
                                                     For byte data, this has no effect. For halfword data, the
                                                     two bytes of each halfword are swapped. For word data,
                                                     the four bytes of each word are swapped to reverse order.                 */
      __IOM uint32_t SNIFF_EN   : 1;            /*!< [23..23] If 1, this channel's data transfers are visible to
                                                     the sniff hardware, and each transfer will advance the
                                                     state of the checksum. This only applies if the sniff hardware
                                                     is enabled, and has this channel selected.
                                                     
                                                     This allows checksum to be enabled or disabled on a per-control-
                                                     block basis.                                                              */
      __IM  uint32_t BUSY       : 1;            /*!< [24..24] This flag goes high when the channel starts a new transfer
                                                     sequence, and low when the last transfer of that sequence
                                                     completes. Clearing EN while BUSY is high pauses the channel,
                                                     and BUSY will stay high while paused.
                                                     
                                                     To terminate a sequence early (and clear the BUSY flag),
                                                     see CHAN_ABORT.                                                           */
            uint32_t            : 4;
      __IOM uint32_t WRITE_ERROR : 1;           /*!< [29..29] If 1, the channel received a write bus error. Write
                                                     one to clear.
                                                     WRITE_ADDR shows the approximate address where the bus
                                                     error was encountered (will not to be earlier, or more
                                                     than 5 transfers later)                                                   */
      __IOM uint32_t READ_ERROR : 1;            /*!< [30..30] If 1, the channel received a read bus error. Write
                                                     one to clear.
                                                     READ_ADDR shows the approximate address where the bus error
                                                     was encountered (will not to be earlier, or more than 3
                                                     transfers later)                                                          */
      __IM  uint32_t AHB_ERROR  : 1;            /*!< [31..31] Logical OR of the READ_ERROR and WRITE_ERROR flags.
                                                     The channel halts when it encounters any bus error, and
                                                     always raises its channel IRQ flag.                                       */
    } bit;
  } CH8_CTRL_TRIG;
  __IM  uint32_t  CH8_AL1_CTRL;                 /*!< (@ 0x00000210) Alias for channel 8 CTRL register                          */
  __IM  uint32_t  CH8_AL1_READ_ADDR;            /*!< (@ 0x00000214) Alias for channel 8 READ_ADDR register                     */
  __IM  uint32_t  CH8_AL1_WRITE_ADDR;           /*!< (@ 0x00000218) Alias for channel 8 WRITE_ADDR register                    */
  __IM  uint32_t  CH8_AL1_TRANS_COUNT_TRIG;     /*!< (@ 0x0000021C) Alias for channel 8 TRANS_COUNT register
                                                                    This is a trigger register (0xc). Writing
                                                                    a nonzero value will
                                                                    reload the channel counter and start the
                                                                    channel.                                                   */
  __IM  uint32_t  CH8_AL2_CTRL;                 /*!< (@ 0x00000220) Alias for channel 8 CTRL register                          */
  __IM  uint32_t  CH8_AL2_TRANS_COUNT;          /*!< (@ 0x00000224) Alias for channel 8 TRANS_COUNT register                   */
  __IM  uint32_t  CH8_AL2_READ_ADDR;            /*!< (@ 0x00000228) Alias for channel 8 READ_ADDR register                     */
  __IM  uint32_t  CH8_AL2_WRITE_ADDR_TRIG;      /*!< (@ 0x0000022C) Alias for channel 8 WRITE_ADDR register
                                                                    This is a trigger register (0xc). Writing
                                                                    a nonzero value will
                                                                    reload the channel counter and start the
                                                                    channel.                                                   */
  __IM  uint32_t  CH8_AL3_CTRL;                 /*!< (@ 0x00000230) Alias for channel 8 CTRL register                          */
  __IM  uint32_t  CH8_AL3_WRITE_ADDR;           /*!< (@ 0x00000234) Alias for channel 8 WRITE_ADDR register                    */
  __IM  uint32_t  CH8_AL3_TRANS_COUNT;          /*!< (@ 0x00000238) Alias for channel 8 TRANS_COUNT register                   */
  __IM  uint32_t  CH8_AL3_READ_ADDR_TRIG;       /*!< (@ 0x0000023C) Alias for channel 8 READ_ADDR register
                                                                    This is a trigger register (0xc). Writing
                                                                    a nonzero value will
                                                                    reload the channel counter and start the
                                                                    channel.                                                   */
  __IOM uint32_t  CH9_READ_ADDR;                /*!< (@ 0x00000240) DMA Channel 9 Read Address pointer
                                                                    This register updates automatically each
                                                                    time a read completes. The current value
                                                                    is the next address to be read by this channel.            */
  __IOM uint32_t  CH9_WRITE_ADDR;               /*!< (@ 0x00000244) DMA Channel 9 Write Address pointer
                                                                    This register updates automatically each
                                                                    time a write completes. The current value
                                                                    is the next address to be written by this
                                                                    channel.                                                   */
  __IOM uint32_t  CH9_TRANS_COUNT;              /*!< (@ 0x00000248) DMA Channel 9 Transfer Count
                                                                    Program the number of bus transfers a channel
                                                                    will perform before halting. Note that,
                                                                    if transfers are larger than one byte in
                                                                    size, this is not equal to the number of
                                                                    bytes transferred (see CTRL_DATA_SIZE).
                                                                    
                                                                    When the channel is active, reading this
                                                                    register shows the number of transfers remaining,
                                                                    updating automatically each time a write
                                                                    transfer completes.
                                                                    
                                                                    Writing this register sets the RELOAD value
                                                                    for the tran                                               */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000024C) DMA Channel 9 Control and Status                           */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] DMA Channel Enable.
                                                     When 1, the channel will respond to triggering events,
                                                     which will cause it to become BUSY and start transferring
                                                     data. When 0, the channel will ignore triggers, stop issuing
                                                     transfers, and pause the current transfer sequence (i.e.
                                                     BUSY will remain high if already high)                                    */
      __IOM uint32_t HIGH_PRIORITY : 1;         /*!< [1..1] HIGH_PRIORITY gives a channel preferential treatment
                                                     in issue scheduling: in each scheduling round, all high
                                                     priority channels are considered first, and then only a
                                                     single low priority channel, before returning to the high
                                                     priority channels.
                                                     
                                                     This only affects the order in which the DMA schedules
                                                     channels. The DMA's bus priority is not changed. If the
                                                     DMA is not saturated then a low priority channel will see
                                                     no loss of throughput.                                                    */
      __IOM uint32_t DATA_SIZE  : 2;            /*!< [3..2] Set the size of each bus transfer (byte/halfword/word).
                                                     READ_ADDR and WRITE_ADDR advance by this amount (1/2/4
                                                     bytes) with each transfer.                                                */
      __IOM uint32_t INCR_READ  : 1;            /*!< [4..4] If 1, the read address increments with each transfer.
                                                     If 0, each read is directed to the same, initial address.
                                                     
                                                     Generally this should be disabled for peripheral-to-memory
                                                     transfers.                                                                */
      __IOM uint32_t INCR_WRITE : 1;            /*!< [5..5] If 1, the write address increments with each transfer.
                                                     If 0, each write is directed to the same, initial address.
                                                     
                                                     Generally this should be disabled for memory-to-peripheral
                                                     transfers.                                                                */
      __IOM uint32_t RING_SIZE  : 4;            /*!< [9..6] Size of address wrap region. If 0, don't wrap. For values
                                                     n > 0, only the lower n bits of the address will change.
                                                     This wraps the address on a (1 << n) byte boundary, facilitating
                                                     access to naturally-aligned ring buffers.
                                                     
                                                     Ring sizes between 2 and 32768 bytes are possible. This
                                                     can apply to either read or write addresses, based on value
                                                     of RING_SEL.                                                              */
      __IOM uint32_t RING_SEL   : 1;            /*!< [10..10] Select whether RING_SIZE applies to read or write addresses.
                                                     If 0, read addresses are wrapped on a (1 << RING_SIZE)
                                                     boundary. If 1, write addresses are wrapped.                              */
      __IOM uint32_t CHAIN_TO   : 4;            /*!< [14..11] When this channel completes, it will trigger the channel
                                                     indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this
                                                     channel)_.
                                                     Reset value is equal to channel number (9).                               */
      __IOM uint32_t TREQ_SEL   : 6;            /*!< [20..15] Select a Transfer Request signal.
                                                     The channel uses the transfer request signal to pace its
                                                     data transfer rate. Sources for TREQ signals are internal
                                                     (TIMERS) or external (DREQ, a Data Request from the system).
                                                     0x0 to 0x3a -> select DREQ n as TREQ                                      */
      __IOM uint32_t IRQ_QUIET  : 1;            /*!< [21..21] In QUIET mode, the channel does not generate IRQs at
                                                     the end of every transfer block. Instead, an IRQ is raised
                                                     when NULL is written to a trigger register, indicating
                                                     the end of a control block chain.
                                                     
                                                     This reduces the number of interrupts to be serviced by
                                                     the CPU when transferring a DMA chain of many small control
                                                     blocks.                                                                   */
      __IOM uint32_t BSWAP      : 1;            /*!< [22..22] Apply byte-swap transformation to DMA data.
                                                     For byte data, this has no effect. For halfword data, the
                                                     two bytes of each halfword are swapped. For word data,
                                                     the four bytes of each word are swapped to reverse order.                 */
      __IOM uint32_t SNIFF_EN   : 1;            /*!< [23..23] If 1, this channel's data transfers are visible to
                                                     the sniff hardware, and each transfer will advance the
                                                     state of the checksum. This only applies if the sniff hardware
                                                     is enabled, and has this channel selected.
                                                     
                                                     This allows checksum to be enabled or disabled on a per-control-
                                                     block basis.                                                              */
      __IM  uint32_t BUSY       : 1;            /*!< [24..24] This flag goes high when the channel starts a new transfer
                                                     sequence, and low when the last transfer of that sequence
                                                     completes. Clearing EN while BUSY is high pauses the channel,
                                                     and BUSY will stay high while paused.
                                                     
                                                     To terminate a sequence early (and clear the BUSY flag),
                                                     see CHAN_ABORT.                                                           */
            uint32_t            : 4;
      __IOM uint32_t WRITE_ERROR : 1;           /*!< [29..29] If 1, the channel received a write bus error. Write
                                                     one to clear.
                                                     WRITE_ADDR shows the approximate address where the bus
                                                     error was encountered (will not to be earlier, or more
                                                     than 5 transfers later)                                                   */
      __IOM uint32_t READ_ERROR : 1;            /*!< [30..30] If 1, the channel received a read bus error. Write
                                                     one to clear.
                                                     READ_ADDR shows the approximate address where the bus error
                                                     was encountered (will not to be earlier, or more than 3
                                                     transfers later)                                                          */
      __IM  uint32_t AHB_ERROR  : 1;            /*!< [31..31] Logical OR of the READ_ERROR and WRITE_ERROR flags.
                                                     The channel halts when it encounters any bus error, and
                                                     always raises its channel IRQ flag.                                       */
    } bit;
  } CH9_CTRL_TRIG;
  __IM  uint32_t  CH9_AL1_CTRL;                 /*!< (@ 0x00000250) Alias for channel 9 CTRL register                          */
  __IM  uint32_t  CH9_AL1_READ_ADDR;            /*!< (@ 0x00000254) Alias for channel 9 READ_ADDR register                     */
  __IM  uint32_t  CH9_AL1_WRITE_ADDR;           /*!< (@ 0x00000258) Alias for channel 9 WRITE_ADDR register                    */
  __IM  uint32_t  CH9_AL1_TRANS_COUNT_TRIG;     /*!< (@ 0x0000025C) Alias for channel 9 TRANS_COUNT register
                                                                    This is a trigger register (0xc). Writing
                                                                    a nonzero value will
                                                                    reload the channel counter and start the
                                                                    channel.                                                   */
  __IM  uint32_t  CH9_AL2_CTRL;                 /*!< (@ 0x00000260) Alias for channel 9 CTRL register                          */
  __IM  uint32_t  CH9_AL2_TRANS_COUNT;          /*!< (@ 0x00000264) Alias for channel 9 TRANS_COUNT register                   */
  __IM  uint32_t  CH9_AL2_READ_ADDR;            /*!< (@ 0x00000268) Alias for channel 9 READ_ADDR register                     */
  __IM  uint32_t  CH9_AL2_WRITE_ADDR_TRIG;      /*!< (@ 0x0000026C) Alias for channel 9 WRITE_ADDR register
                                                                    This is a trigger register (0xc). Writing
                                                                    a nonzero value will
                                                                    reload the channel counter and start the
                                                                    channel.                                                   */
  __IM  uint32_t  CH9_AL3_CTRL;                 /*!< (@ 0x00000270) Alias for channel 9 CTRL register                          */
  __IM  uint32_t  CH9_AL3_WRITE_ADDR;           /*!< (@ 0x00000274) Alias for channel 9 WRITE_ADDR register                    */
  __IM  uint32_t  CH9_AL3_TRANS_COUNT;          /*!< (@ 0x00000278) Alias for channel 9 TRANS_COUNT register                   */
  __IM  uint32_t  CH9_AL3_READ_ADDR_TRIG;       /*!< (@ 0x0000027C) Alias for channel 9 READ_ADDR register
                                                                    This is a trigger register (0xc). Writing
                                                                    a nonzero value will
                                                                    reload the channel counter and start the
                                                                    channel.                                                   */
  __IOM uint32_t  CH10_READ_ADDR;               /*!< (@ 0x00000280) DMA Channel 10 Read Address pointer
                                                                    This register updates automatically each
                                                                    time a read completes. The current value
                                                                    is the next address to be read by this channel.            */
  __IOM uint32_t  CH10_WRITE_ADDR;              /*!< (@ 0x00000284) DMA Channel 10 Write Address pointer
                                                                    This register updates automatically each
                                                                    time a write completes. The current value
                                                                    is the next address to be written by this
                                                                    channel.                                                   */
  __IOM uint32_t  CH10_TRANS_COUNT;             /*!< (@ 0x00000288) DMA Channel 10 Transfer Count
                                                                    Program the number of bus transfers a channel
                                                                    will perform before halting. Note that,
                                                                    if transfers are larger than one byte in
                                                                    size, this is not equal to the number of
                                                                    bytes transferred (see CTRL_DATA_SIZE).
                                                                    
                                                                    When the channel is active, reading this
                                                                    register shows the number of transfers remaining,
                                                                    updating automatically each time a write
                                                                    transfer completes.
                                                                    
                                                                    Writing this register sets the RELOAD value
                                                                    for the tra                                                */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000028C) DMA Channel 10 Control and Status                          */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] DMA Channel Enable.
                                                     When 1, the channel will respond to triggering events,
                                                     which will cause it to become BUSY and start transferring
                                                     data. When 0, the channel will ignore triggers, stop issuing
                                                     transfers, and pause the current transfer sequence (i.e.
                                                     BUSY will remain high if already high)                                    */
      __IOM uint32_t HIGH_PRIORITY : 1;         /*!< [1..1] HIGH_PRIORITY gives a channel preferential treatment
                                                     in issue scheduling: in each scheduling round, all high
                                                     priority channels are considered first, and then only a
                                                     single low priority channel, before returning to the high
                                                     priority channels.
                                                     
                                                     This only affects the order in which the DMA schedules
                                                     channels. The DMA's bus priority is not changed. If the
                                                     DMA is not saturated then a low priority channel will see
                                                     no loss of throughput.                                                    */
      __IOM uint32_t DATA_SIZE  : 2;            /*!< [3..2] Set the size of each bus transfer (byte/halfword/word).
                                                     READ_ADDR and WRITE_ADDR advance by this amount (1/2/4
                                                     bytes) with each transfer.                                                */
      __IOM uint32_t INCR_READ  : 1;            /*!< [4..4] If 1, the read address increments with each transfer.
                                                     If 0, each read is directed to the same, initial address.
                                                     
                                                     Generally this should be disabled for peripheral-to-memory
                                                     transfers.                                                                */
      __IOM uint32_t INCR_WRITE : 1;            /*!< [5..5] If 1, the write address increments with each transfer.
                                                     If 0, each write is directed to the same, initial address.
                                                     
                                                     Generally this should be disabled for memory-to-peripheral
                                                     transfers.                                                                */
      __IOM uint32_t RING_SIZE  : 4;            /*!< [9..6] Size of address wrap region. If 0, don't wrap. For values
                                                     n > 0, only the lower n bits of the address will change.
                                                     This wraps the address on a (1 << n) byte boundary, facilitating
                                                     access to naturally-aligned ring buffers.
                                                     
                                                     Ring sizes between 2 and 32768 bytes are possible. This
                                                     can apply to either read or write addresses, based on value
                                                     of RING_SEL.                                                              */
      __IOM uint32_t RING_SEL   : 1;            /*!< [10..10] Select whether RING_SIZE applies to read or write addresses.
                                                     If 0, read addresses are wrapped on a (1 << RING_SIZE)
                                                     boundary. If 1, write addresses are wrapped.                              */
      __IOM uint32_t CHAIN_TO   : 4;            /*!< [14..11] When this channel completes, it will trigger the channel
                                                     indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this
                                                     channel)_.
                                                     Reset value is equal to channel number (10).                              */
      __IOM uint32_t TREQ_SEL   : 6;            /*!< [20..15] Select a Transfer Request signal.
                                                     The channel uses the transfer request signal to pace its
                                                     data transfer rate. Sources for TREQ signals are internal
                                                     (TIMERS) or external (DREQ, a Data Request from the system).
                                                     0x0 to 0x3a -> select DREQ n as TREQ                                      */
      __IOM uint32_t IRQ_QUIET  : 1;            /*!< [21..21] In QUIET mode, the channel does not generate IRQs at
                                                     the end of every transfer block. Instead, an IRQ is raised
                                                     when NULL is written to a trigger register, indicating
                                                     the end of a control block chain.
                                                     
                                                     This reduces the number of interrupts to be serviced by
                                                     the CPU when transferring a DMA chain of many small control
                                                     blocks.                                                                   */
      __IOM uint32_t BSWAP      : 1;            /*!< [22..22] Apply byte-swap transformation to DMA data.
                                                     For byte data, this has no effect. For halfword data, the
                                                     two bytes of each halfword are swapped. For word data,
                                                     the four bytes of each word are swapped to reverse order.                 */
      __IOM uint32_t SNIFF_EN   : 1;            /*!< [23..23] If 1, this channel's data transfers are visible to
                                                     the sniff hardware, and each transfer will advance the
                                                     state of the checksum. This only applies if the sniff hardware
                                                     is enabled, and has this channel selected.
                                                     
                                                     This allows checksum to be enabled or disabled on a per-control-
                                                     block basis.                                                              */
      __IM  uint32_t BUSY       : 1;            /*!< [24..24] This flag goes high when the channel starts a new transfer
                                                     sequence, and low when the last transfer of that sequence
                                                     completes. Clearing EN while BUSY is high pauses the channel,
                                                     and BUSY will stay high while paused.
                                                     
                                                     To terminate a sequence early (and clear the BUSY flag),
                                                     see CHAN_ABORT.                                                           */
            uint32_t            : 4;
      __IOM uint32_t WRITE_ERROR : 1;           /*!< [29..29] If 1, the channel received a write bus error. Write
                                                     one to clear.
                                                     WRITE_ADDR shows the approximate address where the bus
                                                     error was encountered (will not to be earlier, or more
                                                     than 5 transfers later)                                                   */
      __IOM uint32_t READ_ERROR : 1;            /*!< [30..30] If 1, the channel received a read bus error. Write
                                                     one to clear.
                                                     READ_ADDR shows the approximate address where the bus error
                                                     was encountered (will not to be earlier, or more than 3
                                                     transfers later)                                                          */
      __IM  uint32_t AHB_ERROR  : 1;            /*!< [31..31] Logical OR of the READ_ERROR and WRITE_ERROR flags.
                                                     The channel halts when it encounters any bus error, and
                                                     always raises its channel IRQ flag.                                       */
    } bit;
  } CH10_CTRL_TRIG;
  __IM  uint32_t  CH10_AL1_CTRL;                /*!< (@ 0x00000290) Alias for channel 10 CTRL register                         */
  __IM  uint32_t  CH10_AL1_READ_ADDR;           /*!< (@ 0x00000294) Alias for channel 10 READ_ADDR register                    */
  __IM  uint32_t  CH10_AL1_WRITE_ADDR;          /*!< (@ 0x00000298) Alias for channel 10 WRITE_ADDR register                   */
  __IM  uint32_t  CH10_AL1_TRANS_COUNT_TRIG;    /*!< (@ 0x0000029C) Alias for channel 10 TRANS_COUNT register
                                                                    This is a trigger register (0xc). Writing
                                                                    a nonzero value will
                                                                    reload the channel counter and start the
                                                                    channel.                                                   */
  __IM  uint32_t  CH10_AL2_CTRL;                /*!< (@ 0x000002A0) Alias for channel 10 CTRL register                         */
  __IM  uint32_t  CH10_AL2_TRANS_COUNT;         /*!< (@ 0x000002A4) Alias for channel 10 TRANS_COUNT register                  */
  __IM  uint32_t  CH10_AL2_READ_ADDR;           /*!< (@ 0x000002A8) Alias for channel 10 READ_ADDR register                    */
  __IM  uint32_t  CH10_AL2_WRITE_ADDR_TRIG;     /*!< (@ 0x000002AC) Alias for channel 10 WRITE_ADDR register
                                                                    This is a trigger register (0xc). Writing
                                                                    a nonzero value will
                                                                    reload the channel counter and start the
                                                                    channel.                                                   */
  __IM  uint32_t  CH10_AL3_CTRL;                /*!< (@ 0x000002B0) Alias for channel 10 CTRL register                         */
  __IM  uint32_t  CH10_AL3_WRITE_ADDR;          /*!< (@ 0x000002B4) Alias for channel 10 WRITE_ADDR register                   */
  __IM  uint32_t  CH10_AL3_TRANS_COUNT;         /*!< (@ 0x000002B8) Alias for channel 10 TRANS_COUNT register                  */
  __IM  uint32_t  CH10_AL3_READ_ADDR_TRIG;      /*!< (@ 0x000002BC) Alias for channel 10 READ_ADDR register
                                                                    This is a trigger register (0xc). Writing
                                                                    a nonzero value will
                                                                    reload the channel counter and start the
                                                                    channel.                                                   */
  __IOM uint32_t  CH11_READ_ADDR;               /*!< (@ 0x000002C0) DMA Channel 11 Read Address pointer
                                                                    This register updates automatically each
                                                                    time a read completes. The current value
                                                                    is the next address to be read by this channel.            */
  __IOM uint32_t  CH11_WRITE_ADDR;              /*!< (@ 0x000002C4) DMA Channel 11 Write Address pointer
                                                                    This register updates automatically each
                                                                    time a write completes. The current value
                                                                    is the next address to be written by this
                                                                    channel.                                                   */
  __IOM uint32_t  CH11_TRANS_COUNT;             /*!< (@ 0x000002C8) DMA Channel 11 Transfer Count
                                                                    Program the number of bus transfers a channel
                                                                    will perform before halting. Note that,
                                                                    if transfers are larger than one byte in
                                                                    size, this is not equal to the number of
                                                                    bytes transferred (see CTRL_DATA_SIZE).
                                                                    
                                                                    When the channel is active, reading this
                                                                    register shows the number of transfers remaining,
                                                                    updating automatically each time a write
                                                                    transfer completes.
                                                                    
                                                                    Writing this register sets the RELOAD value
                                                                    for the tra                                                */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000002CC) DMA Channel 11 Control and Status                          */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] DMA Channel Enable.
                                                     When 1, the channel will respond to triggering events,
                                                     which will cause it to become BUSY and start transferring
                                                     data. When 0, the channel will ignore triggers, stop issuing
                                                     transfers, and pause the current transfer sequence (i.e.
                                                     BUSY will remain high if already high)                                    */
      __IOM uint32_t HIGH_PRIORITY : 1;         /*!< [1..1] HIGH_PRIORITY gives a channel preferential treatment
                                                     in issue scheduling: in each scheduling round, all high
                                                     priority channels are considered first, and then only a
                                                     single low priority channel, before returning to the high
                                                     priority channels.
                                                     
                                                     This only affects the order in which the DMA schedules
                                                     channels. The DMA's bus priority is not changed. If the
                                                     DMA is not saturated then a low priority channel will see
                                                     no loss of throughput.                                                    */
      __IOM uint32_t DATA_SIZE  : 2;            /*!< [3..2] Set the size of each bus transfer (byte/halfword/word).
                                                     READ_ADDR and WRITE_ADDR advance by this amount (1/2/4
                                                     bytes) with each transfer.                                                */
      __IOM uint32_t INCR_READ  : 1;            /*!< [4..4] If 1, the read address increments with each transfer.
                                                     If 0, each read is directed to the same, initial address.
                                                     
                                                     Generally this should be disabled for peripheral-to-memory
                                                     transfers.                                                                */
      __IOM uint32_t INCR_WRITE : 1;            /*!< [5..5] If 1, the write address increments with each transfer.
                                                     If 0, each write is directed to the same, initial address.
                                                     
                                                     Generally this should be disabled for memory-to-peripheral
                                                     transfers.                                                                */
      __IOM uint32_t RING_SIZE  : 4;            /*!< [9..6] Size of address wrap region. If 0, don't wrap. For values
                                                     n > 0, only the lower n bits of the address will change.
                                                     This wraps the address on a (1 << n) byte boundary, facilitating
                                                     access to naturally-aligned ring buffers.
                                                     
                                                     Ring sizes between 2 and 32768 bytes are possible. This
                                                     can apply to either read or write addresses, based on value
                                                     of RING_SEL.                                                              */
      __IOM uint32_t RING_SEL   : 1;            /*!< [10..10] Select whether RING_SIZE applies to read or write addresses.
                                                     If 0, read addresses are wrapped on a (1 << RING_SIZE)
                                                     boundary. If 1, write addresses are wrapped.                              */
      __IOM uint32_t CHAIN_TO   : 4;            /*!< [14..11] When this channel completes, it will trigger the channel
                                                     indicated by CHAIN_TO. Disable by setting CHAIN_TO = _(this
                                                     channel)_.
                                                     Reset value is equal to channel number (11).                              */
      __IOM uint32_t TREQ_SEL   : 6;            /*!< [20..15] Select a Transfer Request signal.
                                                     The channel uses the transfer request signal to pace its
                                                     data transfer rate. Sources for TREQ signals are internal
                                                     (TIMERS) or external (DREQ, a Data Request from the system).
                                                     0x0 to 0x3a -> select DREQ n as TREQ                                      */
      __IOM uint32_t IRQ_QUIET  : 1;            /*!< [21..21] In QUIET mode, the channel does not generate IRQs at
                                                     the end of every transfer block. Instead, an IRQ is raised
                                                     when NULL is written to a trigger register, indicating
                                                     the end of a control block chain.
                                                     
                                                     This reduces the number of interrupts to be serviced by
                                                     the CPU when transferring a DMA chain of many small control
                                                     blocks.                                                                   */
      __IOM uint32_t BSWAP      : 1;            /*!< [22..22] Apply byte-swap transformation to DMA data.
                                                     For byte data, this has no effect. For halfword data, the
                                                     two bytes of each halfword are swapped. For word data,
                                                     the four bytes of each word are swapped to reverse order.                 */
      __IOM uint32_t SNIFF_EN   : 1;            /*!< [23..23] If 1, this channel's data transfers are visible to
                                                     the sniff hardware, and each transfer will advance the
                                                     state of the checksum. This only applies if the sniff hardware
                                                     is enabled, and has this channel selected.
                                                     
                                                     This allows checksum to be enabled or disabled on a per-control-
                                                     block basis.                                                              */
      __IM  uint32_t BUSY       : 1;            /*!< [24..24] This flag goes high when the channel starts a new transfer
                                                     sequence, and low when the last transfer of that sequence
                                                     completes. Clearing EN while BUSY is high pauses the channel,
                                                     and BUSY will stay high while paused.
                                                     
                                                     To terminate a sequence early (and clear the BUSY flag),
                                                     see CHAN_ABORT.                                                           */
            uint32_t            : 4;
      __IOM uint32_t WRITE_ERROR : 1;           /*!< [29..29] If 1, the channel received a write bus error. Write
                                                     one to clear.
                                                     WRITE_ADDR shows the approximate address where the bus
                                                     error was encountered (will not to be earlier, or more
                                                     than 5 transfers later)                                                   */
      __IOM uint32_t READ_ERROR : 1;            /*!< [30..30] If 1, the channel received a read bus error. Write
                                                     one to clear.
                                                     READ_ADDR shows the approximate address where the bus error
                                                     was encountered (will not to be earlier, or more than 3
                                                     transfers later)                                                          */
      __IM  uint32_t AHB_ERROR  : 1;            /*!< [31..31] Logical OR of the READ_ERROR and WRITE_ERROR flags.
                                                     The channel halts when it encounters any bus error, and
                                                     always raises its channel IRQ flag.                                       */
    } bit;
  } CH11_CTRL_TRIG;
  __IM  uint32_t  CH11_AL1_CTRL;                /*!< (@ 0x000002D0) Alias for channel 11 CTRL register                         */
  __IM  uint32_t  CH11_AL1_READ_ADDR;           /*!< (@ 0x000002D4) Alias for channel 11 READ_ADDR register                    */
  __IM  uint32_t  CH11_AL1_WRITE_ADDR;          /*!< (@ 0x000002D8) Alias for channel 11 WRITE_ADDR register                   */
  __IM  uint32_t  CH11_AL1_TRANS_COUNT_TRIG;    /*!< (@ 0x000002DC) Alias for channel 11 TRANS_COUNT register
                                                                    This is a trigger register (0xc). Writing
                                                                    a nonzero value will
                                                                    reload the channel counter and start the
                                                                    channel.                                                   */
  __IM  uint32_t  CH11_AL2_CTRL;                /*!< (@ 0x000002E0) Alias for channel 11 CTRL register                         */
  __IM  uint32_t  CH11_AL2_TRANS_COUNT;         /*!< (@ 0x000002E4) Alias for channel 11 TRANS_COUNT register                  */
  __IM  uint32_t  CH11_AL2_READ_ADDR;           /*!< (@ 0x000002E8) Alias for channel 11 READ_ADDR register                    */
  __IM  uint32_t  CH11_AL2_WRITE_ADDR_TRIG;     /*!< (@ 0x000002EC) Alias for channel 11 WRITE_ADDR register
                                                                    This is a trigger register (0xc). Writing
                                                                    a nonzero value will
                                                                    reload the channel counter and start the
                                                                    channel.                                                   */
  __IM  uint32_t  CH11_AL3_CTRL;                /*!< (@ 0x000002F0) Alias for channel 11 CTRL register                         */
  __IM  uint32_t  CH11_AL3_WRITE_ADDR;          /*!< (@ 0x000002F4) Alias for channel 11 WRITE_ADDR register                   */
  __IM  uint32_t  CH11_AL3_TRANS_COUNT;         /*!< (@ 0x000002F8) Alias for channel 11 TRANS_COUNT register                  */
  __IM  uint32_t  CH11_AL3_READ_ADDR_TRIG;      /*!< (@ 0x000002FC) Alias for channel 11 READ_ADDR register
                                                                    This is a trigger register (0xc). Writing
                                                                    a nonzero value will
                                                                    reload the channel counter and start the
                                                                    channel.                                                   */
  __IM  uint32_t  RESERVED[64];
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000400) Interrupt Status (raw)                                     */
    
    struct {
      __IM  uint32_t INTR       : 16;           /*!< [15..0] Raw interrupt status for DMA Channels 0..15. Bit n corresponds
                                                     to channel n. Ignores any masking or forcing. Channel interrupts
                                                     can be cleared by writing a bit mask to INTR, INTS0 or
                                                     INTS1.
                                                     
                                                     Channel interrupts can be routed to either of two system-level
                                                     IRQs based on INTE0 and INTE1.
                                                     
                                                     This can be used vector different channel interrupts to
                                                     different ISRs: this might be done to allow NVIC IRQ preemption
                                                     for more time-critical channels, or to spread IRQ load
                                                     across d                                                                  */
            uint32_t            : 16;
    } bit;
  } INTR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000404) Interrupt Enables for IRQ 0                                */
    
    struct {
      __IOM uint32_t INTE0      : 16;           /*!< [15..0] Set bit n to pass interrupts from channel n to DMA IRQ
                                                     0.                                                                        */
            uint32_t            : 16;
    } bit;
  } INTE0;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000408) Force Interrupts                                           */
    
    struct {
      __IOM uint32_t INTF0      : 16;           /*!< [15..0] Write 1s to force the corresponding bits in INTE0. The
                                                     interrupt remains asserted until INTF0 is cleared.                        */
            uint32_t            : 16;
    } bit;
  } INTF0;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000040C) Interrupt Status for IRQ 0                                 */
    
    struct {
      __IOM uint32_t INTS0      : 16;           /*!< [15..0] Indicates active channel interrupt requests which are
                                                     currently causing IRQ 0 to be asserted.
                                                     Channel interrupts can be cleared by writing a bit mask
                                                     here.                                                                     */
            uint32_t            : 16;
    } bit;
  } INTS0;
  __IM  uint32_t  RESERVED1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000414) Interrupt Enables for IRQ 1                                */
    
    struct {
      __IOM uint32_t INTE1      : 16;           /*!< [15..0] Set bit n to pass interrupts from channel n to DMA IRQ
                                                     1.                                                                        */
            uint32_t            : 16;
    } bit;
  } INTE1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000418) Force Interrupts for IRQ 1                                 */
    
    struct {
      __IOM uint32_t INTF1      : 16;           /*!< [15..0] Write 1s to force the corresponding bits in INTE0. The
                                                     interrupt remains asserted until INTF0 is cleared.                        */
            uint32_t            : 16;
    } bit;
  } INTF1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000041C) Interrupt Status (masked) for IRQ 1                        */
    
    struct {
      __IOM uint32_t INTS1      : 16;           /*!< [15..0] Indicates active channel interrupt requests which are
                                                     currently causing IRQ 1 to be asserted.
                                                     Channel interrupts can be cleared by writing a bit mask
                                                     here.                                                                     */
            uint32_t            : 16;
    } bit;
  } INTS1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000420) Pacing (X/Y) Fractional Timer
                                                                    The pacing timer produces TREQ assertions
                                                                    at a rate set by ((X/Y) * sys_clk). This
                                                                    equation is evaluated every sys_clk cycles
                                                                    and therefore can only generate TREQs at
                                                                    a rate of 1 per sys_clk (i.e. permanent
                                                                    TREQ) or less.                                             */
    
    struct {
      __IOM uint32_t Y          : 16;           /*!< [15..0] Pacing Timer Divisor. Specifies the Y value for the
                                                     (X/Y) fractional timer.                                                   */
      __IOM uint32_t X          : 16;           /*!< [31..16] Pacing Timer Dividend. Specifies the X value for the
                                                     (X/Y) fractional timer.                                                   */
    } bit;
  } TIMER0;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000424) Pacing (X/Y) Fractional Timer
                                                                    The pacing timer produces TREQ assertions
                                                                    at a rate set by ((X/Y) * sys_clk). This
                                                                    equation is evaluated every sys_clk cycles
                                                                    and therefore can only generate TREQs at
                                                                    a rate of 1 per sys_clk (i.e. permanent
                                                                    TREQ) or less.                                             */
    
    struct {
      __IOM uint32_t Y          : 16;           /*!< [15..0] Pacing Timer Divisor. Specifies the Y value for the
                                                     (X/Y) fractional timer.                                                   */
      __IOM uint32_t X          : 16;           /*!< [31..16] Pacing Timer Dividend. Specifies the X value for the
                                                     (X/Y) fractional timer.                                                   */
    } bit;
  } TIMER1;
  __IM  uint32_t  RESERVED2[2];
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000430) Trigger one or more channels simultaneously                */
    
    struct {
      __IOM uint32_t MULTI_CHAN_TRIGGER : 16;   /*!< [15..0] Each bit in this register corresponds to a DMA channel.
                                                     Writing a 1 to the relevant bit is the same as writing
                                                     to that channel's trigger register; the channel will start
                                                     if it is currently enabled and not already busy.                          */
            uint32_t            : 16;
    } bit;
  } MULTI_CHAN_TRIGGER;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000434) Sniffer Control                                            */
    
    struct {
      __IOM uint32_t EN         : 1;            /*!< [0..0] Enable sniffer                                                     */
      __IOM uint32_t DMACH      : 4;            /*!< [4..1] DMA channel for Sniffer to observe                                 */
      __IOM uint32_t CALC       : 4;            /*!< [8..5] CALC                                                               */
      __IOM uint32_t BSWAP      : 1;            /*!< [9..9] Locally perform a byte reverse on the sniffed data, before
                                                     feeding into checksum.
                                                     
                                                     Note that the sniff hardware is downstream of the DMA channel
                                                     byteswap performed in the read master: if channel CTRL_BSWAP
                                                     and SNIFF_CTRL_BSWAP are both enabled, their effects cancel
                                                     from the sniffer's point of view.                                         */
      __IOM uint32_t OUT_REV    : 1;            /*!< [10..10] If set, the result appears bit-reversed when read.
                                                     This does not affect the way the checksum is calculated;
                                                     the result is transformed on-the-fly between the result
                                                     register and the bus.                                                     */
      __IOM uint32_t OUT_INV    : 1;            /*!< [11..11] If set, the result appears inverted (bitwise complement)
                                                     when read. This does not affect the way the checksum is
                                                     calculated; the result is transformed on-the-fly between
                                                     the result register and the bus.                                          */
            uint32_t            : 20;
    } bit;
  } SNIFF_CTRL;
  __IOM uint32_t  SNIFF_DATA;                   /*!< (@ 0x00000438) Data accumulator for sniff hardware
                                                                    Write an initial seed value here before
                                                                    starting a DMA transfer on the channel indicated
                                                                    by SNIFF_CTRL_DMACH. The hardware will update
                                                                    this register each time it observes a read
                                                                    from the indicated channel. Once the channel
                                                                    completes, the final result can be read
                                                                    from this register.                                        */
  __IM  uint32_t  RESERVED3;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000440) Debug RAF, WAF, TDF levels                                 */
    
    struct {
      __IM  uint32_t TDF_LVL    : 8;            /*!< [7..0] Current Transfer-Data-FIFO fill level                              */
      __IM  uint32_t WAF_LVL    : 8;            /*!< [15..8] Current Write-Address-FIFO fill level                             */
      __IM  uint32_t RAF_LVL    : 8;            /*!< [23..16] Current Read-Address-FIFO fill level                             */
            uint32_t            : 8;
    } bit;
  } FIFO_LEVELS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000444) Abort an in-progress transfer sequence on one
                                                                    or more channels                                           */
    
    struct {
      __IOM uint32_t CHAN_ABORT : 16;           /*!< [15..0] Each bit corresponds to a channel. Writing a 1 aborts
                                                     whatever transfer sequence is in progress on that channel.
                                                     The bit will remain high until any in-flight transfers
                                                     have been flushed through the address and data FIFOs.
                                                     
                                                     After writing, this register must be polled until it returns
                                                     all-zero. Until this point, it is unsafe to restart the
                                                     channel.                                                                  */
            uint32_t            : 16;
    } bit;
  } CHAN_ABORT;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000448) The number of channels this DMA instance is equipped
                                                                    with. This DMA supports up to 16 hardware
                                                                    channels, but can be configured with as
                                                                    few as one, to minimise silicon area.                      */
    
    struct {
      __IM  uint32_t N_CHANNELS : 5;            /*!< [4..0] N_CHANNELS                                                         */
            uint32_t            : 27;
    } bit;
  } N_CHANNELS;
  __IM  uint32_t  RESERVED4[237];
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000800) Read: get channel DREQ counter (i.e. how many
                                                                    accesses the DMA expects it can perform
                                                                    on the peripheral without overflow/underflow.
                                                                    Write any value: clears the counter, and
                                                                    cause channel to re-initiate DREQ handshake.               */
    
    struct {
      __IM  uint32_t CH0_DBG_CTDREQ : 6;        /*!< [5..0] CH0_DBG_CTDREQ                                                     */
            uint32_t            : 26;
    } bit;
  } CH0_DBG_CTDREQ;
  __IM  uint32_t  CH0_DBG_TCR;                  /*!< (@ 0x00000804) Read to get channel TRANS_COUNT reload value,
                                                                    i.e. the length of the next transfer                       */
  __IM  uint32_t  RESERVED5[14];
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000840) Read: get channel DREQ counter (i.e. how many
                                                                    accesses the DMA expects it can perform
                                                                    on the peripheral without overflow/underflow.
                                                                    Write any value: clears the counter, and
                                                                    cause channel to re-initiate DREQ handshake.               */
    
    struct {
      __IM  uint32_t CH1_DBG_CTDREQ : 6;        /*!< [5..0] CH1_DBG_CTDREQ                                                     */
            uint32_t            : 26;
    } bit;
  } CH1_DBG_CTDREQ;
  __IM  uint32_t  CH1_DBG_TCR;                  /*!< (@ 0x00000844) Read to get channel TRANS_COUNT reload value,
                                                                    i.e. the length of the next transfer                       */
  __IM  uint32_t  RESERVED6[14];
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000880) Read: get channel DREQ counter (i.e. how many
                                                                    accesses the DMA expects it can perform
                                                                    on the peripheral without overflow/underflow.
                                                                    Write any value: clears the counter, and
                                                                    cause channel to re-initiate DREQ handshake.               */
    
    struct {
      __IM  uint32_t CH2_DBG_CTDREQ : 6;        /*!< [5..0] CH2_DBG_CTDREQ                                                     */
            uint32_t            : 26;
    } bit;
  } CH2_DBG_CTDREQ;
  __IM  uint32_t  CH2_DBG_TCR;                  /*!< (@ 0x00000884) Read to get channel TRANS_COUNT reload value,
                                                                    i.e. the length of the next transfer                       */
  __IM  uint32_t  RESERVED7[14];
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000008C0) Read: get channel DREQ counter (i.e. how many
                                                                    accesses the DMA expects it can perform
                                                                    on the peripheral without overflow/underflow.
                                                                    Write any value: clears the counter, and
                                                                    cause channel to re-initiate DREQ handshake.               */
    
    struct {
      __IM  uint32_t CH3_DBG_CTDREQ : 6;        /*!< [5..0] CH3_DBG_CTDREQ                                                     */
            uint32_t            : 26;
    } bit;
  } CH3_DBG_CTDREQ;
  __IM  uint32_t  CH3_DBG_TCR;                  /*!< (@ 0x000008C4) Read to get channel TRANS_COUNT reload value,
                                                                    i.e. the length of the next transfer                       */
  __IM  uint32_t  RESERVED8[14];
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000900) Read: get channel DREQ counter (i.e. how many
                                                                    accesses the DMA expects it can perform
                                                                    on the peripheral without overflow/underflow.
                                                                    Write any value: clears the counter, and
                                                                    cause channel to re-initiate DREQ handshake.               */
    
    struct {
      __IM  uint32_t CH4_DBG_CTDREQ : 6;        /*!< [5..0] CH4_DBG_CTDREQ                                                     */
            uint32_t            : 26;
    } bit;
  } CH4_DBG_CTDREQ;
  __IM  uint32_t  CH4_DBG_TCR;                  /*!< (@ 0x00000904) Read to get channel TRANS_COUNT reload value,
                                                                    i.e. the length of the next transfer                       */
  __IM  uint32_t  RESERVED9[14];
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000940) Read: get channel DREQ counter (i.e. how many
                                                                    accesses the DMA expects it can perform
                                                                    on the peripheral without overflow/underflow.
                                                                    Write any value: clears the counter, and
                                                                    cause channel to re-initiate DREQ handshake.               */
    
    struct {
      __IM  uint32_t CH5_DBG_CTDREQ : 6;        /*!< [5..0] CH5_DBG_CTDREQ                                                     */
            uint32_t            : 26;
    } bit;
  } CH5_DBG_CTDREQ;
  __IM  uint32_t  CH5_DBG_TCR;                  /*!< (@ 0x00000944) Read to get channel TRANS_COUNT reload value,
                                                                    i.e. the length of the next transfer                       */
  __IM  uint32_t  RESERVED10[14];
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000980) Read: get channel DREQ counter (i.e. how many
                                                                    accesses the DMA expects it can perform
                                                                    on the peripheral without overflow/underflow.
                                                                    Write any value: clears the counter, and
                                                                    cause channel to re-initiate DREQ handshake.               */
    
    struct {
      __IM  uint32_t CH6_DBG_CTDREQ : 6;        /*!< [5..0] CH6_DBG_CTDREQ                                                     */
            uint32_t            : 26;
    } bit;
  } CH6_DBG_CTDREQ;
  __IM  uint32_t  CH6_DBG_TCR;                  /*!< (@ 0x00000984) Read to get channel TRANS_COUNT reload value,
                                                                    i.e. the length of the next transfer                       */
  __IM  uint32_t  RESERVED11[14];
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000009C0) Read: get channel DREQ counter (i.e. how many
                                                                    accesses the DMA expects it can perform
                                                                    on the peripheral without overflow/underflow.
                                                                    Write any value: clears the counter, and
                                                                    cause channel to re-initiate DREQ handshake.               */
    
    struct {
      __IM  uint32_t CH7_DBG_CTDREQ : 6;        /*!< [5..0] CH7_DBG_CTDREQ                                                     */
            uint32_t            : 26;
    } bit;
  } CH7_DBG_CTDREQ;
  __IM  uint32_t  CH7_DBG_TCR;                  /*!< (@ 0x000009C4) Read to get channel TRANS_COUNT reload value,
                                                                    i.e. the length of the next transfer                       */
  __IM  uint32_t  RESERVED12[14];
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000A00) Read: get channel DREQ counter (i.e. how many
                                                                    accesses the DMA expects it can perform
                                                                    on the peripheral without overflow/underflow.
                                                                    Write any value: clears the counter, and
                                                                    cause channel to re-initiate DREQ handshake.               */
    
    struct {
      __IM  uint32_t CH8_DBG_CTDREQ : 6;        /*!< [5..0] CH8_DBG_CTDREQ                                                     */
            uint32_t            : 26;
    } bit;
  } CH8_DBG_CTDREQ;
  __IM  uint32_t  CH8_DBG_TCR;                  /*!< (@ 0x00000A04) Read to get channel TRANS_COUNT reload value,
                                                                    i.e. the length of the next transfer                       */
  __IM  uint32_t  RESERVED13[14];
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000A40) Read: get channel DREQ counter (i.e. how many
                                                                    accesses the DMA expects it can perform
                                                                    on the peripheral without overflow/underflow.
                                                                    Write any value: clears the counter, and
                                                                    cause channel to re-initiate DREQ handshake.               */
    
    struct {
      __IM  uint32_t CH9_DBG_CTDREQ : 6;        /*!< [5..0] CH9_DBG_CTDREQ                                                     */
            uint32_t            : 26;
    } bit;
  } CH9_DBG_CTDREQ;
  __IM  uint32_t  CH9_DBG_TCR;                  /*!< (@ 0x00000A44) Read to get channel TRANS_COUNT reload value,
                                                                    i.e. the length of the next transfer                       */
  __IM  uint32_t  RESERVED14[14];
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000A80) Read: get channel DREQ counter (i.e. how many
                                                                    accesses the DMA expects it can perform
                                                                    on the peripheral without overflow/underflow.
                                                                    Write any value: clears the counter, and
                                                                    cause channel to re-initiate DREQ handshake.               */
    
    struct {
      __IM  uint32_t CH10_DBG_CTDREQ : 6;       /*!< [5..0] CH10_DBG_CTDREQ                                                    */
            uint32_t            : 26;
    } bit;
  } CH10_DBG_CTDREQ;
  __IM  uint32_t  CH10_DBG_TCR;                 /*!< (@ 0x00000A84) Read to get channel TRANS_COUNT reload value,
                                                                    i.e. the length of the next transfer                       */
  __IM  uint32_t  RESERVED15[14];
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000AC0) Read: get channel DREQ counter (i.e. how many
                                                                    accesses the DMA expects it can perform
                                                                    on the peripheral without overflow/underflow.
                                                                    Write any value: clears the counter, and
                                                                    cause channel to re-initiate DREQ handshake.               */
    
    struct {
      __IM  uint32_t CH11_DBG_CTDREQ : 6;       /*!< [5..0] CH11_DBG_CTDREQ                                                    */
            uint32_t            : 26;
    } bit;
  } CH11_DBG_CTDREQ;
  __IM  uint32_t  CH11_DBG_TCR;                 /*!< (@ 0x00000AC4) Read to get channel TRANS_COUNT reload value,
                                                                    i.e. the length of the next transfer                       */
} DMA_Type;                                     /*!< Size = 2760 (0xac8)                                                       */



/* =========================================================================================================================== */
/* ================                                       USBCTRL_REGS                                        ================ */
/* =========================================================================================================================== */


/**
  * @brief USB FS/LS controller device registers (USBCTRL_REGS)
  */

typedef struct {                                /*!< (@ 0x50110000) USBCTRL_REGS Structure                                     */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000000) Device address and endpoint control                        */
    
    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< [6..0] In device mode, the address that the device should respond
                                                     to. Set in response to a SET_ADDR setup packet from the
                                                     host. In host mode set to the address of the device to
                                                     communicate with.                                                         */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< [19..16] Device endpoint to send data to. Only valid for HOST
                                                     mode.                                                                     */
            uint32_t            : 12;
    } bit;
  } ADDR_ENDP;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000004) Interrupt endpoint 1. Only valid for HOST mode.            */
    
    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< [6..0] Device address                                                     */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< [19..16] Endpoint number of the interrupt endpoint                        */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< [25..25] Direction of the interrupt endpoint. In=0, Out=1                 */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< [26..26] Interrupt EP requires preamble (is a low speed device
                                                     on a full speed hub)                                                      */
            uint32_t            : 5;
    } bit;
  } ADDR_ENDP1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000008) Interrupt endpoint 2. Only valid for HOST mode.            */
    
    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< [6..0] Device address                                                     */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< [19..16] Endpoint number of the interrupt endpoint                        */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< [25..25] Direction of the interrupt endpoint. In=0, Out=1                 */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< [26..26] Interrupt EP requires preamble (is a low speed device
                                                     on a full speed hub)                                                      */
            uint32_t            : 5;
    } bit;
  } ADDR_ENDP2;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000000C) Interrupt endpoint 3. Only valid for HOST mode.            */
    
    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< [6..0] Device address                                                     */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< [19..16] Endpoint number of the interrupt endpoint                        */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< [25..25] Direction of the interrupt endpoint. In=0, Out=1                 */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< [26..26] Interrupt EP requires preamble (is a low speed device
                                                     on a full speed hub)                                                      */
            uint32_t            : 5;
    } bit;
  } ADDR_ENDP3;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000010) Interrupt endpoint 4. Only valid for HOST mode.            */
    
    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< [6..0] Device address                                                     */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< [19..16] Endpoint number of the interrupt endpoint                        */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< [25..25] Direction of the interrupt endpoint. In=0, Out=1                 */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< [26..26] Interrupt EP requires preamble (is a low speed device
                                                     on a full speed hub)                                                      */
            uint32_t            : 5;
    } bit;
  } ADDR_ENDP4;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000014) Interrupt endpoint 5. Only valid for HOST mode.            */
    
    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< [6..0] Device address                                                     */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< [19..16] Endpoint number of the interrupt endpoint                        */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< [25..25] Direction of the interrupt endpoint. In=0, Out=1                 */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< [26..26] Interrupt EP requires preamble (is a low speed device
                                                     on a full speed hub)                                                      */
            uint32_t            : 5;
    } bit;
  } ADDR_ENDP5;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000018) Interrupt endpoint 6. Only valid for HOST mode.            */
    
    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< [6..0] Device address                                                     */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< [19..16] Endpoint number of the interrupt endpoint                        */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< [25..25] Direction of the interrupt endpoint. In=0, Out=1                 */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< [26..26] Interrupt EP requires preamble (is a low speed device
                                                     on a full speed hub)                                                      */
            uint32_t            : 5;
    } bit;
  } ADDR_ENDP6;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000001C) Interrupt endpoint 7. Only valid for HOST mode.            */
    
    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< [6..0] Device address                                                     */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< [19..16] Endpoint number of the interrupt endpoint                        */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< [25..25] Direction of the interrupt endpoint. In=0, Out=1                 */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< [26..26] Interrupt EP requires preamble (is a low speed device
                                                     on a full speed hub)                                                      */
            uint32_t            : 5;
    } bit;
  } ADDR_ENDP7;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000020) Interrupt endpoint 8. Only valid for HOST mode.            */
    
    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< [6..0] Device address                                                     */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< [19..16] Endpoint number of the interrupt endpoint                        */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< [25..25] Direction of the interrupt endpoint. In=0, Out=1                 */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< [26..26] Interrupt EP requires preamble (is a low speed device
                                                     on a full speed hub)                                                      */
            uint32_t            : 5;
    } bit;
  } ADDR_ENDP8;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000024) Interrupt endpoint 9. Only valid for HOST mode.            */
    
    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< [6..0] Device address                                                     */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< [19..16] Endpoint number of the interrupt endpoint                        */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< [25..25] Direction of the interrupt endpoint. In=0, Out=1                 */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< [26..26] Interrupt EP requires preamble (is a low speed device
                                                     on a full speed hub)                                                      */
            uint32_t            : 5;
    } bit;
  } ADDR_ENDP9;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000028) Interrupt endpoint 10. Only valid for HOST mode.           */
    
    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< [6..0] Device address                                                     */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< [19..16] Endpoint number of the interrupt endpoint                        */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< [25..25] Direction of the interrupt endpoint. In=0, Out=1                 */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< [26..26] Interrupt EP requires preamble (is a low speed device
                                                     on a full speed hub)                                                      */
            uint32_t            : 5;
    } bit;
  } ADDR_ENDP10;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000002C) Interrupt endpoint 11. Only valid for HOST mode.           */
    
    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< [6..0] Device address                                                     */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< [19..16] Endpoint number of the interrupt endpoint                        */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< [25..25] Direction of the interrupt endpoint. In=0, Out=1                 */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< [26..26] Interrupt EP requires preamble (is a low speed device
                                                     on a full speed hub)                                                      */
            uint32_t            : 5;
    } bit;
  } ADDR_ENDP11;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000030) Interrupt endpoint 12. Only valid for HOST mode.           */
    
    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< [6..0] Device address                                                     */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< [19..16] Endpoint number of the interrupt endpoint                        */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< [25..25] Direction of the interrupt endpoint. In=0, Out=1                 */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< [26..26] Interrupt EP requires preamble (is a low speed device
                                                     on a full speed hub)                                                      */
            uint32_t            : 5;
    } bit;
  } ADDR_ENDP12;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000034) Interrupt endpoint 13. Only valid for HOST mode.           */
    
    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< [6..0] Device address                                                     */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< [19..16] Endpoint number of the interrupt endpoint                        */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< [25..25] Direction of the interrupt endpoint. In=0, Out=1                 */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< [26..26] Interrupt EP requires preamble (is a low speed device
                                                     on a full speed hub)                                                      */
            uint32_t            : 5;
    } bit;
  } ADDR_ENDP13;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000038) Interrupt endpoint 14. Only valid for HOST mode.           */
    
    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< [6..0] Device address                                                     */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< [19..16] Endpoint number of the interrupt endpoint                        */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< [25..25] Direction of the interrupt endpoint. In=0, Out=1                 */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< [26..26] Interrupt EP requires preamble (is a low speed device
                                                     on a full speed hub)                                                      */
            uint32_t            : 5;
    } bit;
  } ADDR_ENDP14;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000003C) Interrupt endpoint 15. Only valid for HOST mode.           */
    
    struct {
      __IOM uint32_t ADDRESS    : 7;            /*!< [6..0] Device address                                                     */
            uint32_t            : 9;
      __IOM uint32_t ENDPOINT   : 4;            /*!< [19..16] Endpoint number of the interrupt endpoint                        */
            uint32_t            : 5;
      __IOM uint32_t INTEP_DIR  : 1;            /*!< [25..25] Direction of the interrupt endpoint. In=0, Out=1                 */
      __IOM uint32_t INTEP_PREAMBLE : 1;        /*!< [26..26] Interrupt EP requires preamble (is a low speed device
                                                     on a full speed hub)                                                      */
            uint32_t            : 5;
    } bit;
  } ADDR_ENDP15;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000040) Main control register                                      */
    
    struct {
      __IOM uint32_t CONTROLLER_EN : 1;         /*!< [0..0] Enable controller                                                  */
      __IOM uint32_t HOST_NDEVICE : 1;          /*!< [1..1] Device mode = 0, Host mode = 1                                     */
            uint32_t            : 29;
      __IOM uint32_t SIM_TIMING : 1;            /*!< [31..31] Reduced timings for simulation                                   */
    } bit;
  } MAIN_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000044) Set the SOF (Start of Frame) frame number in
                                                                    the host controller. The SOF packet is sent
                                                                    every 1ms and the host will increment the
                                                                    frame number by 1 each time.                               */
    
    struct {
      __OM  uint32_t COUNT      : 11;           /*!< [10..0] COUNT                                                             */
            uint32_t            : 21;
    } bit;
  } SOF_WR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000048) Read the last SOF (Start of Frame) frame number
                                                                    seen. In device mode the last SOF received
                                                                    from the host. In host mode the last SOF
                                                                    sent by the host.                                          */
    
    struct {
      __IM  uint32_t COUNT      : 11;           /*!< [10..0] COUNT                                                             */
            uint32_t            : 21;
    } bit;
  } SOF_RD;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000004C) SIE control register                                       */
    
    struct {
      __IOM uint32_t START_TRANS : 1;           /*!< [0..0] Host: Start transaction                                            */
      __IOM uint32_t SEND_SETUP : 1;            /*!< [1..1] Host: Send Setup packet                                            */
      __IOM uint32_t SEND_DATA  : 1;            /*!< [2..2] Host: Send transaction (OUT from host)                             */
      __IOM uint32_t RECEIVE_DATA : 1;          /*!< [3..3] Host: Receive transaction (IN to host)                             */
      __IOM uint32_t STOP_TRANS : 1;            /*!< [4..4] Host: Stop transaction                                             */
            uint32_t            : 1;
      __IOM uint32_t PREAMBLE_EN : 1;           /*!< [6..6] Host: Preable enable for LS device on FS hub                       */
            uint32_t            : 1;
      __IOM uint32_t SOF_SYNC   : 1;            /*!< [8..8] Host: Delay packet(s) until after SOF                              */
      __IOM uint32_t SOF_EN     : 1;            /*!< [9..9] Host: Enable SOF generation (for full speed bus)                   */
      __IOM uint32_t KEEP_ALIVE_EN : 1;         /*!< [10..10] Host: Enable keep alive packet (for low speed bus)               */
      __IOM uint32_t VBUS_EN    : 1;            /*!< [11..11] Host: Enable VBUS                                                */
      __IOM uint32_t RESUME     : 1;            /*!< [12..12] Device: Remote wakeup. Device can initiate its own
                                                     resume after suspend.                                                     */
      __IOM uint32_t RESET_BUS  : 1;            /*!< [13..13] Host: Reset bus                                                  */
            uint32_t            : 1;
      __IOM uint32_t PULLDOWN_EN : 1;           /*!< [15..15] Host: Enable pull down resistors                                 */
      __IOM uint32_t PULLUP_EN  : 1;            /*!< [16..16] Device: Enable pull up resistor                                  */
      __IOM uint32_t RPU_OPT    : 1;            /*!< [17..17] Device: Pull-up strength (0=1K2, 1=2k3)                          */
      __IOM uint32_t TRANSCEIVER_PD : 1;        /*!< [18..18] Power down bus transceiver                                       */
            uint32_t            : 5;
      __IOM uint32_t DIRECT_DM  : 1;            /*!< [24..24] Direct control of DM                                             */
      __IOM uint32_t DIRECT_DP  : 1;            /*!< [25..25] Direct control of DP                                             */
      __IOM uint32_t DIRECT_EN  : 1;            /*!< [26..26] Direct bus drive enable                                          */
      __IOM uint32_t EP0_INT_NAK : 1;           /*!< [27..27] Device: Set bit in EP_STATUS_STALL_NAK when EP0 sends
                                                     a NAK                                                                     */
      __IOM uint32_t EP0_INT_2BUF : 1;          /*!< [28..28] Device: Set bit in BUFF_STATUS for every 2 buffers
                                                     completed on EP0                                                          */
      __IOM uint32_t EP0_INT_1BUF : 1;          /*!< [29..29] Device: Set bit in BUFF_STATUS for every buffer completed
                                                     on EP0                                                                    */
      __IOM uint32_t EP0_DOUBLE_BUF : 1;        /*!< [30..30] Device: EP0 single buffered = 0, double buffered =
                                                     1                                                                         */
      __IOM uint32_t EP0_INT_STALL : 1;         /*!< [31..31] Device: Set bit in EP_STATUS_STALL_NAK when EP0 sends
                                                     a STALL                                                                   */
    } bit;
  } SIE_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000050) SIE status register                                        */
    
    struct {
      __IM  uint32_t VBUS_DETECTED : 1;         /*!< [0..0] Device: VBUS Detected                                              */
            uint32_t            : 1;
      __IM  uint32_t LINE_STATE : 2;            /*!< [3..2] USB bus line state                                                 */
      __IM  uint32_t SUSPENDED  : 1;            /*!< [4..4] Bus in suspended state. Valid for device and host. Host
                                                     and device will go into suspend if neither Keep Alive /
                                                     SOF frames are enabled.                                                   */
            uint32_t            : 3;
      __IM  uint32_t SPEED      : 2;            /*!< [9..8] Host: device speed. Disconnected = 00, LS = 01, FS =
                                                     10                                                                        */
      __IM  uint32_t VBUS_OVER_CURR : 1;        /*!< [10..10] VBUS over current detected                                       */
      __IOM uint32_t RESUME     : 1;            /*!< [11..11] Host: Device has initiated a remote resume. Device:
                                                     host has initiated a resume.                                              */
            uint32_t            : 4;
      __IM  uint32_t CONNECTED  : 1;            /*!< [16..16] Device: connected                                                */
      __IOM uint32_t SETUP_REC  : 1;            /*!< [17..17] Device: Setup packet received                                    */
      __IOM uint32_t TRANS_COMPLETE : 1;        /*!< [18..18] Transaction complete.
                                                     
                                                     Raised by device if:
                                                     
                                                     * An IN or OUT packet is sent with the `LAST_BUFF` bit
                                                     set in the buffer control register
                                                     
                                                     Raised by host if:
                                                     
                                                     * A setup packet is sent when no data in or data out transaction
                                                     follows * An IN packet is received and the `LAST_BUFF`
                                                     bit is set in the buffer control register * An IN packet
                                                     is received with zero length * An OUT packet is sent and
                                                     the `LAST_BUFF` bit is set                                                */
      __IOM uint32_t BUS_RESET  : 1;            /*!< [19..19] Device: bus reset received                                       */
            uint32_t            : 4;
      __IOM uint32_t CRC_ERROR  : 1;            /*!< [24..24] CRC Error. Raised by the Serial RX engine.                       */
      __IOM uint32_t BIT_STUFF_ERROR : 1;       /*!< [25..25] Bit Stuff Error. Raised by the Serial RX engine.                 */
      __IOM uint32_t RX_OVERFLOW : 1;           /*!< [26..26] RX overflow is raised by the Serial RX engine if the
                                                     incoming data is too fast.                                                */
      __IOM uint32_t RX_TIMEOUT : 1;            /*!< [27..27] RX timeout is raised by both the host and device if
                                                     an ACK is not received in the maximum time specified by
                                                     the USB spec.                                                             */
      __IOM uint32_t NAK_REC    : 1;            /*!< [28..28] Host: NAK received                                               */
      __IOM uint32_t STALL_REC  : 1;            /*!< [29..29] Host: STALL received                                             */
      __IOM uint32_t ACK_REC    : 1;            /*!< [30..30] ACK received. Raised by both host and device.                    */
      __IOM uint32_t DATA_SEQ_ERROR : 1;        /*!< [31..31] Data Sequence Error.
                                                     
                                                     The device can raise a sequence error in the following
                                                     conditions:
                                                     
                                                     * A SETUP packet is received followed by a DATA1 packet
                                                     (data phase should always be DATA0) * An OUT packet is
                                                     received from the host but doesn't match the data pid in
                                                     the buffer control register read from DPSRAM
                                                     
                                                     The host can raise a data sequence error in the following
                                                     conditions:
                                                     
                                                     * An IN packet from the device has the wrong data PID                     */
    } bit;
  } SIE_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000054) interrupt endpoint control register                        */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t INT_EP_ACTIVE : 15;        /*!< [15..1] Host: Enable interrupt endpoint 1 -> 15                           */
            uint32_t            : 16;
    } bit;
  } INT_EP_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000058) Buffer status register. A bit set here indicates
                                                                    that a buffer has completed on the endpoint
                                                                    (if the buffer interrupt is enabled). It
                                                                    is possible for 2 buffers to be completed,
                                                                    so clearing the buffer status bit may instantly
                                                                    re set it on the next clock cycle.                         */
    
    struct {
      __IM  uint32_t EP0_IN     : 1;            /*!< [0..0] EP0_IN                                                             */
      __IM  uint32_t EP0_OUT    : 1;            /*!< [1..1] EP0_OUT                                                            */
      __IM  uint32_t EP1_IN     : 1;            /*!< [2..2] EP1_IN                                                             */
      __IM  uint32_t EP1_OUT    : 1;            /*!< [3..3] EP1_OUT                                                            */
      __IM  uint32_t EP2_IN     : 1;            /*!< [4..4] EP2_IN                                                             */
      __IM  uint32_t EP2_OUT    : 1;            /*!< [5..5] EP2_OUT                                                            */
      __IM  uint32_t EP3_IN     : 1;            /*!< [6..6] EP3_IN                                                             */
      __IM  uint32_t EP3_OUT    : 1;            /*!< [7..7] EP3_OUT                                                            */
      __IM  uint32_t EP4_IN     : 1;            /*!< [8..8] EP4_IN                                                             */
      __IM  uint32_t EP4_OUT    : 1;            /*!< [9..9] EP4_OUT                                                            */
      __IM  uint32_t EP5_IN     : 1;            /*!< [10..10] EP5_IN                                                           */
      __IM  uint32_t EP5_OUT    : 1;            /*!< [11..11] EP5_OUT                                                          */
      __IM  uint32_t EP6_IN     : 1;            /*!< [12..12] EP6_IN                                                           */
      __IM  uint32_t EP6_OUT    : 1;            /*!< [13..13] EP6_OUT                                                          */
      __IM  uint32_t EP7_IN     : 1;            /*!< [14..14] EP7_IN                                                           */
      __IM  uint32_t EP7_OUT    : 1;            /*!< [15..15] EP7_OUT                                                          */
      __IM  uint32_t EP8_IN     : 1;            /*!< [16..16] EP8_IN                                                           */
      __IM  uint32_t EP8_OUT    : 1;            /*!< [17..17] EP8_OUT                                                          */
      __IM  uint32_t EP9_IN     : 1;            /*!< [18..18] EP9_IN                                                           */
      __IM  uint32_t EP9_OUT    : 1;            /*!< [19..19] EP9_OUT                                                          */
      __IM  uint32_t EP10_IN    : 1;            /*!< [20..20] EP10_IN                                                          */
      __IM  uint32_t EP10_OUT   : 1;            /*!< [21..21] EP10_OUT                                                         */
      __IM  uint32_t EP11_IN    : 1;            /*!< [22..22] EP11_IN                                                          */
      __IM  uint32_t EP11_OUT   : 1;            /*!< [23..23] EP11_OUT                                                         */
      __IM  uint32_t EP12_IN    : 1;            /*!< [24..24] EP12_IN                                                          */
      __IM  uint32_t EP12_OUT   : 1;            /*!< [25..25] EP12_OUT                                                         */
      __IM  uint32_t EP13_IN    : 1;            /*!< [26..26] EP13_IN                                                          */
      __IM  uint32_t EP13_OUT   : 1;            /*!< [27..27] EP13_OUT                                                         */
      __IM  uint32_t EP14_IN    : 1;            /*!< [28..28] EP14_IN                                                          */
      __IM  uint32_t EP14_OUT   : 1;            /*!< [29..29] EP14_OUT                                                         */
      __IM  uint32_t EP15_IN    : 1;            /*!< [30..30] EP15_IN                                                          */
      __IM  uint32_t EP15_OUT   : 1;            /*!< [31..31] EP15_OUT                                                         */
    } bit;
  } BUFF_STATUS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000005C) Which of the double buffers should be handled.
                                                                    Only valid if using an interrupt per buffer
                                                                    (i.e. not per 2 buffers). Not valid for
                                                                    host interrupt endpoint polling because
                                                                    they are only single buffered.                             */
    
    struct {
      __IM  uint32_t EP0_IN     : 1;            /*!< [0..0] EP0_IN                                                             */
      __IM  uint32_t EP0_OUT    : 1;            /*!< [1..1] EP0_OUT                                                            */
      __IM  uint32_t EP1_IN     : 1;            /*!< [2..2] EP1_IN                                                             */
      __IM  uint32_t EP1_OUT    : 1;            /*!< [3..3] EP1_OUT                                                            */
      __IM  uint32_t EP2_IN     : 1;            /*!< [4..4] EP2_IN                                                             */
      __IM  uint32_t EP2_OUT    : 1;            /*!< [5..5] EP2_OUT                                                            */
      __IM  uint32_t EP3_IN     : 1;            /*!< [6..6] EP3_IN                                                             */
      __IM  uint32_t EP3_OUT    : 1;            /*!< [7..7] EP3_OUT                                                            */
      __IM  uint32_t EP4_IN     : 1;            /*!< [8..8] EP4_IN                                                             */
      __IM  uint32_t EP4_OUT    : 1;            /*!< [9..9] EP4_OUT                                                            */
      __IM  uint32_t EP5_IN     : 1;            /*!< [10..10] EP5_IN                                                           */
      __IM  uint32_t EP5_OUT    : 1;            /*!< [11..11] EP5_OUT                                                          */
      __IM  uint32_t EP6_IN     : 1;            /*!< [12..12] EP6_IN                                                           */
      __IM  uint32_t EP6_OUT    : 1;            /*!< [13..13] EP6_OUT                                                          */
      __IM  uint32_t EP7_IN     : 1;            /*!< [14..14] EP7_IN                                                           */
      __IM  uint32_t EP7_OUT    : 1;            /*!< [15..15] EP7_OUT                                                          */
      __IM  uint32_t EP8_IN     : 1;            /*!< [16..16] EP8_IN                                                           */
      __IM  uint32_t EP8_OUT    : 1;            /*!< [17..17] EP8_OUT                                                          */
      __IM  uint32_t EP9_IN     : 1;            /*!< [18..18] EP9_IN                                                           */
      __IM  uint32_t EP9_OUT    : 1;            /*!< [19..19] EP9_OUT                                                          */
      __IM  uint32_t EP10_IN    : 1;            /*!< [20..20] EP10_IN                                                          */
      __IM  uint32_t EP10_OUT   : 1;            /*!< [21..21] EP10_OUT                                                         */
      __IM  uint32_t EP11_IN    : 1;            /*!< [22..22] EP11_IN                                                          */
      __IM  uint32_t EP11_OUT   : 1;            /*!< [23..23] EP11_OUT                                                         */
      __IM  uint32_t EP12_IN    : 1;            /*!< [24..24] EP12_IN                                                          */
      __IM  uint32_t EP12_OUT   : 1;            /*!< [25..25] EP12_OUT                                                         */
      __IM  uint32_t EP13_IN    : 1;            /*!< [26..26] EP13_IN                                                          */
      __IM  uint32_t EP13_OUT   : 1;            /*!< [27..27] EP13_OUT                                                         */
      __IM  uint32_t EP14_IN    : 1;            /*!< [28..28] EP14_IN                                                          */
      __IM  uint32_t EP14_OUT   : 1;            /*!< [29..29] EP14_OUT                                                         */
      __IM  uint32_t EP15_IN    : 1;            /*!< [30..30] EP15_IN                                                          */
      __IM  uint32_t EP15_OUT   : 1;            /*!< [31..31] EP15_OUT                                                         */
    } bit;
  } BUFF_CPU_SHOULD_HANDLE;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000060) Device only: Can be set to ignore the buffer
                                                                    control register for this endpoint in case
                                                                    you would like to revoke a buffer. A NAK
                                                                    will be sent for every access to the endpoint
                                                                    until this bit is cleared. A corresponding
                                                                    bit in `EP_ABORT_DONE` is set when it is
                                                                    safe to modify the buffer control register.                */
    
    struct {
      __IOM uint32_t EP0_IN     : 1;            /*!< [0..0] EP0_IN                                                             */
      __IOM uint32_t EP0_OUT    : 1;            /*!< [1..1] EP0_OUT                                                            */
      __IOM uint32_t EP1_IN     : 1;            /*!< [2..2] EP1_IN                                                             */
      __IOM uint32_t EP1_OUT    : 1;            /*!< [3..3] EP1_OUT                                                            */
      __IOM uint32_t EP2_IN     : 1;            /*!< [4..4] EP2_IN                                                             */
      __IOM uint32_t EP2_OUT    : 1;            /*!< [5..5] EP2_OUT                                                            */
      __IOM uint32_t EP3_IN     : 1;            /*!< [6..6] EP3_IN                                                             */
      __IOM uint32_t EP3_OUT    : 1;            /*!< [7..7] EP3_OUT                                                            */
      __IOM uint32_t EP4_IN     : 1;            /*!< [8..8] EP4_IN                                                             */
      __IOM uint32_t EP4_OUT    : 1;            /*!< [9..9] EP4_OUT                                                            */
      __IOM uint32_t EP5_IN     : 1;            /*!< [10..10] EP5_IN                                                           */
      __IOM uint32_t EP5_OUT    : 1;            /*!< [11..11] EP5_OUT                                                          */
      __IOM uint32_t EP6_IN     : 1;            /*!< [12..12] EP6_IN                                                           */
      __IOM uint32_t EP6_OUT    : 1;            /*!< [13..13] EP6_OUT                                                          */
      __IOM uint32_t EP7_IN     : 1;            /*!< [14..14] EP7_IN                                                           */
      __IOM uint32_t EP7_OUT    : 1;            /*!< [15..15] EP7_OUT                                                          */
      __IOM uint32_t EP8_IN     : 1;            /*!< [16..16] EP8_IN                                                           */
      __IOM uint32_t EP8_OUT    : 1;            /*!< [17..17] EP8_OUT                                                          */
      __IOM uint32_t EP9_IN     : 1;            /*!< [18..18] EP9_IN                                                           */
      __IOM uint32_t EP9_OUT    : 1;            /*!< [19..19] EP9_OUT                                                          */
      __IOM uint32_t EP10_IN    : 1;            /*!< [20..20] EP10_IN                                                          */
      __IOM uint32_t EP10_OUT   : 1;            /*!< [21..21] EP10_OUT                                                         */
      __IOM uint32_t EP11_IN    : 1;            /*!< [22..22] EP11_IN                                                          */
      __IOM uint32_t EP11_OUT   : 1;            /*!< [23..23] EP11_OUT                                                         */
      __IOM uint32_t EP12_IN    : 1;            /*!< [24..24] EP12_IN                                                          */
      __IOM uint32_t EP12_OUT   : 1;            /*!< [25..25] EP12_OUT                                                         */
      __IOM uint32_t EP13_IN    : 1;            /*!< [26..26] EP13_IN                                                          */
      __IOM uint32_t EP13_OUT   : 1;            /*!< [27..27] EP13_OUT                                                         */
      __IOM uint32_t EP14_IN    : 1;            /*!< [28..28] EP14_IN                                                          */
      __IOM uint32_t EP14_OUT   : 1;            /*!< [29..29] EP14_OUT                                                         */
      __IOM uint32_t EP15_IN    : 1;            /*!< [30..30] EP15_IN                                                          */
      __IOM uint32_t EP15_OUT   : 1;            /*!< [31..31] EP15_OUT                                                         */
    } bit;
  } EP_ABORT;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000064) Device only: Used in conjunction with `EP_ABORT`.
                                                                    Set once an endpoint is idle so the programmer
                                                                    knows it is safe to modify the buffer control
                                                                    register.                                                  */
    
    struct {
      __IOM uint32_t EP0_IN     : 1;            /*!< [0..0] EP0_IN                                                             */
      __IOM uint32_t EP0_OUT    : 1;            /*!< [1..1] EP0_OUT                                                            */
      __IOM uint32_t EP1_IN     : 1;            /*!< [2..2] EP1_IN                                                             */
      __IOM uint32_t EP1_OUT    : 1;            /*!< [3..3] EP1_OUT                                                            */
      __IOM uint32_t EP2_IN     : 1;            /*!< [4..4] EP2_IN                                                             */
      __IOM uint32_t EP2_OUT    : 1;            /*!< [5..5] EP2_OUT                                                            */
      __IOM uint32_t EP3_IN     : 1;            /*!< [6..6] EP3_IN                                                             */
      __IOM uint32_t EP3_OUT    : 1;            /*!< [7..7] EP3_OUT                                                            */
      __IOM uint32_t EP4_IN     : 1;            /*!< [8..8] EP4_IN                                                             */
      __IOM uint32_t EP4_OUT    : 1;            /*!< [9..9] EP4_OUT                                                            */
      __IOM uint32_t EP5_IN     : 1;            /*!< [10..10] EP5_IN                                                           */
      __IOM uint32_t EP5_OUT    : 1;            /*!< [11..11] EP5_OUT                                                          */
      __IOM uint32_t EP6_IN     : 1;            /*!< [12..12] EP6_IN                                                           */
      __IOM uint32_t EP6_OUT    : 1;            /*!< [13..13] EP6_OUT                                                          */
      __IOM uint32_t EP7_IN     : 1;            /*!< [14..14] EP7_IN                                                           */
      __IOM uint32_t EP7_OUT    : 1;            /*!< [15..15] EP7_OUT                                                          */
      __IOM uint32_t EP8_IN     : 1;            /*!< [16..16] EP8_IN                                                           */
      __IOM uint32_t EP8_OUT    : 1;            /*!< [17..17] EP8_OUT                                                          */
      __IOM uint32_t EP9_IN     : 1;            /*!< [18..18] EP9_IN                                                           */
      __IOM uint32_t EP9_OUT    : 1;            /*!< [19..19] EP9_OUT                                                          */
      __IOM uint32_t EP10_IN    : 1;            /*!< [20..20] EP10_IN                                                          */
      __IOM uint32_t EP10_OUT   : 1;            /*!< [21..21] EP10_OUT                                                         */
      __IOM uint32_t EP11_IN    : 1;            /*!< [22..22] EP11_IN                                                          */
      __IOM uint32_t EP11_OUT   : 1;            /*!< [23..23] EP11_OUT                                                         */
      __IOM uint32_t EP12_IN    : 1;            /*!< [24..24] EP12_IN                                                          */
      __IOM uint32_t EP12_OUT   : 1;            /*!< [25..25] EP12_OUT                                                         */
      __IOM uint32_t EP13_IN    : 1;            /*!< [26..26] EP13_IN                                                          */
      __IOM uint32_t EP13_OUT   : 1;            /*!< [27..27] EP13_OUT                                                         */
      __IOM uint32_t EP14_IN    : 1;            /*!< [28..28] EP14_IN                                                          */
      __IOM uint32_t EP14_OUT   : 1;            /*!< [29..29] EP14_OUT                                                         */
      __IOM uint32_t EP15_IN    : 1;            /*!< [30..30] EP15_IN                                                          */
      __IOM uint32_t EP15_OUT   : 1;            /*!< [31..31] EP15_OUT                                                         */
    } bit;
  } EP_ABORT_DONE;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000068) Device: this bit must be set in conjunction with
                                                                    the `STALL` bit in the buffer control register
                                                                    to send a STALL on EP0. The device controller
                                                                    clears these bits when a SETUP packet is
                                                                    received because the USB spec requires that
                                                                    a STALL condition is cleared when a SETUP
                                                                    packet is received.                                        */
    
    struct {
      __IOM uint32_t EP0_IN     : 1;            /*!< [0..0] EP0_IN                                                             */
      __IOM uint32_t EP0_OUT    : 1;            /*!< [1..1] EP0_OUT                                                            */
            uint32_t            : 30;
    } bit;
  } EP_STALL_ARM;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000006C) Used by the host controller. Sets the wait time
                                                                    in microseconds before trying again if the
                                                                    device replies with a NAK.                                 */
    
    struct {
      __IOM uint32_t DELAY_LS   : 10;           /*!< [9..0] NAK polling interval for a low speed device                        */
            uint32_t            : 6;
      __IOM uint32_t DELAY_FS   : 10;           /*!< [25..16] NAK polling interval for a full speed device                     */
            uint32_t            : 6;
    } bit;
  } NAK_POLL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000070) Device: bits are set when the `IRQ_ON_NAK` or
                                                                    `IRQ_ON_STALL` bits are set. For EP0 this
                                                                    comes from `SIE_CTRL`. For all other endpoints
                                                                    it comes from the endpoint control register.               */
    
    struct {
      __IOM uint32_t EP0_IN     : 1;            /*!< [0..0] EP0_IN                                                             */
      __IOM uint32_t EP0_OUT    : 1;            /*!< [1..1] EP0_OUT                                                            */
      __IOM uint32_t EP1_IN     : 1;            /*!< [2..2] EP1_IN                                                             */
      __IOM uint32_t EP1_OUT    : 1;            /*!< [3..3] EP1_OUT                                                            */
      __IOM uint32_t EP2_IN     : 1;            /*!< [4..4] EP2_IN                                                             */
      __IOM uint32_t EP2_OUT    : 1;            /*!< [5..5] EP2_OUT                                                            */
      __IOM uint32_t EP3_IN     : 1;            /*!< [6..6] EP3_IN                                                             */
      __IOM uint32_t EP3_OUT    : 1;            /*!< [7..7] EP3_OUT                                                            */
      __IOM uint32_t EP4_IN     : 1;            /*!< [8..8] EP4_IN                                                             */
      __IOM uint32_t EP4_OUT    : 1;            /*!< [9..9] EP4_OUT                                                            */
      __IOM uint32_t EP5_IN     : 1;            /*!< [10..10] EP5_IN                                                           */
      __IOM uint32_t EP5_OUT    : 1;            /*!< [11..11] EP5_OUT                                                          */
      __IOM uint32_t EP6_IN     : 1;            /*!< [12..12] EP6_IN                                                           */
      __IOM uint32_t EP6_OUT    : 1;            /*!< [13..13] EP6_OUT                                                          */
      __IOM uint32_t EP7_IN     : 1;            /*!< [14..14] EP7_IN                                                           */
      __IOM uint32_t EP7_OUT    : 1;            /*!< [15..15] EP7_OUT                                                          */
      __IOM uint32_t EP8_IN     : 1;            /*!< [16..16] EP8_IN                                                           */
      __IOM uint32_t EP8_OUT    : 1;            /*!< [17..17] EP8_OUT                                                          */
      __IOM uint32_t EP9_IN     : 1;            /*!< [18..18] EP9_IN                                                           */
      __IOM uint32_t EP9_OUT    : 1;            /*!< [19..19] EP9_OUT                                                          */
      __IOM uint32_t EP10_IN    : 1;            /*!< [20..20] EP10_IN                                                          */
      __IOM uint32_t EP10_OUT   : 1;            /*!< [21..21] EP10_OUT                                                         */
      __IOM uint32_t EP11_IN    : 1;            /*!< [22..22] EP11_IN                                                          */
      __IOM uint32_t EP11_OUT   : 1;            /*!< [23..23] EP11_OUT                                                         */
      __IOM uint32_t EP12_IN    : 1;            /*!< [24..24] EP12_IN                                                          */
      __IOM uint32_t EP12_OUT   : 1;            /*!< [25..25] EP12_OUT                                                         */
      __IOM uint32_t EP13_IN    : 1;            /*!< [26..26] EP13_IN                                                          */
      __IOM uint32_t EP13_OUT   : 1;            /*!< [27..27] EP13_OUT                                                         */
      __IOM uint32_t EP14_IN    : 1;            /*!< [28..28] EP14_IN                                                          */
      __IOM uint32_t EP14_OUT   : 1;            /*!< [29..29] EP14_OUT                                                         */
      __IOM uint32_t EP15_IN    : 1;            /*!< [30..30] EP15_IN                                                          */
      __IOM uint32_t EP15_OUT   : 1;            /*!< [31..31] EP15_OUT                                                         */
    } bit;
  } EP_STATUS_STALL_NAK;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000074) Where to connect the USB controller. Should be
                                                                    to_phy by default.                                         */
    
    struct {
      __IOM uint32_t TO_PHY     : 1;            /*!< [0..0] TO_PHY                                                             */
      __IOM uint32_t TO_EXTPHY  : 1;            /*!< [1..1] TO_EXTPHY                                                          */
      __IOM uint32_t TO_DIGITAL_PAD : 1;        /*!< [2..2] TO_DIGITAL_PAD                                                     */
      __IOM uint32_t SOFTCON    : 1;            /*!< [3..3] SOFTCON                                                            */
            uint32_t            : 28;
    } bit;
  } USB_MUXING;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000078) Overrides for the power signals in the event
                                                                    that the VBUS signals are not hooked up
                                                                    to GPIO. Set the value of the override and
                                                                    then the override enable to switch over
                                                                    to the override value.                                     */
    
    struct {
      __IOM uint32_t VBUS_EN    : 1;            /*!< [0..0] VBUS_EN                                                            */
      __IOM uint32_t VBUS_EN_OVERRIDE_EN : 1;   /*!< [1..1] VBUS_EN_OVERRIDE_EN                                                */
      __IOM uint32_t VBUS_DETECT : 1;           /*!< [2..2] VBUS_DETECT                                                        */
      __IOM uint32_t VBUS_DETECT_OVERRIDE_EN : 1;/*!< [3..3] VBUS_DETECT_OVERRIDE_EN                                           */
      __IOM uint32_t OVERCURR_DETECT : 1;       /*!< [4..4] OVERCURR_DETECT                                                    */
      __IOM uint32_t OVERCURR_DETECT_EN : 1;    /*!< [5..5] OVERCURR_DETECT_EN                                                 */
            uint32_t            : 26;
    } bit;
  } USB_PWR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000007C) This register allows for direct control of the
                                                                    USB phy. Use in conjunction with usbphy_direct_override
                                                                    register to enable each override bit.                      */
    
    struct {
      __IOM uint32_t DP_PULLUP_HISEL : 1;       /*!< [0..0] Enable the second DP pull up resistor. 0 - Pull = Rpu2;
                                                     1 - Pull = Rpu1 + Rpu2                                                    */
      __IOM uint32_t DP_PULLUP_EN : 1;          /*!< [1..1] DP pull up enable                                                  */
      __IOM uint32_t DP_PULLDN_EN : 1;          /*!< [2..2] DP pull down enable                                                */
            uint32_t            : 1;
      __IOM uint32_t DM_PULLUP_HISEL : 1;       /*!< [4..4] Enable the second DM pull up resistor. 0 - Pull = Rpu2;
                                                     1 - Pull = Rpu1 + Rpu2                                                    */
      __IOM uint32_t DM_PULLUP_EN : 1;          /*!< [5..5] DM pull up enable                                                  */
      __IOM uint32_t DM_PULLDN_EN : 1;          /*!< [6..6] DM pull down enable                                                */
            uint32_t            : 1;
      __IOM uint32_t TX_DP_OE   : 1;            /*!< [8..8] Output enable. If TX_DIFFMODE=1, OE for DPP/DPM diff
                                                     pair. 0 - DPP/DPM in Hi-Z state; 1 - DPP/DPM driving
                                                     If TX_DIFFMODE=0, OE for DPP only. 0 - DPP in Hi-Z state;
                                                     1 - DPP driving                                                           */
      __IOM uint32_t TX_DM_OE   : 1;            /*!< [9..9] Output enable. If TX_DIFFMODE=1, Ignored.
                                                     If TX_DIFFMODE=0, OE for DPM only. 0 - DPM in Hi-Z state;
                                                     1 - DPM driving                                                           */
      __IOM uint32_t TX_DP      : 1;            /*!< [10..10] Output data. If TX_DIFFMODE=1, Drives DPP/DPM diff
                                                     pair. TX_DP_OE=1 to enable drive. DPP=TX_DP, DPM=~TX_DP
                                                     If TX_DIFFMODE=0, Drives DPP only. TX_DP_OE=1 to enable
                                                     drive. DPP=TX_DP                                                          */
      __IOM uint32_t TX_DM      : 1;            /*!< [11..11] Output data. TX_DIFFMODE=1, Ignored
                                                     TX_DIFFMODE=0, Drives DPM only. TX_DM_OE=1 to enable drive.
                                                     DPM=TX_DM                                                                 */
      __IOM uint32_t RX_PD      : 1;            /*!< [12..12] RX power down override (if override enable is set).
                                                     1 = powered down.                                                         */
      __IOM uint32_t TX_PD      : 1;            /*!< [13..13] TX power down override (if override enable is set).
                                                     1 = powered down.                                                         */
      __IOM uint32_t TX_FSSLEW  : 1;            /*!< [14..14] TX_FSSLEW=0: Low speed slew rate
                                                     TX_FSSLEW=1: Full speed slew rate                                         */
      __IOM uint32_t TX_DIFFMODE : 1;           /*!< [15..15] TX_DIFFMODE=0: Single ended mode
                                                     TX_DIFFMODE=1: Differential drive mode (TX_DM, TX_DM_OE
                                                     ignored)                                                                  */
      __IM  uint32_t RX_DD      : 1;            /*!< [16..16] Differential RX                                                  */
      __IM  uint32_t RX_DP      : 1;            /*!< [17..17] DPP pin state                                                    */
      __IM  uint32_t RX_DM      : 1;            /*!< [18..18] DPM pin state                                                    */
      __IM  uint32_t DP_OVCN    : 1;            /*!< [19..19] DP overcurrent                                                   */
      __IM  uint32_t DM_OVCN    : 1;            /*!< [20..20] DM overcurrent                                                   */
      __IM  uint32_t DP_OVV     : 1;            /*!< [21..21] DP over voltage                                                  */
      __IM  uint32_t DM_OVV     : 1;            /*!< [22..22] DM over voltage                                                  */
            uint32_t            : 9;
    } bit;
  } USBPHY_DIRECT;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000080) Override enable for each control in usbphy_direct          */
    
    struct {
      __IOM uint32_t DP_PULLUP_HISEL_OVERRIDE_EN : 1;/*!< [0..0] DP_PULLUP_HISEL_OVERRIDE_EN                                   */
      __IOM uint32_t DM_PULLUP_HISEL_OVERRIDE_EN : 1;/*!< [1..1] DM_PULLUP_HISEL_OVERRIDE_EN                                   */
      __IOM uint32_t DP_PULLUP_EN_OVERRIDE_EN : 1;/*!< [2..2] DP_PULLUP_EN_OVERRIDE_EN                                         */
      __IOM uint32_t DP_PULLDN_EN_OVERRIDE_EN : 1;/*!< [3..3] DP_PULLDN_EN_OVERRIDE_EN                                         */
      __IOM uint32_t DM_PULLDN_EN_OVERRIDE_EN : 1;/*!< [4..4] DM_PULLDN_EN_OVERRIDE_EN                                         */
      __IOM uint32_t TX_DP_OE_OVERRIDE_EN : 1;  /*!< [5..5] TX_DP_OE_OVERRIDE_EN                                               */
      __IOM uint32_t TX_DM_OE_OVERRIDE_EN : 1;  /*!< [6..6] TX_DM_OE_OVERRIDE_EN                                               */
      __IOM uint32_t TX_DP_OVERRIDE_EN : 1;     /*!< [7..7] TX_DP_OVERRIDE_EN                                                  */
      __IOM uint32_t TX_DM_OVERRIDE_EN : 1;     /*!< [8..8] TX_DM_OVERRIDE_EN                                                  */
      __IOM uint32_t RX_PD_OVERRIDE_EN : 1;     /*!< [9..9] RX_PD_OVERRIDE_EN                                                  */
      __IOM uint32_t TX_PD_OVERRIDE_EN : 1;     /*!< [10..10] TX_PD_OVERRIDE_EN                                                */
      __IOM uint32_t TX_FSSLEW_OVERRIDE_EN : 1; /*!< [11..11] TX_FSSLEW_OVERRIDE_EN                                            */
      __IOM uint32_t DM_PULLUP_OVERRIDE_EN : 1; /*!< [12..12] DM_PULLUP_OVERRIDE_EN                                            */
            uint32_t            : 2;
      __IOM uint32_t TX_DIFFMODE_OVERRIDE_EN : 1;/*!< [15..15] TX_DIFFMODE_OVERRIDE_EN                                         */
            uint32_t            : 16;
    } bit;
  } USBPHY_DIRECT_OVERRIDE;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000084) Used to adjust trim values of USB phy pull down
                                                                    resistors.                                                 */
    
    struct {
      __IOM uint32_t DP_PULLDN_TRIM : 5;        /*!< [4..0] Value to drive to USB PHY
                                                     DP pulldown resistor trim control
                                                     Experimental data suggests that the reset value will work,
                                                     but this register allows adjustment if required                           */
            uint32_t            : 3;
      __IOM uint32_t DM_PULLDN_TRIM : 5;        /*!< [12..8] Value to drive to USB PHY
                                                     DM pulldown resistor trim control
                                                     Experimental data suggests that the reset value will work,
                                                     but this register allows adjustment if required                           */
            uint32_t            : 19;
    } bit;
  } USBPHY_TRIM;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000008C) Raw Interrupts                                             */
    
    struct {
      __IM  uint32_t HOST_CONN_DIS : 1;         /*!< [0..0] Host: raised when a device is connected or disconnected
                                                     (i.e. when SIE_STATUS.SPEED changes). Cleared by writing
                                                     to SIE_STATUS.SPEED                                                       */
      __IM  uint32_t HOST_RESUME : 1;           /*!< [1..1] Host: raised when a device wakes up the host. Cleared
                                                     by writing to SIE_STATUS.RESUME                                           */
      __IM  uint32_t HOST_SOF   : 1;            /*!< [2..2] Host: raised every time the host sends a SOF (Start of
                                                     Frame). Cleared by reading SOF_RD                                         */
      __IM  uint32_t TRANS_COMPLETE : 1;        /*!< [3..3] Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear
                                                     by writing to this bit.                                                   */
      __IM  uint32_t BUFF_STATUS : 1;           /*!< [4..4] Raised when any bit in BUFF_STATUS is set. Clear by clearing
                                                     all bits in BUFF_STATUS.                                                  */
      __IM  uint32_t ERROR_DATA_SEQ : 1;        /*!< [5..5] Source: SIE_STATUS.DATA_SEQ_ERROR                                  */
      __IM  uint32_t ERROR_RX_TIMEOUT : 1;      /*!< [6..6] Source: SIE_STATUS.RX_TIMEOUT                                      */
      __IM  uint32_t ERROR_RX_OVERFLOW : 1;     /*!< [7..7] Source: SIE_STATUS.RX_OVERFLOW                                     */
      __IM  uint32_t ERROR_BIT_STUFF : 1;       /*!< [8..8] Source: SIE_STATUS.BIT_STUFF_ERROR                                 */
      __IM  uint32_t ERROR_CRC  : 1;            /*!< [9..9] Source: SIE_STATUS.CRC_ERROR                                       */
      __IM  uint32_t STALL      : 1;            /*!< [10..10] Source: SIE_STATUS.STALL_REC                                     */
      __IM  uint32_t VBUS_DETECT : 1;           /*!< [11..11] Source: SIE_STATUS.VBUS_DETECT                                   */
      __IM  uint32_t BUS_RESET  : 1;            /*!< [12..12] Source: SIE_STATUS.BUS_RESET                                     */
      __IM  uint32_t DEV_CONN_DIS : 1;          /*!< [13..13] Set when the device connection state changes. Cleared
                                                     by writing to SIE_STATUS.CONNECTED                                        */
      __IM  uint32_t DEV_SUSPEND : 1;           /*!< [14..14] Set when the device suspend state changes. Cleared
                                                     by writing to SIE_STATUS.SUSPENDED                                        */
      __IM  uint32_t DEV_RESUME_FROM_HOST : 1;  /*!< [15..15] Set when the device receives a resume from the host.
                                                     Cleared by writing to SIE_STATUS.RESUME                                   */
      __IM  uint32_t SETUP_REQ  : 1;            /*!< [16..16] Device. Source: SIE_STATUS.SETUP_REC                             */
      __IM  uint32_t DEV_SOF    : 1;            /*!< [17..17] Set every time the device receives a SOF (Start of
                                                     Frame) packet. Cleared by reading SOF_RD                                  */
      __IM  uint32_t ABORT_DONE : 1;            /*!< [18..18] Raised when any bit in ABORT_DONE is set. Clear by
                                                     clearing all bits in ABORT_DONE.                                          */
      __IM  uint32_t EP_STALL_NAK : 1;          /*!< [19..19] Raised when any bit in EP_STATUS_STALL_NAK is set.
                                                     Clear by clearing all bits in EP_STATUS_STALL_NAK.                        */
            uint32_t            : 12;
    } bit;
  } INTR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000090) Interrupt Enable                                           */
    
    struct {
      __IOM uint32_t HOST_CONN_DIS : 1;         /*!< [0..0] Host: raised when a device is connected or disconnected
                                                     (i.e. when SIE_STATUS.SPEED changes). Cleared by writing
                                                     to SIE_STATUS.SPEED                                                       */
      __IOM uint32_t HOST_RESUME : 1;           /*!< [1..1] Host: raised when a device wakes up the host. Cleared
                                                     by writing to SIE_STATUS.RESUME                                           */
      __IOM uint32_t HOST_SOF   : 1;            /*!< [2..2] Host: raised every time the host sends a SOF (Start of
                                                     Frame). Cleared by reading SOF_RD                                         */
      __IOM uint32_t TRANS_COMPLETE : 1;        /*!< [3..3] Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear
                                                     by writing to this bit.                                                   */
      __IOM uint32_t BUFF_STATUS : 1;           /*!< [4..4] Raised when any bit in BUFF_STATUS is set. Clear by clearing
                                                     all bits in BUFF_STATUS.                                                  */
      __IOM uint32_t ERROR_DATA_SEQ : 1;        /*!< [5..5] Source: SIE_STATUS.DATA_SEQ_ERROR                                  */
      __IOM uint32_t ERROR_RX_TIMEOUT : 1;      /*!< [6..6] Source: SIE_STATUS.RX_TIMEOUT                                      */
      __IOM uint32_t ERROR_RX_OVERFLOW : 1;     /*!< [7..7] Source: SIE_STATUS.RX_OVERFLOW                                     */
      __IOM uint32_t ERROR_BIT_STUFF : 1;       /*!< [8..8] Source: SIE_STATUS.BIT_STUFF_ERROR                                 */
      __IOM uint32_t ERROR_CRC  : 1;            /*!< [9..9] Source: SIE_STATUS.CRC_ERROR                                       */
      __IOM uint32_t STALL      : 1;            /*!< [10..10] Source: SIE_STATUS.STALL_REC                                     */
      __IOM uint32_t VBUS_DETECT : 1;           /*!< [11..11] Source: SIE_STATUS.VBUS_DETECT                                   */
      __IOM uint32_t BUS_RESET  : 1;            /*!< [12..12] Source: SIE_STATUS.BUS_RESET                                     */
      __IOM uint32_t DEV_CONN_DIS : 1;          /*!< [13..13] Set when the device connection state changes. Cleared
                                                     by writing to SIE_STATUS.CONNECTED                                        */
      __IOM uint32_t DEV_SUSPEND : 1;           /*!< [14..14] Set when the device suspend state changes. Cleared
                                                     by writing to SIE_STATUS.SUSPENDED                                        */
      __IOM uint32_t DEV_RESUME_FROM_HOST : 1;  /*!< [15..15] Set when the device receives a resume from the host.
                                                     Cleared by writing to SIE_STATUS.RESUME                                   */
      __IOM uint32_t SETUP_REQ  : 1;            /*!< [16..16] Device. Source: SIE_STATUS.SETUP_REC                             */
      __IOM uint32_t DEV_SOF    : 1;            /*!< [17..17] Set every time the device receives a SOF (Start of
                                                     Frame) packet. Cleared by reading SOF_RD                                  */
      __IOM uint32_t ABORT_DONE : 1;            /*!< [18..18] Raised when any bit in ABORT_DONE is set. Clear by
                                                     clearing all bits in ABORT_DONE.                                          */
      __IOM uint32_t EP_STALL_NAK : 1;          /*!< [19..19] Raised when any bit in EP_STATUS_STALL_NAK is set.
                                                     Clear by clearing all bits in EP_STATUS_STALL_NAK.                        */
            uint32_t            : 12;
    } bit;
  } INTE;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000094) Interrupt Force                                            */
    
    struct {
      __IOM uint32_t HOST_CONN_DIS : 1;         /*!< [0..0] Host: raised when a device is connected or disconnected
                                                     (i.e. when SIE_STATUS.SPEED changes). Cleared by writing
                                                     to SIE_STATUS.SPEED                                                       */
      __IOM uint32_t HOST_RESUME : 1;           /*!< [1..1] Host: raised when a device wakes up the host. Cleared
                                                     by writing to SIE_STATUS.RESUME                                           */
      __IOM uint32_t HOST_SOF   : 1;            /*!< [2..2] Host: raised every time the host sends a SOF (Start of
                                                     Frame). Cleared by reading SOF_RD                                         */
      __IOM uint32_t TRANS_COMPLETE : 1;        /*!< [3..3] Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear
                                                     by writing to this bit.                                                   */
      __IOM uint32_t BUFF_STATUS : 1;           /*!< [4..4] Raised when any bit in BUFF_STATUS is set. Clear by clearing
                                                     all bits in BUFF_STATUS.                                                  */
      __IOM uint32_t ERROR_DATA_SEQ : 1;        /*!< [5..5] Source: SIE_STATUS.DATA_SEQ_ERROR                                  */
      __IOM uint32_t ERROR_RX_TIMEOUT : 1;      /*!< [6..6] Source: SIE_STATUS.RX_TIMEOUT                                      */
      __IOM uint32_t ERROR_RX_OVERFLOW : 1;     /*!< [7..7] Source: SIE_STATUS.RX_OVERFLOW                                     */
      __IOM uint32_t ERROR_BIT_STUFF : 1;       /*!< [8..8] Source: SIE_STATUS.BIT_STUFF_ERROR                                 */
      __IOM uint32_t ERROR_CRC  : 1;            /*!< [9..9] Source: SIE_STATUS.CRC_ERROR                                       */
      __IOM uint32_t STALL      : 1;            /*!< [10..10] Source: SIE_STATUS.STALL_REC                                     */
      __IOM uint32_t VBUS_DETECT : 1;           /*!< [11..11] Source: SIE_STATUS.VBUS_DETECT                                   */
      __IOM uint32_t BUS_RESET  : 1;            /*!< [12..12] Source: SIE_STATUS.BUS_RESET                                     */
      __IOM uint32_t DEV_CONN_DIS : 1;          /*!< [13..13] Set when the device connection state changes. Cleared
                                                     by writing to SIE_STATUS.CONNECTED                                        */
      __IOM uint32_t DEV_SUSPEND : 1;           /*!< [14..14] Set when the device suspend state changes. Cleared
                                                     by writing to SIE_STATUS.SUSPENDED                                        */
      __IOM uint32_t DEV_RESUME_FROM_HOST : 1;  /*!< [15..15] Set when the device receives a resume from the host.
                                                     Cleared by writing to SIE_STATUS.RESUME                                   */
      __IOM uint32_t SETUP_REQ  : 1;            /*!< [16..16] Device. Source: SIE_STATUS.SETUP_REC                             */
      __IOM uint32_t DEV_SOF    : 1;            /*!< [17..17] Set every time the device receives a SOF (Start of
                                                     Frame) packet. Cleared by reading SOF_RD                                  */
      __IOM uint32_t ABORT_DONE : 1;            /*!< [18..18] Raised when any bit in ABORT_DONE is set. Clear by
                                                     clearing all bits in ABORT_DONE.                                          */
      __IOM uint32_t EP_STALL_NAK : 1;          /*!< [19..19] Raised when any bit in EP_STATUS_STALL_NAK is set.
                                                     Clear by clearing all bits in EP_STATUS_STALL_NAK.                        */
            uint32_t            : 12;
    } bit;
  } INTF;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000098) Interrupt status after masking & forcing                   */
    
    struct {
      __IM  uint32_t HOST_CONN_DIS : 1;         /*!< [0..0] Host: raised when a device is connected or disconnected
                                                     (i.e. when SIE_STATUS.SPEED changes). Cleared by writing
                                                     to SIE_STATUS.SPEED                                                       */
      __IM  uint32_t HOST_RESUME : 1;           /*!< [1..1] Host: raised when a device wakes up the host. Cleared
                                                     by writing to SIE_STATUS.RESUME                                           */
      __IM  uint32_t HOST_SOF   : 1;            /*!< [2..2] Host: raised every time the host sends a SOF (Start of
                                                     Frame). Cleared by reading SOF_RD                                         */
      __IM  uint32_t TRANS_COMPLETE : 1;        /*!< [3..3] Raised every time SIE_STATUS.TRANS_COMPLETE is set. Clear
                                                     by writing to this bit.                                                   */
      __IM  uint32_t BUFF_STATUS : 1;           /*!< [4..4] Raised when any bit in BUFF_STATUS is set. Clear by clearing
                                                     all bits in BUFF_STATUS.                                                  */
      __IM  uint32_t ERROR_DATA_SEQ : 1;        /*!< [5..5] Source: SIE_STATUS.DATA_SEQ_ERROR                                  */
      __IM  uint32_t ERROR_RX_TIMEOUT : 1;      /*!< [6..6] Source: SIE_STATUS.RX_TIMEOUT                                      */
      __IM  uint32_t ERROR_RX_OVERFLOW : 1;     /*!< [7..7] Source: SIE_STATUS.RX_OVERFLOW                                     */
      __IM  uint32_t ERROR_BIT_STUFF : 1;       /*!< [8..8] Source: SIE_STATUS.BIT_STUFF_ERROR                                 */
      __IM  uint32_t ERROR_CRC  : 1;            /*!< [9..9] Source: SIE_STATUS.CRC_ERROR                                       */
      __IM  uint32_t STALL      : 1;            /*!< [10..10] Source: SIE_STATUS.STALL_REC                                     */
      __IM  uint32_t VBUS_DETECT : 1;           /*!< [11..11] Source: SIE_STATUS.VBUS_DETECT                                   */
      __IM  uint32_t BUS_RESET  : 1;            /*!< [12..12] Source: SIE_STATUS.BUS_RESET                                     */
      __IM  uint32_t DEV_CONN_DIS : 1;          /*!< [13..13] Set when the device connection state changes. Cleared
                                                     by writing to SIE_STATUS.CONNECTED                                        */
      __IM  uint32_t DEV_SUSPEND : 1;           /*!< [14..14] Set when the device suspend state changes. Cleared
                                                     by writing to SIE_STATUS.SUSPENDED                                        */
      __IM  uint32_t DEV_RESUME_FROM_HOST : 1;  /*!< [15..15] Set when the device receives a resume from the host.
                                                     Cleared by writing to SIE_STATUS.RESUME                                   */
      __IM  uint32_t SETUP_REQ  : 1;            /*!< [16..16] Device. Source: SIE_STATUS.SETUP_REC                             */
      __IM  uint32_t DEV_SOF    : 1;            /*!< [17..17] Set every time the device receives a SOF (Start of
                                                     Frame) packet. Cleared by reading SOF_RD                                  */
      __IM  uint32_t ABORT_DONE : 1;            /*!< [18..18] Raised when any bit in ABORT_DONE is set. Clear by
                                                     clearing all bits in ABORT_DONE.                                          */
      __IM  uint32_t EP_STALL_NAK : 1;          /*!< [19..19] Raised when any bit in EP_STATUS_STALL_NAK is set.
                                                     Clear by clearing all bits in EP_STATUS_STALL_NAK.                        */
            uint32_t            : 12;
    } bit;
  } INTS;
} USBCTRL_REGS_Type;                            /*!< Size = 156 (0x9c)                                                         */



/* =========================================================================================================================== */
/* ================                                           PIO0                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Programmable IO block (PIO0)
  */

typedef struct {                                /*!< (@ 0x50200000) PIO0 Structure                                             */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000000) PIO control register                                       */
    
    struct {
      __IOM uint32_t SM_ENABLE  : 4;            /*!< [3..0] Enable state machine                                               */
      __IOM uint32_t SM_RESTART : 4;            /*!< [7..4] Clear internal SM state which is otherwise difficult
                                                     to access
                                                     (e.g. shift counters). Self-clearing.                                     */
      __IOM uint32_t CLKDIV_RESTART : 4;        /*!< [11..8] Force clock dividers to restart their count and clear
                                                     fractional
                                                     accumulators. Restart multiple dividers to synchronise
                                                     them.                                                                     */
            uint32_t            : 20;
    } bit;
  } CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000004) FIFO status register                                       */
    
    struct {
      __IM  uint32_t RXFULL     : 4;            /*!< [3..0] State machine RX FIFO is full                                      */
            uint32_t            : 4;
      __IM  uint32_t RXEMPTY    : 4;            /*!< [11..8] State machine RX FIFO is empty                                    */
            uint32_t            : 4;
      __IM  uint32_t TXFULL     : 4;            /*!< [19..16] State machine TX FIFO is full                                    */
            uint32_t            : 4;
      __IM  uint32_t TXEMPTY    : 4;            /*!< [27..24] State machine TX FIFO is empty                                   */
            uint32_t            : 4;
    } bit;
  } FSTAT;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000008) FIFO debug register                                        */
    
    struct {
      __IOM uint32_t RXSTALL    : 4;            /*!< [3..0] State machine has stalled on full RX FIFO. Write 1 to
                                                     clear.                                                                    */
            uint32_t            : 4;
      __IOM uint32_t RXUNDER    : 4;            /*!< [11..8] RX FIFO underflow has occurred. Write 1 to clear.                 */
            uint32_t            : 4;
      __IOM uint32_t TXOVER     : 4;            /*!< [19..16] TX FIFO overflow has occurred. Write 1 to clear.                 */
            uint32_t            : 4;
      __IOM uint32_t TXSTALL    : 4;            /*!< [27..24] State machine has stalled on empty TX FIFO. Write 1
                                                     to clear.                                                                 */
            uint32_t            : 4;
    } bit;
  } FDEBUG;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000000C) FIFO levels                                                */
    
    struct {
      __IM  uint32_t TX0        : 4;            /*!< [3..0] TX0                                                                */
      __IM  uint32_t RX0        : 4;            /*!< [7..4] RX0                                                                */
      __IM  uint32_t TX1        : 4;            /*!< [11..8] TX1                                                               */
      __IM  uint32_t RX1        : 4;            /*!< [15..12] RX1                                                              */
      __IM  uint32_t TX2        : 4;            /*!< [19..16] TX2                                                              */
      __IM  uint32_t RX2        : 4;            /*!< [23..20] RX2                                                              */
      __IM  uint32_t TX3        : 4;            /*!< [27..24] TX3                                                              */
      __IM  uint32_t RX3        : 4;            /*!< [31..28] RX3                                                              */
    } bit;
  } FLEVEL;
  __OM  uint32_t  TXF0;                         /*!< (@ 0x00000010) Direct write access to the TX FIFO for this state
                                                                    machine. Each write pushes one word to the
                                                                    FIFO.                                                      */
  __OM  uint32_t  TXF1;                         /*!< (@ 0x00000014) Direct write access to the TX FIFO for this state
                                                                    machine. Each write pushes one word to the
                                                                    FIFO.                                                      */
  __OM  uint32_t  TXF2;                         /*!< (@ 0x00000018) Direct write access to the TX FIFO for this state
                                                                    machine. Each write pushes one word to the
                                                                    FIFO.                                                      */
  __OM  uint32_t  TXF3;                         /*!< (@ 0x0000001C) Direct write access to the TX FIFO for this state
                                                                    machine. Each write pushes one word to the
                                                                    FIFO.                                                      */
  __IM  uint32_t  RXF0;                         /*!< (@ 0x00000020) Direct read access to the RX FIFO for this state
                                                                    machine. Each read pops one word from the
                                                                    FIFO.                                                      */
  __IM  uint32_t  RXF1;                         /*!< (@ 0x00000024) Direct read access to the RX FIFO for this state
                                                                    machine. Each read pops one word from the
                                                                    FIFO.                                                      */
  __IM  uint32_t  RXF2;                         /*!< (@ 0x00000028) Direct read access to the RX FIFO for this state
                                                                    machine. Each read pops one word from the
                                                                    FIFO.                                                      */
  __IM  uint32_t  RXF3;                         /*!< (@ 0x0000002C) Direct read access to the RX FIFO for this state
                                                                    machine. Each read pops one word from the
                                                                    FIFO.                                                      */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000030) Interrupt request register. Write 1 to clear               */
    
    struct {
      __IOM uint32_t IRQ        : 8;            /*!< [7..0] IRQ                                                                */
            uint32_t            : 24;
    } bit;
  } IRQ;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000034) Writing a 1 to each of these bits will forcibly
                                                                    assert the corresponding IRQ.
                                                                    Note this is different to the INTF register:
                                                                    writing here affects PIO internal
                                                                    state. INTF just asserts the processor-facing
                                                                    IRQ signal for testing ISRs,
                                                                    and is not visible to the state machines.                  */
    
    struct {
      __OM  uint32_t IRQ_FORCE  : 8;            /*!< [7..0] IRQ_FORCE                                                          */
            uint32_t            : 24;
    } bit;
  } IRQ_FORCE;
  __IOM uint32_t  INPUT_SYNC_BYPASS;            /*!< (@ 0x00000038) There is a 2-flipflop synchronizer on each GPIO
                                                                    input, which protects
                                                                    PIO logic from metastabilities. This increases
                                                                    input delay, and for fast
                                                                    synchronous IO (e.g. SPI) these synchronizers
                                                                    may need to be bypassed.
                                                                    Each bit in this register corresponds to
                                                                    one GPIO.
                                                                    0 -> input is synchronized (default)
                                                                    1 -> synchronizer is bypassed
                                                                    If in doubt, leave this register as all
                                                                    zeroes.                                                    */
  __IM  uint32_t  DBG_PADOUT;                   /*!< (@ 0x0000003C) Read to sample the pad output values PIO is currently
                                                                    driving to the GPIOs.                                      */
  __IM  uint32_t  DBG_PADOE;                    /*!< (@ 0x00000040) Read to sample the pad output enables (direction)
                                                                    PIO is currently driving to the GPIOs.                     */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000044) The PIO hardware has some free parameters that
                                                                    may vary between chip products.
                                                                    These should be provided in the chip datasheet,
                                                                    but are also exposed here.                                 */
    
    struct {
      __IM  uint32_t FIFO_DEPTH : 6;            /*!< [5..0] The depth of the state machine TX/RX FIFOs, measured
                                                     in words.
                                                     Joining fifos via SHIFTCTRL_FJOIN gives one FIFO with double
                                                     this depth.                                                               */
            uint32_t            : 2;
      __IM  uint32_t SM_COUNT   : 4;            /*!< [11..8] The number of state machines this PIO instance is equipped
                                                     with.                                                                     */
            uint32_t            : 4;
      __IM  uint32_t IMEM_SIZE  : 6;            /*!< [21..16] The size of the instruction memory, measured in units
                                                     of one instruction                                                        */
            uint32_t            : 10;
    } bit;
  } DBG_CFGINFO;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000048) Write-only access to instruction memory location
                                                                    0                                                          */
    
    struct {
      __IOM uint32_t INSTR_MEM0 : 16;           /*!< [15..0] INSTR_MEM0                                                        */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM0;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000004C) Write-only access to instruction memory location
                                                                    1                                                          */
    
    struct {
      __IOM uint32_t INSTR_MEM1 : 16;           /*!< [15..0] INSTR_MEM1                                                        */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000050) Write-only access to instruction memory location
                                                                    2                                                          */
    
    struct {
      __IOM uint32_t INSTR_MEM2 : 16;           /*!< [15..0] INSTR_MEM2                                                        */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM2;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000054) Write-only access to instruction memory location
                                                                    3                                                          */
    
    struct {
      __IOM uint32_t INSTR_MEM3 : 16;           /*!< [15..0] INSTR_MEM3                                                        */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM3;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000058) Write-only access to instruction memory location
                                                                    4                                                          */
    
    struct {
      __IOM uint32_t INSTR_MEM4 : 16;           /*!< [15..0] INSTR_MEM4                                                        */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM4;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000005C) Write-only access to instruction memory location
                                                                    5                                                          */
    
    struct {
      __IOM uint32_t INSTR_MEM5 : 16;           /*!< [15..0] INSTR_MEM5                                                        */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM5;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000060) Write-only access to instruction memory location
                                                                    6                                                          */
    
    struct {
      __IOM uint32_t INSTR_MEM6 : 16;           /*!< [15..0] INSTR_MEM6                                                        */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM6;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000064) Write-only access to instruction memory location
                                                                    7                                                          */
    
    struct {
      __IOM uint32_t INSTR_MEM7 : 16;           /*!< [15..0] INSTR_MEM7                                                        */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM7;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000068) Write-only access to instruction memory location
                                                                    8                                                          */
    
    struct {
      __IOM uint32_t INSTR_MEM8 : 16;           /*!< [15..0] INSTR_MEM8                                                        */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM8;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000006C) Write-only access to instruction memory location
                                                                    9                                                          */
    
    struct {
      __IOM uint32_t INSTR_MEM9 : 16;           /*!< [15..0] INSTR_MEM9                                                        */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM9;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000070) Write-only access to instruction memory location
                                                                    10                                                         */
    
    struct {
      __IOM uint32_t INSTR_MEM10 : 16;          /*!< [15..0] INSTR_MEM10                                                       */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM10;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000074) Write-only access to instruction memory location
                                                                    11                                                         */
    
    struct {
      __IOM uint32_t INSTR_MEM11 : 16;          /*!< [15..0] INSTR_MEM11                                                       */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM11;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000078) Write-only access to instruction memory location
                                                                    12                                                         */
    
    struct {
      __IOM uint32_t INSTR_MEM12 : 16;          /*!< [15..0] INSTR_MEM12                                                       */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM12;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000007C) Write-only access to instruction memory location
                                                                    13                                                         */
    
    struct {
      __IOM uint32_t INSTR_MEM13 : 16;          /*!< [15..0] INSTR_MEM13                                                       */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM13;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000080) Write-only access to instruction memory location
                                                                    14                                                         */
    
    struct {
      __IOM uint32_t INSTR_MEM14 : 16;          /*!< [15..0] INSTR_MEM14                                                       */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM14;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000084) Write-only access to instruction memory location
                                                                    15                                                         */
    
    struct {
      __IOM uint32_t INSTR_MEM15 : 16;          /*!< [15..0] INSTR_MEM15                                                       */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM15;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000088) Write-only access to instruction memory location
                                                                    16                                                         */
    
    struct {
      __IOM uint32_t INSTR_MEM16 : 16;          /*!< [15..0] INSTR_MEM16                                                       */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM16;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000008C) Write-only access to instruction memory location
                                                                    17                                                         */
    
    struct {
      __IOM uint32_t INSTR_MEM17 : 16;          /*!< [15..0] INSTR_MEM17                                                       */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM17;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000090) Write-only access to instruction memory location
                                                                    18                                                         */
    
    struct {
      __IOM uint32_t INSTR_MEM18 : 16;          /*!< [15..0] INSTR_MEM18                                                       */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM18;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000094) Write-only access to instruction memory location
                                                                    19                                                         */
    
    struct {
      __IOM uint32_t INSTR_MEM19 : 16;          /*!< [15..0] INSTR_MEM19                                                       */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM19;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000098) Write-only access to instruction memory location
                                                                    20                                                         */
    
    struct {
      __IOM uint32_t INSTR_MEM20 : 16;          /*!< [15..0] INSTR_MEM20                                                       */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM20;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000009C) Write-only access to instruction memory location
                                                                    21                                                         */
    
    struct {
      __IOM uint32_t INSTR_MEM21 : 16;          /*!< [15..0] INSTR_MEM21                                                       */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM21;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000A0) Write-only access to instruction memory location
                                                                    22                                                         */
    
    struct {
      __IOM uint32_t INSTR_MEM22 : 16;          /*!< [15..0] INSTR_MEM22                                                       */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM22;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000A4) Write-only access to instruction memory location
                                                                    23                                                         */
    
    struct {
      __IOM uint32_t INSTR_MEM23 : 16;          /*!< [15..0] INSTR_MEM23                                                       */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM23;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000A8) Write-only access to instruction memory location
                                                                    24                                                         */
    
    struct {
      __IOM uint32_t INSTR_MEM24 : 16;          /*!< [15..0] INSTR_MEM24                                                       */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM24;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000AC) Write-only access to instruction memory location
                                                                    25                                                         */
    
    struct {
      __IOM uint32_t INSTR_MEM25 : 16;          /*!< [15..0] INSTR_MEM25                                                       */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM25;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000B0) Write-only access to instruction memory location
                                                                    26                                                         */
    
    struct {
      __IOM uint32_t INSTR_MEM26 : 16;          /*!< [15..0] INSTR_MEM26                                                       */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM26;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000B4) Write-only access to instruction memory location
                                                                    27                                                         */
    
    struct {
      __IOM uint32_t INSTR_MEM27 : 16;          /*!< [15..0] INSTR_MEM27                                                       */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM27;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000B8) Write-only access to instruction memory location
                                                                    28                                                         */
    
    struct {
      __IOM uint32_t INSTR_MEM28 : 16;          /*!< [15..0] INSTR_MEM28                                                       */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM28;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000BC) Write-only access to instruction memory location
                                                                    29                                                         */
    
    struct {
      __IOM uint32_t INSTR_MEM29 : 16;          /*!< [15..0] INSTR_MEM29                                                       */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM29;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000C0) Write-only access to instruction memory location
                                                                    30                                                         */
    
    struct {
      __IOM uint32_t INSTR_MEM30 : 16;          /*!< [15..0] INSTR_MEM30                                                       */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM30;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000C4) Write-only access to instruction memory location
                                                                    31                                                         */
    
    struct {
      __IOM uint32_t INSTR_MEM31 : 16;          /*!< [15..0] INSTR_MEM31                                                       */
            uint32_t            : 16;
    } bit;
  } INSTR_MEM31;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000C8) Clock divider register for state machine 0
                                                                    Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC
                                                                    / 256)                                                     */
    
    struct {
            uint32_t            : 8;
      __IOM uint32_t FRAC       : 8;            /*!< [15..8] Fractional part of clock divider                                  */
      __IOM uint32_t INT        : 16;           /*!< [31..16] Effective frequency is sysclk/int.
                                                     Value of 0 is interpreted as max possible value                           */
    } bit;
  } SM0_CLKDIV;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000CC) Execution/behavioural settings for state machine
                                                                    0                                                          */
    
    struct {
      __IOM uint32_t STATUS_N   : 4;            /*!< [3..0] Comparison level for the MOV x, STATUS instruction                 */
      __IOM uint32_t STATUS_SEL : 1;            /*!< [4..4] Comparison used for the MOV x, STATUS instruction.                 */
            uint32_t            : 2;
      __IOM uint32_t WRAP_BOTTOM : 5;           /*!< [11..7] After reaching wrap_top, execution is wrapped to this
                                                     address.                                                                  */
      __IOM uint32_t WRAP_TOP   : 5;            /*!< [16..12] After reaching this address, execution is wrapped to
                                                     wrap_bottom.
                                                     If the instruction is a jump, and the jump condition is
                                                     true, the jump takes priority.                                            */
      __IOM uint32_t OUT_STICKY : 1;            /*!< [17..17] Continuously assert the most recent OUT/SET to the
                                                     pins                                                                      */
      __IOM uint32_t INLINE_OUT_EN : 1;         /*!< [18..18] If 1, use a bit of OUT data as an auxiliary write enable
                                                     When used in conjunction with OUT_STICKY, writes with an
                                                     enable of 0 will
                                                     deassert the latest pin write. This can create useful masking/override
                                                     behaviour
                                                     due to the priority ordering of state machine pin writes
                                                     (SM0 < SM1 < ...)                                                         */
      __IOM uint32_t OUT_EN_SEL : 5;            /*!< [23..19] Which data bit to use for inline OUT enable                      */
      __IOM uint32_t JMP_PIN    : 5;            /*!< [28..24] The GPIO number to use as condition for JMP PIN. Unaffected
                                                     by input mapping.                                                         */
      __IOM uint32_t SIDE_PINDIR : 1;           /*!< [29..29] Side-set data is asserted to pin OEs instead of pin
                                                     values                                                                    */
      __IOM uint32_t SIDE_EN    : 1;            /*!< [30..30] If 1, the delay MSB is used as side-set enable, rather
                                                     than a
                                                     side-set data bit. This allows instructions to perform
                                                     side-set optionally,
                                                     rather than on every instruction.                                         */
      __IM  uint32_t EXEC_STALLED : 1;          /*!< [31..31] An instruction written to SMx_INSTR is stalled, and
                                                     latched by the
                                                     state machine. Will clear once the instruction completes.                 */
    } bit;
  } SM0_EXECCTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000D0) Control behaviour of the input/output shift registers
                                                                    for state machine 0                                        */
    
    struct {
            uint32_t            : 16;
      __IOM uint32_t AUTOPUSH   : 1;            /*!< [16..16] Push automatically when the input shift register is
                                                     filled                                                                    */
      __IOM uint32_t AUTOPULL   : 1;            /*!< [17..17] Pull automatically when the output shift register is
                                                     emptied                                                                   */
      __IOM uint32_t IN_SHIFTDIR : 1;           /*!< [18..18] 1 = shift input shift register to right (data enters
                                                     from left). 0 = to left.                                                  */
      __IOM uint32_t OUT_SHIFTDIR : 1;          /*!< [19..19] 1 = shift out of output shift register to right. 0
                                                     = to left.                                                                */
      __IOM uint32_t PUSH_THRESH : 5;           /*!< [24..20] Number of bits shifted into RXSR before autopush or
                                                     conditional push.
                                                     Write 0 for value of 32.                                                  */
      __IOM uint32_t PULL_THRESH : 5;           /*!< [29..25] Number of bits shifted out of TXSR before autopull
                                                     or conditional pull.
                                                     Write 0 for value of 32.                                                  */
      __IOM uint32_t FJOIN_TX   : 1;            /*!< [30..30] When 1, TX FIFO steals the RX FIFO's storage, and becomes
                                                     twice as deep.
                                                     RX FIFO is disabled as a result (always reads as both full
                                                     and empty).
                                                     FIFOs are flushed when this bit is changed.                               */
      __IOM uint32_t FJOIN_RX   : 1;            /*!< [31..31] When 1, RX FIFO steals the TX FIFO's storage, and becomes
                                                     twice as deep.
                                                     TX FIFO is disabled as a result (always reads as both full
                                                     and empty).
                                                     FIFOs are flushed when this bit is changed.                               */
    } bit;
  } SM0_SHIFTCTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000D4) Current instruction address of state machine
                                                                    0                                                          */
    
    struct {
      __IM  uint32_t SM0_ADDR   : 5;            /*!< [4..0] SM0_ADDR                                                           */
            uint32_t            : 27;
    } bit;
  } SM0_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000D8) Instruction currently being executed by state
                                                                    machine 0
                                                                    Write to execute an instruction immediately
                                                                    (including jumps) and then resume execution.               */
    
    struct {
      __IOM uint32_t SM0_INSTR  : 16;           /*!< [15..0] SM0_INSTR                                                         */
            uint32_t            : 16;
    } bit;
  } SM0_INSTR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000DC) State machine pin control                                  */
    
    struct {
      __IOM uint32_t OUT_BASE   : 5;            /*!< [4..0] The virtual pin corresponding to OUT bit 0                         */
      __IOM uint32_t SET_BASE   : 5;            /*!< [9..5] The virtual pin corresponding to SET bit 0                         */
      __IOM uint32_t SIDESET_BASE : 5;          /*!< [14..10] The virtual pin corresponding to delay field bit 0               */
      __IOM uint32_t IN_BASE    : 5;            /*!< [19..15] The virtual pin corresponding to IN bit 0                        */
      __IOM uint32_t OUT_COUNT  : 6;            /*!< [25..20] The number of pins asserted by an OUT. Value of 0 ->
                                                     32 pins                                                                   */
      __IOM uint32_t SET_COUNT  : 3;            /*!< [28..26] The number of pins asserted by a SET. Max of 5                   */
      __IOM uint32_t SIDESET_COUNT : 3;         /*!< [31..29] The number of delay bits co-opted for side-set. Inclusive
                                                     of the enable bit, if present.                                            */
    } bit;
  } SM0_PINCTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000E0) Clock divider register for state machine 1
                                                                    Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC
                                                                    / 256)                                                     */
    
    struct {
            uint32_t            : 8;
      __IOM uint32_t FRAC       : 8;            /*!< [15..8] Fractional part of clock divider                                  */
      __IOM uint32_t INT        : 16;           /*!< [31..16] Effective frequency is sysclk/int.
                                                     Value of 0 is interpreted as max possible value                           */
    } bit;
  } SM1_CLKDIV;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000E4) Execution/behavioural settings for state machine
                                                                    1                                                          */
    
    struct {
      __IOM uint32_t STATUS_N   : 4;            /*!< [3..0] Comparison level for the MOV x, STATUS instruction                 */
      __IOM uint32_t STATUS_SEL : 1;            /*!< [4..4] Comparison used for the MOV x, STATUS instruction.                 */
            uint32_t            : 2;
      __IOM uint32_t WRAP_BOTTOM : 5;           /*!< [11..7] After reaching wrap_top, execution is wrapped to this
                                                     address.                                                                  */
      __IOM uint32_t WRAP_TOP   : 5;            /*!< [16..12] After reaching this address, execution is wrapped to
                                                     wrap_bottom.
                                                     If the instruction is a jump, and the jump condition is
                                                     true, the jump takes priority.                                            */
      __IOM uint32_t OUT_STICKY : 1;            /*!< [17..17] Continuously assert the most recent OUT/SET to the
                                                     pins                                                                      */
      __IOM uint32_t INLINE_OUT_EN : 1;         /*!< [18..18] If 1, use a bit of OUT data as an auxiliary write enable
                                                     When used in conjunction with OUT_STICKY, writes with an
                                                     enable of 0 will
                                                     deassert the latest pin write. This can create useful masking/override
                                                     behaviour
                                                     due to the priority ordering of state machine pin writes
                                                     (SM0 < SM1 < ...)                                                         */
      __IOM uint32_t OUT_EN_SEL : 5;            /*!< [23..19] Which data bit to use for inline OUT enable                      */
      __IOM uint32_t JMP_PIN    : 5;            /*!< [28..24] The GPIO number to use as condition for JMP PIN. Unaffected
                                                     by input mapping.                                                         */
      __IOM uint32_t SIDE_PINDIR : 1;           /*!< [29..29] Side-set data is asserted to pin OEs instead of pin
                                                     values                                                                    */
      __IOM uint32_t SIDE_EN    : 1;            /*!< [30..30] If 1, the delay MSB is used as side-set enable, rather
                                                     than a
                                                     side-set data bit. This allows instructions to perform
                                                     side-set optionally,
                                                     rather than on every instruction.                                         */
      __IM  uint32_t EXEC_STALLED : 1;          /*!< [31..31] An instruction written to SMx_INSTR is stalled, and
                                                     latched by the
                                                     state machine. Will clear once the instruction completes.                 */
    } bit;
  } SM1_EXECCTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000E8) Control behaviour of the input/output shift registers
                                                                    for state machine 1                                        */
    
    struct {
            uint32_t            : 16;
      __IOM uint32_t AUTOPUSH   : 1;            /*!< [16..16] Push automatically when the input shift register is
                                                     filled                                                                    */
      __IOM uint32_t AUTOPULL   : 1;            /*!< [17..17] Pull automatically when the output shift register is
                                                     emptied                                                                   */
      __IOM uint32_t IN_SHIFTDIR : 1;           /*!< [18..18] 1 = shift input shift register to right (data enters
                                                     from left). 0 = to left.                                                  */
      __IOM uint32_t OUT_SHIFTDIR : 1;          /*!< [19..19] 1 = shift out of output shift register to right. 0
                                                     = to left.                                                                */
      __IOM uint32_t PUSH_THRESH : 5;           /*!< [24..20] Number of bits shifted into RXSR before autopush or
                                                     conditional push.
                                                     Write 0 for value of 32.                                                  */
      __IOM uint32_t PULL_THRESH : 5;           /*!< [29..25] Number of bits shifted out of TXSR before autopull
                                                     or conditional pull.
                                                     Write 0 for value of 32.                                                  */
      __IOM uint32_t FJOIN_TX   : 1;            /*!< [30..30] When 1, TX FIFO steals the RX FIFO's storage, and becomes
                                                     twice as deep.
                                                     RX FIFO is disabled as a result (always reads as both full
                                                     and empty).
                                                     FIFOs are flushed when this bit is changed.                               */
      __IOM uint32_t FJOIN_RX   : 1;            /*!< [31..31] When 1, RX FIFO steals the TX FIFO's storage, and becomes
                                                     twice as deep.
                                                     TX FIFO is disabled as a result (always reads as both full
                                                     and empty).
                                                     FIFOs are flushed when this bit is changed.                               */
    } bit;
  } SM1_SHIFTCTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000EC) Current instruction address of state machine
                                                                    1                                                          */
    
    struct {
      __IM  uint32_t SM1_ADDR   : 5;            /*!< [4..0] SM1_ADDR                                                           */
            uint32_t            : 27;
    } bit;
  } SM1_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000F0) Instruction currently being executed by state
                                                                    machine 1
                                                                    Write to execute an instruction immediately
                                                                    (including jumps) and then resume execution.               */
    
    struct {
      __IOM uint32_t SM1_INSTR  : 16;           /*!< [15..0] SM1_INSTR                                                         */
            uint32_t            : 16;
    } bit;
  } SM1_INSTR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000F4) State machine pin control                                  */
    
    struct {
      __IOM uint32_t OUT_BASE   : 5;            /*!< [4..0] The virtual pin corresponding to OUT bit 0                         */
      __IOM uint32_t SET_BASE   : 5;            /*!< [9..5] The virtual pin corresponding to SET bit 0                         */
      __IOM uint32_t SIDESET_BASE : 5;          /*!< [14..10] The virtual pin corresponding to delay field bit 0               */
      __IOM uint32_t IN_BASE    : 5;            /*!< [19..15] The virtual pin corresponding to IN bit 0                        */
      __IOM uint32_t OUT_COUNT  : 6;            /*!< [25..20] The number of pins asserted by an OUT. Value of 0 ->
                                                     32 pins                                                                   */
      __IOM uint32_t SET_COUNT  : 3;            /*!< [28..26] The number of pins asserted by a SET. Max of 5                   */
      __IOM uint32_t SIDESET_COUNT : 3;         /*!< [31..29] The number of delay bits co-opted for side-set. Inclusive
                                                     of the enable bit, if present.                                            */
    } bit;
  } SM1_PINCTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000F8) Clock divider register for state machine 2
                                                                    Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC
                                                                    / 256)                                                     */
    
    struct {
            uint32_t            : 8;
      __IOM uint32_t FRAC       : 8;            /*!< [15..8] Fractional part of clock divider                                  */
      __IOM uint32_t INT        : 16;           /*!< [31..16] Effective frequency is sysclk/int.
                                                     Value of 0 is interpreted as max possible value                           */
    } bit;
  } SM2_CLKDIV;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000FC) Execution/behavioural settings for state machine
                                                                    2                                                          */
    
    struct {
      __IOM uint32_t STATUS_N   : 4;            /*!< [3..0] Comparison level for the MOV x, STATUS instruction                 */
      __IOM uint32_t STATUS_SEL : 1;            /*!< [4..4] Comparison used for the MOV x, STATUS instruction.                 */
            uint32_t            : 2;
      __IOM uint32_t WRAP_BOTTOM : 5;           /*!< [11..7] After reaching wrap_top, execution is wrapped to this
                                                     address.                                                                  */
      __IOM uint32_t WRAP_TOP   : 5;            /*!< [16..12] After reaching this address, execution is wrapped to
                                                     wrap_bottom.
                                                     If the instruction is a jump, and the jump condition is
                                                     true, the jump takes priority.                                            */
      __IOM uint32_t OUT_STICKY : 1;            /*!< [17..17] Continuously assert the most recent OUT/SET to the
                                                     pins                                                                      */
      __IOM uint32_t INLINE_OUT_EN : 1;         /*!< [18..18] If 1, use a bit of OUT data as an auxiliary write enable
                                                     When used in conjunction with OUT_STICKY, writes with an
                                                     enable of 0 will
                                                     deassert the latest pin write. This can create useful masking/override
                                                     behaviour
                                                     due to the priority ordering of state machine pin writes
                                                     (SM0 < SM1 < ...)                                                         */
      __IOM uint32_t OUT_EN_SEL : 5;            /*!< [23..19] Which data bit to use for inline OUT enable                      */
      __IOM uint32_t JMP_PIN    : 5;            /*!< [28..24] The GPIO number to use as condition for JMP PIN. Unaffected
                                                     by input mapping.                                                         */
      __IOM uint32_t SIDE_PINDIR : 1;           /*!< [29..29] Side-set data is asserted to pin OEs instead of pin
                                                     values                                                                    */
      __IOM uint32_t SIDE_EN    : 1;            /*!< [30..30] If 1, the delay MSB is used as side-set enable, rather
                                                     than a
                                                     side-set data bit. This allows instructions to perform
                                                     side-set optionally,
                                                     rather than on every instruction.                                         */
      __IM  uint32_t EXEC_STALLED : 1;          /*!< [31..31] An instruction written to SMx_INSTR is stalled, and
                                                     latched by the
                                                     state machine. Will clear once the instruction completes.                 */
    } bit;
  } SM2_EXECCTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000100) Control behaviour of the input/output shift registers
                                                                    for state machine 2                                        */
    
    struct {
            uint32_t            : 16;
      __IOM uint32_t AUTOPUSH   : 1;            /*!< [16..16] Push automatically when the input shift register is
                                                     filled                                                                    */
      __IOM uint32_t AUTOPULL   : 1;            /*!< [17..17] Pull automatically when the output shift register is
                                                     emptied                                                                   */
      __IOM uint32_t IN_SHIFTDIR : 1;           /*!< [18..18] 1 = shift input shift register to right (data enters
                                                     from left). 0 = to left.                                                  */
      __IOM uint32_t OUT_SHIFTDIR : 1;          /*!< [19..19] 1 = shift out of output shift register to right. 0
                                                     = to left.                                                                */
      __IOM uint32_t PUSH_THRESH : 5;           /*!< [24..20] Number of bits shifted into RXSR before autopush or
                                                     conditional push.
                                                     Write 0 for value of 32.                                                  */
      __IOM uint32_t PULL_THRESH : 5;           /*!< [29..25] Number of bits shifted out of TXSR before autopull
                                                     or conditional pull.
                                                     Write 0 for value of 32.                                                  */
      __IOM uint32_t FJOIN_TX   : 1;            /*!< [30..30] When 1, TX FIFO steals the RX FIFO's storage, and becomes
                                                     twice as deep.
                                                     RX FIFO is disabled as a result (always reads as both full
                                                     and empty).
                                                     FIFOs are flushed when this bit is changed.                               */
      __IOM uint32_t FJOIN_RX   : 1;            /*!< [31..31] When 1, RX FIFO steals the TX FIFO's storage, and becomes
                                                     twice as deep.
                                                     TX FIFO is disabled as a result (always reads as both full
                                                     and empty).
                                                     FIFOs are flushed when this bit is changed.                               */
    } bit;
  } SM2_SHIFTCTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000104) Current instruction address of state machine
                                                                    2                                                          */
    
    struct {
      __IM  uint32_t SM2_ADDR   : 5;            /*!< [4..0] SM2_ADDR                                                           */
            uint32_t            : 27;
    } bit;
  } SM2_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000108) Instruction currently being executed by state
                                                                    machine 2
                                                                    Write to execute an instruction immediately
                                                                    (including jumps) and then resume execution.               */
    
    struct {
      __IOM uint32_t SM2_INSTR  : 16;           /*!< [15..0] SM2_INSTR                                                         */
            uint32_t            : 16;
    } bit;
  } SM2_INSTR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000010C) State machine pin control                                  */
    
    struct {
      __IOM uint32_t OUT_BASE   : 5;            /*!< [4..0] The virtual pin corresponding to OUT bit 0                         */
      __IOM uint32_t SET_BASE   : 5;            /*!< [9..5] The virtual pin corresponding to SET bit 0                         */
      __IOM uint32_t SIDESET_BASE : 5;          /*!< [14..10] The virtual pin corresponding to delay field bit 0               */
      __IOM uint32_t IN_BASE    : 5;            /*!< [19..15] The virtual pin corresponding to IN bit 0                        */
      __IOM uint32_t OUT_COUNT  : 6;            /*!< [25..20] The number of pins asserted by an OUT. Value of 0 ->
                                                     32 pins                                                                   */
      __IOM uint32_t SET_COUNT  : 3;            /*!< [28..26] The number of pins asserted by a SET. Max of 5                   */
      __IOM uint32_t SIDESET_COUNT : 3;         /*!< [31..29] The number of delay bits co-opted for side-set. Inclusive
                                                     of the enable bit, if present.                                            */
    } bit;
  } SM2_PINCTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000110) Clock divider register for state machine 3
                                                                    Frequency = clock freq / (CLKDIV_INT + CLKDIV_FRAC
                                                                    / 256)                                                     */
    
    struct {
            uint32_t            : 8;
      __IOM uint32_t FRAC       : 8;            /*!< [15..8] Fractional part of clock divider                                  */
      __IOM uint32_t INT        : 16;           /*!< [31..16] Effective frequency is sysclk/int.
                                                     Value of 0 is interpreted as max possible value                           */
    } bit;
  } SM3_CLKDIV;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000114) Execution/behavioural settings for state machine
                                                                    3                                                          */
    
    struct {
      __IOM uint32_t STATUS_N   : 4;            /*!< [3..0] Comparison level for the MOV x, STATUS instruction                 */
      __IOM uint32_t STATUS_SEL : 1;            /*!< [4..4] Comparison used for the MOV x, STATUS instruction.                 */
            uint32_t            : 2;
      __IOM uint32_t WRAP_BOTTOM : 5;           /*!< [11..7] After reaching wrap_top, execution is wrapped to this
                                                     address.                                                                  */
      __IOM uint32_t WRAP_TOP   : 5;            /*!< [16..12] After reaching this address, execution is wrapped to
                                                     wrap_bottom.
                                                     If the instruction is a jump, and the jump condition is
                                                     true, the jump takes priority.                                            */
      __IOM uint32_t OUT_STICKY : 1;            /*!< [17..17] Continuously assert the most recent OUT/SET to the
                                                     pins                                                                      */
      __IOM uint32_t INLINE_OUT_EN : 1;         /*!< [18..18] If 1, use a bit of OUT data as an auxiliary write enable
                                                     When used in conjunction with OUT_STICKY, writes with an
                                                     enable of 0 will
                                                     deassert the latest pin write. This can create useful masking/override
                                                     behaviour
                                                     due to the priority ordering of state machine pin writes
                                                     (SM0 < SM1 < ...)                                                         */
      __IOM uint32_t OUT_EN_SEL : 5;            /*!< [23..19] Which data bit to use for inline OUT enable                      */
      __IOM uint32_t JMP_PIN    : 5;            /*!< [28..24] The GPIO number to use as condition for JMP PIN. Unaffected
                                                     by input mapping.                                                         */
      __IOM uint32_t SIDE_PINDIR : 1;           /*!< [29..29] Side-set data is asserted to pin OEs instead of pin
                                                     values                                                                    */
      __IOM uint32_t SIDE_EN    : 1;            /*!< [30..30] If 1, the delay MSB is used as side-set enable, rather
                                                     than a
                                                     side-set data bit. This allows instructions to perform
                                                     side-set optionally,
                                                     rather than on every instruction.                                         */
      __IM  uint32_t EXEC_STALLED : 1;          /*!< [31..31] An instruction written to SMx_INSTR is stalled, and
                                                     latched by the
                                                     state machine. Will clear once the instruction completes.                 */
    } bit;
  } SM3_EXECCTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000118) Control behaviour of the input/output shift registers
                                                                    for state machine 3                                        */
    
    struct {
            uint32_t            : 16;
      __IOM uint32_t AUTOPUSH   : 1;            /*!< [16..16] Push automatically when the input shift register is
                                                     filled                                                                    */
      __IOM uint32_t AUTOPULL   : 1;            /*!< [17..17] Pull automatically when the output shift register is
                                                     emptied                                                                   */
      __IOM uint32_t IN_SHIFTDIR : 1;           /*!< [18..18] 1 = shift input shift register to right (data enters
                                                     from left). 0 = to left.                                                  */
      __IOM uint32_t OUT_SHIFTDIR : 1;          /*!< [19..19] 1 = shift out of output shift register to right. 0
                                                     = to left.                                                                */
      __IOM uint32_t PUSH_THRESH : 5;           /*!< [24..20] Number of bits shifted into RXSR before autopush or
                                                     conditional push.
                                                     Write 0 for value of 32.                                                  */
      __IOM uint32_t PULL_THRESH : 5;           /*!< [29..25] Number of bits shifted out of TXSR before autopull
                                                     or conditional pull.
                                                     Write 0 for value of 32.                                                  */
      __IOM uint32_t FJOIN_TX   : 1;            /*!< [30..30] When 1, TX FIFO steals the RX FIFO's storage, and becomes
                                                     twice as deep.
                                                     RX FIFO is disabled as a result (always reads as both full
                                                     and empty).
                                                     FIFOs are flushed when this bit is changed.                               */
      __IOM uint32_t FJOIN_RX   : 1;            /*!< [31..31] When 1, RX FIFO steals the TX FIFO's storage, and becomes
                                                     twice as deep.
                                                     TX FIFO is disabled as a result (always reads as both full
                                                     and empty).
                                                     FIFOs are flushed when this bit is changed.                               */
    } bit;
  } SM3_SHIFTCTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000011C) Current instruction address of state machine
                                                                    3                                                          */
    
    struct {
      __IM  uint32_t SM3_ADDR   : 5;            /*!< [4..0] SM3_ADDR                                                           */
            uint32_t            : 27;
    } bit;
  } SM3_ADDR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000120) Instruction currently being executed by state
                                                                    machine 3
                                                                    Write to execute an instruction immediately
                                                                    (including jumps) and then resume execution.               */
    
    struct {
      __IOM uint32_t SM3_INSTR  : 16;           /*!< [15..0] SM3_INSTR                                                         */
            uint32_t            : 16;
    } bit;
  } SM3_INSTR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000124) State machine pin control                                  */
    
    struct {
      __IOM uint32_t OUT_BASE   : 5;            /*!< [4..0] The virtual pin corresponding to OUT bit 0                         */
      __IOM uint32_t SET_BASE   : 5;            /*!< [9..5] The virtual pin corresponding to SET bit 0                         */
      __IOM uint32_t SIDESET_BASE : 5;          /*!< [14..10] The virtual pin corresponding to delay field bit 0               */
      __IOM uint32_t IN_BASE    : 5;            /*!< [19..15] The virtual pin corresponding to IN bit 0                        */
      __IOM uint32_t OUT_COUNT  : 6;            /*!< [25..20] The number of pins asserted by an OUT. Value of 0 ->
                                                     32 pins                                                                   */
      __IOM uint32_t SET_COUNT  : 3;            /*!< [28..26] The number of pins asserted by a SET. Max of 5                   */
      __IOM uint32_t SIDESET_COUNT : 3;         /*!< [31..29] The number of delay bits co-opted for side-set. Inclusive
                                                     of the enable bit, if present.                                            */
    } bit;
  } SM3_PINCTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000128) Raw Interrupts                                             */
    
    struct {
      __IM  uint32_t SM0_RXNEMPTY : 1;          /*!< [0..0] SM0_RXNEMPTY                                                       */
      __IM  uint32_t SM1_RXNEMPTY : 1;          /*!< [1..1] SM1_RXNEMPTY                                                       */
      __IM  uint32_t SM2_RXNEMPTY : 1;          /*!< [2..2] SM2_RXNEMPTY                                                       */
      __IM  uint32_t SM3_RXNEMPTY : 1;          /*!< [3..3] SM3_RXNEMPTY                                                       */
      __IM  uint32_t SM0_TXNFULL : 1;           /*!< [4..4] SM0_TXNFULL                                                        */
      __IM  uint32_t SM1_TXNFULL : 1;           /*!< [5..5] SM1_TXNFULL                                                        */
      __IM  uint32_t SM2_TXNFULL : 1;           /*!< [6..6] SM2_TXNFULL                                                        */
      __IM  uint32_t SM3_TXNFULL : 1;           /*!< [7..7] SM3_TXNFULL                                                        */
      __IM  uint32_t SM0        : 1;            /*!< [8..8] SM0                                                                */
      __IM  uint32_t SM1        : 1;            /*!< [9..9] SM1                                                                */
      __IM  uint32_t SM2        : 1;            /*!< [10..10] SM2                                                              */
      __IM  uint32_t SM3        : 1;            /*!< [11..11] SM3                                                              */
            uint32_t            : 20;
    } bit;
  } INTR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000012C) Interrupt Enable for irq0                                  */
    
    struct {
      __IOM uint32_t SM0_RXNEMPTY : 1;          /*!< [0..0] SM0_RXNEMPTY                                                       */
      __IOM uint32_t SM1_RXNEMPTY : 1;          /*!< [1..1] SM1_RXNEMPTY                                                       */
      __IOM uint32_t SM2_RXNEMPTY : 1;          /*!< [2..2] SM2_RXNEMPTY                                                       */
      __IOM uint32_t SM3_RXNEMPTY : 1;          /*!< [3..3] SM3_RXNEMPTY                                                       */
      __IOM uint32_t SM0_TXNFULL : 1;           /*!< [4..4] SM0_TXNFULL                                                        */
      __IOM uint32_t SM1_TXNFULL : 1;           /*!< [5..5] SM1_TXNFULL                                                        */
      __IOM uint32_t SM2_TXNFULL : 1;           /*!< [6..6] SM2_TXNFULL                                                        */
      __IOM uint32_t SM3_TXNFULL : 1;           /*!< [7..7] SM3_TXNFULL                                                        */
      __IOM uint32_t SM0        : 1;            /*!< [8..8] SM0                                                                */
      __IOM uint32_t SM1        : 1;            /*!< [9..9] SM1                                                                */
      __IOM uint32_t SM2        : 1;            /*!< [10..10] SM2                                                              */
      __IOM uint32_t SM3        : 1;            /*!< [11..11] SM3                                                              */
            uint32_t            : 20;
    } bit;
  } IRQ0_INTE;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000130) Interrupt Force for irq0                                   */
    
    struct {
      __IOM uint32_t SM0_RXNEMPTY : 1;          /*!< [0..0] SM0_RXNEMPTY                                                       */
      __IOM uint32_t SM1_RXNEMPTY : 1;          /*!< [1..1] SM1_RXNEMPTY                                                       */
      __IOM uint32_t SM2_RXNEMPTY : 1;          /*!< [2..2] SM2_RXNEMPTY                                                       */
      __IOM uint32_t SM3_RXNEMPTY : 1;          /*!< [3..3] SM3_RXNEMPTY                                                       */
      __IOM uint32_t SM0_TXNFULL : 1;           /*!< [4..4] SM0_TXNFULL                                                        */
      __IOM uint32_t SM1_TXNFULL : 1;           /*!< [5..5] SM1_TXNFULL                                                        */
      __IOM uint32_t SM2_TXNFULL : 1;           /*!< [6..6] SM2_TXNFULL                                                        */
      __IOM uint32_t SM3_TXNFULL : 1;           /*!< [7..7] SM3_TXNFULL                                                        */
      __IOM uint32_t SM0        : 1;            /*!< [8..8] SM0                                                                */
      __IOM uint32_t SM1        : 1;            /*!< [9..9] SM1                                                                */
      __IOM uint32_t SM2        : 1;            /*!< [10..10] SM2                                                              */
      __IOM uint32_t SM3        : 1;            /*!< [11..11] SM3                                                              */
            uint32_t            : 20;
    } bit;
  } IRQ0_INTF;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000134) Interrupt status after masking & forcing for
                                                                    irq0                                                       */
    
    struct {
      __IM  uint32_t SM0_RXNEMPTY : 1;          /*!< [0..0] SM0_RXNEMPTY                                                       */
      __IM  uint32_t SM1_RXNEMPTY : 1;          /*!< [1..1] SM1_RXNEMPTY                                                       */
      __IM  uint32_t SM2_RXNEMPTY : 1;          /*!< [2..2] SM2_RXNEMPTY                                                       */
      __IM  uint32_t SM3_RXNEMPTY : 1;          /*!< [3..3] SM3_RXNEMPTY                                                       */
      __IM  uint32_t SM0_TXNFULL : 1;           /*!< [4..4] SM0_TXNFULL                                                        */
      __IM  uint32_t SM1_TXNFULL : 1;           /*!< [5..5] SM1_TXNFULL                                                        */
      __IM  uint32_t SM2_TXNFULL : 1;           /*!< [6..6] SM2_TXNFULL                                                        */
      __IM  uint32_t SM3_TXNFULL : 1;           /*!< [7..7] SM3_TXNFULL                                                        */
      __IM  uint32_t SM0        : 1;            /*!< [8..8] SM0                                                                */
      __IM  uint32_t SM1        : 1;            /*!< [9..9] SM1                                                                */
      __IM  uint32_t SM2        : 1;            /*!< [10..10] SM2                                                              */
      __IM  uint32_t SM3        : 1;            /*!< [11..11] SM3                                                              */
            uint32_t            : 20;
    } bit;
  } IRQ0_INTS;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000138) Interrupt Enable for irq1                                  */
    
    struct {
      __IOM uint32_t SM0_RXNEMPTY : 1;          /*!< [0..0] SM0_RXNEMPTY                                                       */
      __IOM uint32_t SM1_RXNEMPTY : 1;          /*!< [1..1] SM1_RXNEMPTY                                                       */
      __IOM uint32_t SM2_RXNEMPTY : 1;          /*!< [2..2] SM2_RXNEMPTY                                                       */
      __IOM uint32_t SM3_RXNEMPTY : 1;          /*!< [3..3] SM3_RXNEMPTY                                                       */
      __IOM uint32_t SM0_TXNFULL : 1;           /*!< [4..4] SM0_TXNFULL                                                        */
      __IOM uint32_t SM1_TXNFULL : 1;           /*!< [5..5] SM1_TXNFULL                                                        */
      __IOM uint32_t SM2_TXNFULL : 1;           /*!< [6..6] SM2_TXNFULL                                                        */
      __IOM uint32_t SM3_TXNFULL : 1;           /*!< [7..7] SM3_TXNFULL                                                        */
      __IOM uint32_t SM0        : 1;            /*!< [8..8] SM0                                                                */
      __IOM uint32_t SM1        : 1;            /*!< [9..9] SM1                                                                */
      __IOM uint32_t SM2        : 1;            /*!< [10..10] SM2                                                              */
      __IOM uint32_t SM3        : 1;            /*!< [11..11] SM3                                                              */
            uint32_t            : 20;
    } bit;
  } IRQ1_INTE;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000013C) Interrupt Force for irq1                                   */
    
    struct {
      __IOM uint32_t SM0_RXNEMPTY : 1;          /*!< [0..0] SM0_RXNEMPTY                                                       */
      __IOM uint32_t SM1_RXNEMPTY : 1;          /*!< [1..1] SM1_RXNEMPTY                                                       */
      __IOM uint32_t SM2_RXNEMPTY : 1;          /*!< [2..2] SM2_RXNEMPTY                                                       */
      __IOM uint32_t SM3_RXNEMPTY : 1;          /*!< [3..3] SM3_RXNEMPTY                                                       */
      __IOM uint32_t SM0_TXNFULL : 1;           /*!< [4..4] SM0_TXNFULL                                                        */
      __IOM uint32_t SM1_TXNFULL : 1;           /*!< [5..5] SM1_TXNFULL                                                        */
      __IOM uint32_t SM2_TXNFULL : 1;           /*!< [6..6] SM2_TXNFULL                                                        */
      __IOM uint32_t SM3_TXNFULL : 1;           /*!< [7..7] SM3_TXNFULL                                                        */
      __IOM uint32_t SM0        : 1;            /*!< [8..8] SM0                                                                */
      __IOM uint32_t SM1        : 1;            /*!< [9..9] SM1                                                                */
      __IOM uint32_t SM2        : 1;            /*!< [10..10] SM2                                                              */
      __IOM uint32_t SM3        : 1;            /*!< [11..11] SM3                                                              */
            uint32_t            : 20;
    } bit;
  } IRQ1_INTF;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000140) Interrupt status after masking & forcing for
                                                                    irq1                                                       */
    
    struct {
      __IM  uint32_t SM0_RXNEMPTY : 1;          /*!< [0..0] SM0_RXNEMPTY                                                       */
      __IM  uint32_t SM1_RXNEMPTY : 1;          /*!< [1..1] SM1_RXNEMPTY                                                       */
      __IM  uint32_t SM2_RXNEMPTY : 1;          /*!< [2..2] SM2_RXNEMPTY                                                       */
      __IM  uint32_t SM3_RXNEMPTY : 1;          /*!< [3..3] SM3_RXNEMPTY                                                       */
      __IM  uint32_t SM0_TXNFULL : 1;           /*!< [4..4] SM0_TXNFULL                                                        */
      __IM  uint32_t SM1_TXNFULL : 1;           /*!< [5..5] SM1_TXNFULL                                                        */
      __IM  uint32_t SM2_TXNFULL : 1;           /*!< [6..6] SM2_TXNFULL                                                        */
      __IM  uint32_t SM3_TXNFULL : 1;           /*!< [7..7] SM3_TXNFULL                                                        */
      __IM  uint32_t SM0        : 1;            /*!< [8..8] SM0                                                                */
      __IM  uint32_t SM1        : 1;            /*!< [9..9] SM1                                                                */
      __IM  uint32_t SM2        : 1;            /*!< [10..10] SM2                                                              */
      __IM  uint32_t SM3        : 1;            /*!< [11..11] SM3                                                              */
            uint32_t            : 20;
    } bit;
  } IRQ1_INTS;
} PIO0_Type;                                    /*!< Size = 324 (0x144)                                                        */



/* =========================================================================================================================== */
/* ================                                            SIO                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief Single-cycle IO block\n
        Provides core-local and inter-core hardware for the two processors, with single-cycle access. (SIO)
  */

typedef struct {                                /*!< (@ 0xD0000000) SIO Structure                                              */
  __IM  uint32_t  CPUID;                        /*!< (@ 0x00000000) Processor core identifier
                                                                    Value is 0 when read from processor core
                                                                    0, and 1 when read from processor core 1.                  */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000004) Input value for GPIO pins                                  */
    
    struct {
      __IM  uint32_t GPIO_IN    : 30;           /*!< [29..0] Input value for GPIO0...29                                        */
            uint32_t            : 2;
    } bit;
  } GPIO_IN;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000008) Input value for QSPI pins                                  */
    
    struct {
      __IM  uint32_t GPIO_HI_IN : 6;            /*!< [5..0] Input value on QSPI IO in order 0..5: SCLK, SSn, SD0,
                                                     SD1, SD2, SD3                                                             */
            uint32_t            : 26;
    } bit;
  } GPIO_HI_IN;
  __IM  uint32_t  RESERVED;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000010) GPIO output value                                          */
    
    struct {
      __IOM uint32_t GPIO_OUT   : 30;           /*!< [29..0] Set output level (1/0 -> high/low) for GPIO0...29.
                                                     Reading back gives the last value written, NOT the input
                                                     value from the pins.
                                                     If core 0 and core 1 both write to GPIO_OUT simultaneously
                                                     (or to a SET/CLR/XOR alias),
                                                     the result is as though the write from core 0 took place
                                                     first,
                                                     and the write from core 1 was then applied to that intermediate
                                                     result.                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO_OUT;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000014) GPIO output value set                                      */
    
    struct {
      __IOM uint32_t GPIO_OUT_SET : 30;         /*!< [29..0] Perform an atomic bit-set on GPIO_OUT, i.e. `GPIO_OUT
                                                     |= wdata`                                                                 */
            uint32_t            : 2;
    } bit;
  } GPIO_OUT_SET;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000018) GPIO output value clear                                    */
    
    struct {
      __IOM uint32_t GPIO_OUT_CLR : 30;         /*!< [29..0] Perform an atomic bit-clear on GPIO_OUT, i.e. `GPIO_OUT
                                                     &= ~wdata`                                                                */
            uint32_t            : 2;
    } bit;
  } GPIO_OUT_CLR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000001C) GPIO output value XOR                                      */
    
    struct {
      __IOM uint32_t GPIO_OUT_XOR : 30;         /*!< [29..0] Perform an atomic bitwise XOR on GPIO_OUT, i.e. `GPIO_OUT
                                                     ^= wdata`                                                                 */
            uint32_t            : 2;
    } bit;
  } GPIO_OUT_XOR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000020) GPIO output enable                                         */
    
    struct {
      __IOM uint32_t GPIO_OE    : 30;           /*!< [29..0] Set output enable (1/0 -> output/input) for GPIO0...29.
                                                     Reading back gives the last value written.
                                                     If core 0 and core 1 both write to GPIO_OE simultaneously
                                                     (or to a SET/CLR/XOR alias),
                                                     the result is as though the write from core 0 took place
                                                     first,
                                                     and the write from core 1 was then applied to that intermediate
                                                     result.                                                                   */
            uint32_t            : 2;
    } bit;
  } GPIO_OE;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000024) GPIO output enable set                                     */
    
    struct {
      __IOM uint32_t GPIO_OE_SET : 30;          /*!< [29..0] Perform an atomic bit-set on GPIO_OE, i.e. `GPIO_OE
                                                     |= wdata`                                                                 */
            uint32_t            : 2;
    } bit;
  } GPIO_OE_SET;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000028) GPIO output enable clear                                   */
    
    struct {
      __IOM uint32_t GPIO_OE_CLR : 30;          /*!< [29..0] Perform an atomic bit-clear on GPIO_OE, i.e. `GPIO_OE
                                                     &= ~wdata`                                                                */
            uint32_t            : 2;
    } bit;
  } GPIO_OE_CLR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000002C) GPIO output enable XOR                                     */
    
    struct {
      __IOM uint32_t GPIO_OE_XOR : 30;          /*!< [29..0] Perform an atomic bitwise XOR on GPIO_OE, i.e. `GPIO_OE
                                                     ^= wdata`                                                                 */
            uint32_t            : 2;
    } bit;
  } GPIO_OE_XOR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000030) QSPI output value                                          */
    
    struct {
      __IOM uint32_t GPIO_HI_OUT : 6;           /*!< [5..0] Set output level (1/0 -> high/low) for QSPI IO0...5.
                                                     Reading back gives the last value written, NOT the input
                                                     value from the pins.
                                                     If core 0 and core 1 both write to GPIO_HI_OUT simultaneously
                                                     (or to a SET/CLR/XOR alias),
                                                     the result is as though the write from core 0 took place
                                                     first,
                                                     and the write from core 1 was then applied to that intermediate
                                                     result.                                                                   */
            uint32_t            : 26;
    } bit;
  } GPIO_HI_OUT;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000034) QSPI output value set                                      */
    
    struct {
      __IOM uint32_t GPIO_HI_OUT_SET : 6;       /*!< [5..0] Perform an atomic bit-set on GPIO_HI_OUT, i.e. `GPIO_HI_OUT
                                                     |= wdata`                                                                 */
            uint32_t            : 26;
    } bit;
  } GPIO_HI_OUT_SET;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000038) QSPI output value clear                                    */
    
    struct {
      __IOM uint32_t GPIO_HI_OUT_CLR : 6;       /*!< [5..0] Perform an atomic bit-clear on GPIO_HI_OUT, i.e. `GPIO_HI_OUT
                                                     &= ~wdata`                                                                */
            uint32_t            : 26;
    } bit;
  } GPIO_HI_OUT_CLR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000003C) QSPI output value XOR                                      */
    
    struct {
      __IOM uint32_t GPIO_HI_OUT_XOR : 6;       /*!< [5..0] Perform an atomic bitwise XOR on GPIO_HI_OUT, i.e. `GPIO_HI_OUT
                                                     ^= wdata`                                                                 */
            uint32_t            : 26;
    } bit;
  } GPIO_HI_OUT_XOR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000040) QSPI output enable                                         */
    
    struct {
      __IOM uint32_t GPIO_HI_OE : 6;            /*!< [5..0] Set output enable (1/0 -> output/input) for QSPI IO0...5.
                                                     Reading back gives the last value written.
                                                     If core 0 and core 1 both write to GPIO_HI_OE simultaneously
                                                     (or to a SET/CLR/XOR alias),
                                                     the result is as though the write from core 0 took place
                                                     first,
                                                     and the write from core 1 was then applied to that intermediate
                                                     result.                                                                   */
            uint32_t            : 26;
    } bit;
  } GPIO_HI_OE;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000044) QSPI output enable set                                     */
    
    struct {
      __IOM uint32_t GPIO_HI_OE_SET : 6;        /*!< [5..0] Perform an atomic bit-set on GPIO_HI_OE, i.e. `GPIO_HI_OE
                                                     |= wdata`                                                                 */
            uint32_t            : 26;
    } bit;
  } GPIO_HI_OE_SET;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000048) QSPI output enable clear                                   */
    
    struct {
      __IOM uint32_t GPIO_HI_OE_CLR : 6;        /*!< [5..0] Perform an atomic bit-clear on GPIO_HI_OE, i.e. `GPIO_HI_OE
                                                     &= ~wdata`                                                                */
            uint32_t            : 26;
    } bit;
  } GPIO_HI_OE_CLR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000004C) QSPI output enable XOR                                     */
    
    struct {
      __IOM uint32_t GPIO_HI_OE_XOR : 6;        /*!< [5..0] Perform an atomic bitwise XOR on GPIO_HI_OE, i.e. `GPIO_HI_OE
                                                     ^= wdata`                                                                 */
            uint32_t            : 26;
    } bit;
  } GPIO_HI_OE_XOR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000050) Status register for inter-core FIFOs (mailboxes).
                                                                    There is one FIFO in the core 0 -> core
                                                                    1 direction, and one core 1 -> core 0. Both
                                                                    are 32 bits wide and 8 words deep.
                                                                    Core 0 can see the read side of the 1->0
                                                                    FIFO (RX), and the write side of 0->1 FIFO
                                                                    (TX).
                                                                    Core 1 can see the read side of the 0->1
                                                                    FIFO (RX), and the write side of 1->0 FIFO
                                                                    (TX).
                                                                    The SIO IRQ for each core is the logical
                                                                    OR of the VLD, WOF and ROE fields of its
                                                                    FIF                                                        */
    
    struct {
      __IM  uint32_t VLD        : 1;            /*!< [0..0] Value is 1 if this core's RX FIFO is not empty (i.e.
                                                     if FIFO_RD is valid)                                                      */
      __IM  uint32_t RDY        : 1;            /*!< [1..1] Value is 1 if this core's TX FIFO is not full (i.e. if
                                                     FIFO_WR is ready for more data)                                           */
      __IOM uint32_t WOF        : 1;            /*!< [2..2] Sticky flag indicating the TX FIFO was written when full.
                                                     This write was ignored by the FIFO.                                       */
      __IOM uint32_t ROE        : 1;            /*!< [3..3] Sticky flag indicating the RX FIFO was read when empty.
                                                     This read was ignored by the FIFO.                                        */
            uint32_t            : 28;
    } bit;
  } FIFO_ST;
  __OM  uint32_t  FIFO_WR;                      /*!< (@ 0x00000054) Write access to this core's TX FIFO                        */
  __IM  uint32_t  FIFO_RD;                      /*!< (@ 0x00000058) Read access to this core's RX FIFO                         */
  __IM  uint32_t  SPINLOCK_ST;                  /*!< (@ 0x0000005C) Spinlock state
                                                                    A bitmap containing the state of all 32
                                                                    spinlocks (1=locked).
                                                                    Mainly intended for debugging.                             */
  __IOM uint32_t  DIV_UDIVIDEND;                /*!< (@ 0x00000060) Divider unsigned dividend
                                                                    Write to the DIVIDEND operand of the divider,
                                                                    i.e. the p in `p / q`.
                                                                    Any operand write starts a new calculation.
                                                                    The results appear in QUOTIENT, REMAINDER.
                                                                    UDIVIDEND/SDIVIDEND are aliases of the same
                                                                    internal register. The U alias starts an
                                                                    unsigned calculation, and the S alias starts
                                                                    a signed calculation.                                      */
  __IOM uint32_t  DIV_UDIVISOR;                 /*!< (@ 0x00000064) Divider unsigned divisor
                                                                    Write to the DIVISOR operand of the divider,
                                                                    i.e. the q in `p / q`.
                                                                    Any operand write starts a new calculation.
                                                                    The results appear in QUOTIENT, REMAINDER.
                                                                    UDIVIDEND/SDIVIDEND are aliases of the same
                                                                    internal register. The U alias starts an
                                                                    unsigned calculation, and the S alias starts
                                                                    a signed calculation.                                      */
  __IOM uint32_t  DIV_SDIVIDEND;                /*!< (@ 0x00000068) Divider signed dividend
                                                                    The same as UDIVIDEND, but starts a signed
                                                                    calculation, rather than unsigned.                         */
  __IOM uint32_t  DIV_SDIVISOR;                 /*!< (@ 0x0000006C) Divider signed divisor
                                                                    The same as UDIVISOR, but starts a signed
                                                                    calculation, rather than unsigned.                         */
  __IOM uint32_t  DIV_QUOTIENT;                 /*!< (@ 0x00000070) Divider result quotient
                                                                    The result of `DIVIDEND / DIVISOR` (division).
                                                                    Contents undefined while CSR_READY is low.
                                                                    For signed calculations, QUOTIENT is negative
                                                                    when the signs of DIVIDEND and DIVISOR differ.
                                                                    This register can be written to directly,
                                                                    for context save/restore purposes. This
                                                                    halts any
                                                                    in-progress calculation and sets the CSR_READY
                                                                    and CSR_DIRTY flags.
                                                                    Reading from QUOTIENT clears the CSR_DIRTY
                                                                    flag, so                                                   */
  __IOM uint32_t  DIV_REMAINDER;                /*!< (@ 0x00000074) Divider result remainder
                                                                    The result of `DIVIDEND % DIVISOR` (modulo).
                                                                    Contents undefined while CSR_READY is low.
                                                                    For signed calculations, REMAINDER is negative
                                                                    only when DIVIDEND is negative.
                                                                    This register can be written to directly,
                                                                    for context save/restore purposes. This
                                                                    halts any
                                                                    in-progress calculation and sets the CSR_READY
                                                                    and CSR_DIRTY flags.                                       */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x00000078) Control and status register for divider.                   */
    
    struct {
      __IM  uint32_t READY      : 1;            /*!< [0..0] Reads as 0 when a calculation is in progress, 1 otherwise.
                                                     Writing an operand (xDIVIDEND, xDIVISOR) will immediately
                                                     start a new calculation, no
                                                     matter if one is already in progress.
                                                     Writing to a result register will immediately terminate
                                                     any in-progress calculation
                                                     and set the READY and DIRTY flags.                                        */
      __IM  uint32_t DIRTY      : 1;            /*!< [1..1] Changes to 1 when any register is written, and back to
                                                     0 when QUOTIENT is read.
                                                     Software can use this flag to make save/restore more efficient
                                                     (skip if not DIRTY).
                                                     If the flag is used in this way, it's recommended to either
                                                     read QUOTIENT only,
                                                     or REMAINDER and then QUOTIENT, to prevent data loss on
                                                     context switch.                                                           */
            uint32_t            : 30;
    } bit;
  } DIV_CSR;
  __IM  uint32_t  RESERVED1;
  __IOM uint32_t  INTERP0_ACCUM0;               /*!< (@ 0x00000080) Read/write access to accumulator 0                         */
  __IOM uint32_t  INTERP0_ACCUM1;               /*!< (@ 0x00000084) Read/write access to accumulator 1                         */
  __IOM uint32_t  INTERP0_BASE0;                /*!< (@ 0x00000088) Read/write access to BASE0 register.                       */
  __IOM uint32_t  INTERP0_BASE1;                /*!< (@ 0x0000008C) Read/write access to BASE1 register.                       */
  __IOM uint32_t  INTERP0_BASE2;                /*!< (@ 0x00000090) Read/write access to BASE2 register.                       */
  __IM  uint32_t  INTERP0_POP_LANE0;            /*!< (@ 0x00000094) Read LANE0 result, and simultaneously write lane
                                                                    results to both accumulators (POP).                        */
  __IM  uint32_t  INTERP0_POP_LANE1;            /*!< (@ 0x00000098) Read LANE1 result, and simultaneously write lane
                                                                    results to both accumulators (POP).                        */
  __IM  uint32_t  INTERP0_POP_FULL;             /*!< (@ 0x0000009C) Read FULL result, and simultaneously write lane
                                                                    results to both accumulators (POP).                        */
  __IM  uint32_t  INTERP0_PEEK_LANE0;           /*!< (@ 0x000000A0) Read LANE0 result, without altering any internal
                                                                    state (PEEK).                                              */
  __IM  uint32_t  INTERP0_PEEK_LANE1;           /*!< (@ 0x000000A4) Read LANE1 result, without altering any internal
                                                                    state (PEEK).                                              */
  __IM  uint32_t  INTERP0_PEEK_FULL;            /*!< (@ 0x000000A8) Read FULL result, without altering any internal
                                                                    state (PEEK).                                              */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000AC) Control register for lane 0                                */
    
    struct {
      __IOM uint32_t SHIFT      : 5;            /*!< [4..0] Logical right-shift applied to accumulator before masking          */
      __IOM uint32_t MASK_LSB   : 5;            /*!< [9..5] The least-significant bit allowed to pass by the mask
                                                     (inclusive)                                                               */
      __IOM uint32_t MASK_MSB   : 5;            /*!< [14..10] The most-significant bit allowed to pass by the mask
                                                     (inclusive)
                                                     Setting MSB < LSB may cause chip to turn inside-out                       */
      __IOM uint32_t SIGNED     : 1;            /*!< [15..15] If SIGNED is set, the shifted and masked accumulator
                                                     value is sign-extended to 32 bits
                                                     before adding to BASE0, and LANE0 PEEK/POP appear extended
                                                     to 32 bits when read by processor.                                        */
      __IOM uint32_t CROSS_INPUT : 1;           /*!< [16..16] If 1, feed the opposite lane's accumulator into this
                                                     lane's shift + mask hardware.
                                                     Takes effect even if ADD_RAW is set (the CROSS_INPUT mux
                                                     is before the shift+mask bypass)                                          */
      __IOM uint32_t CROSS_RESULT : 1;          /*!< [17..17] If 1, feed the opposite lane's result into this lane's
                                                     accumulator on POP.                                                       */
      __IOM uint32_t ADD_RAW    : 1;            /*!< [18..18] If 1, mask + shift is bypassed for LANE0 result. This
                                                     does not affect FULL result.                                              */
      __IOM uint32_t FORCE_MSB  : 2;            /*!< [20..19] ORed into bits 29:28 of the lane result presented to
                                                     the processor on the bus.
                                                     No effect on the internal 32-bit datapath. Handy for using
                                                     a lane to generate sequence
                                                     of pointers into flash or SRAM.                                           */
      __IOM uint32_t BLEND      : 1;            /*!< [21..21] Only present on INTERP0 on each core. If BLEND mode
                                                     is enabled:
                                                     - LANE1 result is a linear interpolation between BASE0
                                                     and BASE1, controlled
                                                     by the 8 LSBs of lane 1 shift and mask value (a fractional
                                                     number between
                                                     0 and 255/256ths)
                                                     - LANE0 result does not have BASE0 added (yields only the
                                                     8 LSBs of lane 1 shift+mask value)
                                                     - FULL result does not have lane 1 shift+mask value added
                                                     (BASE2 + lane 0 shift+mask)
                                                                                                                               */
            uint32_t            : 1;
      __IM  uint32_t OVERF0     : 1;            /*!< [23..23] Indicates if any masked-off MSBs in ACCUM0 are set.              */
      __IM  uint32_t OVERF1     : 1;            /*!< [24..24] Indicates if any masked-off MSBs in ACCUM1 are set.              */
      __IM  uint32_t OVERF      : 1;            /*!< [25..25] Set if either OVERF0 or OVERF1 is set.                           */
            uint32_t            : 6;
    } bit;
  } INTERP0_CTRL_LANE0;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000B0) Control register for lane 1                                */
    
    struct {
      __IOM uint32_t SHIFT      : 5;            /*!< [4..0] Logical right-shift applied to accumulator before masking          */
      __IOM uint32_t MASK_LSB   : 5;            /*!< [9..5] The least-significant bit allowed to pass by the mask
                                                     (inclusive)                                                               */
      __IOM uint32_t MASK_MSB   : 5;            /*!< [14..10] The most-significant bit allowed to pass by the mask
                                                     (inclusive)
                                                     Setting MSB < LSB may cause chip to turn inside-out                       */
      __IOM uint32_t SIGNED     : 1;            /*!< [15..15] If SIGNED is set, the shifted and masked accumulator
                                                     value is sign-extended to 32 bits
                                                     before adding to BASE1, and LANE1 PEEK/POP appear extended
                                                     to 32 bits when read by processor.                                        */
      __IOM uint32_t CROSS_INPUT : 1;           /*!< [16..16] If 1, feed the opposite lane's accumulator into this
                                                     lane's shift + mask hardware.
                                                     Takes effect even if ADD_RAW is set (the CROSS_INPUT mux
                                                     is before the shift+mask bypass)                                          */
      __IOM uint32_t CROSS_RESULT : 1;          /*!< [17..17] If 1, feed the opposite lane's result into this lane's
                                                     accumulator on POP.                                                       */
      __IOM uint32_t ADD_RAW    : 1;            /*!< [18..18] If 1, mask + shift is bypassed for LANE1 result. This
                                                     does not affect FULL result.                                              */
      __IOM uint32_t FORCE_MSB  : 2;            /*!< [20..19] ORed into bits 29:28 of the lane result presented to
                                                     the processor on the bus.
                                                     No effect on the internal 32-bit datapath. Handy for using
                                                     a lane to generate sequence
                                                     of pointers into flash or SRAM.                                           */
            uint32_t            : 11;
    } bit;
  } INTERP0_CTRL_LANE1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000B4) Values written here are atomically added to ACCUM0
                                                                    Reading yields lane 0's raw shift and mask
                                                                    value (BASE0 not added).                                   */
    
    struct {
      __IOM uint32_t INTERP0_ACCUM0_ADD : 24;   /*!< [23..0] INTERP0_ACCUM0_ADD                                                */
            uint32_t            : 8;
    } bit;
  } INTERP0_ACCUM0_ADD;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000B8) Values written here are atomically added to ACCUM1
                                                                    Reading yields lane 1's raw shift and mask
                                                                    value (BASE1 not added).                                   */
    
    struct {
      __IOM uint32_t INTERP0_ACCUM1_ADD : 24;   /*!< [23..0] INTERP0_ACCUM1_ADD                                                */
            uint32_t            : 8;
    } bit;
  } INTERP0_ACCUM1_ADD;
  __IOM uint32_t  INTERP0_BASE_1AND0;           /*!< (@ 0x000000BC) On write, the lower 16 bits go to BASE0, upper
                                                                    bits to BASE1 simultaneously.
                                                                    Each half is sign-extended to 32 bits if
                                                                    that lane's SIGNED flag is set.                            */
  __IOM uint32_t  INTERP1_ACCUM0;               /*!< (@ 0x000000C0) Read/write access to accumulator 0                         */
  __IOM uint32_t  INTERP1_ACCUM1;               /*!< (@ 0x000000C4) Read/write access to accumulator 1                         */
  __IOM uint32_t  INTERP1_BASE0;                /*!< (@ 0x000000C8) Read/write access to BASE0 register.                       */
  __IOM uint32_t  INTERP1_BASE1;                /*!< (@ 0x000000CC) Read/write access to BASE1 register.                       */
  __IOM uint32_t  INTERP1_BASE2;                /*!< (@ 0x000000D0) Read/write access to BASE2 register.                       */
  __IM  uint32_t  INTERP1_POP_LANE0;            /*!< (@ 0x000000D4) Read LANE0 result, and simultaneously write lane
                                                                    results to both accumulators (POP).                        */
  __IM  uint32_t  INTERP1_POP_LANE1;            /*!< (@ 0x000000D8) Read LANE1 result, and simultaneously write lane
                                                                    results to both accumulators (POP).                        */
  __IM  uint32_t  INTERP1_POP_FULL;             /*!< (@ 0x000000DC) Read FULL result, and simultaneously write lane
                                                                    results to both accumulators (POP).                        */
  __IM  uint32_t  INTERP1_PEEK_LANE0;           /*!< (@ 0x000000E0) Read LANE0 result, without altering any internal
                                                                    state (PEEK).                                              */
  __IM  uint32_t  INTERP1_PEEK_LANE1;           /*!< (@ 0x000000E4) Read LANE1 result, without altering any internal
                                                                    state (PEEK).                                              */
  __IM  uint32_t  INTERP1_PEEK_FULL;            /*!< (@ 0x000000E8) Read FULL result, without altering any internal
                                                                    state (PEEK).                                              */
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000EC) Control register for lane 0                                */
    
    struct {
      __IOM uint32_t SHIFT      : 5;            /*!< [4..0] Logical right-shift applied to accumulator before masking          */
      __IOM uint32_t MASK_LSB   : 5;            /*!< [9..5] The least-significant bit allowed to pass by the mask
                                                     (inclusive)                                                               */
      __IOM uint32_t MASK_MSB   : 5;            /*!< [14..10] The most-significant bit allowed to pass by the mask
                                                     (inclusive)
                                                     Setting MSB < LSB may cause chip to turn inside-out                       */
      __IOM uint32_t SIGNED     : 1;            /*!< [15..15] If SIGNED is set, the shifted and masked accumulator
                                                     value is sign-extended to 32 bits
                                                     before adding to BASE0, and LANE0 PEEK/POP appear extended
                                                     to 32 bits when read by processor.                                        */
      __IOM uint32_t CROSS_INPUT : 1;           /*!< [16..16] If 1, feed the opposite lane's accumulator into this
                                                     lane's shift + mask hardware.
                                                     Takes effect even if ADD_RAW is set (the CROSS_INPUT mux
                                                     is before the shift+mask bypass)                                          */
      __IOM uint32_t CROSS_RESULT : 1;          /*!< [17..17] If 1, feed the opposite lane's result into this lane's
                                                     accumulator on POP.                                                       */
      __IOM uint32_t ADD_RAW    : 1;            /*!< [18..18] If 1, mask + shift is bypassed for LANE0 result. This
                                                     does not affect FULL result.                                              */
      __IOM uint32_t FORCE_MSB  : 2;            /*!< [20..19] ORed into bits 29:28 of the lane result presented to
                                                     the processor on the bus.
                                                     No effect on the internal 32-bit datapath. Handy for using
                                                     a lane to generate sequence
                                                     of pointers into flash or SRAM.                                           */
            uint32_t            : 1;
      __IOM uint32_t CLAMP      : 1;            /*!< [22..22] Only present on INTERP1 on each core. If CLAMP mode
                                                     is enabled:
                                                     - LANE0 result is shifted and masked ACCUM0, clamped by
                                                     a lower bound of
                                                     BASE0 and an upper bound of BASE1.
                                                     - Signedness of these comparisons is determined by LANE0_CTRL_SIGNED      */
      __IM  uint32_t OVERF0     : 1;            /*!< [23..23] Indicates if any masked-off MSBs in ACCUM0 are set.              */
      __IM  uint32_t OVERF1     : 1;            /*!< [24..24] Indicates if any masked-off MSBs in ACCUM1 are set.              */
      __IM  uint32_t OVERF      : 1;            /*!< [25..25] Set if either OVERF0 or OVERF1 is set.                           */
            uint32_t            : 6;
    } bit;
  } INTERP1_CTRL_LANE0;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000F0) Control register for lane 1                                */
    
    struct {
      __IOM uint32_t SHIFT      : 5;            /*!< [4..0] Logical right-shift applied to accumulator before masking          */
      __IOM uint32_t MASK_LSB   : 5;            /*!< [9..5] The least-significant bit allowed to pass by the mask
                                                     (inclusive)                                                               */
      __IOM uint32_t MASK_MSB   : 5;            /*!< [14..10] The most-significant bit allowed to pass by the mask
                                                     (inclusive)
                                                     Setting MSB < LSB may cause chip to turn inside-out                       */
      __IOM uint32_t SIGNED     : 1;            /*!< [15..15] If SIGNED is set, the shifted and masked accumulator
                                                     value is sign-extended to 32 bits
                                                     before adding to BASE1, and LANE1 PEEK/POP appear extended
                                                     to 32 bits when read by processor.                                        */
      __IOM uint32_t CROSS_INPUT : 1;           /*!< [16..16] If 1, feed the opposite lane's accumulator into this
                                                     lane's shift + mask hardware.
                                                     Takes effect even if ADD_RAW is set (the CROSS_INPUT mux
                                                     is before the shift+mask bypass)                                          */
      __IOM uint32_t CROSS_RESULT : 1;          /*!< [17..17] If 1, feed the opposite lane's result into this lane's
                                                     accumulator on POP.                                                       */
      __IOM uint32_t ADD_RAW    : 1;            /*!< [18..18] If 1, mask + shift is bypassed for LANE1 result. This
                                                     does not affect FULL result.                                              */
      __IOM uint32_t FORCE_MSB  : 2;            /*!< [20..19] ORed into bits 29:28 of the lane result presented to
                                                     the processor on the bus.
                                                     No effect on the internal 32-bit datapath. Handy for using
                                                     a lane to generate sequence
                                                     of pointers into flash or SRAM.                                           */
            uint32_t            : 11;
    } bit;
  } INTERP1_CTRL_LANE1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000F4) Values written here are atomically added to ACCUM0
                                                                    Reading yields lane 0's raw shift and mask
                                                                    value (BASE0 not added).                                   */
    
    struct {
      __IOM uint32_t INTERP1_ACCUM0_ADD : 24;   /*!< [23..0] INTERP1_ACCUM0_ADD                                                */
            uint32_t            : 8;
    } bit;
  } INTERP1_ACCUM0_ADD;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x000000F8) Values written here are atomically added to ACCUM1
                                                                    Reading yields lane 1's raw shift and mask
                                                                    value (BASE1 not added).                                   */
    
    struct {
      __IOM uint32_t INTERP1_ACCUM1_ADD : 24;   /*!< [23..0] INTERP1_ACCUM1_ADD                                                */
            uint32_t            : 8;
    } bit;
  } INTERP1_ACCUM1_ADD;
  __IOM uint32_t  INTERP1_BASE_1AND0;           /*!< (@ 0x000000FC) On write, the lower 16 bits go to BASE0, upper
                                                                    bits to BASE1 simultaneously.
                                                                    Each half is sign-extended to 32 bits if
                                                                    that lane's SIGNED flag is set.                            */
  __IM  uint32_t  SPINLOCK0;                    /*!< (@ 0x00000100) Reading from a spinlock address will:
                                                                    - Return 0 if lock is already locked
                                                                    - Otherwise return nonzero, and simultaneously
                                                                    claim the lock
                                                                    
                                                                    Writing (any value) releases the lock.
                                                                    If core 0 and core 1 attempt to claim the
                                                                    same lock simultaneously, core 0 wins.
                                                                    The value returned on success is 0x1 <<
                                                                    lock number.                                               */
  __IM  uint32_t  SPINLOCK1;                    /*!< (@ 0x00000104) Reading from a spinlock address will:
                                                                    - Return 0 if lock is already locked
                                                                    - Otherwise return nonzero, and simultaneously
                                                                    claim the lock
                                                                    
                                                                    Writing (any value) releases the lock.
                                                                    If core 0 and core 1 attempt to claim the
                                                                    same lock simultaneously, core 0 wins.
                                                                    The value returned on success is 0x1 <<
                                                                    lock number.                                               */
  __IM  uint32_t  SPINLOCK2;                    /*!< (@ 0x00000108) Reading from a spinlock address will:
                                                                    - Return 0 if lock is already locked
                                                                    - Otherwise return nonzero, and simultaneously
                                                                    claim the lock
                                                                    
                                                                    Writing (any value) releases the lock.
                                                                    If core 0 and core 1 attempt to claim the
                                                                    same lock simultaneously, core 0 wins.
                                                                    The value returned on success is 0x1 <<
                                                                    lock number.                                               */
  __IM  uint32_t  SPINLOCK3;                    /*!< (@ 0x0000010C) Reading from a spinlock address will:
                                                                    - Return 0 if lock is already locked
                                                                    - Otherwise return nonzero, and simultaneously
                                                                    claim the lock
                                                                    
                                                                    Writing (any value) releases the lock.
                                                                    If core 0 and core 1 attempt to claim the
                                                                    same lock simultaneously, core 0 wins.
                                                                    The value returned on success is 0x1 <<
                                                                    lock number.                                               */
  __IM  uint32_t  SPINLOCK4;                    /*!< (@ 0x00000110) Reading from a spinlock address will:
                                                                    - Return 0 if lock is already locked
                                                                    - Otherwise return nonzero, and simultaneously
                                                                    claim the lock
                                                                    
                                                                    Writing (any value) releases the lock.
                                                                    If core 0 and core 1 attempt to claim the
                                                                    same lock simultaneously, core 0 wins.
                                                                    The value returned on success is 0x1 <<
                                                                    lock number.                                               */
  __IM  uint32_t  SPINLOCK5;                    /*!< (@ 0x00000114) Reading from a spinlock address will:
                                                                    - Return 0 if lock is already locked
                                                                    - Otherwise return nonzero, and simultaneously
                                                                    claim the lock
                                                                    
                                                                    Writing (any value) releases the lock.
                                                                    If core 0 and core 1 attempt to claim the
                                                                    same lock simultaneously, core 0 wins.
                                                                    The value returned on success is 0x1 <<
                                                                    lock number.                                               */
  __IM  uint32_t  SPINLOCK6;                    /*!< (@ 0x00000118) Reading from a spinlock address will:
                                                                    - Return 0 if lock is already locked
                                                                    - Otherwise return nonzero, and simultaneously
                                                                    claim the lock
                                                                    
                                                                    Writing (any value) releases the lock.
                                                                    If core 0 and core 1 attempt to claim the
                                                                    same lock simultaneously, core 0 wins.
                                                                    The value returned on success is 0x1 <<
                                                                    lock number.                                               */
  __IM  uint32_t  SPINLOCK7;                    /*!< (@ 0x0000011C) Reading from a spinlock address will:
                                                                    - Return 0 if lock is already locked
                                                                    - Otherwise return nonzero, and simultaneously
                                                                    claim the lock
                                                                    
                                                                    Writing (any value) releases the lock.
                                                                    If core 0 and core 1 attempt to claim the
                                                                    same lock simultaneously, core 0 wins.
                                                                    The value returned on success is 0x1 <<
                                                                    lock number.                                               */
  __IM  uint32_t  SPINLOCK8;                    /*!< (@ 0x00000120) Reading from a spinlock address will:
                                                                    - Return 0 if lock is already locked
                                                                    - Otherwise return nonzero, and simultaneously
                                                                    claim the lock
                                                                    
                                                                    Writing (any value) releases the lock.
                                                                    If core 0 and core 1 attempt to claim the
                                                                    same lock simultaneously, core 0 wins.
                                                                    The value returned on success is 0x1 <<
                                                                    lock number.                                               */
  __IM  uint32_t  SPINLOCK9;                    /*!< (@ 0x00000124) Reading from a spinlock address will:
                                                                    - Return 0 if lock is already locked
                                                                    - Otherwise return nonzero, and simultaneously
                                                                    claim the lock
                                                                    
                                                                    Writing (any value) releases the lock.
                                                                    If core 0 and core 1 attempt to claim the
                                                                    same lock simultaneously, core 0 wins.
                                                                    The value returned on success is 0x1 <<
                                                                    lock number.                                               */
  __IM  uint32_t  SPINLOCK10;                   /*!< (@ 0x00000128) Reading from a spinlock address will:
                                                                    - Return 0 if lock is already locked
                                                                    - Otherwise return nonzero, and simultaneously
                                                                    claim the lock
                                                                    
                                                                    Writing (any value) releases the lock.
                                                                    If core 0 and core 1 attempt to claim the
                                                                    same lock simultaneously, core 0 wins.
                                                                    The value returned on success is 0x1 <<
                                                                    lock number.                                               */
  __IM  uint32_t  SPINLOCK11;                   /*!< (@ 0x0000012C) Reading from a spinlock address will:
                                                                    - Return 0 if lock is already locked
                                                                    - Otherwise return nonzero, and simultaneously
                                                                    claim the lock
                                                                    
                                                                    Writing (any value) releases the lock.
                                                                    If core 0 and core 1 attempt to claim the
                                                                    same lock simultaneously, core 0 wins.
                                                                    The value returned on success is 0x1 <<
                                                                    lock number.                                               */
  __IM  uint32_t  SPINLOCK12;                   /*!< (@ 0x00000130) Reading from a spinlock address will:
                                                                    - Return 0 if lock is already locked
                                                                    - Otherwise return nonzero, and simultaneously
                                                                    claim the lock
                                                                    
                                                                    Writing (any value) releases the lock.
                                                                    If core 0 and core 1 attempt to claim the
                                                                    same lock simultaneously, core 0 wins.
                                                                    The value returned on success is 0x1 <<
                                                                    lock number.                                               */
  __IM  uint32_t  SPINLOCK13;                   /*!< (@ 0x00000134) Reading from a spinlock address will:
                                                                    - Return 0 if lock is already locked
                                                                    - Otherwise return nonzero, and simultaneously
                                                                    claim the lock
                                                                    
                                                                    Writing (any value) releases the lock.
                                                                    If core 0 and core 1 attempt to claim the
                                                                    same lock simultaneously, core 0 wins.
                                                                    The value returned on success is 0x1 <<
                                                                    lock number.                                               */
  __IM  uint32_t  SPINLOCK14;                   /*!< (@ 0x00000138) Reading from a spinlock address will:
                                                                    - Return 0 if lock is already locked
                                                                    - Otherwise return nonzero, and simultaneously
                                                                    claim the lock
                                                                    
                                                                    Writing (any value) releases the lock.
                                                                    If core 0 and core 1 attempt to claim the
                                                                    same lock simultaneously, core 0 wins.
                                                                    The value returned on success is 0x1 <<
                                                                    lock number.                                               */
  __IM  uint32_t  SPINLOCK15;                   /*!< (@ 0x0000013C) Reading from a spinlock address will:
                                                                    - Return 0 if lock is already locked
                                                                    - Otherwise return nonzero, and simultaneously
                                                                    claim the lock
                                                                    
                                                                    Writing (any value) releases the lock.
                                                                    If core 0 and core 1 attempt to claim the
                                                                    same lock simultaneously, core 0 wins.
                                                                    The value returned on success is 0x1 <<
                                                                    lock number.                                               */
  __IM  uint32_t  SPINLOCK16;                   /*!< (@ 0x00000140) Reading from a spinlock address will:
                                                                    - Return 0 if lock is already locked
                                                                    - Otherwise return nonzero, and simultaneously
                                                                    claim the lock
                                                                    
                                                                    Writing (any value) releases the lock.
                                                                    If core 0 and core 1 attempt to claim the
                                                                    same lock simultaneously, core 0 wins.
                                                                    The value returned on success is 0x1 <<
                                                                    lock number.                                               */
  __IM  uint32_t  SPINLOCK17;                   /*!< (@ 0x00000144) Reading from a spinlock address will:
                                                                    - Return 0 if lock is already locked
                                                                    - Otherwise return nonzero, and simultaneously
                                                                    claim the lock
                                                                    
                                                                    Writing (any value) releases the lock.
                                                                    If core 0 and core 1 attempt to claim the
                                                                    same lock simultaneously, core 0 wins.
                                                                    The value returned on success is 0x1 <<
                                                                    lock number.                                               */
  __IM  uint32_t  SPINLOCK18;                   /*!< (@ 0x00000148) Reading from a spinlock address will:
                                                                    - Return 0 if lock is already locked
                                                                    - Otherwise return nonzero, and simultaneously
                                                                    claim the lock
                                                                    
                                                                    Writing (any value) releases the lock.
                                                                    If core 0 and core 1 attempt to claim the
                                                                    same lock simultaneously, core 0 wins.
                                                                    The value returned on success is 0x1 <<
                                                                    lock number.                                               */
  __IM  uint32_t  SPINLOCK19;                   /*!< (@ 0x0000014C) Reading from a spinlock address will:
                                                                    - Return 0 if lock is already locked
                                                                    - Otherwise return nonzero, and simultaneously
                                                                    claim the lock
                                                                    
                                                                    Writing (any value) releases the lock.
                                                                    If core 0 and core 1 attempt to claim the
                                                                    same lock simultaneously, core 0 wins.
                                                                    The value returned on success is 0x1 <<
                                                                    lock number.                                               */
  __IM  uint32_t  SPINLOCK20;                   /*!< (@ 0x00000150) Reading from a spinlock address will:
                                                                    - Return 0 if lock is already locked
                                                                    - Otherwise return nonzero, and simultaneously
                                                                    claim the lock
                                                                    
                                                                    Writing (any value) releases the lock.
                                                                    If core 0 and core 1 attempt to claim the
                                                                    same lock simultaneously, core 0 wins.
                                                                    The value returned on success is 0x1 <<
                                                                    lock number.                                               */
  __IM  uint32_t  SPINLOCK21;                   /*!< (@ 0x00000154) Reading from a spinlock address will:
                                                                    - Return 0 if lock is already locked
                                                                    - Otherwise return nonzero, and simultaneously
                                                                    claim the lock
                                                                    
                                                                    Writing (any value) releases the lock.
                                                                    If core 0 and core 1 attempt to claim the
                                                                    same lock simultaneously, core 0 wins.
                                                                    The value returned on success is 0x1 <<
                                                                    lock number.                                               */
  __IM  uint32_t  SPINLOCK22;                   /*!< (@ 0x00000158) Reading from a spinlock address will:
                                                                    - Return 0 if lock is already locked
                                                                    - Otherwise return nonzero, and simultaneously
                                                                    claim the lock
                                                                    
                                                                    Writing (any value) releases the lock.
                                                                    If core 0 and core 1 attempt to claim the
                                                                    same lock simultaneously, core 0 wins.
                                                                    The value returned on success is 0x1 <<
                                                                    lock number.                                               */
  __IM  uint32_t  SPINLOCK23;                   /*!< (@ 0x0000015C) Reading from a spinlock address will:
                                                                    - Return 0 if lock is already locked
                                                                    - Otherwise return nonzero, and simultaneously
                                                                    claim the lock
                                                                    
                                                                    Writing (any value) releases the lock.
                                                                    If core 0 and core 1 attempt to claim the
                                                                    same lock simultaneously, core 0 wins.
                                                                    The value returned on success is 0x1 <<
                                                                    lock number.                                               */
  __IM  uint32_t  SPINLOCK24;                   /*!< (@ 0x00000160) Reading from a spinlock address will:
                                                                    - Return 0 if lock is already locked
                                                                    - Otherwise return nonzero, and simultaneously
                                                                    claim the lock
                                                                    
                                                                    Writing (any value) releases the lock.
                                                                    If core 0 and core 1 attempt to claim the
                                                                    same lock simultaneously, core 0 wins.
                                                                    The value returned on success is 0x1 <<
                                                                    lock number.                                               */
  __IM  uint32_t  SPINLOCK25;                   /*!< (@ 0x00000164) Reading from a spinlock address will:
                                                                    - Return 0 if lock is already locked
                                                                    - Otherwise return nonzero, and simultaneously
                                                                    claim the lock
                                                                    
                                                                    Writing (any value) releases the lock.
                                                                    If core 0 and core 1 attempt to claim the
                                                                    same lock simultaneously, core 0 wins.
                                                                    The value returned on success is 0x1 <<
                                                                    lock number.                                               */
  __IM  uint32_t  SPINLOCK26;                   /*!< (@ 0x00000168) Reading from a spinlock address will:
                                                                    - Return 0 if lock is already locked
                                                                    - Otherwise return nonzero, and simultaneously
                                                                    claim the lock
                                                                    
                                                                    Writing (any value) releases the lock.
                                                                    If core 0 and core 1 attempt to claim the
                                                                    same lock simultaneously, core 0 wins.
                                                                    The value returned on success is 0x1 <<
                                                                    lock number.                                               */
  __IM  uint32_t  SPINLOCK27;                   /*!< (@ 0x0000016C) Reading from a spinlock address will:
                                                                    - Return 0 if lock is already locked
                                                                    - Otherwise return nonzero, and simultaneously
                                                                    claim the lock
                                                                    
                                                                    Writing (any value) releases the lock.
                                                                    If core 0 and core 1 attempt to claim the
                                                                    same lock simultaneously, core 0 wins.
                                                                    The value returned on success is 0x1 <<
                                                                    lock number.                                               */
  __IM  uint32_t  SPINLOCK28;                   /*!< (@ 0x00000170) Reading from a spinlock address will:
                                                                    - Return 0 if lock is already locked
                                                                    - Otherwise return nonzero, and simultaneously
                                                                    claim the lock
                                                                    
                                                                    Writing (any value) releases the lock.
                                                                    If core 0 and core 1 attempt to claim the
                                                                    same lock simultaneously, core 0 wins.
                                                                    The value returned on success is 0x1 <<
                                                                    lock number.                                               */
  __IM  uint32_t  SPINLOCK29;                   /*!< (@ 0x00000174) Reading from a spinlock address will:
                                                                    - Return 0 if lock is already locked
                                                                    - Otherwise return nonzero, and simultaneously
                                                                    claim the lock
                                                                    
                                                                    Writing (any value) releases the lock.
                                                                    If core 0 and core 1 attempt to claim the
                                                                    same lock simultaneously, core 0 wins.
                                                                    The value returned on success is 0x1 <<
                                                                    lock number.                                               */
  __IM  uint32_t  SPINLOCK30;                   /*!< (@ 0x00000178) Reading from a spinlock address will:
                                                                    - Return 0 if lock is already locked
                                                                    - Otherwise return nonzero, and simultaneously
                                                                    claim the lock
                                                                    
                                                                    Writing (any value) releases the lock.
                                                                    If core 0 and core 1 attempt to claim the
                                                                    same lock simultaneously, core 0 wins.
                                                                    The value returned on success is 0x1 <<
                                                                    lock number.                                               */
  __IM  uint32_t  SPINLOCK31;                   /*!< (@ 0x0000017C) Reading from a spinlock address will:
                                                                    - Return 0 if lock is already locked
                                                                    - Otherwise return nonzero, and simultaneously
                                                                    claim the lock
                                                                    
                                                                    Writing (any value) releases the lock.
                                                                    If core 0 and core 1 attempt to claim the
                                                                    same lock simultaneously, core 0 wins.
                                                                    The value returned on success is 0x1 <<
                                                                    lock number.                                               */
} SIO_Type;                                     /*!< Size = 384 (0x180)                                                        */



/* =========================================================================================================================== */
/* ================                                            PPB                                            ================ */
/* =========================================================================================================================== */


/**
  * @brief PPB (PPB)
  */

typedef struct {                                /*!< (@ 0xE0000000) PPB Structure                                              */
  __IM  uint32_t  RESERVED[14340];
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000E010) Use the SysTick Control and Status Register to
                                                                    enable the SysTick features.                               */
    
    struct {
      __IOM uint32_t ENABLE     : 1;            /*!< [0..0] Enable SysTick counter:
                                                     0 = Counter disabled.
                                                     1 = Counter enabled.                                                      */
      __IOM uint32_t TICKINT    : 1;            /*!< [1..1] Enables SysTick exception request:
                                                     0 = Counting down to zero does not assert the SysTick exception
                                                     request.
                                                     1 = Counting down to zero to asserts the SysTick exception
                                                     request.                                                                  */
      __IOM uint32_t CLKSOURCE  : 1;            /*!< [2..2] SysTick clock source. Always reads as one if SYST_CALIB
                                                     reports NOREF.
                                                     Selects the SysTick timer clock source:
                                                     0 = External reference clock.
                                                     1 = Processor clock.                                                      */
            uint32_t            : 13;
      __IM  uint32_t COUNTFLAG  : 1;            /*!< [16..16] Returns 1 if timer counted to 0 since last time this
                                                     was read. Clears on read by application or debugger.                      */
            uint32_t            : 15;
    } bit;
  } SYST_CSR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000E014) Use the SysTick Reload Value Register to specify
                                                                    the start value to load into the current
                                                                    value register when the counter reaches
                                                                    0. It can be any value between 0 and 0x00FFFFFF.
                                                                    A start value of 0 is possible, but has
                                                                    no effect because the SysTick interrupt
                                                                    and COUNTFLAG are activated when counting
                                                                    from 1 to 0. The reset value of this register
                                                                    is UNKNOWN.
                                                                    To generate a multi-shot timer with a period
                                                                    of N processor clock cycles, use a RELOAD
                                                                    value of N-1. For example, if the                          */
    
    struct {
      __IOM uint32_t RELOAD     : 24;           /*!< [23..0] Value to load into the SysTick Current Value Register
                                                     when the counter reaches 0.                                               */
            uint32_t            : 8;
    } bit;
  } SYST_RVR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000E018) Use the SysTick Current Value Register to find
                                                                    the current value in the register. The reset
                                                                    value of this register is UNKNOWN.                         */
    
    struct {
      __IOM uint32_t CURRENT    : 24;           /*!< [23..0] Reads return the current value of the SysTick counter.
                                                     This register is write-clear. Writing to it with any value
                                                     clears the register to 0. Clearing this register also clears
                                                     the COUNTFLAG bit of the SysTick Control and Status Register.             */
            uint32_t            : 8;
    } bit;
  } SYST_CVR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000E01C) Use the SysTick Calibration Value Register to
                                                                    enable software to scale to any required
                                                                    speed using divide and multiply.                           */
    
    struct {
      __IM  uint32_t TENMS      : 24;           /*!< [23..0] An optional Reload value to be used for 10ms (100Hz)
                                                     timing, subject to system clock skew errors. If the value
                                                     reads as 0, the calibration value is not known.                           */
            uint32_t            : 6;
      __IM  uint32_t SKEW       : 1;            /*!< [30..30] If reads as 1, the calibration value for 10ms is inexact
                                                     (due to clock frequency).                                                 */
      __IM  uint32_t NOREF      : 1;            /*!< [31..31] If reads as 1, the Reference clock is not provided
                                                     - the CLKSOURCE bit of the SysTick Control and Status register
                                                     will be forced to 1 and cannot be cleared to 0.                           */
    } bit;
  } SYST_CALIB;
  __IM  uint32_t  RESERVED1[56];
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000E100) Use the Interrupt Set-Enable Register to enable
                                                                    interrupts and determine which interrupts
                                                                    are currently enabled.
                                                                    If a pending interrupt is enabled, the NVIC
                                                                    activates the interrupt based on its priority.
                                                                    If an interrupt is not enabled, asserting
                                                                    its interrupt signal changes the interrupt
                                                                    state to pending, but the NVIC never activates
                                                                    the interrupt, regardless of its priority.                 */
    
    struct {
      __IOM uint32_t SETENA     : 32;           /*!< [31..0] Interrupt set-enable bits.
                                                     Write:
                                                     0 = No effect.
                                                     1 = Enable interrupt.
                                                     Read:
                                                     0 = Interrupt disabled.
                                                     1 = Interrupt enabled.                                                    */
    } bit;
  } NVIC_ISER;
  __IM  uint32_t  RESERVED2[31];
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000E180) Use the Interrupt Clear-Enable Registers to disable
                                                                    interrupts and determine which interrupts
                                                                    are currently enabled.                                     */
    
    struct {
      __IOM uint32_t CLRENA     : 32;           /*!< [31..0] Interrupt clear-enable bits.
                                                     Write:
                                                     0 = No effect.
                                                     1 = Disable interrupt.
                                                     Read:
                                                     0 = Interrupt disabled.
                                                     1 = Interrupt enabled.                                                    */
    } bit;
  } NVIC_ICER;
  __IM  uint32_t  RESERVED3[31];
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000E200) The NVIC_ISPR forces interrupts into the pending
                                                                    state, and shows which interrupts are pending.             */
    
    struct {
      __IOM uint32_t SETPEND    : 32;           /*!< [31..0] Interrupt set-pending bits.
                                                     Write:
                                                     0 = No effect.
                                                     1 = Changes interrupt state to pending.
                                                     Read:
                                                     0 = Interrupt is not pending.
                                                     1 = Interrupt is pending.
                                                     Note: Writing 1 to the NVIC_ISPR bit corresponding to:
                                                     An interrupt that is pending has no effect.
                                                     A disabled interrupt sets the state of that interrupt to
                                                     pending.                                                                  */
    } bit;
  } NVIC_ISPR;
  __IM  uint32_t  RESERVED4[31];
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000E280) Use the Interrupt Clear-Pending Register to clear
                                                                    pending interrupts and determine which interrupts
                                                                    are currently pending.                                     */
    
    struct {
      __IOM uint32_t CLRPEND    : 32;           /*!< [31..0] Interrupt clear-pending bits.
                                                     Write:
                                                     0 = No effect.
                                                     1 = Removes pending state and interrupt.
                                                     Read:
                                                     0 = Interrupt is not pending.
                                                     1 = Interrupt is pending.                                                 */
    } bit;
  } NVIC_ICPR;
  __IM  uint32_t  RESERVED5[95];
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000E400) Use the Interrupt Priority Registers to assign
                                                                    a priority from 0 to 3 to each of the available
                                                                    interrupts. 0 is the highest priority, and
                                                                    3 is the lowest.
                                                                    Note: Writing 1 to an NVIC_ICPR bit does
                                                                    not affect the active state of the corresponding
                                                                    interrupt.
                                                                    These registers are only word-accessible                   */
    
    struct {
            uint32_t            : 6;
      __IOM uint32_t IP_0       : 2;            /*!< [7..6] Priority of interrupt 0                                            */
            uint32_t            : 6;
      __IOM uint32_t IP_1       : 2;            /*!< [15..14] Priority of interrupt 1                                          */
            uint32_t            : 6;
      __IOM uint32_t IP_2       : 2;            /*!< [23..22] Priority of interrupt 2                                          */
            uint32_t            : 6;
      __IOM uint32_t IP_3       : 2;            /*!< [31..30] Priority of interrupt 3                                          */
    } bit;
  } NVIC_IPR0;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000E404) Use the Interrupt Priority Registers to assign
                                                                    a priority from 0 to 3 to each of the available
                                                                    interrupts. 0 is the highest priority, and
                                                                    3 is the lowest.                                           */
    
    struct {
            uint32_t            : 6;
      __IOM uint32_t IP_4       : 2;            /*!< [7..6] Priority of interrupt 4                                            */
            uint32_t            : 6;
      __IOM uint32_t IP_5       : 2;            /*!< [15..14] Priority of interrupt 5                                          */
            uint32_t            : 6;
      __IOM uint32_t IP_6       : 2;            /*!< [23..22] Priority of interrupt 6                                          */
            uint32_t            : 6;
      __IOM uint32_t IP_7       : 2;            /*!< [31..30] Priority of interrupt 7                                          */
    } bit;
  } NVIC_IPR1;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000E408) Use the Interrupt Priority Registers to assign
                                                                    a priority from 0 to 3 to each of the available
                                                                    interrupts. 0 is the highest priority, and
                                                                    3 is the lowest.                                           */
    
    struct {
            uint32_t            : 6;
      __IOM uint32_t IP_8       : 2;            /*!< [7..6] Priority of interrupt 8                                            */
            uint32_t            : 6;
      __IOM uint32_t IP_9       : 2;            /*!< [15..14] Priority of interrupt 9                                          */
            uint32_t            : 6;
      __IOM uint32_t IP_10      : 2;            /*!< [23..22] Priority of interrupt 10                                         */
            uint32_t            : 6;
      __IOM uint32_t IP_11      : 2;            /*!< [31..30] Priority of interrupt 11                                         */
    } bit;
  } NVIC_IPR2;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000E40C) Use the Interrupt Priority Registers to assign
                                                                    a priority from 0 to 3 to each of the available
                                                                    interrupts. 0 is the highest priority, and
                                                                    3 is the lowest.                                           */
    
    struct {
            uint32_t            : 6;
      __IOM uint32_t IP_12      : 2;            /*!< [7..6] Priority of interrupt 12                                           */
            uint32_t            : 6;
      __IOM uint32_t IP_13      : 2;            /*!< [15..14] Priority of interrupt 13                                         */
            uint32_t            : 6;
      __IOM uint32_t IP_14      : 2;            /*!< [23..22] Priority of interrupt 14                                         */
            uint32_t            : 6;
      __IOM uint32_t IP_15      : 2;            /*!< [31..30] Priority of interrupt 15                                         */
    } bit;
  } NVIC_IPR3;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000E410) Use the Interrupt Priority Registers to assign
                                                                    a priority from 0 to 3 to each of the available
                                                                    interrupts. 0 is the highest priority, and
                                                                    3 is the lowest.                                           */
    
    struct {
            uint32_t            : 6;
      __IOM uint32_t IP_16      : 2;            /*!< [7..6] Priority of interrupt 16                                           */
            uint32_t            : 6;
      __IOM uint32_t IP_17      : 2;            /*!< [15..14] Priority of interrupt 17                                         */
            uint32_t            : 6;
      __IOM uint32_t IP_18      : 2;            /*!< [23..22] Priority of interrupt 18                                         */
            uint32_t            : 6;
      __IOM uint32_t IP_19      : 2;            /*!< [31..30] Priority of interrupt 19                                         */
    } bit;
  } NVIC_IPR4;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000E414) Use the Interrupt Priority Registers to assign
                                                                    a priority from 0 to 3 to each of the available
                                                                    interrupts. 0 is the highest priority, and
                                                                    3 is the lowest.                                           */
    
    struct {
            uint32_t            : 6;
      __IOM uint32_t IP_20      : 2;            /*!< [7..6] Priority of interrupt 20                                           */
            uint32_t            : 6;
      __IOM uint32_t IP_21      : 2;            /*!< [15..14] Priority of interrupt 21                                         */
            uint32_t            : 6;
      __IOM uint32_t IP_22      : 2;            /*!< [23..22] Priority of interrupt 22                                         */
            uint32_t            : 6;
      __IOM uint32_t IP_23      : 2;            /*!< [31..30] Priority of interrupt 23                                         */
    } bit;
  } NVIC_IPR5;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000E418) Use the Interrupt Priority Registers to assign
                                                                    a priority from 0 to 3 to each of the available
                                                                    interrupts. 0 is the highest priority, and
                                                                    3 is the lowest.                                           */
    
    struct {
            uint32_t            : 6;
      __IOM uint32_t IP_24      : 2;            /*!< [7..6] Priority of interrupt 24                                           */
            uint32_t            : 6;
      __IOM uint32_t IP_25      : 2;            /*!< [15..14] Priority of interrupt 25                                         */
            uint32_t            : 6;
      __IOM uint32_t IP_26      : 2;            /*!< [23..22] Priority of interrupt 26                                         */
            uint32_t            : 6;
      __IOM uint32_t IP_27      : 2;            /*!< [31..30] Priority of interrupt 27                                         */
    } bit;
  } NVIC_IPR6;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000E41C) Use the Interrupt Priority Registers to assign
                                                                    a priority from 0 to 3 to each of the available
                                                                    interrupts. 0 is the highest priority, and
                                                                    3 is the lowest.                                           */
    
    struct {
            uint32_t            : 6;
      __IOM uint32_t IP_28      : 2;            /*!< [7..6] Priority of interrupt 28                                           */
            uint32_t            : 6;
      __IOM uint32_t IP_29      : 2;            /*!< [15..14] Priority of interrupt 29                                         */
            uint32_t            : 6;
      __IOM uint32_t IP_30      : 2;            /*!< [23..22] Priority of interrupt 30                                         */
            uint32_t            : 6;
      __IOM uint32_t IP_31      : 2;            /*!< [31..30] Priority of interrupt 31                                         */
    } bit;
  } NVIC_IPR7;
  __IM  uint32_t  RESERVED6[568];
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000ED00) Read the CPU ID Base Register to determine: the
                                                                    ID number of the processor core, the version
                                                                    number of the processor core, the implementation
                                                                    details of the processor core.                             */
    
    struct {
      __IM  uint32_t REVISION   : 4;            /*!< [3..0] Minor revision number m in the rnpm revision status:
                                                     0x1 = Patch 1.                                                            */
      __IM  uint32_t PARTNO     : 12;           /*!< [15..4] Number of processor within family: 0xC60 = Cortex-M0+             */
      __IM  uint32_t ARCHITECTURE : 4;          /*!< [19..16] Constant that defines the architecture of the processor:
                                                     0xC = ARMv6-M architecture.                                               */
      __IM  uint32_t VARIANT    : 4;            /*!< [23..20] Major revision number n in the rnpm revision status:
                                                     0x0 = Revision 0.                                                         */
      __IM  uint32_t IMPLEMENTER : 8;           /*!< [31..24] Implementor code: 0x41 = ARM                                     */
    } bit;
  } CPUID;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000ED04) Use the Interrupt Control State Register to set
                                                                    a pending Non-Maskable Interrupt (NMI),
                                                                    set or clear a pending PendSV, set or clear
                                                                    a pending SysTick, check for pending exceptions,
                                                                    check the vector number of the highest priority
                                                                    pended exception, check the vector number
                                                                    of the active exception.                                   */
    
    struct {
      __IM  uint32_t VECTACTIVE : 9;            /*!< [8..0] Active exception number field. Reset clears the VECTACTIVE
                                                     field.                                                                    */
            uint32_t            : 3;
      __IM  uint32_t VECTPENDING : 9;           /*!< [20..12] Indicates the exception number for the highest priority
                                                     pending exception: 0 = no pending exceptions. Non zero
                                                     = The pending state includes the effect of memory-mapped
                                                     enable and mask registers. It does not include the PRIMASK
                                                     special-purpose register qualifier.                                       */
            uint32_t            : 1;
      __IM  uint32_t ISRPENDING : 1;            /*!< [22..22] External interrupt pending flag                                  */
      __IM  uint32_t ISRPREEMPT : 1;            /*!< [23..23] The system can only access this bit when the core is
                                                     halted. It indicates that a pending interrupt is to be
                                                     taken in the next running cycle. If C_MASKINTS is clear
                                                     in the Debug Halting Control and Status Register, the interrupt
                                                     is serviced.                                                              */
            uint32_t            : 1;
      __IOM uint32_t PENDSTCLR  : 1;            /*!< [25..25] SysTick exception clear-pending bit.
                                                     Write:
                                                     0 = No effect.
                                                     1 = Removes the pending state from the SysTick exception.
                                                     This bit is WO. On a register read its value is Unknown.                  */
      __IOM uint32_t PENDSTSET  : 1;            /*!< [26..26] SysTick exception set-pending bit.
                                                     Write:
                                                     0 = No effect.
                                                     1 = Changes SysTick exception state to pending.
                                                     Read:
                                                     0 = SysTick exception is not pending.
                                                     1 = SysTick exception is pending.                                         */
      __IOM uint32_t PENDSVCLR  : 1;            /*!< [27..27] PendSV clear-pending bit.
                                                     Write:
                                                     0 = No effect.
                                                     1 = Removes the pending state from the PendSV exception.                  */
      __IOM uint32_t PENDSVSET  : 1;            /*!< [28..28] PendSV set-pending bit.
                                                     Write:
                                                     0 = No effect.
                                                     1 = Changes PendSV exception state to pending.
                                                     Read:
                                                     0 = PendSV exception is not pending.
                                                     1 = PendSV exception is pending.
                                                     Writing 1 to this bit is the only way to set the PendSV
                                                     exception state to pending.                                               */
            uint32_t            : 2;
      __IOM uint32_t NMIPENDSET : 1;            /*!< [31..31] Setting this bit will activate an NMI. Since NMI is
                                                     the highest priority exception, it will activate as soon
                                                     as it is registered.
                                                     NMI set-pending bit.
                                                     Write:
                                                     0 = No effect.
                                                     1 = Changes NMI exception state to pending.
                                                     Read:
                                                     0 = NMI exception is not pending.
                                                     1 = NMI exception is pending.
                                                     Because NMI is the highest-priority exception, normally
                                                     the processor                                                             */
    } bit;
  } ICSR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000ED08) The VTOR holds the vector table offset address.            */
    
    struct {
            uint32_t            : 8;
      __IOM uint32_t TBLOFF     : 24;           /*!< [31..8] Bits [31:8] of the indicate the vector table offset
                                                     address.                                                                  */
    } bit;
  } VTOR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000ED0C) Use the Application Interrupt and Reset Control
                                                                    Register to: determine data endianness,
                                                                    clear all active state information from
                                                                    debug halt mode, request a system reset.                   */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t VECTCLRACTIVE : 1;         /*!< [1..1] Clears all active state information for fixed and configurable
                                                     exceptions. This bit: is self-clearing, can only be set
                                                     by the DAP when the core is halted. When set: clears all
                                                     active exception status of the processor, forces a return
                                                     to Thread mode, forces an IPSR of 0. A debugger must re-initialize
                                                     the stack.                                                                */
      __IOM uint32_t SYSRESETREQ : 1;           /*!< [2..2] Writing 1 to this bit causes the SYSRESETREQ signal to
                                                     the outer system to be asserted to request a reset. The
                                                     intention is to force a large system reset of all major
                                                     components except for debug. The C_HALT bit in the DHCSR
                                                     is cleared as a result of the system reset requested. The
                                                     debugger does not lose contact with the device.                           */
            uint32_t            : 12;
      __IM  uint32_t ENDIANESS  : 1;            /*!< [15..15] Data endianness implemented:
                                                     0 = Little-endian.                                                        */
      __IOM uint32_t VECTKEY    : 16;           /*!< [31..16] Register key:
                                                     Reads as Unknown
                                                     On writes, write 0x05FA to VECTKEY, otherwise the write
                                                     is ignored.                                                               */
    } bit;
  } AIRCR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000ED10) System Control Register. Use the System Control
                                                                    Register for power-management functions:
                                                                    signal to the system when the processor
                                                                    can enter a low power state, control how
                                                                    the processor enters and exits low power
                                                                    states.                                                    */
    
    struct {
            uint32_t            : 1;
      __IOM uint32_t SLEEPONEXIT : 1;           /*!< [1..1] Indicates sleep-on-exit when returning from Handler mode
                                                     to Thread mode:
                                                     0 = Do not sleep when returning to Thread mode.
                                                     1 = Enter sleep, or deep sleep, on return from an ISR to
                                                     Thread mode.
                                                     Setting this bit to 1 enables an interrupt driven application
                                                     to avoid returning to an empty main application.                          */
      __IOM uint32_t SLEEPDEEP  : 1;            /*!< [2..2] Controls whether the processor uses sleep or deep sleep
                                                     as its low power mode:
                                                     0 = Sleep.
                                                     1 = Deep sleep.                                                           */
            uint32_t            : 1;
      __IOM uint32_t SEVONPEND  : 1;            /*!< [4..4] Send Event on Pending bit:
                                                     0 = Only enabled interrupts or events can wakeup the processor,
                                                     disabled interrupts are excluded.
                                                     1 = Enabled events and all interrupts, including disabled
                                                     interrupts, can wakeup the processor.
                                                     When an event or interrupt becomes pending, the event signal
                                                     wakes up the processor from WFE. If the
                                                     processor is not waiting for an event, the event is registered
                                                     and affects the next WFE.
                                                     The                                                                       */
            uint32_t            : 27;
    } bit;
  } SCR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000ED14) The Configuration and Control Register permanently
                                                                    enables stack alignment and causes unaligned
                                                                    accesses to result in a Hard Fault.                        */
    
    struct {
            uint32_t            : 3;
      __IM  uint32_t UNALIGN_TRP : 1;           /*!< [3..3] Always reads as one, indicates that all unaligned accesses
                                                     generate a HardFault.                                                     */
            uint32_t            : 5;
      __IM  uint32_t STKALIGN   : 1;            /*!< [9..9] Always reads as one, indicates 8-byte stack alignment
                                                     on exception entry. On exception entry, the processor uses
                                                     bit[9] of the stacked PSR to indicate the stack alignment.
                                                     On return from the exception it uses this stacked bit to
                                                     restore the correct stack alignment.                                      */
            uint32_t            : 22;
    } bit;
  } CCR;
  __IM  uint32_t  RESERVED7;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000ED1C) System handlers are a special class of exception
                                                                    handler that can have their priority set
                                                                    to any of the priority levels. Use the System
                                                                    Handler Priority Register 2 to set the priority
                                                                    of SVCall.                                                 */
    
    struct {
            uint32_t            : 30;
      __IOM uint32_t PRI_11     : 2;            /*!< [31..30] Priority of system handler 11, SVCall                            */
    } bit;
  } SHPR2;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000ED20) System handlers are a special class of exception
                                                                    handler that can have their priority set
                                                                    to any of the priority levels. Use the System
                                                                    Handler Priority Register 3 to set the priority
                                                                    of PendSV and SysTick.                                     */
    
    struct {
            uint32_t            : 22;
      __IOM uint32_t PRI_14     : 2;            /*!< [23..22] Priority of system handler 14, PendSV                            */
            uint32_t            : 6;
      __IOM uint32_t PRI_15     : 2;            /*!< [31..30] Priority of system handler 15, SysTick                           */
    } bit;
  } SHPR3;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000ED24) Use the System Handler Control and State Register
                                                                    to determine or clear the pending status
                                                                    of SVCall.                                                 */
    
    struct {
            uint32_t            : 15;
      __IOM uint32_t SVCALLPENDED : 1;          /*!< [15..15] Reads as 1 if SVCall is Pending. Write 1 to set pending
                                                     SVCall, write 0 to clear pending SVCall.                                  */
            uint32_t            : 16;
    } bit;
  } SHCSR;
  __IM  uint32_t  RESERVED8[26];
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000ED90) Read the MPU Type Register to determine if the
                                                                    processor implements an MPU, and how many
                                                                    regions the MPU supports.                                  */
    
    struct {
      __IM  uint32_t SEPARATE   : 1;            /*!< [0..0] Indicates support for separate instruction and data address
                                                     maps. Reads as 0 as ARMv6-M only supports a unified MPU.                  */
            uint32_t            : 7;
      __IM  uint32_t DREGION    : 8;            /*!< [15..8] Number of regions supported by the MPU.                           */
      __IM  uint32_t IREGION    : 8;            /*!< [23..16] Instruction region. Reads as zero as ARMv6-M only supports
                                                     a unified MPU.                                                            */
            uint32_t            : 8;
    } bit;
  } MPU_TYPE;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000ED94) Use the MPU Control Register to enable and disable
                                                                    the MPU, and to control whether the default
                                                                    memory map is enabled as a background region
                                                                    for privileged accesses, and whether the
                                                                    MPU is enabled for HardFaults and NMIs.                    */
    
    struct {
      __IOM uint32_t ENABLE     : 1;            /*!< [0..0] Enables the MPU. If the MPU is disabled, privileged and
                                                     unprivileged accesses use the default memory map.
                                                     0 = MPU disabled.
                                                     1 = MPU enabled.                                                          */
      __IOM uint32_t HFNMIENA   : 1;            /*!< [1..1] Controls the use of the MPU for HardFaults and NMIs.
                                                     Setting this bit when ENABLE is clear results in UNPREDICTABLE
                                                     behaviour.
                                                     When the MPU is enabled:
                                                     0 = MPU is disabled during HardFault and NMI handlers,
                                                     regardless of the value of the ENABLE bit.
                                                     1 = the MPU is enabled during HardFault and NMI handlers.                 */
      __IOM uint32_t PRIVDEFENA : 1;            /*!< [2..2] Controls whether the default memory map is enabled as
                                                     a background region for privileged accesses. This bit is
                                                     ignored when ENABLE is clear.
                                                     0 = If the MPU is enabled, disables use of the default
                                                     memory map. Any memory access to a location not
                                                     covered by any enabled region causes a fault.
                                                     1 = If the MPU is enabled, enables use of the default memory
                                                     map as a background region for privileged software accesses.
                                                     When enabled, the bac                                                     */
            uint32_t            : 29;
    } bit;
  } MPU_CTRL;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000ED98) Use the MPU Region Number Register to select
                                                                    the region currently accessed by MPU_RBAR
                                                                    and MPU_RASR.                                              */
    
    struct {
      __IOM uint32_t REGION     : 4;            /*!< [3..0] Indicates the MPU region referenced by the MPU_RBAR and
                                                     MPU_RASR registers.
                                                     The MPU supports 8 memory regions, so the permitted values
                                                     of this field are 0-7.                                                    */
            uint32_t            : 28;
    } bit;
  } MPU_RNR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000ED9C) Read the MPU Region Base Address Register to
                                                                    determine the base address of the region
                                                                    identified by MPU_RNR. Write to update the
                                                                    base address of said region or that of a
                                                                    specified region, with whose number MPU_RNR
                                                                    will also be updated.                                      */
    
    struct {
      __IOM uint32_t REGION     : 4;            /*!< [3..0] On writes, specifies the number of the region whose base
                                                     address to update provided VALID is set written as 1. On
                                                     reads, returns bits [3:0] of MPU_RNR.                                     */
      __IOM uint32_t VALID      : 1;            /*!< [4..4] On writes, indicates whether the write must update the
                                                     base address of the region identified by the REGION field,
                                                     updating the MPU_RNR to indicate this new region.
                                                     Write:
                                                     0 = MPU_RNR not changed, and the processor:
                                                     Updates the base address for the region specified in the
                                                     MPU_RNR.
                                                     Ignores the value of the REGION field.
                                                     1 = The processor:
                                                     Updates the value of the MPU_RNR to the value of the REG                  */
            uint32_t            : 3;
      __IOM uint32_t ADDR       : 24;           /*!< [31..8] Base address of the region.                                       */
    } bit;
  } MPU_RBAR;
  
  union {
    __IOM uint32_t reg;                         /*!< (@ 0x0000EDA0) Use the MPU Region Attribute and Size Register
                                                                    to define the size, access behaviour and
                                                                    memory type of the region identified by
                                                                    MPU_RNR, and enable that region.                           */
    
    struct {
      __IOM uint32_t ENABLE     : 1;            /*!< [0..0] Enables the region.                                                */
      __IOM uint32_t SIZE       : 5;            /*!< [5..1] Indicates the region size. Region size in bytes = 2^(SIZE+1).
                                                     The minimum permitted value is 7 (b00111) = 256Bytes                      */
            uint32_t            : 2;
      __IOM uint32_t SRD        : 8;            /*!< [15..8] Subregion Disable. For regions of 256 bytes or larger,
                                                     each bit of this field controls whether one of the eight
                                                     equal subregions is enabled.                                              */
      __IOM uint32_t ATTRS      : 16;           /*!< [31..16] The MPU Region Attribute field. Use to define the region
                                                     attribute control.
                                                     28 = XN: Instruction access disable bit:
                                                     0 = Instruction fetches enabled.
                                                     1 = Instruction fetches disabled.
                                                     26:24 = AP: Access permission field
                                                     18 = S: Shareable bit
                                                     17 = C: Cacheable bit
                                                     16 = B: Bufferable bit                                                    */
    } bit;
  } MPU_RASR;
} PPB_Type;                                     /*!< Size = 60836 (0xeda4)                                                     */


/** @} */ /* End of group Device_Peripheral_peripherals */


/* =========================================================================================================================== */
/* ================                          Device Specific Peripheral Address Map                           ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_peripheralAddr
  * @{
  */

#define XIP_CTRL_BASE               0x14000000UL
#define XIP_SSI_BASE                0x18000000UL
#define SYSINFO_BASE                0x40000000UL
#define SYSCFG_BASE                 0x40004000UL
#define CLOCKS_BASE                 0x40008000UL
#define RESETS_BASE                 0x4000C000UL
#define PSM_BASE                    0x40010000UL
#define IO_BANK0_BASE               0x40014000UL
#define IO_QSPI_BASE                0x40018000UL
#define PADS_BANK0_BASE             0x4001C000UL
#define PADS_QSPI_BASE              0x40020000UL
#define XOSC_BASE                   0x40024000UL
#define PLL_SYS_BASE                0x40028000UL
#define PLL_USB_BASE                0x4002C000UL
#define BUSCTRL_BASE                0x40030000UL
#define UART0_BASE                  0x40034000UL
#define UART1_BASE                  0x40038000UL
#define SPI0_BASE                   0x4003C000UL
#define SPI1_BASE                   0x40040000UL
#define I2C0_BASE                   0x40044000UL
#define I2C1_BASE                   0x40048000UL
#define ADC_BASE                    0x4004C000UL
#define PWM_BASE                    0x40050000UL
#define TIMER_BASE                  0x40054000UL
#define WATCHDOG_BASE               0x40058000UL
#define RTC_BASE                    0x4005C000UL
#define ROSC_BASE                   0x40060000UL
#define VREG_AND_CHIP_RESET_BASE    0x40064000UL
#define TBMAN_BASE                  0x4006C000UL
#define DMA_BASE                    0x50000000UL
#define USBCTRL_REGS_BASE           0x50110000UL
#define PIO0_BASE                   0x50200000UL
#define PIO1_BASE                   0x50300000UL
#define SIO_BASE                    0xD0000000UL
#define PPB_BASE                    0xE0000000UL

/** @} */ /* End of group Device_Peripheral_peripheralAddr */


/* =========================================================================================================================== */
/* ================                                  Peripheral declaration                                   ================ */
/* =========================================================================================================================== */


/** @addtogroup Device_Peripheral_declaration
  * @{
  */

#define XIP_CTRL                    ((XIP_CTRL_Type*)          XIP_CTRL_BASE)
#define XIP_SSI                     ((XIP_SSI_Type*)           XIP_SSI_BASE)
#define SYSINFO                     ((SYSINFO_Type*)           SYSINFO_BASE)
#define SYSCFG                      ((SYSCFG_Type*)            SYSCFG_BASE)
#define CLOCKS                      ((CLOCKS_Type*)            CLOCKS_BASE)
#define RESETS                      ((RESETS_Type*)            RESETS_BASE)
#define PSM                         ((PSM_Type*)               PSM_BASE)
#define IO_BANK0                    ((IO_BANK0_Type*)          IO_BANK0_BASE)
#define IO_QSPI                     ((IO_QSPI_Type*)           IO_QSPI_BASE)
#define PADS_BANK0                  ((PADS_BANK0_Type*)        PADS_BANK0_BASE)
#define PADS_QSPI                   ((PADS_QSPI_Type*)         PADS_QSPI_BASE)
#define XOSC                        ((XOSC_Type*)              XOSC_BASE)
#define PLL_SYS                     ((PLL_SYS_Type*)           PLL_SYS_BASE)
#define PLL_USB                     ((PLL_SYS_Type*)           PLL_USB_BASE)
#define BUSCTRL                     ((BUSCTRL_Type*)           BUSCTRL_BASE)
#define UART0                       ((UART0_Type*)             UART0_BASE)
#define UART1                       ((UART0_Type*)             UART1_BASE)
#define SPI0                        ((SPI0_Type*)              SPI0_BASE)
#define SPI1                        ((SPI0_Type*)              SPI1_BASE)
#define I2C0                        ((I2C0_Type*)              I2C0_BASE)
#define I2C1                        ((I2C0_Type*)              I2C1_BASE)
#define ADC                         ((ADC_Type*)               ADC_BASE)
#define PWM                         ((PWM_Type*)               PWM_BASE)
#define TIMER                       ((TIMER_Type*)             TIMER_BASE)
#define WATCHDOG                    ((WATCHDOG_Type*)          WATCHDOG_BASE)
#define RTC                         ((RTC_Type*)               RTC_BASE)
#define ROSC                        ((ROSC_Type*)              ROSC_BASE)
#define VREG_AND_CHIP_RESET         ((VREG_AND_CHIP_RESET_Type*)  VREG_AND_CHIP_RESET_BASE)
#define TBMAN                       ((TBMAN_Type*)             TBMAN_BASE)
#define DMA                         ((DMA_Type*)               DMA_BASE)
#define USBCTRL_REGS                ((USBCTRL_REGS_Type*)      USBCTRL_REGS_BASE)
#define PIO0                        ((PIO0_Type*)              PIO0_BASE)
#define PIO1                        ((PIO0_Type*)              PIO1_BASE)
#define SIO                         ((SIO_Type*)               SIO_BASE)
#define PPB                         ((PPB_Type*)               PPB_BASE)

/** @} */ /* End of group Device_Peripheral_declaration */


/* =========================================================================================================================== */
/* ================                                Pos/Mask Peripheral Section                                ================ */
/* =========================================================================================================================== */


/** @addtogroup PosMask_peripherals
  * @{
  */



/* =========================================================================================================================== */
/* ================                                         XIP_CTRL                                          ================ */
/* =========================================================================================================================== */

/* =========================================================  CTRL  ========================================================== */
#define XIP_CTRL_CTRL_POWER_DOWN_Pos      (3UL)                     /*!< POWER_DOWN (Bit 3)                                    */
#define XIP_CTRL_CTRL_POWER_DOWN_Msk      (0x8UL)                   /*!< POWER_DOWN (Bitfield-Mask: 0x01)                      */
#define XIP_CTRL_CTRL_ERR_BADWRITE_Pos    (1UL)                     /*!< ERR_BADWRITE (Bit 1)                                  */
#define XIP_CTRL_CTRL_ERR_BADWRITE_Msk    (0x2UL)                   /*!< ERR_BADWRITE (Bitfield-Mask: 0x01)                    */
#define XIP_CTRL_CTRL_EN_Pos              (0UL)                     /*!< EN (Bit 0)                                            */
#define XIP_CTRL_CTRL_EN_Msk              (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01)                              */
/* =========================================================  FLUSH  ========================================================= */
#define XIP_CTRL_FLUSH_FLUSH_Pos          (0UL)                     /*!< FLUSH (Bit 0)                                         */
#define XIP_CTRL_FLUSH_FLUSH_Msk          (0x1UL)                   /*!< FLUSH (Bitfield-Mask: 0x01)                           */
/* =========================================================  STAT  ========================================================== */
#define XIP_CTRL_STAT_FIFO_FULL_Pos       (2UL)                     /*!< FIFO_FULL (Bit 2)                                     */
#define XIP_CTRL_STAT_FIFO_FULL_Msk       (0x4UL)                   /*!< FIFO_FULL (Bitfield-Mask: 0x01)                       */
#define XIP_CTRL_STAT_FIFO_EMPTY_Pos      (1UL)                     /*!< FIFO_EMPTY (Bit 1)                                    */
#define XIP_CTRL_STAT_FIFO_EMPTY_Msk      (0x2UL)                   /*!< FIFO_EMPTY (Bitfield-Mask: 0x01)                      */
#define XIP_CTRL_STAT_FLUSH_READY_Pos     (0UL)                     /*!< FLUSH_READY (Bit 0)                                   */
#define XIP_CTRL_STAT_FLUSH_READY_Msk     (0x1UL)                   /*!< FLUSH_READY (Bitfield-Mask: 0x01)                     */
/* ========================================================  CTR_HIT  ======================================================== */
/* ========================================================  CTR_ACC  ======================================================== */
/* ======================================================  STREAM_ADDR  ====================================================== */
#define XIP_CTRL_STREAM_ADDR_STREAM_ADDR_Pos (2UL)                  /*!< STREAM_ADDR (Bit 2)                                   */
#define XIP_CTRL_STREAM_ADDR_STREAM_ADDR_Msk (0xfffffffcUL)         /*!< STREAM_ADDR (Bitfield-Mask: 0x3fffffff)               */
/* ======================================================  STREAM_CTR  ======================================================= */
#define XIP_CTRL_STREAM_CTR_STREAM_CTR_Pos (0UL)                    /*!< STREAM_CTR (Bit 0)                                    */
#define XIP_CTRL_STREAM_CTR_STREAM_CTR_Msk (0x3fffffUL)             /*!< STREAM_CTR (Bitfield-Mask: 0x3fffff)                  */
/* ======================================================  STREAM_FIFO  ====================================================== */


/* =========================================================================================================================== */
/* ================                                          XIP_SSI                                          ================ */
/* =========================================================================================================================== */

/* ========================================================  CTRLR0  ========================================================= */
#define XIP_SSI_CTRLR0_SSTE_Pos           (24UL)                    /*!< SSTE (Bit 24)                                         */
#define XIP_SSI_CTRLR0_SSTE_Msk           (0x1000000UL)             /*!< SSTE (Bitfield-Mask: 0x01)                            */
#define XIP_SSI_CTRLR0_SPI_FRF_Pos        (21UL)                    /*!< SPI_FRF (Bit 21)                                      */
#define XIP_SSI_CTRLR0_SPI_FRF_Msk        (0x600000UL)              /*!< SPI_FRF (Bitfield-Mask: 0x03)                         */
#define XIP_SSI_CTRLR0_DFS_32_Pos         (16UL)                    /*!< DFS_32 (Bit 16)                                       */
#define XIP_SSI_CTRLR0_DFS_32_Msk         (0x1f0000UL)              /*!< DFS_32 (Bitfield-Mask: 0x1f)                          */
#define XIP_SSI_CTRLR0_CFS_Pos            (12UL)                    /*!< CFS (Bit 12)                                          */
#define XIP_SSI_CTRLR0_CFS_Msk            (0xf000UL)                /*!< CFS (Bitfield-Mask: 0x0f)                             */
#define XIP_SSI_CTRLR0_SRL_Pos            (11UL)                    /*!< SRL (Bit 11)                                          */
#define XIP_SSI_CTRLR0_SRL_Msk            (0x800UL)                 /*!< SRL (Bitfield-Mask: 0x01)                             */
#define XIP_SSI_CTRLR0_SLV_OE_Pos         (10UL)                    /*!< SLV_OE (Bit 10)                                       */
#define XIP_SSI_CTRLR0_SLV_OE_Msk         (0x400UL)                 /*!< SLV_OE (Bitfield-Mask: 0x01)                          */
#define XIP_SSI_CTRLR0_TMOD_Pos           (8UL)                     /*!< TMOD (Bit 8)                                          */
#define XIP_SSI_CTRLR0_TMOD_Msk           (0x300UL)                 /*!< TMOD (Bitfield-Mask: 0x03)                            */
#define XIP_SSI_CTRLR0_SCPOL_Pos          (7UL)                     /*!< SCPOL (Bit 7)                                         */
#define XIP_SSI_CTRLR0_SCPOL_Msk          (0x80UL)                  /*!< SCPOL (Bitfield-Mask: 0x01)                           */
#define XIP_SSI_CTRLR0_SCPH_Pos           (6UL)                     /*!< SCPH (Bit 6)                                          */
#define XIP_SSI_CTRLR0_SCPH_Msk           (0x40UL)                  /*!< SCPH (Bitfield-Mask: 0x01)                            */
#define XIP_SSI_CTRLR0_FRF_Pos            (4UL)                     /*!< FRF (Bit 4)                                           */
#define XIP_SSI_CTRLR0_FRF_Msk            (0x30UL)                  /*!< FRF (Bitfield-Mask: 0x03)                             */
#define XIP_SSI_CTRLR0_DFS_Pos            (0UL)                     /*!< DFS (Bit 0)                                           */
#define XIP_SSI_CTRLR0_DFS_Msk            (0xfUL)                   /*!< DFS (Bitfield-Mask: 0x0f)                             */
/* ========================================================  CTRLR1  ========================================================= */
#define XIP_SSI_CTRLR1_NDF_Pos            (0UL)                     /*!< NDF (Bit 0)                                           */
#define XIP_SSI_CTRLR1_NDF_Msk            (0xffffUL)                /*!< NDF (Bitfield-Mask: 0xffff)                           */
/* ========================================================  SSIENR  ========================================================= */
#define XIP_SSI_SSIENR_SSI_EN_Pos         (0UL)                     /*!< SSI_EN (Bit 0)                                        */
#define XIP_SSI_SSIENR_SSI_EN_Msk         (0x1UL)                   /*!< SSI_EN (Bitfield-Mask: 0x01)                          */
/* =========================================================  MWCR  ========================================================== */
#define XIP_SSI_MWCR_MHS_Pos              (2UL)                     /*!< MHS (Bit 2)                                           */
#define XIP_SSI_MWCR_MHS_Msk              (0x4UL)                   /*!< MHS (Bitfield-Mask: 0x01)                             */
#define XIP_SSI_MWCR_MDD_Pos              (1UL)                     /*!< MDD (Bit 1)                                           */
#define XIP_SSI_MWCR_MDD_Msk              (0x2UL)                   /*!< MDD (Bitfield-Mask: 0x01)                             */
#define XIP_SSI_MWCR_MWMOD_Pos            (0UL)                     /*!< MWMOD (Bit 0)                                         */
#define XIP_SSI_MWCR_MWMOD_Msk            (0x1UL)                   /*!< MWMOD (Bitfield-Mask: 0x01)                           */
/* ==========================================================  SER  ========================================================== */
#define XIP_SSI_SER_SER_Pos               (0UL)                     /*!< SER (Bit 0)                                           */
#define XIP_SSI_SER_SER_Msk               (0x1UL)                   /*!< SER (Bitfield-Mask: 0x01)                             */
/* =========================================================  BAUDR  ========================================================= */
#define XIP_SSI_BAUDR_SCKDV_Pos           (0UL)                     /*!< SCKDV (Bit 0)                                         */
#define XIP_SSI_BAUDR_SCKDV_Msk           (0xffffUL)                /*!< SCKDV (Bitfield-Mask: 0xffff)                         */
/* ========================================================  TXFTLR  ========================================================= */
#define XIP_SSI_TXFTLR_TFT_Pos            (0UL)                     /*!< TFT (Bit 0)                                           */
#define XIP_SSI_TXFTLR_TFT_Msk            (0xffUL)                  /*!< TFT (Bitfield-Mask: 0xff)                             */
/* ========================================================  RXFTLR  ========================================================= */
#define XIP_SSI_RXFTLR_RFT_Pos            (0UL)                     /*!< RFT (Bit 0)                                           */
#define XIP_SSI_RXFTLR_RFT_Msk            (0xffUL)                  /*!< RFT (Bitfield-Mask: 0xff)                             */
/* =========================================================  TXFLR  ========================================================= */
#define XIP_SSI_TXFLR_TFTFL_Pos           (0UL)                     /*!< TFTFL (Bit 0)                                         */
#define XIP_SSI_TXFLR_TFTFL_Msk           (0xffUL)                  /*!< TFTFL (Bitfield-Mask: 0xff)                           */
/* =========================================================  RXFLR  ========================================================= */
#define XIP_SSI_RXFLR_RXTFL_Pos           (0UL)                     /*!< RXTFL (Bit 0)                                         */
#define XIP_SSI_RXFLR_RXTFL_Msk           (0xffUL)                  /*!< RXTFL (Bitfield-Mask: 0xff)                           */
/* ==========================================================  SR  =========================================================== */
#define XIP_SSI_SR_DCOL_Pos               (6UL)                     /*!< DCOL (Bit 6)                                          */
#define XIP_SSI_SR_DCOL_Msk               (0x40UL)                  /*!< DCOL (Bitfield-Mask: 0x01)                            */
#define XIP_SSI_SR_TXE_Pos                (5UL)                     /*!< TXE (Bit 5)                                           */
#define XIP_SSI_SR_TXE_Msk                (0x20UL)                  /*!< TXE (Bitfield-Mask: 0x01)                             */
#define XIP_SSI_SR_RFF_Pos                (4UL)                     /*!< RFF (Bit 4)                                           */
#define XIP_SSI_SR_RFF_Msk                (0x10UL)                  /*!< RFF (Bitfield-Mask: 0x01)                             */
#define XIP_SSI_SR_RFNE_Pos               (3UL)                     /*!< RFNE (Bit 3)                                          */
#define XIP_SSI_SR_RFNE_Msk               (0x8UL)                   /*!< RFNE (Bitfield-Mask: 0x01)                            */
#define XIP_SSI_SR_TFE_Pos                (2UL)                     /*!< TFE (Bit 2)                                           */
#define XIP_SSI_SR_TFE_Msk                (0x4UL)                   /*!< TFE (Bitfield-Mask: 0x01)                             */
#define XIP_SSI_SR_TFNF_Pos               (1UL)                     /*!< TFNF (Bit 1)                                          */
#define XIP_SSI_SR_TFNF_Msk               (0x2UL)                   /*!< TFNF (Bitfield-Mask: 0x01)                            */
#define XIP_SSI_SR_BUSY_Pos               (0UL)                     /*!< BUSY (Bit 0)                                          */
#define XIP_SSI_SR_BUSY_Msk               (0x1UL)                   /*!< BUSY (Bitfield-Mask: 0x01)                            */
/* ==========================================================  IMR  ========================================================== */
#define XIP_SSI_IMR_MSTIM_Pos             (5UL)                     /*!< MSTIM (Bit 5)                                         */
#define XIP_SSI_IMR_MSTIM_Msk             (0x20UL)                  /*!< MSTIM (Bitfield-Mask: 0x01)                           */
#define XIP_SSI_IMR_RXFIM_Pos             (4UL)                     /*!< RXFIM (Bit 4)                                         */
#define XIP_SSI_IMR_RXFIM_Msk             (0x10UL)                  /*!< RXFIM (Bitfield-Mask: 0x01)                           */
#define XIP_SSI_IMR_RXOIM_Pos             (3UL)                     /*!< RXOIM (Bit 3)                                         */
#define XIP_SSI_IMR_RXOIM_Msk             (0x8UL)                   /*!< RXOIM (Bitfield-Mask: 0x01)                           */
#define XIP_SSI_IMR_RXUIM_Pos             (2UL)                     /*!< RXUIM (Bit 2)                                         */
#define XIP_SSI_IMR_RXUIM_Msk             (0x4UL)                   /*!< RXUIM (Bitfield-Mask: 0x01)                           */
#define XIP_SSI_IMR_TXOIM_Pos             (1UL)                     /*!< TXOIM (Bit 1)                                         */
#define XIP_SSI_IMR_TXOIM_Msk             (0x2UL)                   /*!< TXOIM (Bitfield-Mask: 0x01)                           */
#define XIP_SSI_IMR_TXEIM_Pos             (0UL)                     /*!< TXEIM (Bit 0)                                         */
#define XIP_SSI_IMR_TXEIM_Msk             (0x1UL)                   /*!< TXEIM (Bitfield-Mask: 0x01)                           */
/* ==========================================================  ISR  ========================================================== */
#define XIP_SSI_ISR_MSTIS_Pos             (5UL)                     /*!< MSTIS (Bit 5)                                         */
#define XIP_SSI_ISR_MSTIS_Msk             (0x20UL)                  /*!< MSTIS (Bitfield-Mask: 0x01)                           */
#define XIP_SSI_ISR_RXFIS_Pos             (4UL)                     /*!< RXFIS (Bit 4)                                         */
#define XIP_SSI_ISR_RXFIS_Msk             (0x10UL)                  /*!< RXFIS (Bitfield-Mask: 0x01)                           */
#define XIP_SSI_ISR_RXOIS_Pos             (3UL)                     /*!< RXOIS (Bit 3)                                         */
#define XIP_SSI_ISR_RXOIS_Msk             (0x8UL)                   /*!< RXOIS (Bitfield-Mask: 0x01)                           */
#define XIP_SSI_ISR_RXUIS_Pos             (2UL)                     /*!< RXUIS (Bit 2)                                         */
#define XIP_SSI_ISR_RXUIS_Msk             (0x4UL)                   /*!< RXUIS (Bitfield-Mask: 0x01)                           */
#define XIP_SSI_ISR_TXOIS_Pos             (1UL)                     /*!< TXOIS (Bit 1)                                         */
#define XIP_SSI_ISR_TXOIS_Msk             (0x2UL)                   /*!< TXOIS (Bitfield-Mask: 0x01)                           */
#define XIP_SSI_ISR_TXEIS_Pos             (0UL)                     /*!< TXEIS (Bit 0)                                         */
#define XIP_SSI_ISR_TXEIS_Msk             (0x1UL)                   /*!< TXEIS (Bitfield-Mask: 0x01)                           */
/* =========================================================  RISR  ========================================================== */
#define XIP_SSI_RISR_MSTIR_Pos            (5UL)                     /*!< MSTIR (Bit 5)                                         */
#define XIP_SSI_RISR_MSTIR_Msk            (0x20UL)                  /*!< MSTIR (Bitfield-Mask: 0x01)                           */
#define XIP_SSI_RISR_RXFIR_Pos            (4UL)                     /*!< RXFIR (Bit 4)                                         */
#define XIP_SSI_RISR_RXFIR_Msk            (0x10UL)                  /*!< RXFIR (Bitfield-Mask: 0x01)                           */
#define XIP_SSI_RISR_RXOIR_Pos            (3UL)                     /*!< RXOIR (Bit 3)                                         */
#define XIP_SSI_RISR_RXOIR_Msk            (0x8UL)                   /*!< RXOIR (Bitfield-Mask: 0x01)                           */
#define XIP_SSI_RISR_RXUIR_Pos            (2UL)                     /*!< RXUIR (Bit 2)                                         */
#define XIP_SSI_RISR_RXUIR_Msk            (0x4UL)                   /*!< RXUIR (Bitfield-Mask: 0x01)                           */
#define XIP_SSI_RISR_TXOIR_Pos            (1UL)                     /*!< TXOIR (Bit 1)                                         */
#define XIP_SSI_RISR_TXOIR_Msk            (0x2UL)                   /*!< TXOIR (Bitfield-Mask: 0x01)                           */
#define XIP_SSI_RISR_TXEIR_Pos            (0UL)                     /*!< TXEIR (Bit 0)                                         */
#define XIP_SSI_RISR_TXEIR_Msk            (0x1UL)                   /*!< TXEIR (Bitfield-Mask: 0x01)                           */
/* ========================================================  TXOICR  ========================================================= */
#define XIP_SSI_TXOICR_TXOICR_Pos         (0UL)                     /*!< TXOICR (Bit 0)                                        */
#define XIP_SSI_TXOICR_TXOICR_Msk         (0x1UL)                   /*!< TXOICR (Bitfield-Mask: 0x01)                          */
/* ========================================================  RXOICR  ========================================================= */
#define XIP_SSI_RXOICR_RXOICR_Pos         (0UL)                     /*!< RXOICR (Bit 0)                                        */
#define XIP_SSI_RXOICR_RXOICR_Msk         (0x1UL)                   /*!< RXOICR (Bitfield-Mask: 0x01)                          */
/* ========================================================  RXUICR  ========================================================= */
#define XIP_SSI_RXUICR_RXUICR_Pos         (0UL)                     /*!< RXUICR (Bit 0)                                        */
#define XIP_SSI_RXUICR_RXUICR_Msk         (0x1UL)                   /*!< RXUICR (Bitfield-Mask: 0x01)                          */
/* ========================================================  MSTICR  ========================================================= */
#define XIP_SSI_MSTICR_MSTICR_Pos         (0UL)                     /*!< MSTICR (Bit 0)                                        */
#define XIP_SSI_MSTICR_MSTICR_Msk         (0x1UL)                   /*!< MSTICR (Bitfield-Mask: 0x01)                          */
/* ==========================================================  ICR  ========================================================== */
#define XIP_SSI_ICR_ICR_Pos               (0UL)                     /*!< ICR (Bit 0)                                           */
#define XIP_SSI_ICR_ICR_Msk               (0x1UL)                   /*!< ICR (Bitfield-Mask: 0x01)                             */
/* =========================================================  DMACR  ========================================================= */
#define XIP_SSI_DMACR_TDMAE_Pos           (1UL)                     /*!< TDMAE (Bit 1)                                         */
#define XIP_SSI_DMACR_TDMAE_Msk           (0x2UL)                   /*!< TDMAE (Bitfield-Mask: 0x01)                           */
#define XIP_SSI_DMACR_RDMAE_Pos           (0UL)                     /*!< RDMAE (Bit 0)                                         */
#define XIP_SSI_DMACR_RDMAE_Msk           (0x1UL)                   /*!< RDMAE (Bitfield-Mask: 0x01)                           */
/* ========================================================  DMATDLR  ======================================================== */
#define XIP_SSI_DMATDLR_DMATDL_Pos        (0UL)                     /*!< DMATDL (Bit 0)                                        */
#define XIP_SSI_DMATDLR_DMATDL_Msk        (0xffUL)                  /*!< DMATDL (Bitfield-Mask: 0xff)                          */
/* ========================================================  DMARDLR  ======================================================== */
#define XIP_SSI_DMARDLR_DMARDL_Pos        (0UL)                     /*!< DMARDL (Bit 0)                                        */
#define XIP_SSI_DMARDLR_DMARDL_Msk        (0xffUL)                  /*!< DMARDL (Bitfield-Mask: 0xff)                          */
/* ==========================================================  IDR  ========================================================== */
#define XIP_SSI_IDR_IDCODE_Pos            (0UL)                     /*!< IDCODE (Bit 0)                                        */
#define XIP_SSI_IDR_IDCODE_Msk            (0xffffffffUL)            /*!< IDCODE (Bitfield-Mask: 0xffffffff)                    */
/* ====================================================  SSI_VERSION_ID  ===================================================== */
#define XIP_SSI_SSI_VERSION_ID_SSI_COMP_VERSION_Pos (0UL)           /*!< SSI_COMP_VERSION (Bit 0)                              */
#define XIP_SSI_SSI_VERSION_ID_SSI_COMP_VERSION_Msk (0xffffffffUL)  /*!< SSI_COMP_VERSION (Bitfield-Mask: 0xffffffff)          */
/* ==========================================================  DR0  ========================================================== */
#define XIP_SSI_DR0_DR_Pos                (0UL)                     /*!< DR (Bit 0)                                            */
#define XIP_SSI_DR0_DR_Msk                (0xffffffffUL)            /*!< DR (Bitfield-Mask: 0xffffffff)                        */
/* =====================================================  RX_SAMPLE_DLY  ===================================================== */
#define XIP_SSI_RX_SAMPLE_DLY_RSD_Pos     (0UL)                     /*!< RSD (Bit 0)                                           */
#define XIP_SSI_RX_SAMPLE_DLY_RSD_Msk     (0xffUL)                  /*!< RSD (Bitfield-Mask: 0xff)                             */
/* ======================================================  SPI_CTRLR0  ======================================================= */
#define XIP_SSI_SPI_CTRLR0_XIP_CMD_Pos    (24UL)                    /*!< XIP_CMD (Bit 24)                                      */
#define XIP_SSI_SPI_CTRLR0_XIP_CMD_Msk    (0xff000000UL)            /*!< XIP_CMD (Bitfield-Mask: 0xff)                         */
#define XIP_SSI_SPI_CTRLR0_SPI_RXDS_EN_Pos (18UL)                   /*!< SPI_RXDS_EN (Bit 18)                                  */
#define XIP_SSI_SPI_CTRLR0_SPI_RXDS_EN_Msk (0x40000UL)              /*!< SPI_RXDS_EN (Bitfield-Mask: 0x01)                     */
#define XIP_SSI_SPI_CTRLR0_INST_DDR_EN_Pos (17UL)                   /*!< INST_DDR_EN (Bit 17)                                  */
#define XIP_SSI_SPI_CTRLR0_INST_DDR_EN_Msk (0x20000UL)              /*!< INST_DDR_EN (Bitfield-Mask: 0x01)                     */
#define XIP_SSI_SPI_CTRLR0_SPI_DDR_EN_Pos (16UL)                    /*!< SPI_DDR_EN (Bit 16)                                   */
#define XIP_SSI_SPI_CTRLR0_SPI_DDR_EN_Msk (0x10000UL)               /*!< SPI_DDR_EN (Bitfield-Mask: 0x01)                      */
#define XIP_SSI_SPI_CTRLR0_WAIT_CYCLES_Pos (11UL)                   /*!< WAIT_CYCLES (Bit 11)                                  */
#define XIP_SSI_SPI_CTRLR0_WAIT_CYCLES_Msk (0xf800UL)               /*!< WAIT_CYCLES (Bitfield-Mask: 0x1f)                     */
#define XIP_SSI_SPI_CTRLR0_INST_L_Pos     (8UL)                     /*!< INST_L (Bit 8)                                        */
#define XIP_SSI_SPI_CTRLR0_INST_L_Msk     (0x300UL)                 /*!< INST_L (Bitfield-Mask: 0x03)                          */
#define XIP_SSI_SPI_CTRLR0_ADDR_L_Pos     (2UL)                     /*!< ADDR_L (Bit 2)                                        */
#define XIP_SSI_SPI_CTRLR0_ADDR_L_Msk     (0x3cUL)                  /*!< ADDR_L (Bitfield-Mask: 0x0f)                          */
#define XIP_SSI_SPI_CTRLR0_TRANS_TYPE_Pos (0UL)                     /*!< TRANS_TYPE (Bit 0)                                    */
#define XIP_SSI_SPI_CTRLR0_TRANS_TYPE_Msk (0x3UL)                   /*!< TRANS_TYPE (Bitfield-Mask: 0x03)                      */
/* ====================================================  TXD_DRIVE_EDGE  ===================================================== */
#define XIP_SSI_TXD_DRIVE_EDGE_TDE_Pos    (0UL)                     /*!< TDE (Bit 0)                                           */
#define XIP_SSI_TXD_DRIVE_EDGE_TDE_Msk    (0xffUL)                  /*!< TDE (Bitfield-Mask: 0xff)                             */


/* =========================================================================================================================== */
/* ================                                          SYSINFO                                          ================ */
/* =========================================================================================================================== */

/* ========================================================  CHIP_ID  ======================================================== */
#define SYSINFO_CHIP_ID_REVISION_Pos      (28UL)                    /*!< REVISION (Bit 28)                                     */
#define SYSINFO_CHIP_ID_REVISION_Msk      (0xf0000000UL)            /*!< REVISION (Bitfield-Mask: 0x0f)                        */
#define SYSINFO_CHIP_ID_PART_Pos          (12UL)                    /*!< PART (Bit 12)                                         */
#define SYSINFO_CHIP_ID_PART_Msk          (0xffff000UL)             /*!< PART (Bitfield-Mask: 0xffff)                          */
#define SYSINFO_CHIP_ID_MANUFACTURER_Pos  (0UL)                     /*!< MANUFACTURER (Bit 0)                                  */
#define SYSINFO_CHIP_ID_MANUFACTURER_Msk  (0xfffUL)                 /*!< MANUFACTURER (Bitfield-Mask: 0xfff)                   */
/* =======================================================  PLATFORM  ======================================================== */
#define SYSINFO_PLATFORM_ASIC_Pos         (1UL)                     /*!< ASIC (Bit 1)                                          */
#define SYSINFO_PLATFORM_ASIC_Msk         (0x2UL)                   /*!< ASIC (Bitfield-Mask: 0x01)                            */
#define SYSINFO_PLATFORM_FPGA_Pos         (0UL)                     /*!< FPGA (Bit 0)                                          */
#define SYSINFO_PLATFORM_FPGA_Msk         (0x1UL)                   /*!< FPGA (Bitfield-Mask: 0x01)                            */
/* =====================================================  GITREF_RP2040  ===================================================== */


/* =========================================================================================================================== */
/* ================                                          SYSCFG                                           ================ */
/* =========================================================================================================================== */

/* ====================================================  PROC0_NMI_MASK  ===================================================== */
/* ====================================================  PROC1_NMI_MASK  ===================================================== */
/* ======================================================  PROC_CONFIG  ====================================================== */
#define SYSCFG_PROC_CONFIG_PROC1_DAP_INSTID_Pos (28UL)              /*!< PROC1_DAP_INSTID (Bit 28)                             */
#define SYSCFG_PROC_CONFIG_PROC1_DAP_INSTID_Msk (0xf0000000UL)      /*!< PROC1_DAP_INSTID (Bitfield-Mask: 0x0f)                */
#define SYSCFG_PROC_CONFIG_PROC0_DAP_INSTID_Pos (24UL)              /*!< PROC0_DAP_INSTID (Bit 24)                             */
#define SYSCFG_PROC_CONFIG_PROC0_DAP_INSTID_Msk (0xf000000UL)       /*!< PROC0_DAP_INSTID (Bitfield-Mask: 0x0f)                */
#define SYSCFG_PROC_CONFIG_PROC1_HALTED_Pos (1UL)                   /*!< PROC1_HALTED (Bit 1)                                  */
#define SYSCFG_PROC_CONFIG_PROC1_HALTED_Msk (0x2UL)                 /*!< PROC1_HALTED (Bitfield-Mask: 0x01)                    */
#define SYSCFG_PROC_CONFIG_PROC0_HALTED_Pos (0UL)                   /*!< PROC0_HALTED (Bit 0)                                  */
#define SYSCFG_PROC_CONFIG_PROC0_HALTED_Msk (0x1UL)                 /*!< PROC0_HALTED (Bitfield-Mask: 0x01)                    */
/* ==================================================  PROC_IN_SYNC_BYPASS  ================================================== */
#define SYSCFG_PROC_IN_SYNC_BYPASS_PROC_IN_SYNC_BYPASS_Pos (0UL)    /*!< PROC_IN_SYNC_BYPASS (Bit 0)                           */
#define SYSCFG_PROC_IN_SYNC_BYPASS_PROC_IN_SYNC_BYPASS_Msk (0x3fffffffUL) /*!< PROC_IN_SYNC_BYPASS (Bitfield-Mask: 0x3fffffff) */
/* ================================================  PROC_IN_SYNC_BYPASS_HI  ================================================= */
#define SYSCFG_PROC_IN_SYNC_BYPASS_HI_PROC_IN_SYNC_BYPASS_HI_Pos (0UL) /*!< PROC_IN_SYNC_BYPASS_HI (Bit 0)                     */
#define SYSCFG_PROC_IN_SYNC_BYPASS_HI_PROC_IN_SYNC_BYPASS_HI_Msk (0x3fUL) /*!< PROC_IN_SYNC_BYPASS_HI (Bitfield-Mask: 0x3f)    */
/* =======================================================  DBGFORCE  ======================================================== */
#define SYSCFG_DBGFORCE_PROC1_ATTACH_Pos  (7UL)                     /*!< PROC1_ATTACH (Bit 7)                                  */
#define SYSCFG_DBGFORCE_PROC1_ATTACH_Msk  (0x80UL)                  /*!< PROC1_ATTACH (Bitfield-Mask: 0x01)                    */
#define SYSCFG_DBGFORCE_PROC1_SWCLK_Pos   (6UL)                     /*!< PROC1_SWCLK (Bit 6)                                   */
#define SYSCFG_DBGFORCE_PROC1_SWCLK_Msk   (0x40UL)                  /*!< PROC1_SWCLK (Bitfield-Mask: 0x01)                     */
#define SYSCFG_DBGFORCE_PROC1_SWDI_Pos    (5UL)                     /*!< PROC1_SWDI (Bit 5)                                    */
#define SYSCFG_DBGFORCE_PROC1_SWDI_Msk    (0x20UL)                  /*!< PROC1_SWDI (Bitfield-Mask: 0x01)                      */
#define SYSCFG_DBGFORCE_PROC1_SWDO_Pos    (4UL)                     /*!< PROC1_SWDO (Bit 4)                                    */
#define SYSCFG_DBGFORCE_PROC1_SWDO_Msk    (0x10UL)                  /*!< PROC1_SWDO (Bitfield-Mask: 0x01)                      */
#define SYSCFG_DBGFORCE_PROC0_ATTACH_Pos  (3UL)                     /*!< PROC0_ATTACH (Bit 3)                                  */
#define SYSCFG_DBGFORCE_PROC0_ATTACH_Msk  (0x8UL)                   /*!< PROC0_ATTACH (Bitfield-Mask: 0x01)                    */
#define SYSCFG_DBGFORCE_PROC0_SWCLK_Pos   (2UL)                     /*!< PROC0_SWCLK (Bit 2)                                   */
#define SYSCFG_DBGFORCE_PROC0_SWCLK_Msk   (0x4UL)                   /*!< PROC0_SWCLK (Bitfield-Mask: 0x01)                     */
#define SYSCFG_DBGFORCE_PROC0_SWDI_Pos    (1UL)                     /*!< PROC0_SWDI (Bit 1)                                    */
#define SYSCFG_DBGFORCE_PROC0_SWDI_Msk    (0x2UL)                   /*!< PROC0_SWDI (Bitfield-Mask: 0x01)                      */
#define SYSCFG_DBGFORCE_PROC0_SWDO_Pos    (0UL)                     /*!< PROC0_SWDO (Bit 0)                                    */
#define SYSCFG_DBGFORCE_PROC0_SWDO_Msk    (0x1UL)                   /*!< PROC0_SWDO (Bitfield-Mask: 0x01)                      */
/* =====================================================  MEMPOWERDOWN  ====================================================== */
#define SYSCFG_MEMPOWERDOWN_ROM_Pos       (7UL)                     /*!< ROM (Bit 7)                                           */
#define SYSCFG_MEMPOWERDOWN_ROM_Msk       (0x80UL)                  /*!< ROM (Bitfield-Mask: 0x01)                             */
#define SYSCFG_MEMPOWERDOWN_USB_Pos       (6UL)                     /*!< USB (Bit 6)                                           */
#define SYSCFG_MEMPOWERDOWN_USB_Msk       (0x40UL)                  /*!< USB (Bitfield-Mask: 0x01)                             */
#define SYSCFG_MEMPOWERDOWN_SRAM5_Pos     (5UL)                     /*!< SRAM5 (Bit 5)                                         */
#define SYSCFG_MEMPOWERDOWN_SRAM5_Msk     (0x20UL)                  /*!< SRAM5 (Bitfield-Mask: 0x01)                           */
#define SYSCFG_MEMPOWERDOWN_SRAM4_Pos     (4UL)                     /*!< SRAM4 (Bit 4)                                         */
#define SYSCFG_MEMPOWERDOWN_SRAM4_Msk     (0x10UL)                  /*!< SRAM4 (Bitfield-Mask: 0x01)                           */
#define SYSCFG_MEMPOWERDOWN_SRAM3_Pos     (3UL)                     /*!< SRAM3 (Bit 3)                                         */
#define SYSCFG_MEMPOWERDOWN_SRAM3_Msk     (0x8UL)                   /*!< SRAM3 (Bitfield-Mask: 0x01)                           */
#define SYSCFG_MEMPOWERDOWN_SRAM2_Pos     (2UL)                     /*!< SRAM2 (Bit 2)                                         */
#define SYSCFG_MEMPOWERDOWN_SRAM2_Msk     (0x4UL)                   /*!< SRAM2 (Bitfield-Mask: 0x01)                           */
#define SYSCFG_MEMPOWERDOWN_SRAM1_Pos     (1UL)                     /*!< SRAM1 (Bit 1)                                         */
#define SYSCFG_MEMPOWERDOWN_SRAM1_Msk     (0x2UL)                   /*!< SRAM1 (Bitfield-Mask: 0x01)                           */
#define SYSCFG_MEMPOWERDOWN_SRAM0_Pos     (0UL)                     /*!< SRAM0 (Bit 0)                                         */
#define SYSCFG_MEMPOWERDOWN_SRAM0_Msk     (0x1UL)                   /*!< SRAM0 (Bitfield-Mask: 0x01)                           */


/* =========================================================================================================================== */
/* ================                                          CLOCKS                                           ================ */
/* =========================================================================================================================== */

/* ====================================================  CLK_GPOUT0_CTRL  ==================================================== */
#define CLOCKS_CLK_GPOUT0_CTRL_NUDGE_Pos  (20UL)                    /*!< NUDGE (Bit 20)                                        */
#define CLOCKS_CLK_GPOUT0_CTRL_NUDGE_Msk  (0x100000UL)              /*!< NUDGE (Bitfield-Mask: 0x01)                           */
#define CLOCKS_CLK_GPOUT0_CTRL_PHASE_Pos  (16UL)                    /*!< PHASE (Bit 16)                                        */
#define CLOCKS_CLK_GPOUT0_CTRL_PHASE_Msk  (0x30000UL)               /*!< PHASE (Bitfield-Mask: 0x03)                           */
#define CLOCKS_CLK_GPOUT0_CTRL_DC50_Pos   (12UL)                    /*!< DC50 (Bit 12)                                         */
#define CLOCKS_CLK_GPOUT0_CTRL_DC50_Msk   (0x1000UL)                /*!< DC50 (Bitfield-Mask: 0x01)                            */
#define CLOCKS_CLK_GPOUT0_CTRL_ENABLE_Pos (11UL)                    /*!< ENABLE (Bit 11)                                       */
#define CLOCKS_CLK_GPOUT0_CTRL_ENABLE_Msk (0x800UL)                 /*!< ENABLE (Bitfield-Mask: 0x01)                          */
#define CLOCKS_CLK_GPOUT0_CTRL_KILL_Pos   (10UL)                    /*!< KILL (Bit 10)                                         */
#define CLOCKS_CLK_GPOUT0_CTRL_KILL_Msk   (0x400UL)                 /*!< KILL (Bitfield-Mask: 0x01)                            */
#define CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_Pos (5UL)                     /*!< AUXSRC (Bit 5)                                        */
#define CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_Msk (0x1e0UL)                 /*!< AUXSRC (Bitfield-Mask: 0x0f)                          */
/* ====================================================  CLK_GPOUT0_DIV  ===================================================== */
#define CLOCKS_CLK_GPOUT0_DIV_INT_Pos     (8UL)                     /*!< INT (Bit 8)                                           */
#define CLOCKS_CLK_GPOUT0_DIV_INT_Msk     (0xffffff00UL)            /*!< INT (Bitfield-Mask: 0xffffff)                         */
#define CLOCKS_CLK_GPOUT0_DIV_FRAC_Pos    (0UL)                     /*!< FRAC (Bit 0)                                          */
#define CLOCKS_CLK_GPOUT0_DIV_FRAC_Msk    (0xffUL)                  /*!< FRAC (Bitfield-Mask: 0xff)                            */
/* ==================================================  CLK_GPOUT0_SELECTED  ================================================== */
/* ====================================================  CLK_GPOUT1_CTRL  ==================================================== */
#define CLOCKS_CLK_GPOUT1_CTRL_NUDGE_Pos  (20UL)                    /*!< NUDGE (Bit 20)                                        */
#define CLOCKS_CLK_GPOUT1_CTRL_NUDGE_Msk  (0x100000UL)              /*!< NUDGE (Bitfield-Mask: 0x01)                           */
#define CLOCKS_CLK_GPOUT1_CTRL_PHASE_Pos  (16UL)                    /*!< PHASE (Bit 16)                                        */
#define CLOCKS_CLK_GPOUT1_CTRL_PHASE_Msk  (0x30000UL)               /*!< PHASE (Bitfield-Mask: 0x03)                           */
#define CLOCKS_CLK_GPOUT1_CTRL_DC50_Pos   (12UL)                    /*!< DC50 (Bit 12)                                         */
#define CLOCKS_CLK_GPOUT1_CTRL_DC50_Msk   (0x1000UL)                /*!< DC50 (Bitfield-Mask: 0x01)                            */
#define CLOCKS_CLK_GPOUT1_CTRL_ENABLE_Pos (11UL)                    /*!< ENABLE (Bit 11)                                       */
#define CLOCKS_CLK_GPOUT1_CTRL_ENABLE_Msk (0x800UL)                 /*!< ENABLE (Bitfield-Mask: 0x01)                          */
#define CLOCKS_CLK_GPOUT1_CTRL_KILL_Pos   (10UL)                    /*!< KILL (Bit 10)                                         */
#define CLOCKS_CLK_GPOUT1_CTRL_KILL_Msk   (0x400UL)                 /*!< KILL (Bitfield-Mask: 0x01)                            */
#define CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_Pos (5UL)                     /*!< AUXSRC (Bit 5)                                        */
#define CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_Msk (0x1e0UL)                 /*!< AUXSRC (Bitfield-Mask: 0x0f)                          */
/* ====================================================  CLK_GPOUT1_DIV  ===================================================== */
#define CLOCKS_CLK_GPOUT1_DIV_INT_Pos     (8UL)                     /*!< INT (Bit 8)                                           */
#define CLOCKS_CLK_GPOUT1_DIV_INT_Msk     (0xffffff00UL)            /*!< INT (Bitfield-Mask: 0xffffff)                         */
#define CLOCKS_CLK_GPOUT1_DIV_FRAC_Pos    (0UL)                     /*!< FRAC (Bit 0)                                          */
#define CLOCKS_CLK_GPOUT1_DIV_FRAC_Msk    (0xffUL)                  /*!< FRAC (Bitfield-Mask: 0xff)                            */
/* ==================================================  CLK_GPOUT1_SELECTED  ================================================== */
/* ====================================================  CLK_GPOUT2_CTRL  ==================================================== */
#define CLOCKS_CLK_GPOUT2_CTRL_NUDGE_Pos  (20UL)                    /*!< NUDGE (Bit 20)                                        */
#define CLOCKS_CLK_GPOUT2_CTRL_NUDGE_Msk  (0x100000UL)              /*!< NUDGE (Bitfield-Mask: 0x01)                           */
#define CLOCKS_CLK_GPOUT2_CTRL_PHASE_Pos  (16UL)                    /*!< PHASE (Bit 16)                                        */
#define CLOCKS_CLK_GPOUT2_CTRL_PHASE_Msk  (0x30000UL)               /*!< PHASE (Bitfield-Mask: 0x03)                           */
#define CLOCKS_CLK_GPOUT2_CTRL_DC50_Pos   (12UL)                    /*!< DC50 (Bit 12)                                         */
#define CLOCKS_CLK_GPOUT2_CTRL_DC50_Msk   (0x1000UL)                /*!< DC50 (Bitfield-Mask: 0x01)                            */
#define CLOCKS_CLK_GPOUT2_CTRL_ENABLE_Pos (11UL)                    /*!< ENABLE (Bit 11)                                       */
#define CLOCKS_CLK_GPOUT2_CTRL_ENABLE_Msk (0x800UL)                 /*!< ENABLE (Bitfield-Mask: 0x01)                          */
#define CLOCKS_CLK_GPOUT2_CTRL_KILL_Pos   (10UL)                    /*!< KILL (Bit 10)                                         */
#define CLOCKS_CLK_GPOUT2_CTRL_KILL_Msk   (0x400UL)                 /*!< KILL (Bitfield-Mask: 0x01)                            */
#define CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_Pos (5UL)                     /*!< AUXSRC (Bit 5)                                        */
#define CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_Msk (0x1e0UL)                 /*!< AUXSRC (Bitfield-Mask: 0x0f)                          */
/* ====================================================  CLK_GPOUT2_DIV  ===================================================== */
#define CLOCKS_CLK_GPOUT2_DIV_INT_Pos     (8UL)                     /*!< INT (Bit 8)                                           */
#define CLOCKS_CLK_GPOUT2_DIV_INT_Msk     (0xffffff00UL)            /*!< INT (Bitfield-Mask: 0xffffff)                         */
#define CLOCKS_CLK_GPOUT2_DIV_FRAC_Pos    (0UL)                     /*!< FRAC (Bit 0)                                          */
#define CLOCKS_CLK_GPOUT2_DIV_FRAC_Msk    (0xffUL)                  /*!< FRAC (Bitfield-Mask: 0xff)                            */
/* ==================================================  CLK_GPOUT2_SELECTED  ================================================== */
/* ====================================================  CLK_GPOUT3_CTRL  ==================================================== */
#define CLOCKS_CLK_GPOUT3_CTRL_NUDGE_Pos  (20UL)                    /*!< NUDGE (Bit 20)                                        */
#define CLOCKS_CLK_GPOUT3_CTRL_NUDGE_Msk  (0x100000UL)              /*!< NUDGE (Bitfield-Mask: 0x01)                           */
#define CLOCKS_CLK_GPOUT3_CTRL_PHASE_Pos  (16UL)                    /*!< PHASE (Bit 16)                                        */
#define CLOCKS_CLK_GPOUT3_CTRL_PHASE_Msk  (0x30000UL)               /*!< PHASE (Bitfield-Mask: 0x03)                           */
#define CLOCKS_CLK_GPOUT3_CTRL_DC50_Pos   (12UL)                    /*!< DC50 (Bit 12)                                         */
#define CLOCKS_CLK_GPOUT3_CTRL_DC50_Msk   (0x1000UL)                /*!< DC50 (Bitfield-Mask: 0x01)                            */
#define CLOCKS_CLK_GPOUT3_CTRL_ENABLE_Pos (11UL)                    /*!< ENABLE (Bit 11)                                       */
#define CLOCKS_CLK_GPOUT3_CTRL_ENABLE_Msk (0x800UL)                 /*!< ENABLE (Bitfield-Mask: 0x01)                          */
#define CLOCKS_CLK_GPOUT3_CTRL_KILL_Pos   (10UL)                    /*!< KILL (Bit 10)                                         */
#define CLOCKS_CLK_GPOUT3_CTRL_KILL_Msk   (0x400UL)                 /*!< KILL (Bitfield-Mask: 0x01)                            */
#define CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_Pos (5UL)                     /*!< AUXSRC (Bit 5)                                        */
#define CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_Msk (0x1e0UL)                 /*!< AUXSRC (Bitfield-Mask: 0x0f)                          */
/* ====================================================  CLK_GPOUT3_DIV  ===================================================== */
#define CLOCKS_CLK_GPOUT3_DIV_INT_Pos     (8UL)                     /*!< INT (Bit 8)                                           */
#define CLOCKS_CLK_GPOUT3_DIV_INT_Msk     (0xffffff00UL)            /*!< INT (Bitfield-Mask: 0xffffff)                         */
#define CLOCKS_CLK_GPOUT3_DIV_FRAC_Pos    (0UL)                     /*!< FRAC (Bit 0)                                          */
#define CLOCKS_CLK_GPOUT3_DIV_FRAC_Msk    (0xffUL)                  /*!< FRAC (Bitfield-Mask: 0xff)                            */
/* ==================================================  CLK_GPOUT3_SELECTED  ================================================== */
/* =====================================================  CLK_REF_CTRL  ====================================================== */
#define CLOCKS_CLK_REF_CTRL_AUXSRC_Pos    (5UL)                     /*!< AUXSRC (Bit 5)                                        */
#define CLOCKS_CLK_REF_CTRL_AUXSRC_Msk    (0x60UL)                  /*!< AUXSRC (Bitfield-Mask: 0x03)                          */
#define CLOCKS_CLK_REF_CTRL_SRC_Pos       (0UL)                     /*!< SRC (Bit 0)                                           */
#define CLOCKS_CLK_REF_CTRL_SRC_Msk       (0x3UL)                   /*!< SRC (Bitfield-Mask: 0x03)                             */
/* ======================================================  CLK_REF_DIV  ====================================================== */
#define CLOCKS_CLK_REF_DIV_INT_Pos        (8UL)                     /*!< INT (Bit 8)                                           */
#define CLOCKS_CLK_REF_DIV_INT_Msk        (0x300UL)                 /*!< INT (Bitfield-Mask: 0x03)                             */
/* ===================================================  CLK_REF_SELECTED  ==================================================== */
/* =====================================================  CLK_SYS_CTRL  ====================================================== */
#define CLOCKS_CLK_SYS_CTRL_AUXSRC_Pos    (5UL)                     /*!< AUXSRC (Bit 5)                                        */
#define CLOCKS_CLK_SYS_CTRL_AUXSRC_Msk    (0xe0UL)                  /*!< AUXSRC (Bitfield-Mask: 0x07)                          */
#define CLOCKS_CLK_SYS_CTRL_SRC_Pos       (0UL)                     /*!< SRC (Bit 0)                                           */
#define CLOCKS_CLK_SYS_CTRL_SRC_Msk       (0x1UL)                   /*!< SRC (Bitfield-Mask: 0x01)                             */
/* ======================================================  CLK_SYS_DIV  ====================================================== */
#define CLOCKS_CLK_SYS_DIV_INT_Pos        (8UL)                     /*!< INT (Bit 8)                                           */
#define CLOCKS_CLK_SYS_DIV_INT_Msk        (0xffffff00UL)            /*!< INT (Bitfield-Mask: 0xffffff)                         */
#define CLOCKS_CLK_SYS_DIV_FRAC_Pos       (0UL)                     /*!< FRAC (Bit 0)                                          */
#define CLOCKS_CLK_SYS_DIV_FRAC_Msk       (0xffUL)                  /*!< FRAC (Bitfield-Mask: 0xff)                            */
/* ===================================================  CLK_SYS_SELECTED  ==================================================== */
/* =====================================================  CLK_PERI_CTRL  ===================================================== */
#define CLOCKS_CLK_PERI_CTRL_ENABLE_Pos   (11UL)                    /*!< ENABLE (Bit 11)                                       */
#define CLOCKS_CLK_PERI_CTRL_ENABLE_Msk   (0x800UL)                 /*!< ENABLE (Bitfield-Mask: 0x01)                          */
#define CLOCKS_CLK_PERI_CTRL_KILL_Pos     (10UL)                    /*!< KILL (Bit 10)                                         */
#define CLOCKS_CLK_PERI_CTRL_KILL_Msk     (0x400UL)                 /*!< KILL (Bitfield-Mask: 0x01)                            */
#define CLOCKS_CLK_PERI_CTRL_AUXSRC_Pos   (5UL)                     /*!< AUXSRC (Bit 5)                                        */
#define CLOCKS_CLK_PERI_CTRL_AUXSRC_Msk   (0xe0UL)                  /*!< AUXSRC (Bitfield-Mask: 0x07)                          */
/* ===================================================  CLK_PERI_SELECTED  =================================================== */
/* =====================================================  CLK_USB_CTRL  ====================================================== */
#define CLOCKS_CLK_USB_CTRL_NUDGE_Pos     (20UL)                    /*!< NUDGE (Bit 20)                                        */
#define CLOCKS_CLK_USB_CTRL_NUDGE_Msk     (0x100000UL)              /*!< NUDGE (Bitfield-Mask: 0x01)                           */
#define CLOCKS_CLK_USB_CTRL_PHASE_Pos     (16UL)                    /*!< PHASE (Bit 16)                                        */
#define CLOCKS_CLK_USB_CTRL_PHASE_Msk     (0x30000UL)               /*!< PHASE (Bitfield-Mask: 0x03)                           */
#define CLOCKS_CLK_USB_CTRL_ENABLE_Pos    (11UL)                    /*!< ENABLE (Bit 11)                                       */
#define CLOCKS_CLK_USB_CTRL_ENABLE_Msk    (0x800UL)                 /*!< ENABLE (Bitfield-Mask: 0x01)                          */
#define CLOCKS_CLK_USB_CTRL_KILL_Pos      (10UL)                    /*!< KILL (Bit 10)                                         */
#define CLOCKS_CLK_USB_CTRL_KILL_Msk      (0x400UL)                 /*!< KILL (Bitfield-Mask: 0x01)                            */
#define CLOCKS_CLK_USB_CTRL_AUXSRC_Pos    (5UL)                     /*!< AUXSRC (Bit 5)                                        */
#define CLOCKS_CLK_USB_CTRL_AUXSRC_Msk    (0xe0UL)                  /*!< AUXSRC (Bitfield-Mask: 0x07)                          */
/* ======================================================  CLK_USB_DIV  ====================================================== */
#define CLOCKS_CLK_USB_DIV_INT_Pos        (8UL)                     /*!< INT (Bit 8)                                           */
#define CLOCKS_CLK_USB_DIV_INT_Msk        (0x300UL)                 /*!< INT (Bitfield-Mask: 0x03)                             */
/* ===================================================  CLK_USB_SELECTED  ==================================================== */
/* =====================================================  CLK_ADC_CTRL  ====================================================== */
#define CLOCKS_CLK_ADC_CTRL_NUDGE_Pos     (20UL)                    /*!< NUDGE (Bit 20)                                        */
#define CLOCKS_CLK_ADC_CTRL_NUDGE_Msk     (0x100000UL)              /*!< NUDGE (Bitfield-Mask: 0x01)                           */
#define CLOCKS_CLK_ADC_CTRL_PHASE_Pos     (16UL)                    /*!< PHASE (Bit 16)                                        */
#define CLOCKS_CLK_ADC_CTRL_PHASE_Msk     (0x30000UL)               /*!< PHASE (Bitfield-Mask: 0x03)                           */
#define CLOCKS_CLK_ADC_CTRL_ENABLE_Pos    (11UL)                    /*!< ENABLE (Bit 11)                                       */
#define CLOCKS_CLK_ADC_CTRL_ENABLE_Msk    (0x800UL)                 /*!< ENABLE (Bitfield-Mask: 0x01)                          */
#define CLOCKS_CLK_ADC_CTRL_KILL_Pos      (10UL)                    /*!< KILL (Bit 10)                                         */
#define CLOCKS_CLK_ADC_CTRL_KILL_Msk      (0x400UL)                 /*!< KILL (Bitfield-Mask: 0x01)                            */
#define CLOCKS_CLK_ADC_CTRL_AUXSRC_Pos    (5UL)                     /*!< AUXSRC (Bit 5)                                        */
#define CLOCKS_CLK_ADC_CTRL_AUXSRC_Msk    (0xe0UL)                  /*!< AUXSRC (Bitfield-Mask: 0x07)                          */
/* ======================================================  CLK_ADC_DIV  ====================================================== */
#define CLOCKS_CLK_ADC_DIV_INT_Pos        (8UL)                     /*!< INT (Bit 8)                                           */
#define CLOCKS_CLK_ADC_DIV_INT_Msk        (0x300UL)                 /*!< INT (Bitfield-Mask: 0x03)                             */
/* ===================================================  CLK_ADC_SELECTED  ==================================================== */
/* =====================================================  CLK_RTC_CTRL  ====================================================== */
#define CLOCKS_CLK_RTC_CTRL_NUDGE_Pos     (20UL)                    /*!< NUDGE (Bit 20)                                        */
#define CLOCKS_CLK_RTC_CTRL_NUDGE_Msk     (0x100000UL)              /*!< NUDGE (Bitfield-Mask: 0x01)                           */
#define CLOCKS_CLK_RTC_CTRL_PHASE_Pos     (16UL)                    /*!< PHASE (Bit 16)                                        */
#define CLOCKS_CLK_RTC_CTRL_PHASE_Msk     (0x30000UL)               /*!< PHASE (Bitfield-Mask: 0x03)                           */
#define CLOCKS_CLK_RTC_CTRL_ENABLE_Pos    (11UL)                    /*!< ENABLE (Bit 11)                                       */
#define CLOCKS_CLK_RTC_CTRL_ENABLE_Msk    (0x800UL)                 /*!< ENABLE (Bitfield-Mask: 0x01)                          */
#define CLOCKS_CLK_RTC_CTRL_KILL_Pos      (10UL)                    /*!< KILL (Bit 10)                                         */
#define CLOCKS_CLK_RTC_CTRL_KILL_Msk      (0x400UL)                 /*!< KILL (Bitfield-Mask: 0x01)                            */
#define CLOCKS_CLK_RTC_CTRL_AUXSRC_Pos    (5UL)                     /*!< AUXSRC (Bit 5)                                        */
#define CLOCKS_CLK_RTC_CTRL_AUXSRC_Msk    (0xe0UL)                  /*!< AUXSRC (Bitfield-Mask: 0x07)                          */
/* ======================================================  CLK_RTC_DIV  ====================================================== */
#define CLOCKS_CLK_RTC_DIV_INT_Pos        (8UL)                     /*!< INT (Bit 8)                                           */
#define CLOCKS_CLK_RTC_DIV_INT_Msk        (0xffffff00UL)            /*!< INT (Bitfield-Mask: 0xffffff)                         */
#define CLOCKS_CLK_RTC_DIV_FRAC_Pos       (0UL)                     /*!< FRAC (Bit 0)                                          */
#define CLOCKS_CLK_RTC_DIV_FRAC_Msk       (0xffUL)                  /*!< FRAC (Bitfield-Mask: 0xff)                            */
/* ===================================================  CLK_RTC_SELECTED  ==================================================== */
/* ==================================================  CLK_SYS_RESUS_CTRL  =================================================== */
#define CLOCKS_CLK_SYS_RESUS_CTRL_CLEAR_Pos (16UL)                  /*!< CLEAR (Bit 16)                                        */
#define CLOCKS_CLK_SYS_RESUS_CTRL_CLEAR_Msk (0x10000UL)             /*!< CLEAR (Bitfield-Mask: 0x01)                           */
#define CLOCKS_CLK_SYS_RESUS_CTRL_FRCE_Pos (12UL)                   /*!< FRCE (Bit 12)                                         */
#define CLOCKS_CLK_SYS_RESUS_CTRL_FRCE_Msk (0x1000UL)               /*!< FRCE (Bitfield-Mask: 0x01)                            */
#define CLOCKS_CLK_SYS_RESUS_CTRL_ENABLE_Pos (8UL)                  /*!< ENABLE (Bit 8)                                        */
#define CLOCKS_CLK_SYS_RESUS_CTRL_ENABLE_Msk (0x100UL)              /*!< ENABLE (Bitfield-Mask: 0x01)                          */
#define CLOCKS_CLK_SYS_RESUS_CTRL_TIMEOUT_Pos (0UL)                 /*!< TIMEOUT (Bit 0)                                       */
#define CLOCKS_CLK_SYS_RESUS_CTRL_TIMEOUT_Msk (0xffUL)              /*!< TIMEOUT (Bitfield-Mask: 0xff)                         */
/* =================================================  CLK_SYS_RESUS_STATUS  ================================================== */
#define CLOCKS_CLK_SYS_RESUS_STATUS_RESUSSED_Pos (0UL)              /*!< RESUSSED (Bit 0)                                      */
#define CLOCKS_CLK_SYS_RESUS_STATUS_RESUSSED_Msk (0x1UL)            /*!< RESUSSED (Bitfield-Mask: 0x01)                        */
/* ======================================================  FC0_REF_KHZ  ====================================================== */
#define CLOCKS_FC0_REF_KHZ_FC0_REF_KHZ_Pos (0UL)                    /*!< FC0_REF_KHZ (Bit 0)                                   */
#define CLOCKS_FC0_REF_KHZ_FC0_REF_KHZ_Msk (0xfffffUL)              /*!< FC0_REF_KHZ (Bitfield-Mask: 0xfffff)                  */
/* ======================================================  FC0_MIN_KHZ  ====================================================== */
#define CLOCKS_FC0_MIN_KHZ_FC0_MIN_KHZ_Pos (0UL)                    /*!< FC0_MIN_KHZ (Bit 0)                                   */
#define CLOCKS_FC0_MIN_KHZ_FC0_MIN_KHZ_Msk (0x1ffffffUL)            /*!< FC0_MIN_KHZ (Bitfield-Mask: 0x1ffffff)                */
/* ======================================================  FC0_MAX_KHZ  ====================================================== */
#define CLOCKS_FC0_MAX_KHZ_FC0_MAX_KHZ_Pos (0UL)                    /*!< FC0_MAX_KHZ (Bit 0)                                   */
#define CLOCKS_FC0_MAX_KHZ_FC0_MAX_KHZ_Msk (0x1ffffffUL)            /*!< FC0_MAX_KHZ (Bitfield-Mask: 0x1ffffff)                */
/* =======================================================  FC0_DELAY  ======================================================= */
#define CLOCKS_FC0_DELAY_FC0_DELAY_Pos    (0UL)                     /*!< FC0_DELAY (Bit 0)                                     */
#define CLOCKS_FC0_DELAY_FC0_DELAY_Msk    (0x7UL)                   /*!< FC0_DELAY (Bitfield-Mask: 0x07)                       */
/* =====================================================  FC0_INTERVAL  ====================================================== */
#define CLOCKS_FC0_INTERVAL_FC0_INTERVAL_Pos (0UL)                  /*!< FC0_INTERVAL (Bit 0)                                  */
#define CLOCKS_FC0_INTERVAL_FC0_INTERVAL_Msk (0xfUL)                /*!< FC0_INTERVAL (Bitfield-Mask: 0x0f)                    */
/* ========================================================  FC0_SRC  ======================================================== */
#define CLOCKS_FC0_SRC_FC0_SRC_Pos        (0UL)                     /*!< FC0_SRC (Bit 0)                                       */
#define CLOCKS_FC0_SRC_FC0_SRC_Msk        (0xffUL)                  /*!< FC0_SRC (Bitfield-Mask: 0xff)                         */
/* ======================================================  FC0_STATUS  ======================================================= */
#define CLOCKS_FC0_STATUS_DIED_Pos        (28UL)                    /*!< DIED (Bit 28)                                         */
#define CLOCKS_FC0_STATUS_DIED_Msk        (0x10000000UL)            /*!< DIED (Bitfield-Mask: 0x01)                            */
#define CLOCKS_FC0_STATUS_FAST_Pos        (24UL)                    /*!< FAST (Bit 24)                                         */
#define CLOCKS_FC0_STATUS_FAST_Msk        (0x1000000UL)             /*!< FAST (Bitfield-Mask: 0x01)                            */
#define CLOCKS_FC0_STATUS_SLOW_Pos        (20UL)                    /*!< SLOW (Bit 20)                                         */
#define CLOCKS_FC0_STATUS_SLOW_Msk        (0x100000UL)              /*!< SLOW (Bitfield-Mask: 0x01)                            */
#define CLOCKS_FC0_STATUS_FAIL_Pos        (16UL)                    /*!< FAIL (Bit 16)                                         */
#define CLOCKS_FC0_STATUS_FAIL_Msk        (0x10000UL)               /*!< FAIL (Bitfield-Mask: 0x01)                            */
#define CLOCKS_FC0_STATUS_WAITING_Pos     (12UL)                    /*!< WAITING (Bit 12)                                      */
#define CLOCKS_FC0_STATUS_WAITING_Msk     (0x1000UL)                /*!< WAITING (Bitfield-Mask: 0x01)                         */
#define CLOCKS_FC0_STATUS_RUNNING_Pos     (8UL)                     /*!< RUNNING (Bit 8)                                       */
#define CLOCKS_FC0_STATUS_RUNNING_Msk     (0x100UL)                 /*!< RUNNING (Bitfield-Mask: 0x01)                         */
#define CLOCKS_FC0_STATUS_DONE_Pos        (4UL)                     /*!< DONE (Bit 4)                                          */
#define CLOCKS_FC0_STATUS_DONE_Msk        (0x10UL)                  /*!< DONE (Bitfield-Mask: 0x01)                            */
#define CLOCKS_FC0_STATUS_PASS_Pos        (0UL)                     /*!< PASS (Bit 0)                                          */
#define CLOCKS_FC0_STATUS_PASS_Msk        (0x1UL)                   /*!< PASS (Bitfield-Mask: 0x01)                            */
/* ======================================================  FC0_RESULT  ======================================================= */
#define CLOCKS_FC0_RESULT_KHZ_Pos         (5UL)                     /*!< KHZ (Bit 5)                                           */
#define CLOCKS_FC0_RESULT_KHZ_Msk         (0x3fffffe0UL)            /*!< KHZ (Bitfield-Mask: 0x1ffffff)                        */
#define CLOCKS_FC0_RESULT_FRAC_Pos        (0UL)                     /*!< FRAC (Bit 0)                                          */
#define CLOCKS_FC0_RESULT_FRAC_Msk        (0x1fUL)                  /*!< FRAC (Bitfield-Mask: 0x1f)                            */
/* =======================================================  WAKE_EN0  ======================================================== */
#define CLOCKS_WAKE_EN0_clk_sys_sram3_Pos (31UL)                    /*!< clk_sys_sram3 (Bit 31)                                */
#define CLOCKS_WAKE_EN0_clk_sys_sram3_Msk (0x80000000UL)            /*!< clk_sys_sram3 (Bitfield-Mask: 0x01)                   */
#define CLOCKS_WAKE_EN0_clk_sys_sram2_Pos (30UL)                    /*!< clk_sys_sram2 (Bit 30)                                */
#define CLOCKS_WAKE_EN0_clk_sys_sram2_Msk (0x40000000UL)            /*!< clk_sys_sram2 (Bitfield-Mask: 0x01)                   */
#define CLOCKS_WAKE_EN0_clk_sys_sram1_Pos (29UL)                    /*!< clk_sys_sram1 (Bit 29)                                */
#define CLOCKS_WAKE_EN0_clk_sys_sram1_Msk (0x20000000UL)            /*!< clk_sys_sram1 (Bitfield-Mask: 0x01)                   */
#define CLOCKS_WAKE_EN0_clk_sys_sram0_Pos (28UL)                    /*!< clk_sys_sram0 (Bit 28)                                */
#define CLOCKS_WAKE_EN0_clk_sys_sram0_Msk (0x10000000UL)            /*!< clk_sys_sram0 (Bitfield-Mask: 0x01)                   */
#define CLOCKS_WAKE_EN0_clk_sys_spi1_Pos  (27UL)                    /*!< clk_sys_spi1 (Bit 27)                                 */
#define CLOCKS_WAKE_EN0_clk_sys_spi1_Msk  (0x8000000UL)             /*!< clk_sys_spi1 (Bitfield-Mask: 0x01)                    */
#define CLOCKS_WAKE_EN0_clk_peri_spi1_Pos (26UL)                    /*!< clk_peri_spi1 (Bit 26)                                */
#define CLOCKS_WAKE_EN0_clk_peri_spi1_Msk (0x4000000UL)             /*!< clk_peri_spi1 (Bitfield-Mask: 0x01)                   */
#define CLOCKS_WAKE_EN0_clk_sys_spi0_Pos  (25UL)                    /*!< clk_sys_spi0 (Bit 25)                                 */
#define CLOCKS_WAKE_EN0_clk_sys_spi0_Msk  (0x2000000UL)             /*!< clk_sys_spi0 (Bitfield-Mask: 0x01)                    */
#define CLOCKS_WAKE_EN0_clk_peri_spi0_Pos (24UL)                    /*!< clk_peri_spi0 (Bit 24)                                */
#define CLOCKS_WAKE_EN0_clk_peri_spi0_Msk (0x1000000UL)             /*!< clk_peri_spi0 (Bitfield-Mask: 0x01)                   */
#define CLOCKS_WAKE_EN0_clk_sys_sio_Pos   (23UL)                    /*!< clk_sys_sio (Bit 23)                                  */
#define CLOCKS_WAKE_EN0_clk_sys_sio_Msk   (0x800000UL)              /*!< clk_sys_sio (Bitfield-Mask: 0x01)                     */
#define CLOCKS_WAKE_EN0_clk_sys_rtc_Pos   (22UL)                    /*!< clk_sys_rtc (Bit 22)                                  */
#define CLOCKS_WAKE_EN0_clk_sys_rtc_Msk   (0x400000UL)              /*!< clk_sys_rtc (Bitfield-Mask: 0x01)                     */
#define CLOCKS_WAKE_EN0_clk_rtc_rtc_Pos   (21UL)                    /*!< clk_rtc_rtc (Bit 21)                                  */
#define CLOCKS_WAKE_EN0_clk_rtc_rtc_Msk   (0x200000UL)              /*!< clk_rtc_rtc (Bitfield-Mask: 0x01)                     */
#define CLOCKS_WAKE_EN0_clk_sys_rosc_Pos  (20UL)                    /*!< clk_sys_rosc (Bit 20)                                 */
#define CLOCKS_WAKE_EN0_clk_sys_rosc_Msk  (0x100000UL)              /*!< clk_sys_rosc (Bitfield-Mask: 0x01)                    */
#define CLOCKS_WAKE_EN0_clk_sys_rom_Pos   (19UL)                    /*!< clk_sys_rom (Bit 19)                                  */
#define CLOCKS_WAKE_EN0_clk_sys_rom_Msk   (0x80000UL)               /*!< clk_sys_rom (Bitfield-Mask: 0x01)                     */
#define CLOCKS_WAKE_EN0_clk_sys_resets_Pos (18UL)                   /*!< clk_sys_resets (Bit 18)                               */
#define CLOCKS_WAKE_EN0_clk_sys_resets_Msk (0x40000UL)              /*!< clk_sys_resets (Bitfield-Mask: 0x01)                  */
#define CLOCKS_WAKE_EN0_clk_sys_pwm_Pos   (17UL)                    /*!< clk_sys_pwm (Bit 17)                                  */
#define CLOCKS_WAKE_EN0_clk_sys_pwm_Msk   (0x20000UL)               /*!< clk_sys_pwm (Bitfield-Mask: 0x01)                     */
#define CLOCKS_WAKE_EN0_clk_sys_psm_Pos   (16UL)                    /*!< clk_sys_psm (Bit 16)                                  */
#define CLOCKS_WAKE_EN0_clk_sys_psm_Msk   (0x10000UL)               /*!< clk_sys_psm (Bitfield-Mask: 0x01)                     */
#define CLOCKS_WAKE_EN0_clk_sys_pll_usb_Pos (15UL)                  /*!< clk_sys_pll_usb (Bit 15)                              */
#define CLOCKS_WAKE_EN0_clk_sys_pll_usb_Msk (0x8000UL)              /*!< clk_sys_pll_usb (Bitfield-Mask: 0x01)                 */
#define CLOCKS_WAKE_EN0_clk_sys_pll_sys_Pos (14UL)                  /*!< clk_sys_pll_sys (Bit 14)                              */
#define CLOCKS_WAKE_EN0_clk_sys_pll_sys_Msk (0x4000UL)              /*!< clk_sys_pll_sys (Bitfield-Mask: 0x01)                 */
#define CLOCKS_WAKE_EN0_clk_sys_pio1_Pos  (13UL)                    /*!< clk_sys_pio1 (Bit 13)                                 */
#define CLOCKS_WAKE_EN0_clk_sys_pio1_Msk  (0x2000UL)                /*!< clk_sys_pio1 (Bitfield-Mask: 0x01)                    */
#define CLOCKS_WAKE_EN0_clk_sys_pio0_Pos  (12UL)                    /*!< clk_sys_pio0 (Bit 12)                                 */
#define CLOCKS_WAKE_EN0_clk_sys_pio0_Msk  (0x1000UL)                /*!< clk_sys_pio0 (Bitfield-Mask: 0x01)                    */
#define CLOCKS_WAKE_EN0_clk_sys_pads_Pos  (11UL)                    /*!< clk_sys_pads (Bit 11)                                 */
#define CLOCKS_WAKE_EN0_clk_sys_pads_Msk  (0x800UL)                 /*!< clk_sys_pads (Bitfield-Mask: 0x01)                    */
#define CLOCKS_WAKE_EN0_clk_sys_vreg_and_chip_reset_Pos (10UL)      /*!< clk_sys_vreg_and_chip_reset (Bit 10)                  */
#define CLOCKS_WAKE_EN0_clk_sys_vreg_and_chip_reset_Msk (0x400UL)   /*!< clk_sys_vreg_and_chip_reset (Bitfield-Mask: 0x01)     */
#define CLOCKS_WAKE_EN0_clk_sys_jtag_Pos  (9UL)                     /*!< clk_sys_jtag (Bit 9)                                  */
#define CLOCKS_WAKE_EN0_clk_sys_jtag_Msk  (0x200UL)                 /*!< clk_sys_jtag (Bitfield-Mask: 0x01)                    */
#define CLOCKS_WAKE_EN0_clk_sys_io_Pos    (8UL)                     /*!< clk_sys_io (Bit 8)                                    */
#define CLOCKS_WAKE_EN0_clk_sys_io_Msk    (0x100UL)                 /*!< clk_sys_io (Bitfield-Mask: 0x01)                      */
#define CLOCKS_WAKE_EN0_clk_sys_i2c1_Pos  (7UL)                     /*!< clk_sys_i2c1 (Bit 7)                                  */
#define CLOCKS_WAKE_EN0_clk_sys_i2c1_Msk  (0x80UL)                  /*!< clk_sys_i2c1 (Bitfield-Mask: 0x01)                    */
#define CLOCKS_WAKE_EN0_clk_sys_i2c0_Pos  (6UL)                     /*!< clk_sys_i2c0 (Bit 6)                                  */
#define CLOCKS_WAKE_EN0_clk_sys_i2c0_Msk  (0x40UL)                  /*!< clk_sys_i2c0 (Bitfield-Mask: 0x01)                    */
#define CLOCKS_WAKE_EN0_clk_sys_dma_Pos   (5UL)                     /*!< clk_sys_dma (Bit 5)                                   */
#define CLOCKS_WAKE_EN0_clk_sys_dma_Msk   (0x20UL)                  /*!< clk_sys_dma (Bitfield-Mask: 0x01)                     */
#define CLOCKS_WAKE_EN0_clk_sys_busfabric_Pos (4UL)                 /*!< clk_sys_busfabric (Bit 4)                             */
#define CLOCKS_WAKE_EN0_clk_sys_busfabric_Msk (0x10UL)              /*!< clk_sys_busfabric (Bitfield-Mask: 0x01)               */
#define CLOCKS_WAKE_EN0_clk_sys_busctrl_Pos (3UL)                   /*!< clk_sys_busctrl (Bit 3)                               */
#define CLOCKS_WAKE_EN0_clk_sys_busctrl_Msk (0x8UL)                 /*!< clk_sys_busctrl (Bitfield-Mask: 0x01)                 */
#define CLOCKS_WAKE_EN0_clk_sys_adc_Pos   (2UL)                     /*!< clk_sys_adc (Bit 2)                                   */
#define CLOCKS_WAKE_EN0_clk_sys_adc_Msk   (0x4UL)                   /*!< clk_sys_adc (Bitfield-Mask: 0x01)                     */
#define CLOCKS_WAKE_EN0_clk_adc_adc_Pos   (1UL)                     /*!< clk_adc_adc (Bit 1)                                   */
#define CLOCKS_WAKE_EN0_clk_adc_adc_Msk   (0x2UL)                   /*!< clk_adc_adc (Bitfield-Mask: 0x01)                     */
#define CLOCKS_WAKE_EN0_clk_sys_clocks_Pos (0UL)                    /*!< clk_sys_clocks (Bit 0)                                */
#define CLOCKS_WAKE_EN0_clk_sys_clocks_Msk (0x1UL)                  /*!< clk_sys_clocks (Bitfield-Mask: 0x01)                  */
/* =======================================================  WAKE_EN1  ======================================================== */
#define CLOCKS_WAKE_EN1_clk_sys_xosc_Pos  (14UL)                    /*!< clk_sys_xosc (Bit 14)                                 */
#define CLOCKS_WAKE_EN1_clk_sys_xosc_Msk  (0x4000UL)                /*!< clk_sys_xosc (Bitfield-Mask: 0x01)                    */
#define CLOCKS_WAKE_EN1_clk_sys_xip_Pos   (13UL)                    /*!< clk_sys_xip (Bit 13)                                  */
#define CLOCKS_WAKE_EN1_clk_sys_xip_Msk   (0x2000UL)                /*!< clk_sys_xip (Bitfield-Mask: 0x01)                     */
#define CLOCKS_WAKE_EN1_clk_sys_watchdog_Pos (12UL)                 /*!< clk_sys_watchdog (Bit 12)                             */
#define CLOCKS_WAKE_EN1_clk_sys_watchdog_Msk (0x1000UL)             /*!< clk_sys_watchdog (Bitfield-Mask: 0x01)                */
#define CLOCKS_WAKE_EN1_clk_usb_usbctrl_Pos (11UL)                  /*!< clk_usb_usbctrl (Bit 11)                              */
#define CLOCKS_WAKE_EN1_clk_usb_usbctrl_Msk (0x800UL)               /*!< clk_usb_usbctrl (Bitfield-Mask: 0x01)                 */
#define CLOCKS_WAKE_EN1_clk_sys_usbctrl_Pos (10UL)                  /*!< clk_sys_usbctrl (Bit 10)                              */
#define CLOCKS_WAKE_EN1_clk_sys_usbctrl_Msk (0x400UL)               /*!< clk_sys_usbctrl (Bitfield-Mask: 0x01)                 */
#define CLOCKS_WAKE_EN1_clk_sys_uart1_Pos (9UL)                     /*!< clk_sys_uart1 (Bit 9)                                 */
#define CLOCKS_WAKE_EN1_clk_sys_uart1_Msk (0x200UL)                 /*!< clk_sys_uart1 (Bitfield-Mask: 0x01)                   */
#define CLOCKS_WAKE_EN1_clk_peri_uart1_Pos (8UL)                    /*!< clk_peri_uart1 (Bit 8)                                */
#define CLOCKS_WAKE_EN1_clk_peri_uart1_Msk (0x100UL)                /*!< clk_peri_uart1 (Bitfield-Mask: 0x01)                  */
#define CLOCKS_WAKE_EN1_clk_sys_uart0_Pos (7UL)                     /*!< clk_sys_uart0 (Bit 7)                                 */
#define CLOCKS_WAKE_EN1_clk_sys_uart0_Msk (0x80UL)                  /*!< clk_sys_uart0 (Bitfield-Mask: 0x01)                   */
#define CLOCKS_WAKE_EN1_clk_peri_uart0_Pos (6UL)                    /*!< clk_peri_uart0 (Bit 6)                                */
#define CLOCKS_WAKE_EN1_clk_peri_uart0_Msk (0x40UL)                 /*!< clk_peri_uart0 (Bitfield-Mask: 0x01)                  */
#define CLOCKS_WAKE_EN1_clk_sys_timer_Pos (5UL)                     /*!< clk_sys_timer (Bit 5)                                 */
#define CLOCKS_WAKE_EN1_clk_sys_timer_Msk (0x20UL)                  /*!< clk_sys_timer (Bitfield-Mask: 0x01)                   */
#define CLOCKS_WAKE_EN1_clk_sys_tbman_Pos (4UL)                     /*!< clk_sys_tbman (Bit 4)                                 */
#define CLOCKS_WAKE_EN1_clk_sys_tbman_Msk (0x10UL)                  /*!< clk_sys_tbman (Bitfield-Mask: 0x01)                   */
#define CLOCKS_WAKE_EN1_clk_sys_sysinfo_Pos (3UL)                   /*!< clk_sys_sysinfo (Bit 3)                               */
#define CLOCKS_WAKE_EN1_clk_sys_sysinfo_Msk (0x8UL)                 /*!< clk_sys_sysinfo (Bitfield-Mask: 0x01)                 */
#define CLOCKS_WAKE_EN1_clk_sys_syscfg_Pos (2UL)                    /*!< clk_sys_syscfg (Bit 2)                                */
#define CLOCKS_WAKE_EN1_clk_sys_syscfg_Msk (0x4UL)                  /*!< clk_sys_syscfg (Bitfield-Mask: 0x01)                  */
#define CLOCKS_WAKE_EN1_clk_sys_sram5_Pos (1UL)                     /*!< clk_sys_sram5 (Bit 1)                                 */
#define CLOCKS_WAKE_EN1_clk_sys_sram5_Msk (0x2UL)                   /*!< clk_sys_sram5 (Bitfield-Mask: 0x01)                   */
#define CLOCKS_WAKE_EN1_clk_sys_sram4_Pos (0UL)                     /*!< clk_sys_sram4 (Bit 0)                                 */
#define CLOCKS_WAKE_EN1_clk_sys_sram4_Msk (0x1UL)                   /*!< clk_sys_sram4 (Bitfield-Mask: 0x01)                   */
/* =======================================================  SLEEP_EN0  ======================================================= */
#define CLOCKS_SLEEP_EN0_clk_sys_sram3_Pos (31UL)                   /*!< clk_sys_sram3 (Bit 31)                                */
#define CLOCKS_SLEEP_EN0_clk_sys_sram3_Msk (0x80000000UL)           /*!< clk_sys_sram3 (Bitfield-Mask: 0x01)                   */
#define CLOCKS_SLEEP_EN0_clk_sys_sram2_Pos (30UL)                   /*!< clk_sys_sram2 (Bit 30)                                */
#define CLOCKS_SLEEP_EN0_clk_sys_sram2_Msk (0x40000000UL)           /*!< clk_sys_sram2 (Bitfield-Mask: 0x01)                   */
#define CLOCKS_SLEEP_EN0_clk_sys_sram1_Pos (29UL)                   /*!< clk_sys_sram1 (Bit 29)                                */
#define CLOCKS_SLEEP_EN0_clk_sys_sram1_Msk (0x20000000UL)           /*!< clk_sys_sram1 (Bitfield-Mask: 0x01)                   */
#define CLOCKS_SLEEP_EN0_clk_sys_sram0_Pos (28UL)                   /*!< clk_sys_sram0 (Bit 28)                                */
#define CLOCKS_SLEEP_EN0_clk_sys_sram0_Msk (0x10000000UL)           /*!< clk_sys_sram0 (Bitfield-Mask: 0x01)                   */
#define CLOCKS_SLEEP_EN0_clk_sys_spi1_Pos (27UL)                    /*!< clk_sys_spi1 (Bit 27)                                 */
#define CLOCKS_SLEEP_EN0_clk_sys_spi1_Msk (0x8000000UL)             /*!< clk_sys_spi1 (Bitfield-Mask: 0x01)                    */
#define CLOCKS_SLEEP_EN0_clk_peri_spi1_Pos (26UL)                   /*!< clk_peri_spi1 (Bit 26)                                */
#define CLOCKS_SLEEP_EN0_clk_peri_spi1_Msk (0x4000000UL)            /*!< clk_peri_spi1 (Bitfield-Mask: 0x01)                   */
#define CLOCKS_SLEEP_EN0_clk_sys_spi0_Pos (25UL)                    /*!< clk_sys_spi0 (Bit 25)                                 */
#define CLOCKS_SLEEP_EN0_clk_sys_spi0_Msk (0x2000000UL)             /*!< clk_sys_spi0 (Bitfield-Mask: 0x01)                    */
#define CLOCKS_SLEEP_EN0_clk_peri_spi0_Pos (24UL)                   /*!< clk_peri_spi0 (Bit 24)                                */
#define CLOCKS_SLEEP_EN0_clk_peri_spi0_Msk (0x1000000UL)            /*!< clk_peri_spi0 (Bitfield-Mask: 0x01)                   */
#define CLOCKS_SLEEP_EN0_clk_sys_sio_Pos  (23UL)                    /*!< clk_sys_sio (Bit 23)                                  */
#define CLOCKS_SLEEP_EN0_clk_sys_sio_Msk  (0x800000UL)              /*!< clk_sys_sio (Bitfield-Mask: 0x01)                     */
#define CLOCKS_SLEEP_EN0_clk_sys_rtc_Pos  (22UL)                    /*!< clk_sys_rtc (Bit 22)                                  */
#define CLOCKS_SLEEP_EN0_clk_sys_rtc_Msk  (0x400000UL)              /*!< clk_sys_rtc (Bitfield-Mask: 0x01)                     */
#define CLOCKS_SLEEP_EN0_clk_rtc_rtc_Pos  (21UL)                    /*!< clk_rtc_rtc (Bit 21)                                  */
#define CLOCKS_SLEEP_EN0_clk_rtc_rtc_Msk  (0x200000UL)              /*!< clk_rtc_rtc (Bitfield-Mask: 0x01)                     */
#define CLOCKS_SLEEP_EN0_clk_sys_rosc_Pos (20UL)                    /*!< clk_sys_rosc (Bit 20)                                 */
#define CLOCKS_SLEEP_EN0_clk_sys_rosc_Msk (0x100000UL)              /*!< clk_sys_rosc (Bitfield-Mask: 0x01)                    */
#define CLOCKS_SLEEP_EN0_clk_sys_rom_Pos  (19UL)                    /*!< clk_sys_rom (Bit 19)                                  */
#define CLOCKS_SLEEP_EN0_clk_sys_rom_Msk  (0x80000UL)               /*!< clk_sys_rom (Bitfield-Mask: 0x01)                     */
#define CLOCKS_SLEEP_EN0_clk_sys_resets_Pos (18UL)                  /*!< clk_sys_resets (Bit 18)                               */
#define CLOCKS_SLEEP_EN0_clk_sys_resets_Msk (0x40000UL)             /*!< clk_sys_resets (Bitfield-Mask: 0x01)                  */
#define CLOCKS_SLEEP_EN0_clk_sys_pwm_Pos  (17UL)                    /*!< clk_sys_pwm (Bit 17)                                  */
#define CLOCKS_SLEEP_EN0_clk_sys_pwm_Msk  (0x20000UL)               /*!< clk_sys_pwm (Bitfield-Mask: 0x01)                     */
#define CLOCKS_SLEEP_EN0_clk_sys_psm_Pos  (16UL)                    /*!< clk_sys_psm (Bit 16)                                  */
#define CLOCKS_SLEEP_EN0_clk_sys_psm_Msk  (0x10000UL)               /*!< clk_sys_psm (Bitfield-Mask: 0x01)                     */
#define CLOCKS_SLEEP_EN0_clk_sys_pll_usb_Pos (15UL)                 /*!< clk_sys_pll_usb (Bit 15)                              */
#define CLOCKS_SLEEP_EN0_clk_sys_pll_usb_Msk (0x8000UL)             /*!< clk_sys_pll_usb (Bitfield-Mask: 0x01)                 */
#define CLOCKS_SLEEP_EN0_clk_sys_pll_sys_Pos (14UL)                 /*!< clk_sys_pll_sys (Bit 14)                              */
#define CLOCKS_SLEEP_EN0_clk_sys_pll_sys_Msk (0x4000UL)             /*!< clk_sys_pll_sys (Bitfield-Mask: 0x01)                 */
#define CLOCKS_SLEEP_EN0_clk_sys_pio1_Pos (13UL)                    /*!< clk_sys_pio1 (Bit 13)                                 */
#define CLOCKS_SLEEP_EN0_clk_sys_pio1_Msk (0x2000UL)                /*!< clk_sys_pio1 (Bitfield-Mask: 0x01)                    */
#define CLOCKS_SLEEP_EN0_clk_sys_pio0_Pos (12UL)                    /*!< clk_sys_pio0 (Bit 12)                                 */
#define CLOCKS_SLEEP_EN0_clk_sys_pio0_Msk (0x1000UL)                /*!< clk_sys_pio0 (Bitfield-Mask: 0x01)                    */
#define CLOCKS_SLEEP_EN0_clk_sys_pads_Pos (11UL)                    /*!< clk_sys_pads (Bit 11)                                 */
#define CLOCKS_SLEEP_EN0_clk_sys_pads_Msk (0x800UL)                 /*!< clk_sys_pads (Bitfield-Mask: 0x01)                    */
#define CLOCKS_SLEEP_EN0_clk_sys_vreg_and_chip_reset_Pos (10UL)     /*!< clk_sys_vreg_and_chip_reset (Bit 10)                  */
#define CLOCKS_SLEEP_EN0_clk_sys_vreg_and_chip_reset_Msk (0x400UL)  /*!< clk_sys_vreg_and_chip_reset (Bitfield-Mask: 0x01)     */
#define CLOCKS_SLEEP_EN0_clk_sys_jtag_Pos (9UL)                     /*!< clk_sys_jtag (Bit 9)                                  */
#define CLOCKS_SLEEP_EN0_clk_sys_jtag_Msk (0x200UL)                 /*!< clk_sys_jtag (Bitfield-Mask: 0x01)                    */
#define CLOCKS_SLEEP_EN0_clk_sys_io_Pos   (8UL)                     /*!< clk_sys_io (Bit 8)                                    */
#define CLOCKS_SLEEP_EN0_clk_sys_io_Msk   (0x100UL)                 /*!< clk_sys_io (Bitfield-Mask: 0x01)                      */
#define CLOCKS_SLEEP_EN0_clk_sys_i2c1_Pos (7UL)                     /*!< clk_sys_i2c1 (Bit 7)                                  */
#define CLOCKS_SLEEP_EN0_clk_sys_i2c1_Msk (0x80UL)                  /*!< clk_sys_i2c1 (Bitfield-Mask: 0x01)                    */
#define CLOCKS_SLEEP_EN0_clk_sys_i2c0_Pos (6UL)                     /*!< clk_sys_i2c0 (Bit 6)                                  */
#define CLOCKS_SLEEP_EN0_clk_sys_i2c0_Msk (0x40UL)                  /*!< clk_sys_i2c0 (Bitfield-Mask: 0x01)                    */
#define CLOCKS_SLEEP_EN0_clk_sys_dma_Pos  (5UL)                     /*!< clk_sys_dma (Bit 5)                                   */
#define CLOCKS_SLEEP_EN0_clk_sys_dma_Msk  (0x20UL)                  /*!< clk_sys_dma (Bitfield-Mask: 0x01)                     */
#define CLOCKS_SLEEP_EN0_clk_sys_busfabric_Pos (4UL)                /*!< clk_sys_busfabric (Bit 4)                             */
#define CLOCKS_SLEEP_EN0_clk_sys_busfabric_Msk (0x10UL)             /*!< clk_sys_busfabric (Bitfield-Mask: 0x01)               */
#define CLOCKS_SLEEP_EN0_clk_sys_busctrl_Pos (3UL)                  /*!< clk_sys_busctrl (Bit 3)                               */
#define CLOCKS_SLEEP_EN0_clk_sys_busctrl_Msk (0x8UL)                /*!< clk_sys_busctrl (Bitfield-Mask: 0x01)                 */
#define CLOCKS_SLEEP_EN0_clk_sys_adc_Pos  (2UL)                     /*!< clk_sys_adc (Bit 2)                                   */
#define CLOCKS_SLEEP_EN0_clk_sys_adc_Msk  (0x4UL)                   /*!< clk_sys_adc (Bitfield-Mask: 0x01)                     */
#define CLOCKS_SLEEP_EN0_clk_adc_adc_Pos  (1UL)                     /*!< clk_adc_adc (Bit 1)                                   */
#define CLOCKS_SLEEP_EN0_clk_adc_adc_Msk  (0x2UL)                   /*!< clk_adc_adc (Bitfield-Mask: 0x01)                     */
#define CLOCKS_SLEEP_EN0_clk_sys_clocks_Pos (0UL)                   /*!< clk_sys_clocks (Bit 0)                                */
#define CLOCKS_SLEEP_EN0_clk_sys_clocks_Msk (0x1UL)                 /*!< clk_sys_clocks (Bitfield-Mask: 0x01)                  */
/* =======================================================  SLEEP_EN1  ======================================================= */
#define CLOCKS_SLEEP_EN1_clk_sys_xosc_Pos (14UL)                    /*!< clk_sys_xosc (Bit 14)                                 */
#define CLOCKS_SLEEP_EN1_clk_sys_xosc_Msk (0x4000UL)                /*!< clk_sys_xosc (Bitfield-Mask: 0x01)                    */
#define CLOCKS_SLEEP_EN1_clk_sys_xip_Pos  (13UL)                    /*!< clk_sys_xip (Bit 13)                                  */
#define CLOCKS_SLEEP_EN1_clk_sys_xip_Msk  (0x2000UL)                /*!< clk_sys_xip (Bitfield-Mask: 0x01)                     */
#define CLOCKS_SLEEP_EN1_clk_sys_watchdog_Pos (12UL)                /*!< clk_sys_watchdog (Bit 12)                             */
#define CLOCKS_SLEEP_EN1_clk_sys_watchdog_Msk (0x1000UL)            /*!< clk_sys_watchdog (Bitfield-Mask: 0x01)                */
#define CLOCKS_SLEEP_EN1_clk_usb_usbctrl_Pos (11UL)                 /*!< clk_usb_usbctrl (Bit 11)                              */
#define CLOCKS_SLEEP_EN1_clk_usb_usbctrl_Msk (0x800UL)              /*!< clk_usb_usbctrl (Bitfield-Mask: 0x01)                 */
#define CLOCKS_SLEEP_EN1_clk_sys_usbctrl_Pos (10UL)                 /*!< clk_sys_usbctrl (Bit 10)                              */
#define CLOCKS_SLEEP_EN1_clk_sys_usbctrl_Msk (0x400UL)              /*!< clk_sys_usbctrl (Bitfield-Mask: 0x01)                 */
#define CLOCKS_SLEEP_EN1_clk_sys_uart1_Pos (9UL)                    /*!< clk_sys_uart1 (Bit 9)                                 */
#define CLOCKS_SLEEP_EN1_clk_sys_uart1_Msk (0x200UL)                /*!< clk_sys_uart1 (Bitfield-Mask: 0x01)                   */
#define CLOCKS_SLEEP_EN1_clk_peri_uart1_Pos (8UL)                   /*!< clk_peri_uart1 (Bit 8)                                */
#define CLOCKS_SLEEP_EN1_clk_peri_uart1_Msk (0x100UL)               /*!< clk_peri_uart1 (Bitfield-Mask: 0x01)                  */
#define CLOCKS_SLEEP_EN1_clk_sys_uart0_Pos (7UL)                    /*!< clk_sys_uart0 (Bit 7)                                 */
#define CLOCKS_SLEEP_EN1_clk_sys_uart0_Msk (0x80UL)                 /*!< clk_sys_uart0 (Bitfield-Mask: 0x01)                   */
#define CLOCKS_SLEEP_EN1_clk_peri_uart0_Pos (6UL)                   /*!< clk_peri_uart0 (Bit 6)                                */
#define CLOCKS_SLEEP_EN1_clk_peri_uart0_Msk (0x40UL)                /*!< clk_peri_uart0 (Bitfield-Mask: 0x01)                  */
#define CLOCKS_SLEEP_EN1_clk_sys_timer_Pos (5UL)                    /*!< clk_sys_timer (Bit 5)                                 */
#define CLOCKS_SLEEP_EN1_clk_sys_timer_Msk (0x20UL)                 /*!< clk_sys_timer (Bitfield-Mask: 0x01)                   */
#define CLOCKS_SLEEP_EN1_clk_sys_tbman_Pos (4UL)                    /*!< clk_sys_tbman (Bit 4)                                 */
#define CLOCKS_SLEEP_EN1_clk_sys_tbman_Msk (0x10UL)                 /*!< clk_sys_tbman (Bitfield-Mask: 0x01)                   */
#define CLOCKS_SLEEP_EN1_clk_sys_sysinfo_Pos (3UL)                  /*!< clk_sys_sysinfo (Bit 3)                               */
#define CLOCKS_SLEEP_EN1_clk_sys_sysinfo_Msk (0x8UL)                /*!< clk_sys_sysinfo (Bitfield-Mask: 0x01)                 */
#define CLOCKS_SLEEP_EN1_clk_sys_syscfg_Pos (2UL)                   /*!< clk_sys_syscfg (Bit 2)                                */
#define CLOCKS_SLEEP_EN1_clk_sys_syscfg_Msk (0x4UL)                 /*!< clk_sys_syscfg (Bitfield-Mask: 0x01)                  */
#define CLOCKS_SLEEP_EN1_clk_sys_sram5_Pos (1UL)                    /*!< clk_sys_sram5 (Bit 1)                                 */
#define CLOCKS_SLEEP_EN1_clk_sys_sram5_Msk (0x2UL)                  /*!< clk_sys_sram5 (Bitfield-Mask: 0x01)                   */
#define CLOCKS_SLEEP_EN1_clk_sys_sram4_Pos (0UL)                    /*!< clk_sys_sram4 (Bit 0)                                 */
#define CLOCKS_SLEEP_EN1_clk_sys_sram4_Msk (0x1UL)                  /*!< clk_sys_sram4 (Bitfield-Mask: 0x01)                   */
/* =======================================================  ENABLED0  ======================================================== */
#define CLOCKS_ENABLED0_clk_sys_sram3_Pos (31UL)                    /*!< clk_sys_sram3 (Bit 31)                                */
#define CLOCKS_ENABLED0_clk_sys_sram3_Msk (0x80000000UL)            /*!< clk_sys_sram3 (Bitfield-Mask: 0x01)                   */
#define CLOCKS_ENABLED0_clk_sys_sram2_Pos (30UL)                    /*!< clk_sys_sram2 (Bit 30)                                */
#define CLOCKS_ENABLED0_clk_sys_sram2_Msk (0x40000000UL)            /*!< clk_sys_sram2 (Bitfield-Mask: 0x01)                   */
#define CLOCKS_ENABLED0_clk_sys_sram1_Pos (29UL)                    /*!< clk_sys_sram1 (Bit 29)                                */
#define CLOCKS_ENABLED0_clk_sys_sram1_Msk (0x20000000UL)            /*!< clk_sys_sram1 (Bitfield-Mask: 0x01)                   */
#define CLOCKS_ENABLED0_clk_sys_sram0_Pos (28UL)                    /*!< clk_sys_sram0 (Bit 28)                                */
#define CLOCKS_ENABLED0_clk_sys_sram0_Msk (0x10000000UL)            /*!< clk_sys_sram0 (Bitfield-Mask: 0x01)                   */
#define CLOCKS_ENABLED0_clk_sys_spi1_Pos  (27UL)                    /*!< clk_sys_spi1 (Bit 27)                                 */
#define CLOCKS_ENABLED0_clk_sys_spi1_Msk  (0x8000000UL)             /*!< clk_sys_spi1 (Bitfield-Mask: 0x01)                    */
#define CLOCKS_ENABLED0_clk_peri_spi1_Pos (26UL)                    /*!< clk_peri_spi1 (Bit 26)                                */
#define CLOCKS_ENABLED0_clk_peri_spi1_Msk (0x4000000UL)             /*!< clk_peri_spi1 (Bitfield-Mask: 0x01)                   */
#define CLOCKS_ENABLED0_clk_sys_spi0_Pos  (25UL)                    /*!< clk_sys_spi0 (Bit 25)                                 */
#define CLOCKS_ENABLED0_clk_sys_spi0_Msk  (0x2000000UL)             /*!< clk_sys_spi0 (Bitfield-Mask: 0x01)                    */
#define CLOCKS_ENABLED0_clk_peri_spi0_Pos (24UL)                    /*!< clk_peri_spi0 (Bit 24)                                */
#define CLOCKS_ENABLED0_clk_peri_spi0_Msk (0x1000000UL)             /*!< clk_peri_spi0 (Bitfield-Mask: 0x01)                   */
#define CLOCKS_ENABLED0_clk_sys_sio_Pos   (23UL)                    /*!< clk_sys_sio (Bit 23)                                  */
#define CLOCKS_ENABLED0_clk_sys_sio_Msk   (0x800000UL)              /*!< clk_sys_sio (Bitfield-Mask: 0x01)                     */
#define CLOCKS_ENABLED0_clk_sys_rtc_Pos   (22UL)                    /*!< clk_sys_rtc (Bit 22)                                  */
#define CLOCKS_ENABLED0_clk_sys_rtc_Msk   (0x400000UL)              /*!< clk_sys_rtc (Bitfield-Mask: 0x01)                     */
#define CLOCKS_ENABLED0_clk_rtc_rtc_Pos   (21UL)                    /*!< clk_rtc_rtc (Bit 21)                                  */
#define CLOCKS_ENABLED0_clk_rtc_rtc_Msk   (0x200000UL)              /*!< clk_rtc_rtc (Bitfield-Mask: 0x01)                     */
#define CLOCKS_ENABLED0_clk_sys_rosc_Pos  (20UL)                    /*!< clk_sys_rosc (Bit 20)                                 */
#define CLOCKS_ENABLED0_clk_sys_rosc_Msk  (0x100000UL)              /*!< clk_sys_rosc (Bitfield-Mask: 0x01)                    */
#define CLOCKS_ENABLED0_clk_sys_rom_Pos   (19UL)                    /*!< clk_sys_rom (Bit 19)                                  */
#define CLOCKS_ENABLED0_clk_sys_rom_Msk   (0x80000UL)               /*!< clk_sys_rom (Bitfield-Mask: 0x01)                     */
#define CLOCKS_ENABLED0_clk_sys_resets_Pos (18UL)                   /*!< clk_sys_resets (Bit 18)                               */
#define CLOCKS_ENABLED0_clk_sys_resets_Msk (0x40000UL)              /*!< clk_sys_resets (Bitfield-Mask: 0x01)                  */
#define CLOCKS_ENABLED0_clk_sys_pwm_Pos   (17UL)                    /*!< clk_sys_pwm (Bit 17)                                  */
#define CLOCKS_ENABLED0_clk_sys_pwm_Msk   (0x20000UL)               /*!< clk_sys_pwm (Bitfield-Mask: 0x01)                     */
#define CLOCKS_ENABLED0_clk_sys_psm_Pos   (16UL)                    /*!< clk_sys_psm (Bit 16)                                  */
#define CLOCKS_ENABLED0_clk_sys_psm_Msk   (0x10000UL)               /*!< clk_sys_psm (Bitfield-Mask: 0x01)                     */
#define CLOCKS_ENABLED0_clk_sys_pll_usb_Pos (15UL)                  /*!< clk_sys_pll_usb (Bit 15)                              */
#define CLOCKS_ENABLED0_clk_sys_pll_usb_Msk (0x8000UL)              /*!< clk_sys_pll_usb (Bitfield-Mask: 0x01)                 */
#define CLOCKS_ENABLED0_clk_sys_pll_sys_Pos (14UL)                  /*!< clk_sys_pll_sys (Bit 14)                              */
#define CLOCKS_ENABLED0_clk_sys_pll_sys_Msk (0x4000UL)              /*!< clk_sys_pll_sys (Bitfield-Mask: 0x01)                 */
#define CLOCKS_ENABLED0_clk_sys_pio1_Pos  (13UL)                    /*!< clk_sys_pio1 (Bit 13)                                 */
#define CLOCKS_ENABLED0_clk_sys_pio1_Msk  (0x2000UL)                /*!< clk_sys_pio1 (Bitfield-Mask: 0x01)                    */
#define CLOCKS_ENABLED0_clk_sys_pio0_Pos  (12UL)                    /*!< clk_sys_pio0 (Bit 12)                                 */
#define CLOCKS_ENABLED0_clk_sys_pio0_Msk  (0x1000UL)                /*!< clk_sys_pio0 (Bitfield-Mask: 0x01)                    */
#define CLOCKS_ENABLED0_clk_sys_pads_Pos  (11UL)                    /*!< clk_sys_pads (Bit 11)                                 */
#define CLOCKS_ENABLED0_clk_sys_pads_Msk  (0x800UL)                 /*!< clk_sys_pads (Bitfield-Mask: 0x01)                    */
#define CLOCKS_ENABLED0_clk_sys_vreg_and_chip_reset_Pos (10UL)      /*!< clk_sys_vreg_and_chip_reset (Bit 10)                  */
#define CLOCKS_ENABLED0_clk_sys_vreg_and_chip_reset_Msk (0x400UL)   /*!< clk_sys_vreg_and_chip_reset (Bitfield-Mask: 0x01)     */
#define CLOCKS_ENABLED0_clk_sys_jtag_Pos  (9UL)                     /*!< clk_sys_jtag (Bit 9)                                  */
#define CLOCKS_ENABLED0_clk_sys_jtag_Msk  (0x200UL)                 /*!< clk_sys_jtag (Bitfield-Mask: 0x01)                    */
#define CLOCKS_ENABLED0_clk_sys_io_Pos    (8UL)                     /*!< clk_sys_io (Bit 8)                                    */
#define CLOCKS_ENABLED0_clk_sys_io_Msk    (0x100UL)                 /*!< clk_sys_io (Bitfield-Mask: 0x01)                      */
#define CLOCKS_ENABLED0_clk_sys_i2c1_Pos  (7UL)                     /*!< clk_sys_i2c1 (Bit 7)                                  */
#define CLOCKS_ENABLED0_clk_sys_i2c1_Msk  (0x80UL)                  /*!< clk_sys_i2c1 (Bitfield-Mask: 0x01)                    */
#define CLOCKS_ENABLED0_clk_sys_i2c0_Pos  (6UL)                     /*!< clk_sys_i2c0 (Bit 6)                                  */
#define CLOCKS_ENABLED0_clk_sys_i2c0_Msk  (0x40UL)                  /*!< clk_sys_i2c0 (Bitfield-Mask: 0x01)                    */
#define CLOCKS_ENABLED0_clk_sys_dma_Pos   (5UL)                     /*!< clk_sys_dma (Bit 5)                                   */
#define CLOCKS_ENABLED0_clk_sys_dma_Msk   (0x20UL)                  /*!< clk_sys_dma (Bitfield-Mask: 0x01)                     */
#define CLOCKS_ENABLED0_clk_sys_busfabric_Pos (4UL)                 /*!< clk_sys_busfabric (Bit 4)                             */
#define CLOCKS_ENABLED0_clk_sys_busfabric_Msk (0x10UL)              /*!< clk_sys_busfabric (Bitfield-Mask: 0x01)               */
#define CLOCKS_ENABLED0_clk_sys_busctrl_Pos (3UL)                   /*!< clk_sys_busctrl (Bit 3)                               */
#define CLOCKS_ENABLED0_clk_sys_busctrl_Msk (0x8UL)                 /*!< clk_sys_busctrl (Bitfield-Mask: 0x01)                 */
#define CLOCKS_ENABLED0_clk_sys_adc_Pos   (2UL)                     /*!< clk_sys_adc (Bit 2)                                   */
#define CLOCKS_ENABLED0_clk_sys_adc_Msk   (0x4UL)                   /*!< clk_sys_adc (Bitfield-Mask: 0x01)                     */
#define CLOCKS_ENABLED0_clk_adc_adc_Pos   (1UL)                     /*!< clk_adc_adc (Bit 1)                                   */
#define CLOCKS_ENABLED0_clk_adc_adc_Msk   (0x2UL)                   /*!< clk_adc_adc (Bitfield-Mask: 0x01)                     */
#define CLOCKS_ENABLED0_clk_sys_clocks_Pos (0UL)                    /*!< clk_sys_clocks (Bit 0)                                */
#define CLOCKS_ENABLED0_clk_sys_clocks_Msk (0x1UL)                  /*!< clk_sys_clocks (Bitfield-Mask: 0x01)                  */
/* =======================================================  ENABLED1  ======================================================== */
#define CLOCKS_ENABLED1_clk_sys_xosc_Pos  (14UL)                    /*!< clk_sys_xosc (Bit 14)                                 */
#define CLOCKS_ENABLED1_clk_sys_xosc_Msk  (0x4000UL)                /*!< clk_sys_xosc (Bitfield-Mask: 0x01)                    */
#define CLOCKS_ENABLED1_clk_sys_xip_Pos   (13UL)                    /*!< clk_sys_xip (Bit 13)                                  */
#define CLOCKS_ENABLED1_clk_sys_xip_Msk   (0x2000UL)                /*!< clk_sys_xip (Bitfield-Mask: 0x01)                     */
#define CLOCKS_ENABLED1_clk_sys_watchdog_Pos (12UL)                 /*!< clk_sys_watchdog (Bit 12)                             */
#define CLOCKS_ENABLED1_clk_sys_watchdog_Msk (0x1000UL)             /*!< clk_sys_watchdog (Bitfield-Mask: 0x01)                */
#define CLOCKS_ENABLED1_clk_usb_usbctrl_Pos (11UL)                  /*!< clk_usb_usbctrl (Bit 11)                              */
#define CLOCKS_ENABLED1_clk_usb_usbctrl_Msk (0x800UL)               /*!< clk_usb_usbctrl (Bitfield-Mask: 0x01)                 */
#define CLOCKS_ENABLED1_clk_sys_usbctrl_Pos (10UL)                  /*!< clk_sys_usbctrl (Bit 10)                              */
#define CLOCKS_ENABLED1_clk_sys_usbctrl_Msk (0x400UL)               /*!< clk_sys_usbctrl (Bitfield-Mask: 0x01)                 */
#define CLOCKS_ENABLED1_clk_sys_uart1_Pos (9UL)                     /*!< clk_sys_uart1 (Bit 9)                                 */
#define CLOCKS_ENABLED1_clk_sys_uart1_Msk (0x200UL)                 /*!< clk_sys_uart1 (Bitfield-Mask: 0x01)                   */
#define CLOCKS_ENABLED1_clk_peri_uart1_Pos (8UL)                    /*!< clk_peri_uart1 (Bit 8)                                */
#define CLOCKS_ENABLED1_clk_peri_uart1_Msk (0x100UL)                /*!< clk_peri_uart1 (Bitfield-Mask: 0x01)                  */
#define CLOCKS_ENABLED1_clk_sys_uart0_Pos (7UL)                     /*!< clk_sys_uart0 (Bit 7)                                 */
#define CLOCKS_ENABLED1_clk_sys_uart0_Msk (0x80UL)                  /*!< clk_sys_uart0 (Bitfield-Mask: 0x01)                   */
#define CLOCKS_ENABLED1_clk_peri_uart0_Pos (6UL)                    /*!< clk_peri_uart0 (Bit 6)                                */
#define CLOCKS_ENABLED1_clk_peri_uart0_Msk (0x40UL)                 /*!< clk_peri_uart0 (Bitfield-Mask: 0x01)                  */
#define CLOCKS_ENABLED1_clk_sys_timer_Pos (5UL)                     /*!< clk_sys_timer (Bit 5)                                 */
#define CLOCKS_ENABLED1_clk_sys_timer_Msk (0x20UL)                  /*!< clk_sys_timer (Bitfield-Mask: 0x01)                   */
#define CLOCKS_ENABLED1_clk_sys_tbman_Pos (4UL)                     /*!< clk_sys_tbman (Bit 4)                                 */
#define CLOCKS_ENABLED1_clk_sys_tbman_Msk (0x10UL)                  /*!< clk_sys_tbman (Bitfield-Mask: 0x01)                   */
#define CLOCKS_ENABLED1_clk_sys_sysinfo_Pos (3UL)                   /*!< clk_sys_sysinfo (Bit 3)                               */
#define CLOCKS_ENABLED1_clk_sys_sysinfo_Msk (0x8UL)                 /*!< clk_sys_sysinfo (Bitfield-Mask: 0x01)                 */
#define CLOCKS_ENABLED1_clk_sys_syscfg_Pos (2UL)                    /*!< clk_sys_syscfg (Bit 2)                                */
#define CLOCKS_ENABLED1_clk_sys_syscfg_Msk (0x4UL)                  /*!< clk_sys_syscfg (Bitfield-Mask: 0x01)                  */
#define CLOCKS_ENABLED1_clk_sys_sram5_Pos (1UL)                     /*!< clk_sys_sram5 (Bit 1)                                 */
#define CLOCKS_ENABLED1_clk_sys_sram5_Msk (0x2UL)                   /*!< clk_sys_sram5 (Bitfield-Mask: 0x01)                   */
#define CLOCKS_ENABLED1_clk_sys_sram4_Pos (0UL)                     /*!< clk_sys_sram4 (Bit 0)                                 */
#define CLOCKS_ENABLED1_clk_sys_sram4_Msk (0x1UL)                   /*!< clk_sys_sram4 (Bitfield-Mask: 0x01)                   */
/* =========================================================  INTR  ========================================================== */
#define CLOCKS_INTR_CLK_SYS_RESUS_Pos     (0UL)                     /*!< CLK_SYS_RESUS (Bit 0)                                 */
#define CLOCKS_INTR_CLK_SYS_RESUS_Msk     (0x1UL)                   /*!< CLK_SYS_RESUS (Bitfield-Mask: 0x01)                   */
/* =========================================================  INTE  ========================================================== */
#define CLOCKS_INTE_CLK_SYS_RESUS_Pos     (0UL)                     /*!< CLK_SYS_RESUS (Bit 0)                                 */
#define CLOCKS_INTE_CLK_SYS_RESUS_Msk     (0x1UL)                   /*!< CLK_SYS_RESUS (Bitfield-Mask: 0x01)                   */
/* =========================================================  INTF  ========================================================== */
#define CLOCKS_INTF_CLK_SYS_RESUS_Pos     (0UL)                     /*!< CLK_SYS_RESUS (Bit 0)                                 */
#define CLOCKS_INTF_CLK_SYS_RESUS_Msk     (0x1UL)                   /*!< CLK_SYS_RESUS (Bitfield-Mask: 0x01)                   */
/* =========================================================  INTS  ========================================================== */
#define CLOCKS_INTS_CLK_SYS_RESUS_Pos     (0UL)                     /*!< CLK_SYS_RESUS (Bit 0)                                 */
#define CLOCKS_INTS_CLK_SYS_RESUS_Msk     (0x1UL)                   /*!< CLK_SYS_RESUS (Bitfield-Mask: 0x01)                   */


/* =========================================================================================================================== */
/* ================                                          RESETS                                           ================ */
/* =========================================================================================================================== */

/* =========================================================  RESET  ========================================================= */
#define RESETS_RESET_usbctrl_Pos          (24UL)                    /*!< usbctrl (Bit 24)                                      */
#define RESETS_RESET_usbctrl_Msk          (0x1000000UL)             /*!< usbctrl (Bitfield-Mask: 0x01)                         */
#define RESETS_RESET_uart1_Pos            (23UL)                    /*!< uart1 (Bit 23)                                        */
#define RESETS_RESET_uart1_Msk            (0x800000UL)              /*!< uart1 (Bitfield-Mask: 0x01)                           */
#define RESETS_RESET_uart0_Pos            (22UL)                    /*!< uart0 (Bit 22)                                        */
#define RESETS_RESET_uart0_Msk            (0x400000UL)              /*!< uart0 (Bitfield-Mask: 0x01)                           */
#define RESETS_RESET_timer_Pos            (21UL)                    /*!< timer (Bit 21)                                        */
#define RESETS_RESET_timer_Msk            (0x200000UL)              /*!< timer (Bitfield-Mask: 0x01)                           */
#define RESETS_RESET_tbman_Pos            (20UL)                    /*!< tbman (Bit 20)                                        */
#define RESETS_RESET_tbman_Msk            (0x100000UL)              /*!< tbman (Bitfield-Mask: 0x01)                           */
#define RESETS_RESET_sysinfo_Pos          (19UL)                    /*!< sysinfo (Bit 19)                                      */
#define RESETS_RESET_sysinfo_Msk          (0x80000UL)               /*!< sysinfo (Bitfield-Mask: 0x01)                         */
#define RESETS_RESET_syscfg_Pos           (18UL)                    /*!< syscfg (Bit 18)                                       */
#define RESETS_RESET_syscfg_Msk           (0x40000UL)               /*!< syscfg (Bitfield-Mask: 0x01)                          */
#define RESETS_RESET_spi1_Pos             (17UL)                    /*!< spi1 (Bit 17)                                         */
#define RESETS_RESET_spi1_Msk             (0x20000UL)               /*!< spi1 (Bitfield-Mask: 0x01)                            */
#define RESETS_RESET_spi0_Pos             (16UL)                    /*!< spi0 (Bit 16)                                         */
#define RESETS_RESET_spi0_Msk             (0x10000UL)               /*!< spi0 (Bitfield-Mask: 0x01)                            */
#define RESETS_RESET_rtc_Pos              (15UL)                    /*!< rtc (Bit 15)                                          */
#define RESETS_RESET_rtc_Msk              (0x8000UL)                /*!< rtc (Bitfield-Mask: 0x01)                             */
#define RESETS_RESET_pwm_Pos              (14UL)                    /*!< pwm (Bit 14)                                          */
#define RESETS_RESET_pwm_Msk              (0x4000UL)                /*!< pwm (Bitfield-Mask: 0x01)                             */
#define RESETS_RESET_pll_usb_Pos          (13UL)                    /*!< pll_usb (Bit 13)                                      */
#define RESETS_RESET_pll_usb_Msk          (0x2000UL)                /*!< pll_usb (Bitfield-Mask: 0x01)                         */
#define RESETS_RESET_pll_sys_Pos          (12UL)                    /*!< pll_sys (Bit 12)                                      */
#define RESETS_RESET_pll_sys_Msk          (0x1000UL)                /*!< pll_sys (Bitfield-Mask: 0x01)                         */
#define RESETS_RESET_pio1_Pos             (11UL)                    /*!< pio1 (Bit 11)                                         */
#define RESETS_RESET_pio1_Msk             (0x800UL)                 /*!< pio1 (Bitfield-Mask: 0x01)                            */
#define RESETS_RESET_pio0_Pos             (10UL)                    /*!< pio0 (Bit 10)                                         */
#define RESETS_RESET_pio0_Msk             (0x400UL)                 /*!< pio0 (Bitfield-Mask: 0x01)                            */
#define RESETS_RESET_pads_qspi_Pos        (9UL)                     /*!< pads_qspi (Bit 9)                                     */
#define RESETS_RESET_pads_qspi_Msk        (0x200UL)                 /*!< pads_qspi (Bitfield-Mask: 0x01)                       */
#define RESETS_RESET_pads_bank0_Pos       (8UL)                     /*!< pads_bank0 (Bit 8)                                    */
#define RESETS_RESET_pads_bank0_Msk       (0x100UL)                 /*!< pads_bank0 (Bitfield-Mask: 0x01)                      */
#define RESETS_RESET_jtag_Pos             (7UL)                     /*!< jtag (Bit 7)                                          */
#define RESETS_RESET_jtag_Msk             (0x80UL)                  /*!< jtag (Bitfield-Mask: 0x01)                            */
#define RESETS_RESET_io_qspi_Pos          (6UL)                     /*!< io_qspi (Bit 6)                                       */
#define RESETS_RESET_io_qspi_Msk          (0x40UL)                  /*!< io_qspi (Bitfield-Mask: 0x01)                         */
#define RESETS_RESET_io_bank0_Pos         (5UL)                     /*!< io_bank0 (Bit 5)                                      */
#define RESETS_RESET_io_bank0_Msk         (0x20UL)                  /*!< io_bank0 (Bitfield-Mask: 0x01)                        */
#define RESETS_RESET_i2c1_Pos             (4UL)                     /*!< i2c1 (Bit 4)                                          */
#define RESETS_RESET_i2c1_Msk             (0x10UL)                  /*!< i2c1 (Bitfield-Mask: 0x01)                            */
#define RESETS_RESET_i2c0_Pos             (3UL)                     /*!< i2c0 (Bit 3)                                          */
#define RESETS_RESET_i2c0_Msk             (0x8UL)                   /*!< i2c0 (Bitfield-Mask: 0x01)                            */
#define RESETS_RESET_dma_Pos              (2UL)                     /*!< dma (Bit 2)                                           */
#define RESETS_RESET_dma_Msk              (0x4UL)                   /*!< dma (Bitfield-Mask: 0x01)                             */
#define RESETS_RESET_busctrl_Pos          (1UL)                     /*!< busctrl (Bit 1)                                       */
#define RESETS_RESET_busctrl_Msk          (0x2UL)                   /*!< busctrl (Bitfield-Mask: 0x01)                         */
#define RESETS_RESET_adc_Pos              (0UL)                     /*!< adc (Bit 0)                                           */
#define RESETS_RESET_adc_Msk              (0x1UL)                   /*!< adc (Bitfield-Mask: 0x01)                             */
/* =========================================================  WDSEL  ========================================================= */
#define RESETS_WDSEL_usbctrl_Pos          (24UL)                    /*!< usbctrl (Bit 24)                                      */
#define RESETS_WDSEL_usbctrl_Msk          (0x1000000UL)             /*!< usbctrl (Bitfield-Mask: 0x01)                         */
#define RESETS_WDSEL_uart1_Pos            (23UL)                    /*!< uart1 (Bit 23)                                        */
#define RESETS_WDSEL_uart1_Msk            (0x800000UL)              /*!< uart1 (Bitfield-Mask: 0x01)                           */
#define RESETS_WDSEL_uart0_Pos            (22UL)                    /*!< uart0 (Bit 22)                                        */
#define RESETS_WDSEL_uart0_Msk            (0x400000UL)              /*!< uart0 (Bitfield-Mask: 0x01)                           */
#define RESETS_WDSEL_timer_Pos            (21UL)                    /*!< timer (Bit 21)                                        */
#define RESETS_WDSEL_timer_Msk            (0x200000UL)              /*!< timer (Bitfield-Mask: 0x01)                           */
#define RESETS_WDSEL_tbman_Pos            (20UL)                    /*!< tbman (Bit 20)                                        */
#define RESETS_WDSEL_tbman_Msk            (0x100000UL)              /*!< tbman (Bitfield-Mask: 0x01)                           */
#define RESETS_WDSEL_sysinfo_Pos          (19UL)                    /*!< sysinfo (Bit 19)                                      */
#define RESETS_WDSEL_sysinfo_Msk          (0x80000UL)               /*!< sysinfo (Bitfield-Mask: 0x01)                         */
#define RESETS_WDSEL_syscfg_Pos           (18UL)                    /*!< syscfg (Bit 18)                                       */
#define RESETS_WDSEL_syscfg_Msk           (0x40000UL)               /*!< syscfg (Bitfield-Mask: 0x01)                          */
#define RESETS_WDSEL_spi1_Pos             (17UL)                    /*!< spi1 (Bit 17)                                         */
#define RESETS_WDSEL_spi1_Msk             (0x20000UL)               /*!< spi1 (Bitfield-Mask: 0x01)                            */
#define RESETS_WDSEL_spi0_Pos             (16UL)                    /*!< spi0 (Bit 16)                                         */
#define RESETS_WDSEL_spi0_Msk             (0x10000UL)               /*!< spi0 (Bitfield-Mask: 0x01)                            */
#define RESETS_WDSEL_rtc_Pos              (15UL)                    /*!< rtc (Bit 15)                                          */
#define RESETS_WDSEL_rtc_Msk              (0x8000UL)                /*!< rtc (Bitfield-Mask: 0x01)                             */
#define RESETS_WDSEL_pwm_Pos              (14UL)                    /*!< pwm (Bit 14)                                          */
#define RESETS_WDSEL_pwm_Msk              (0x4000UL)                /*!< pwm (Bitfield-Mask: 0x01)                             */
#define RESETS_WDSEL_pll_usb_Pos          (13UL)                    /*!< pll_usb (Bit 13)                                      */
#define RESETS_WDSEL_pll_usb_Msk          (0x2000UL)                /*!< pll_usb (Bitfield-Mask: 0x01)                         */
#define RESETS_WDSEL_pll_sys_Pos          (12UL)                    /*!< pll_sys (Bit 12)                                      */
#define RESETS_WDSEL_pll_sys_Msk          (0x1000UL)                /*!< pll_sys (Bitfield-Mask: 0x01)                         */
#define RESETS_WDSEL_pio1_Pos             (11UL)                    /*!< pio1 (Bit 11)                                         */
#define RESETS_WDSEL_pio1_Msk             (0x800UL)                 /*!< pio1 (Bitfield-Mask: 0x01)                            */
#define RESETS_WDSEL_pio0_Pos             (10UL)                    /*!< pio0 (Bit 10)                                         */
#define RESETS_WDSEL_pio0_Msk             (0x400UL)                 /*!< pio0 (Bitfield-Mask: 0x01)                            */
#define RESETS_WDSEL_pads_qspi_Pos        (9UL)                     /*!< pads_qspi (Bit 9)                                     */
#define RESETS_WDSEL_pads_qspi_Msk        (0x200UL)                 /*!< pads_qspi (Bitfield-Mask: 0x01)                       */
#define RESETS_WDSEL_pads_bank0_Pos       (8UL)                     /*!< pads_bank0 (Bit 8)                                    */
#define RESETS_WDSEL_pads_bank0_Msk       (0x100UL)                 /*!< pads_bank0 (Bitfield-Mask: 0x01)                      */
#define RESETS_WDSEL_jtag_Pos             (7UL)                     /*!< jtag (Bit 7)                                          */
#define RESETS_WDSEL_jtag_Msk             (0x80UL)                  /*!< jtag (Bitfield-Mask: 0x01)                            */
#define RESETS_WDSEL_io_qspi_Pos          (6UL)                     /*!< io_qspi (Bit 6)                                       */
#define RESETS_WDSEL_io_qspi_Msk          (0x40UL)                  /*!< io_qspi (Bitfield-Mask: 0x01)                         */
#define RESETS_WDSEL_io_bank0_Pos         (5UL)                     /*!< io_bank0 (Bit 5)                                      */
#define RESETS_WDSEL_io_bank0_Msk         (0x20UL)                  /*!< io_bank0 (Bitfield-Mask: 0x01)                        */
#define RESETS_WDSEL_i2c1_Pos             (4UL)                     /*!< i2c1 (Bit 4)                                          */
#define RESETS_WDSEL_i2c1_Msk             (0x10UL)                  /*!< i2c1 (Bitfield-Mask: 0x01)                            */
#define RESETS_WDSEL_i2c0_Pos             (3UL)                     /*!< i2c0 (Bit 3)                                          */
#define RESETS_WDSEL_i2c0_Msk             (0x8UL)                   /*!< i2c0 (Bitfield-Mask: 0x01)                            */
#define RESETS_WDSEL_dma_Pos              (2UL)                     /*!< dma (Bit 2)                                           */
#define RESETS_WDSEL_dma_Msk              (0x4UL)                   /*!< dma (Bitfield-Mask: 0x01)                             */
#define RESETS_WDSEL_busctrl_Pos          (1UL)                     /*!< busctrl (Bit 1)                                       */
#define RESETS_WDSEL_busctrl_Msk          (0x2UL)                   /*!< busctrl (Bitfield-Mask: 0x01)                         */
#define RESETS_WDSEL_adc_Pos              (0UL)                     /*!< adc (Bit 0)                                           */
#define RESETS_WDSEL_adc_Msk              (0x1UL)                   /*!< adc (Bitfield-Mask: 0x01)                             */
/* ======================================================  RESET_DONE  ======================================================= */
#define RESETS_RESET_DONE_usbctrl_Pos     (24UL)                    /*!< usbctrl (Bit 24)                                      */
#define RESETS_RESET_DONE_usbctrl_Msk     (0x1000000UL)             /*!< usbctrl (Bitfield-Mask: 0x01)                         */
#define RESETS_RESET_DONE_uart1_Pos       (23UL)                    /*!< uart1 (Bit 23)                                        */
#define RESETS_RESET_DONE_uart1_Msk       (0x800000UL)              /*!< uart1 (Bitfield-Mask: 0x01)                           */
#define RESETS_RESET_DONE_uart0_Pos       (22UL)                    /*!< uart0 (Bit 22)                                        */
#define RESETS_RESET_DONE_uart0_Msk       (0x400000UL)              /*!< uart0 (Bitfield-Mask: 0x01)                           */
#define RESETS_RESET_DONE_timer_Pos       (21UL)                    /*!< timer (Bit 21)                                        */
#define RESETS_RESET_DONE_timer_Msk       (0x200000UL)              /*!< timer (Bitfield-Mask: 0x01)                           */
#define RESETS_RESET_DONE_tbman_Pos       (20UL)                    /*!< tbman (Bit 20)                                        */
#define RESETS_RESET_DONE_tbman_Msk       (0x100000UL)              /*!< tbman (Bitfield-Mask: 0x01)                           */
#define RESETS_RESET_DONE_sysinfo_Pos     (19UL)                    /*!< sysinfo (Bit 19)                                      */
#define RESETS_RESET_DONE_sysinfo_Msk     (0x80000UL)               /*!< sysinfo (Bitfield-Mask: 0x01)                         */
#define RESETS_RESET_DONE_syscfg_Pos      (18UL)                    /*!< syscfg (Bit 18)                                       */
#define RESETS_RESET_DONE_syscfg_Msk      (0x40000UL)               /*!< syscfg (Bitfield-Mask: 0x01)                          */
#define RESETS_RESET_DONE_spi1_Pos        (17UL)                    /*!< spi1 (Bit 17)                                         */
#define RESETS_RESET_DONE_spi1_Msk        (0x20000UL)               /*!< spi1 (Bitfield-Mask: 0x01)                            */
#define RESETS_RESET_DONE_spi0_Pos        (16UL)                    /*!< spi0 (Bit 16)                                         */
#define RESETS_RESET_DONE_spi0_Msk        (0x10000UL)               /*!< spi0 (Bitfield-Mask: 0x01)                            */
#define RESETS_RESET_DONE_rtc_Pos         (15UL)                    /*!< rtc (Bit 15)                                          */
#define RESETS_RESET_DONE_rtc_Msk         (0x8000UL)                /*!< rtc (Bitfield-Mask: 0x01)                             */
#define RESETS_RESET_DONE_pwm_Pos         (14UL)                    /*!< pwm (Bit 14)                                          */
#define RESETS_RESET_DONE_pwm_Msk         (0x4000UL)                /*!< pwm (Bitfield-Mask: 0x01)                             */
#define RESETS_RESET_DONE_pll_usb_Pos     (13UL)                    /*!< pll_usb (Bit 13)                                      */
#define RESETS_RESET_DONE_pll_usb_Msk     (0x2000UL)                /*!< pll_usb (Bitfield-Mask: 0x01)                         */
#define RESETS_RESET_DONE_pll_sys_Pos     (12UL)                    /*!< pll_sys (Bit 12)                                      */
#define RESETS_RESET_DONE_pll_sys_Msk     (0x1000UL)                /*!< pll_sys (Bitfield-Mask: 0x01)                         */
#define RESETS_RESET_DONE_pio1_Pos        (11UL)                    /*!< pio1 (Bit 11)                                         */
#define RESETS_RESET_DONE_pio1_Msk        (0x800UL)                 /*!< pio1 (Bitfield-Mask: 0x01)                            */
#define RESETS_RESET_DONE_pio0_Pos        (10UL)                    /*!< pio0 (Bit 10)                                         */
#define RESETS_RESET_DONE_pio0_Msk        (0x400UL)                 /*!< pio0 (Bitfield-Mask: 0x01)                            */
#define RESETS_RESET_DONE_pads_qspi_Pos   (9UL)                     /*!< pads_qspi (Bit 9)                                     */
#define RESETS_RESET_DONE_pads_qspi_Msk   (0x200UL)                 /*!< pads_qspi (Bitfield-Mask: 0x01)                       */
#define RESETS_RESET_DONE_pads_bank0_Pos  (8UL)                     /*!< pads_bank0 (Bit 8)                                    */
#define RESETS_RESET_DONE_pads_bank0_Msk  (0x100UL)                 /*!< pads_bank0 (Bitfield-Mask: 0x01)                      */
#define RESETS_RESET_DONE_jtag_Pos        (7UL)                     /*!< jtag (Bit 7)                                          */
#define RESETS_RESET_DONE_jtag_Msk        (0x80UL)                  /*!< jtag (Bitfield-Mask: 0x01)                            */
#define RESETS_RESET_DONE_io_qspi_Pos     (6UL)                     /*!< io_qspi (Bit 6)                                       */
#define RESETS_RESET_DONE_io_qspi_Msk     (0x40UL)                  /*!< io_qspi (Bitfield-Mask: 0x01)                         */
#define RESETS_RESET_DONE_io_bank0_Pos    (5UL)                     /*!< io_bank0 (Bit 5)                                      */
#define RESETS_RESET_DONE_io_bank0_Msk    (0x20UL)                  /*!< io_bank0 (Bitfield-Mask: 0x01)                        */
#define RESETS_RESET_DONE_i2c1_Pos        (4UL)                     /*!< i2c1 (Bit 4)                                          */
#define RESETS_RESET_DONE_i2c1_Msk        (0x10UL)                  /*!< i2c1 (Bitfield-Mask: 0x01)                            */
#define RESETS_RESET_DONE_i2c0_Pos        (3UL)                     /*!< i2c0 (Bit 3)                                          */
#define RESETS_RESET_DONE_i2c0_Msk        (0x8UL)                   /*!< i2c0 (Bitfield-Mask: 0x01)                            */
#define RESETS_RESET_DONE_dma_Pos         (2UL)                     /*!< dma (Bit 2)                                           */
#define RESETS_RESET_DONE_dma_Msk         (0x4UL)                   /*!< dma (Bitfield-Mask: 0x01)                             */
#define RESETS_RESET_DONE_busctrl_Pos     (1UL)                     /*!< busctrl (Bit 1)                                       */
#define RESETS_RESET_DONE_busctrl_Msk     (0x2UL)                   /*!< busctrl (Bitfield-Mask: 0x01)                         */
#define RESETS_RESET_DONE_adc_Pos         (0UL)                     /*!< adc (Bit 0)                                           */
#define RESETS_RESET_DONE_adc_Msk         (0x1UL)                   /*!< adc (Bitfield-Mask: 0x01)                             */


/* =========================================================================================================================== */
/* ================                                            PSM                                            ================ */
/* =========================================================================================================================== */

/* ========================================================  FRCE_ON  ======================================================== */
#define PSM_FRCE_ON_proc1_Pos             (16UL)                    /*!< proc1 (Bit 16)                                        */
#define PSM_FRCE_ON_proc1_Msk             (0x10000UL)               /*!< proc1 (Bitfield-Mask: 0x01)                           */
#define PSM_FRCE_ON_proc0_Pos             (15UL)                    /*!< proc0 (Bit 15)                                        */
#define PSM_FRCE_ON_proc0_Msk             (0x8000UL)                /*!< proc0 (Bitfield-Mask: 0x01)                           */
#define PSM_FRCE_ON_sio_Pos               (14UL)                    /*!< sio (Bit 14)                                          */
#define PSM_FRCE_ON_sio_Msk               (0x4000UL)                /*!< sio (Bitfield-Mask: 0x01)                             */
#define PSM_FRCE_ON_vreg_and_chip_reset_Pos (13UL)                  /*!< vreg_and_chip_reset (Bit 13)                          */
#define PSM_FRCE_ON_vreg_and_chip_reset_Msk (0x2000UL)              /*!< vreg_and_chip_reset (Bitfield-Mask: 0x01)             */
#define PSM_FRCE_ON_xip_Pos               (12UL)                    /*!< xip (Bit 12)                                          */
#define PSM_FRCE_ON_xip_Msk               (0x1000UL)                /*!< xip (Bitfield-Mask: 0x01)                             */
#define PSM_FRCE_ON_sram5_Pos             (11UL)                    /*!< sram5 (Bit 11)                                        */
#define PSM_FRCE_ON_sram5_Msk             (0x800UL)                 /*!< sram5 (Bitfield-Mask: 0x01)                           */
#define PSM_FRCE_ON_sram4_Pos             (10UL)                    /*!< sram4 (Bit 10)                                        */
#define PSM_FRCE_ON_sram4_Msk             (0x400UL)                 /*!< sram4 (Bitfield-Mask: 0x01)                           */
#define PSM_FRCE_ON_sram3_Pos             (9UL)                     /*!< sram3 (Bit 9)                                         */
#define PSM_FRCE_ON_sram3_Msk             (0x200UL)                 /*!< sram3 (Bitfield-Mask: 0x01)                           */
#define PSM_FRCE_ON_sram2_Pos             (8UL)                     /*!< sram2 (Bit 8)                                         */
#define PSM_FRCE_ON_sram2_Msk             (0x100UL)                 /*!< sram2 (Bitfield-Mask: 0x01)                           */
#define PSM_FRCE_ON_sram1_Pos             (7UL)                     /*!< sram1 (Bit 7)                                         */
#define PSM_FRCE_ON_sram1_Msk             (0x80UL)                  /*!< sram1 (Bitfield-Mask: 0x01)                           */
#define PSM_FRCE_ON_sram0_Pos             (6UL)                     /*!< sram0 (Bit 6)                                         */
#define PSM_FRCE_ON_sram0_Msk             (0x40UL)                  /*!< sram0 (Bitfield-Mask: 0x01)                           */
#define PSM_FRCE_ON_rom_Pos               (5UL)                     /*!< rom (Bit 5)                                           */
#define PSM_FRCE_ON_rom_Msk               (0x20UL)                  /*!< rom (Bitfield-Mask: 0x01)                             */
#define PSM_FRCE_ON_busfabric_Pos         (4UL)                     /*!< busfabric (Bit 4)                                     */
#define PSM_FRCE_ON_busfabric_Msk         (0x10UL)                  /*!< busfabric (Bitfield-Mask: 0x01)                       */
#define PSM_FRCE_ON_resets_Pos            (3UL)                     /*!< resets (Bit 3)                                        */
#define PSM_FRCE_ON_resets_Msk            (0x8UL)                   /*!< resets (Bitfield-Mask: 0x01)                          */
#define PSM_FRCE_ON_clocks_Pos            (2UL)                     /*!< clocks (Bit 2)                                        */
#define PSM_FRCE_ON_clocks_Msk            (0x4UL)                   /*!< clocks (Bitfield-Mask: 0x01)                          */
#define PSM_FRCE_ON_xosc_Pos              (1UL)                     /*!< xosc (Bit 1)                                          */
#define PSM_FRCE_ON_xosc_Msk              (0x2UL)                   /*!< xosc (Bitfield-Mask: 0x01)                            */
#define PSM_FRCE_ON_rosc_Pos              (0UL)                     /*!< rosc (Bit 0)                                          */
#define PSM_FRCE_ON_rosc_Msk              (0x1UL)                   /*!< rosc (Bitfield-Mask: 0x01)                            */
/* =======================================================  FRCE_OFF  ======================================================== */
#define PSM_FRCE_OFF_proc1_Pos            (16UL)                    /*!< proc1 (Bit 16)                                        */
#define PSM_FRCE_OFF_proc1_Msk            (0x10000UL)               /*!< proc1 (Bitfield-Mask: 0x01)                           */
#define PSM_FRCE_OFF_proc0_Pos            (15UL)                    /*!< proc0 (Bit 15)                                        */
#define PSM_FRCE_OFF_proc0_Msk            (0x8000UL)                /*!< proc0 (Bitfield-Mask: 0x01)                           */
#define PSM_FRCE_OFF_sio_Pos              (14UL)                    /*!< sio (Bit 14)                                          */
#define PSM_FRCE_OFF_sio_Msk              (0x4000UL)                /*!< sio (Bitfield-Mask: 0x01)                             */
#define PSM_FRCE_OFF_vreg_and_chip_reset_Pos (13UL)                 /*!< vreg_and_chip_reset (Bit 13)                          */
#define PSM_FRCE_OFF_vreg_and_chip_reset_Msk (0x2000UL)             /*!< vreg_and_chip_reset (Bitfield-Mask: 0x01)             */
#define PSM_FRCE_OFF_xip_Pos              (12UL)                    /*!< xip (Bit 12)                                          */
#define PSM_FRCE_OFF_xip_Msk              (0x1000UL)                /*!< xip (Bitfield-Mask: 0x01)                             */
#define PSM_FRCE_OFF_sram5_Pos            (11UL)                    /*!< sram5 (Bit 11)                                        */
#define PSM_FRCE_OFF_sram5_Msk            (0x800UL)                 /*!< sram5 (Bitfield-Mask: 0x01)                           */
#define PSM_FRCE_OFF_sram4_Pos            (10UL)                    /*!< sram4 (Bit 10)                                        */
#define PSM_FRCE_OFF_sram4_Msk            (0x400UL)                 /*!< sram4 (Bitfield-Mask: 0x01)                           */
#define PSM_FRCE_OFF_sram3_Pos            (9UL)                     /*!< sram3 (Bit 9)                                         */
#define PSM_FRCE_OFF_sram3_Msk            (0x200UL)                 /*!< sram3 (Bitfield-Mask: 0x01)                           */
#define PSM_FRCE_OFF_sram2_Pos            (8UL)                     /*!< sram2 (Bit 8)                                         */
#define PSM_FRCE_OFF_sram2_Msk            (0x100UL)                 /*!< sram2 (Bitfield-Mask: 0x01)                           */
#define PSM_FRCE_OFF_sram1_Pos            (7UL)                     /*!< sram1 (Bit 7)                                         */
#define PSM_FRCE_OFF_sram1_Msk            (0x80UL)                  /*!< sram1 (Bitfield-Mask: 0x01)                           */
#define PSM_FRCE_OFF_sram0_Pos            (6UL)                     /*!< sram0 (Bit 6)                                         */
#define PSM_FRCE_OFF_sram0_Msk            (0x40UL)                  /*!< sram0 (Bitfield-Mask: 0x01)                           */
#define PSM_FRCE_OFF_rom_Pos              (5UL)                     /*!< rom (Bit 5)                                           */
#define PSM_FRCE_OFF_rom_Msk              (0x20UL)                  /*!< rom (Bitfield-Mask: 0x01)                             */
#define PSM_FRCE_OFF_busfabric_Pos        (4UL)                     /*!< busfabric (Bit 4)                                     */
#define PSM_FRCE_OFF_busfabric_Msk        (0x10UL)                  /*!< busfabric (Bitfield-Mask: 0x01)                       */
#define PSM_FRCE_OFF_resets_Pos           (3UL)                     /*!< resets (Bit 3)                                        */
#define PSM_FRCE_OFF_resets_Msk           (0x8UL)                   /*!< resets (Bitfield-Mask: 0x01)                          */
#define PSM_FRCE_OFF_clocks_Pos           (2UL)                     /*!< clocks (Bit 2)                                        */
#define PSM_FRCE_OFF_clocks_Msk           (0x4UL)                   /*!< clocks (Bitfield-Mask: 0x01)                          */
#define PSM_FRCE_OFF_xosc_Pos             (1UL)                     /*!< xosc (Bit 1)                                          */
#define PSM_FRCE_OFF_xosc_Msk             (0x2UL)                   /*!< xosc (Bitfield-Mask: 0x01)                            */
#define PSM_FRCE_OFF_rosc_Pos             (0UL)                     /*!< rosc (Bit 0)                                          */
#define PSM_FRCE_OFF_rosc_Msk             (0x1UL)                   /*!< rosc (Bitfield-Mask: 0x01)                            */
/* =========================================================  WDSEL  ========================================================= */
#define PSM_WDSEL_proc1_Pos               (16UL)                    /*!< proc1 (Bit 16)                                        */
#define PSM_WDSEL_proc1_Msk               (0x10000UL)               /*!< proc1 (Bitfield-Mask: 0x01)                           */
#define PSM_WDSEL_proc0_Pos               (15UL)                    /*!< proc0 (Bit 15)                                        */
#define PSM_WDSEL_proc0_Msk               (0x8000UL)                /*!< proc0 (Bitfield-Mask: 0x01)                           */
#define PSM_WDSEL_sio_Pos                 (14UL)                    /*!< sio (Bit 14)                                          */
#define PSM_WDSEL_sio_Msk                 (0x4000UL)                /*!< sio (Bitfield-Mask: 0x01)                             */
#define PSM_WDSEL_vreg_and_chip_reset_Pos (13UL)                    /*!< vreg_and_chip_reset (Bit 13)                          */
#define PSM_WDSEL_vreg_and_chip_reset_Msk (0x2000UL)                /*!< vreg_and_chip_reset (Bitfield-Mask: 0x01)             */
#define PSM_WDSEL_xip_Pos                 (12UL)                    /*!< xip (Bit 12)                                          */
#define PSM_WDSEL_xip_Msk                 (0x1000UL)                /*!< xip (Bitfield-Mask: 0x01)                             */
#define PSM_WDSEL_sram5_Pos               (11UL)                    /*!< sram5 (Bit 11)                                        */
#define PSM_WDSEL_sram5_Msk               (0x800UL)                 /*!< sram5 (Bitfield-Mask: 0x01)                           */
#define PSM_WDSEL_sram4_Pos               (10UL)                    /*!< sram4 (Bit 10)                                        */
#define PSM_WDSEL_sram4_Msk               (0x400UL)                 /*!< sram4 (Bitfield-Mask: 0x01)                           */
#define PSM_WDSEL_sram3_Pos               (9UL)                     /*!< sram3 (Bit 9)                                         */
#define PSM_WDSEL_sram3_Msk               (0x200UL)                 /*!< sram3 (Bitfield-Mask: 0x01)                           */
#define PSM_WDSEL_sram2_Pos               (8UL)                     /*!< sram2 (Bit 8)                                         */
#define PSM_WDSEL_sram2_Msk               (0x100UL)                 /*!< sram2 (Bitfield-Mask: 0x01)                           */
#define PSM_WDSEL_sram1_Pos               (7UL)                     /*!< sram1 (Bit 7)                                         */
#define PSM_WDSEL_sram1_Msk               (0x80UL)                  /*!< sram1 (Bitfield-Mask: 0x01)                           */
#define PSM_WDSEL_sram0_Pos               (6UL)                     /*!< sram0 (Bit 6)                                         */
#define PSM_WDSEL_sram0_Msk               (0x40UL)                  /*!< sram0 (Bitfield-Mask: 0x01)                           */
#define PSM_WDSEL_rom_Pos                 (5UL)                     /*!< rom (Bit 5)                                           */
#define PSM_WDSEL_rom_Msk                 (0x20UL)                  /*!< rom (Bitfield-Mask: 0x01)                             */
#define PSM_WDSEL_busfabric_Pos           (4UL)                     /*!< busfabric (Bit 4)                                     */
#define PSM_WDSEL_busfabric_Msk           (0x10UL)                  /*!< busfabric (Bitfield-Mask: 0x01)                       */
#define PSM_WDSEL_resets_Pos              (3UL)                     /*!< resets (Bit 3)                                        */
#define PSM_WDSEL_resets_Msk              (0x8UL)                   /*!< resets (Bitfield-Mask: 0x01)                          */
#define PSM_WDSEL_clocks_Pos              (2UL)                     /*!< clocks (Bit 2)                                        */
#define PSM_WDSEL_clocks_Msk              (0x4UL)                   /*!< clocks (Bitfield-Mask: 0x01)                          */
#define PSM_WDSEL_xosc_Pos                (1UL)                     /*!< xosc (Bit 1)                                          */
#define PSM_WDSEL_xosc_Msk                (0x2UL)                   /*!< xosc (Bitfield-Mask: 0x01)                            */
#define PSM_WDSEL_rosc_Pos                (0UL)                     /*!< rosc (Bit 0)                                          */
#define PSM_WDSEL_rosc_Msk                (0x1UL)                   /*!< rosc (Bitfield-Mask: 0x01)                            */
/* =========================================================  DONE  ========================================================== */
#define PSM_DONE_proc1_Pos                (16UL)                    /*!< proc1 (Bit 16)                                        */
#define PSM_DONE_proc1_Msk                (0x10000UL)               /*!< proc1 (Bitfield-Mask: 0x01)                           */
#define PSM_DONE_proc0_Pos                (15UL)                    /*!< proc0 (Bit 15)                                        */
#define PSM_DONE_proc0_Msk                (0x8000UL)                /*!< proc0 (Bitfield-Mask: 0x01)                           */
#define PSM_DONE_sio_Pos                  (14UL)                    /*!< sio (Bit 14)                                          */
#define PSM_DONE_sio_Msk                  (0x4000UL)                /*!< sio (Bitfield-Mask: 0x01)                             */
#define PSM_DONE_vreg_and_chip_reset_Pos  (13UL)                    /*!< vreg_and_chip_reset (Bit 13)                          */
#define PSM_DONE_vreg_and_chip_reset_Msk  (0x2000UL)                /*!< vreg_and_chip_reset (Bitfield-Mask: 0x01)             */
#define PSM_DONE_xip_Pos                  (12UL)                    /*!< xip (Bit 12)                                          */
#define PSM_DONE_xip_Msk                  (0x1000UL)                /*!< xip (Bitfield-Mask: 0x01)                             */
#define PSM_DONE_sram5_Pos                (11UL)                    /*!< sram5 (Bit 11)                                        */
#define PSM_DONE_sram5_Msk                (0x800UL)                 /*!< sram5 (Bitfield-Mask: 0x01)                           */
#define PSM_DONE_sram4_Pos                (10UL)                    /*!< sram4 (Bit 10)                                        */
#define PSM_DONE_sram4_Msk                (0x400UL)                 /*!< sram4 (Bitfield-Mask: 0x01)                           */
#define PSM_DONE_sram3_Pos                (9UL)                     /*!< sram3 (Bit 9)                                         */
#define PSM_DONE_sram3_Msk                (0x200UL)                 /*!< sram3 (Bitfield-Mask: 0x01)                           */
#define PSM_DONE_sram2_Pos                (8UL)                     /*!< sram2 (Bit 8)                                         */
#define PSM_DONE_sram2_Msk                (0x100UL)                 /*!< sram2 (Bitfield-Mask: 0x01)                           */
#define PSM_DONE_sram1_Pos                (7UL)                     /*!< sram1 (Bit 7)                                         */
#define PSM_DONE_sram1_Msk                (0x80UL)                  /*!< sram1 (Bitfield-Mask: 0x01)                           */
#define PSM_DONE_sram0_Pos                (6UL)                     /*!< sram0 (Bit 6)                                         */
#define PSM_DONE_sram0_Msk                (0x40UL)                  /*!< sram0 (Bitfield-Mask: 0x01)                           */
#define PSM_DONE_rom_Pos                  (5UL)                     /*!< rom (Bit 5)                                           */
#define PSM_DONE_rom_Msk                  (0x20UL)                  /*!< rom (Bitfield-Mask: 0x01)                             */
#define PSM_DONE_busfabric_Pos            (4UL)                     /*!< busfabric (Bit 4)                                     */
#define PSM_DONE_busfabric_Msk            (0x10UL)                  /*!< busfabric (Bitfield-Mask: 0x01)                       */
#define PSM_DONE_resets_Pos               (3UL)                     /*!< resets (Bit 3)                                        */
#define PSM_DONE_resets_Msk               (0x8UL)                   /*!< resets (Bitfield-Mask: 0x01)                          */
#define PSM_DONE_clocks_Pos               (2UL)                     /*!< clocks (Bit 2)                                        */
#define PSM_DONE_clocks_Msk               (0x4UL)                   /*!< clocks (Bitfield-Mask: 0x01)                          */
#define PSM_DONE_xosc_Pos                 (1UL)                     /*!< xosc (Bit 1)                                          */
#define PSM_DONE_xosc_Msk                 (0x2UL)                   /*!< xosc (Bitfield-Mask: 0x01)                            */
#define PSM_DONE_rosc_Pos                 (0UL)                     /*!< rosc (Bit 0)                                          */
#define PSM_DONE_rosc_Msk                 (0x1UL)                   /*!< rosc (Bitfield-Mask: 0x01)                            */


/* =========================================================================================================================== */
/* ================                                         IO_BANK0                                          ================ */
/* =========================================================================================================================== */

/* =====================================================  GPIO0_STATUS  ====================================================== */
#define IO_BANK0_GPIO0_STATUS_IRQTOPROC_Pos (26UL)                  /*!< IRQTOPROC (Bit 26)                                    */
#define IO_BANK0_GPIO0_STATUS_IRQTOPROC_Msk (0x4000000UL)           /*!< IRQTOPROC (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO0_STATUS_IRQFROMPAD_Pos (24UL)                 /*!< IRQFROMPAD (Bit 24)                                   */
#define IO_BANK0_GPIO0_STATUS_IRQFROMPAD_Msk (0x1000000UL)          /*!< IRQFROMPAD (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO0_STATUS_INTOPERI_Pos (19UL)                   /*!< INTOPERI (Bit 19)                                     */
#define IO_BANK0_GPIO0_STATUS_INTOPERI_Msk (0x80000UL)              /*!< INTOPERI (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO0_STATUS_INFROMPAD_Pos (17UL)                  /*!< INFROMPAD (Bit 17)                                    */
#define IO_BANK0_GPIO0_STATUS_INFROMPAD_Msk (0x20000UL)             /*!< INFROMPAD (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO0_STATUS_OETOPAD_Pos (13UL)                    /*!< OETOPAD (Bit 13)                                      */
#define IO_BANK0_GPIO0_STATUS_OETOPAD_Msk (0x2000UL)                /*!< OETOPAD (Bitfield-Mask: 0x01)                         */
#define IO_BANK0_GPIO0_STATUS_OEFROMPERI_Pos (12UL)                 /*!< OEFROMPERI (Bit 12)                                   */
#define IO_BANK0_GPIO0_STATUS_OEFROMPERI_Msk (0x1000UL)             /*!< OEFROMPERI (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO0_STATUS_OUTTOPAD_Pos (9UL)                    /*!< OUTTOPAD (Bit 9)                                      */
#define IO_BANK0_GPIO0_STATUS_OUTTOPAD_Msk (0x200UL)                /*!< OUTTOPAD (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO0_STATUS_OUTFROMPERI_Pos (8UL)                 /*!< OUTFROMPERI (Bit 8)                                   */
#define IO_BANK0_GPIO0_STATUS_OUTFROMPERI_Msk (0x100UL)             /*!< OUTFROMPERI (Bitfield-Mask: 0x01)                     */
/* ======================================================  GPIO0_CTRL  ======================================================= */
#define IO_BANK0_GPIO0_CTRL_IRQOVER_Pos   (28UL)                    /*!< IRQOVER (Bit 28)                                      */
#define IO_BANK0_GPIO0_CTRL_IRQOVER_Msk   (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO0_CTRL_INOVER_Pos    (16UL)                    /*!< INOVER (Bit 16)                                       */
#define IO_BANK0_GPIO0_CTRL_INOVER_Msk    (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO0_CTRL_OEOVER_Pos    (12UL)                    /*!< OEOVER (Bit 12)                                       */
#define IO_BANK0_GPIO0_CTRL_OEOVER_Msk    (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO0_CTRL_OUTOVER_Pos   (8UL)                     /*!< OUTOVER (Bit 8)                                       */
#define IO_BANK0_GPIO0_CTRL_OUTOVER_Msk   (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO0_CTRL_FUNCSEL_Pos   (0UL)                     /*!< FUNCSEL (Bit 0)                                       */
#define IO_BANK0_GPIO0_CTRL_FUNCSEL_Msk   (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f)                         */
/* =====================================================  GPIO1_STATUS  ====================================================== */
#define IO_BANK0_GPIO1_STATUS_IRQTOPROC_Pos (26UL)                  /*!< IRQTOPROC (Bit 26)                                    */
#define IO_BANK0_GPIO1_STATUS_IRQTOPROC_Msk (0x4000000UL)           /*!< IRQTOPROC (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO1_STATUS_IRQFROMPAD_Pos (24UL)                 /*!< IRQFROMPAD (Bit 24)                                   */
#define IO_BANK0_GPIO1_STATUS_IRQFROMPAD_Msk (0x1000000UL)          /*!< IRQFROMPAD (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO1_STATUS_INTOPERI_Pos (19UL)                   /*!< INTOPERI (Bit 19)                                     */
#define IO_BANK0_GPIO1_STATUS_INTOPERI_Msk (0x80000UL)              /*!< INTOPERI (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO1_STATUS_INFROMPAD_Pos (17UL)                  /*!< INFROMPAD (Bit 17)                                    */
#define IO_BANK0_GPIO1_STATUS_INFROMPAD_Msk (0x20000UL)             /*!< INFROMPAD (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO1_STATUS_OETOPAD_Pos (13UL)                    /*!< OETOPAD (Bit 13)                                      */
#define IO_BANK0_GPIO1_STATUS_OETOPAD_Msk (0x2000UL)                /*!< OETOPAD (Bitfield-Mask: 0x01)                         */
#define IO_BANK0_GPIO1_STATUS_OEFROMPERI_Pos (12UL)                 /*!< OEFROMPERI (Bit 12)                                   */
#define IO_BANK0_GPIO1_STATUS_OEFROMPERI_Msk (0x1000UL)             /*!< OEFROMPERI (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO1_STATUS_OUTTOPAD_Pos (9UL)                    /*!< OUTTOPAD (Bit 9)                                      */
#define IO_BANK0_GPIO1_STATUS_OUTTOPAD_Msk (0x200UL)                /*!< OUTTOPAD (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO1_STATUS_OUTFROMPERI_Pos (8UL)                 /*!< OUTFROMPERI (Bit 8)                                   */
#define IO_BANK0_GPIO1_STATUS_OUTFROMPERI_Msk (0x100UL)             /*!< OUTFROMPERI (Bitfield-Mask: 0x01)                     */
/* ======================================================  GPIO1_CTRL  ======================================================= */
#define IO_BANK0_GPIO1_CTRL_IRQOVER_Pos   (28UL)                    /*!< IRQOVER (Bit 28)                                      */
#define IO_BANK0_GPIO1_CTRL_IRQOVER_Msk   (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO1_CTRL_INOVER_Pos    (16UL)                    /*!< INOVER (Bit 16)                                       */
#define IO_BANK0_GPIO1_CTRL_INOVER_Msk    (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO1_CTRL_OEOVER_Pos    (12UL)                    /*!< OEOVER (Bit 12)                                       */
#define IO_BANK0_GPIO1_CTRL_OEOVER_Msk    (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO1_CTRL_OUTOVER_Pos   (8UL)                     /*!< OUTOVER (Bit 8)                                       */
#define IO_BANK0_GPIO1_CTRL_OUTOVER_Msk   (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO1_CTRL_FUNCSEL_Pos   (0UL)                     /*!< FUNCSEL (Bit 0)                                       */
#define IO_BANK0_GPIO1_CTRL_FUNCSEL_Msk   (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f)                         */
/* =====================================================  GPIO2_STATUS  ====================================================== */
#define IO_BANK0_GPIO2_STATUS_IRQTOPROC_Pos (26UL)                  /*!< IRQTOPROC (Bit 26)                                    */
#define IO_BANK0_GPIO2_STATUS_IRQTOPROC_Msk (0x4000000UL)           /*!< IRQTOPROC (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO2_STATUS_IRQFROMPAD_Pos (24UL)                 /*!< IRQFROMPAD (Bit 24)                                   */
#define IO_BANK0_GPIO2_STATUS_IRQFROMPAD_Msk (0x1000000UL)          /*!< IRQFROMPAD (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO2_STATUS_INTOPERI_Pos (19UL)                   /*!< INTOPERI (Bit 19)                                     */
#define IO_BANK0_GPIO2_STATUS_INTOPERI_Msk (0x80000UL)              /*!< INTOPERI (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO2_STATUS_INFROMPAD_Pos (17UL)                  /*!< INFROMPAD (Bit 17)                                    */
#define IO_BANK0_GPIO2_STATUS_INFROMPAD_Msk (0x20000UL)             /*!< INFROMPAD (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO2_STATUS_OETOPAD_Pos (13UL)                    /*!< OETOPAD (Bit 13)                                      */
#define IO_BANK0_GPIO2_STATUS_OETOPAD_Msk (0x2000UL)                /*!< OETOPAD (Bitfield-Mask: 0x01)                         */
#define IO_BANK0_GPIO2_STATUS_OEFROMPERI_Pos (12UL)                 /*!< OEFROMPERI (Bit 12)                                   */
#define IO_BANK0_GPIO2_STATUS_OEFROMPERI_Msk (0x1000UL)             /*!< OEFROMPERI (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO2_STATUS_OUTTOPAD_Pos (9UL)                    /*!< OUTTOPAD (Bit 9)                                      */
#define IO_BANK0_GPIO2_STATUS_OUTTOPAD_Msk (0x200UL)                /*!< OUTTOPAD (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO2_STATUS_OUTFROMPERI_Pos (8UL)                 /*!< OUTFROMPERI (Bit 8)                                   */
#define IO_BANK0_GPIO2_STATUS_OUTFROMPERI_Msk (0x100UL)             /*!< OUTFROMPERI (Bitfield-Mask: 0x01)                     */
/* ======================================================  GPIO2_CTRL  ======================================================= */
#define IO_BANK0_GPIO2_CTRL_IRQOVER_Pos   (28UL)                    /*!< IRQOVER (Bit 28)                                      */
#define IO_BANK0_GPIO2_CTRL_IRQOVER_Msk   (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO2_CTRL_INOVER_Pos    (16UL)                    /*!< INOVER (Bit 16)                                       */
#define IO_BANK0_GPIO2_CTRL_INOVER_Msk    (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO2_CTRL_OEOVER_Pos    (12UL)                    /*!< OEOVER (Bit 12)                                       */
#define IO_BANK0_GPIO2_CTRL_OEOVER_Msk    (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO2_CTRL_OUTOVER_Pos   (8UL)                     /*!< OUTOVER (Bit 8)                                       */
#define IO_BANK0_GPIO2_CTRL_OUTOVER_Msk   (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO2_CTRL_FUNCSEL_Pos   (0UL)                     /*!< FUNCSEL (Bit 0)                                       */
#define IO_BANK0_GPIO2_CTRL_FUNCSEL_Msk   (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f)                         */
/* =====================================================  GPIO3_STATUS  ====================================================== */
#define IO_BANK0_GPIO3_STATUS_IRQTOPROC_Pos (26UL)                  /*!< IRQTOPROC (Bit 26)                                    */
#define IO_BANK0_GPIO3_STATUS_IRQTOPROC_Msk (0x4000000UL)           /*!< IRQTOPROC (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO3_STATUS_IRQFROMPAD_Pos (24UL)                 /*!< IRQFROMPAD (Bit 24)                                   */
#define IO_BANK0_GPIO3_STATUS_IRQFROMPAD_Msk (0x1000000UL)          /*!< IRQFROMPAD (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO3_STATUS_INTOPERI_Pos (19UL)                   /*!< INTOPERI (Bit 19)                                     */
#define IO_BANK0_GPIO3_STATUS_INTOPERI_Msk (0x80000UL)              /*!< INTOPERI (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO3_STATUS_INFROMPAD_Pos (17UL)                  /*!< INFROMPAD (Bit 17)                                    */
#define IO_BANK0_GPIO3_STATUS_INFROMPAD_Msk (0x20000UL)             /*!< INFROMPAD (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO3_STATUS_OETOPAD_Pos (13UL)                    /*!< OETOPAD (Bit 13)                                      */
#define IO_BANK0_GPIO3_STATUS_OETOPAD_Msk (0x2000UL)                /*!< OETOPAD (Bitfield-Mask: 0x01)                         */
#define IO_BANK0_GPIO3_STATUS_OEFROMPERI_Pos (12UL)                 /*!< OEFROMPERI (Bit 12)                                   */
#define IO_BANK0_GPIO3_STATUS_OEFROMPERI_Msk (0x1000UL)             /*!< OEFROMPERI (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO3_STATUS_OUTTOPAD_Pos (9UL)                    /*!< OUTTOPAD (Bit 9)                                      */
#define IO_BANK0_GPIO3_STATUS_OUTTOPAD_Msk (0x200UL)                /*!< OUTTOPAD (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO3_STATUS_OUTFROMPERI_Pos (8UL)                 /*!< OUTFROMPERI (Bit 8)                                   */
#define IO_BANK0_GPIO3_STATUS_OUTFROMPERI_Msk (0x100UL)             /*!< OUTFROMPERI (Bitfield-Mask: 0x01)                     */
/* ======================================================  GPIO3_CTRL  ======================================================= */
#define IO_BANK0_GPIO3_CTRL_IRQOVER_Pos   (28UL)                    /*!< IRQOVER (Bit 28)                                      */
#define IO_BANK0_GPIO3_CTRL_IRQOVER_Msk   (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO3_CTRL_INOVER_Pos    (16UL)                    /*!< INOVER (Bit 16)                                       */
#define IO_BANK0_GPIO3_CTRL_INOVER_Msk    (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO3_CTRL_OEOVER_Pos    (12UL)                    /*!< OEOVER (Bit 12)                                       */
#define IO_BANK0_GPIO3_CTRL_OEOVER_Msk    (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO3_CTRL_OUTOVER_Pos   (8UL)                     /*!< OUTOVER (Bit 8)                                       */
#define IO_BANK0_GPIO3_CTRL_OUTOVER_Msk   (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO3_CTRL_FUNCSEL_Pos   (0UL)                     /*!< FUNCSEL (Bit 0)                                       */
#define IO_BANK0_GPIO3_CTRL_FUNCSEL_Msk   (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f)                         */
/* =====================================================  GPIO4_STATUS  ====================================================== */
#define IO_BANK0_GPIO4_STATUS_IRQTOPROC_Pos (26UL)                  /*!< IRQTOPROC (Bit 26)                                    */
#define IO_BANK0_GPIO4_STATUS_IRQTOPROC_Msk (0x4000000UL)           /*!< IRQTOPROC (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO4_STATUS_IRQFROMPAD_Pos (24UL)                 /*!< IRQFROMPAD (Bit 24)                                   */
#define IO_BANK0_GPIO4_STATUS_IRQFROMPAD_Msk (0x1000000UL)          /*!< IRQFROMPAD (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO4_STATUS_INTOPERI_Pos (19UL)                   /*!< INTOPERI (Bit 19)                                     */
#define IO_BANK0_GPIO4_STATUS_INTOPERI_Msk (0x80000UL)              /*!< INTOPERI (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO4_STATUS_INFROMPAD_Pos (17UL)                  /*!< INFROMPAD (Bit 17)                                    */
#define IO_BANK0_GPIO4_STATUS_INFROMPAD_Msk (0x20000UL)             /*!< INFROMPAD (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO4_STATUS_OETOPAD_Pos (13UL)                    /*!< OETOPAD (Bit 13)                                      */
#define IO_BANK0_GPIO4_STATUS_OETOPAD_Msk (0x2000UL)                /*!< OETOPAD (Bitfield-Mask: 0x01)                         */
#define IO_BANK0_GPIO4_STATUS_OEFROMPERI_Pos (12UL)                 /*!< OEFROMPERI (Bit 12)                                   */
#define IO_BANK0_GPIO4_STATUS_OEFROMPERI_Msk (0x1000UL)             /*!< OEFROMPERI (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO4_STATUS_OUTTOPAD_Pos (9UL)                    /*!< OUTTOPAD (Bit 9)                                      */
#define IO_BANK0_GPIO4_STATUS_OUTTOPAD_Msk (0x200UL)                /*!< OUTTOPAD (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO4_STATUS_OUTFROMPERI_Pos (8UL)                 /*!< OUTFROMPERI (Bit 8)                                   */
#define IO_BANK0_GPIO4_STATUS_OUTFROMPERI_Msk (0x100UL)             /*!< OUTFROMPERI (Bitfield-Mask: 0x01)                     */
/* ======================================================  GPIO4_CTRL  ======================================================= */
#define IO_BANK0_GPIO4_CTRL_IRQOVER_Pos   (28UL)                    /*!< IRQOVER (Bit 28)                                      */
#define IO_BANK0_GPIO4_CTRL_IRQOVER_Msk   (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO4_CTRL_INOVER_Pos    (16UL)                    /*!< INOVER (Bit 16)                                       */
#define IO_BANK0_GPIO4_CTRL_INOVER_Msk    (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO4_CTRL_OEOVER_Pos    (12UL)                    /*!< OEOVER (Bit 12)                                       */
#define IO_BANK0_GPIO4_CTRL_OEOVER_Msk    (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO4_CTRL_OUTOVER_Pos   (8UL)                     /*!< OUTOVER (Bit 8)                                       */
#define IO_BANK0_GPIO4_CTRL_OUTOVER_Msk   (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO4_CTRL_FUNCSEL_Pos   (0UL)                     /*!< FUNCSEL (Bit 0)                                       */
#define IO_BANK0_GPIO4_CTRL_FUNCSEL_Msk   (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f)                         */
/* =====================================================  GPIO5_STATUS  ====================================================== */
#define IO_BANK0_GPIO5_STATUS_IRQTOPROC_Pos (26UL)                  /*!< IRQTOPROC (Bit 26)                                    */
#define IO_BANK0_GPIO5_STATUS_IRQTOPROC_Msk (0x4000000UL)           /*!< IRQTOPROC (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO5_STATUS_IRQFROMPAD_Pos (24UL)                 /*!< IRQFROMPAD (Bit 24)                                   */
#define IO_BANK0_GPIO5_STATUS_IRQFROMPAD_Msk (0x1000000UL)          /*!< IRQFROMPAD (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO5_STATUS_INTOPERI_Pos (19UL)                   /*!< INTOPERI (Bit 19)                                     */
#define IO_BANK0_GPIO5_STATUS_INTOPERI_Msk (0x80000UL)              /*!< INTOPERI (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO5_STATUS_INFROMPAD_Pos (17UL)                  /*!< INFROMPAD (Bit 17)                                    */
#define IO_BANK0_GPIO5_STATUS_INFROMPAD_Msk (0x20000UL)             /*!< INFROMPAD (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO5_STATUS_OETOPAD_Pos (13UL)                    /*!< OETOPAD (Bit 13)                                      */
#define IO_BANK0_GPIO5_STATUS_OETOPAD_Msk (0x2000UL)                /*!< OETOPAD (Bitfield-Mask: 0x01)                         */
#define IO_BANK0_GPIO5_STATUS_OEFROMPERI_Pos (12UL)                 /*!< OEFROMPERI (Bit 12)                                   */
#define IO_BANK0_GPIO5_STATUS_OEFROMPERI_Msk (0x1000UL)             /*!< OEFROMPERI (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO5_STATUS_OUTTOPAD_Pos (9UL)                    /*!< OUTTOPAD (Bit 9)                                      */
#define IO_BANK0_GPIO5_STATUS_OUTTOPAD_Msk (0x200UL)                /*!< OUTTOPAD (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO5_STATUS_OUTFROMPERI_Pos (8UL)                 /*!< OUTFROMPERI (Bit 8)                                   */
#define IO_BANK0_GPIO5_STATUS_OUTFROMPERI_Msk (0x100UL)             /*!< OUTFROMPERI (Bitfield-Mask: 0x01)                     */
/* ======================================================  GPIO5_CTRL  ======================================================= */
#define IO_BANK0_GPIO5_CTRL_IRQOVER_Pos   (28UL)                    /*!< IRQOVER (Bit 28)                                      */
#define IO_BANK0_GPIO5_CTRL_IRQOVER_Msk   (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO5_CTRL_INOVER_Pos    (16UL)                    /*!< INOVER (Bit 16)                                       */
#define IO_BANK0_GPIO5_CTRL_INOVER_Msk    (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO5_CTRL_OEOVER_Pos    (12UL)                    /*!< OEOVER (Bit 12)                                       */
#define IO_BANK0_GPIO5_CTRL_OEOVER_Msk    (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO5_CTRL_OUTOVER_Pos   (8UL)                     /*!< OUTOVER (Bit 8)                                       */
#define IO_BANK0_GPIO5_CTRL_OUTOVER_Msk   (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO5_CTRL_FUNCSEL_Pos   (0UL)                     /*!< FUNCSEL (Bit 0)                                       */
#define IO_BANK0_GPIO5_CTRL_FUNCSEL_Msk   (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f)                         */
/* =====================================================  GPIO6_STATUS  ====================================================== */
#define IO_BANK0_GPIO6_STATUS_IRQTOPROC_Pos (26UL)                  /*!< IRQTOPROC (Bit 26)                                    */
#define IO_BANK0_GPIO6_STATUS_IRQTOPROC_Msk (0x4000000UL)           /*!< IRQTOPROC (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO6_STATUS_IRQFROMPAD_Pos (24UL)                 /*!< IRQFROMPAD (Bit 24)                                   */
#define IO_BANK0_GPIO6_STATUS_IRQFROMPAD_Msk (0x1000000UL)          /*!< IRQFROMPAD (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO6_STATUS_INTOPERI_Pos (19UL)                   /*!< INTOPERI (Bit 19)                                     */
#define IO_BANK0_GPIO6_STATUS_INTOPERI_Msk (0x80000UL)              /*!< INTOPERI (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO6_STATUS_INFROMPAD_Pos (17UL)                  /*!< INFROMPAD (Bit 17)                                    */
#define IO_BANK0_GPIO6_STATUS_INFROMPAD_Msk (0x20000UL)             /*!< INFROMPAD (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO6_STATUS_OETOPAD_Pos (13UL)                    /*!< OETOPAD (Bit 13)                                      */
#define IO_BANK0_GPIO6_STATUS_OETOPAD_Msk (0x2000UL)                /*!< OETOPAD (Bitfield-Mask: 0x01)                         */
#define IO_BANK0_GPIO6_STATUS_OEFROMPERI_Pos (12UL)                 /*!< OEFROMPERI (Bit 12)                                   */
#define IO_BANK0_GPIO6_STATUS_OEFROMPERI_Msk (0x1000UL)             /*!< OEFROMPERI (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO6_STATUS_OUTTOPAD_Pos (9UL)                    /*!< OUTTOPAD (Bit 9)                                      */
#define IO_BANK0_GPIO6_STATUS_OUTTOPAD_Msk (0x200UL)                /*!< OUTTOPAD (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO6_STATUS_OUTFROMPERI_Pos (8UL)                 /*!< OUTFROMPERI (Bit 8)                                   */
#define IO_BANK0_GPIO6_STATUS_OUTFROMPERI_Msk (0x100UL)             /*!< OUTFROMPERI (Bitfield-Mask: 0x01)                     */
/* ======================================================  GPIO6_CTRL  ======================================================= */
#define IO_BANK0_GPIO6_CTRL_IRQOVER_Pos   (28UL)                    /*!< IRQOVER (Bit 28)                                      */
#define IO_BANK0_GPIO6_CTRL_IRQOVER_Msk   (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO6_CTRL_INOVER_Pos    (16UL)                    /*!< INOVER (Bit 16)                                       */
#define IO_BANK0_GPIO6_CTRL_INOVER_Msk    (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO6_CTRL_OEOVER_Pos    (12UL)                    /*!< OEOVER (Bit 12)                                       */
#define IO_BANK0_GPIO6_CTRL_OEOVER_Msk    (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO6_CTRL_OUTOVER_Pos   (8UL)                     /*!< OUTOVER (Bit 8)                                       */
#define IO_BANK0_GPIO6_CTRL_OUTOVER_Msk   (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO6_CTRL_FUNCSEL_Pos   (0UL)                     /*!< FUNCSEL (Bit 0)                                       */
#define IO_BANK0_GPIO6_CTRL_FUNCSEL_Msk   (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f)                         */
/* =====================================================  GPIO7_STATUS  ====================================================== */
#define IO_BANK0_GPIO7_STATUS_IRQTOPROC_Pos (26UL)                  /*!< IRQTOPROC (Bit 26)                                    */
#define IO_BANK0_GPIO7_STATUS_IRQTOPROC_Msk (0x4000000UL)           /*!< IRQTOPROC (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO7_STATUS_IRQFROMPAD_Pos (24UL)                 /*!< IRQFROMPAD (Bit 24)                                   */
#define IO_BANK0_GPIO7_STATUS_IRQFROMPAD_Msk (0x1000000UL)          /*!< IRQFROMPAD (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO7_STATUS_INTOPERI_Pos (19UL)                   /*!< INTOPERI (Bit 19)                                     */
#define IO_BANK0_GPIO7_STATUS_INTOPERI_Msk (0x80000UL)              /*!< INTOPERI (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO7_STATUS_INFROMPAD_Pos (17UL)                  /*!< INFROMPAD (Bit 17)                                    */
#define IO_BANK0_GPIO7_STATUS_INFROMPAD_Msk (0x20000UL)             /*!< INFROMPAD (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO7_STATUS_OETOPAD_Pos (13UL)                    /*!< OETOPAD (Bit 13)                                      */
#define IO_BANK0_GPIO7_STATUS_OETOPAD_Msk (0x2000UL)                /*!< OETOPAD (Bitfield-Mask: 0x01)                         */
#define IO_BANK0_GPIO7_STATUS_OEFROMPERI_Pos (12UL)                 /*!< OEFROMPERI (Bit 12)                                   */
#define IO_BANK0_GPIO7_STATUS_OEFROMPERI_Msk (0x1000UL)             /*!< OEFROMPERI (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO7_STATUS_OUTTOPAD_Pos (9UL)                    /*!< OUTTOPAD (Bit 9)                                      */
#define IO_BANK0_GPIO7_STATUS_OUTTOPAD_Msk (0x200UL)                /*!< OUTTOPAD (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO7_STATUS_OUTFROMPERI_Pos (8UL)                 /*!< OUTFROMPERI (Bit 8)                                   */
#define IO_BANK0_GPIO7_STATUS_OUTFROMPERI_Msk (0x100UL)             /*!< OUTFROMPERI (Bitfield-Mask: 0x01)                     */
/* ======================================================  GPIO7_CTRL  ======================================================= */
#define IO_BANK0_GPIO7_CTRL_IRQOVER_Pos   (28UL)                    /*!< IRQOVER (Bit 28)                                      */
#define IO_BANK0_GPIO7_CTRL_IRQOVER_Msk   (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO7_CTRL_INOVER_Pos    (16UL)                    /*!< INOVER (Bit 16)                                       */
#define IO_BANK0_GPIO7_CTRL_INOVER_Msk    (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO7_CTRL_OEOVER_Pos    (12UL)                    /*!< OEOVER (Bit 12)                                       */
#define IO_BANK0_GPIO7_CTRL_OEOVER_Msk    (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO7_CTRL_OUTOVER_Pos   (8UL)                     /*!< OUTOVER (Bit 8)                                       */
#define IO_BANK0_GPIO7_CTRL_OUTOVER_Msk   (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO7_CTRL_FUNCSEL_Pos   (0UL)                     /*!< FUNCSEL (Bit 0)                                       */
#define IO_BANK0_GPIO7_CTRL_FUNCSEL_Msk   (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f)                         */
/* =====================================================  GPIO8_STATUS  ====================================================== */
#define IO_BANK0_GPIO8_STATUS_IRQTOPROC_Pos (26UL)                  /*!< IRQTOPROC (Bit 26)                                    */
#define IO_BANK0_GPIO8_STATUS_IRQTOPROC_Msk (0x4000000UL)           /*!< IRQTOPROC (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO8_STATUS_IRQFROMPAD_Pos (24UL)                 /*!< IRQFROMPAD (Bit 24)                                   */
#define IO_BANK0_GPIO8_STATUS_IRQFROMPAD_Msk (0x1000000UL)          /*!< IRQFROMPAD (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO8_STATUS_INTOPERI_Pos (19UL)                   /*!< INTOPERI (Bit 19)                                     */
#define IO_BANK0_GPIO8_STATUS_INTOPERI_Msk (0x80000UL)              /*!< INTOPERI (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO8_STATUS_INFROMPAD_Pos (17UL)                  /*!< INFROMPAD (Bit 17)                                    */
#define IO_BANK0_GPIO8_STATUS_INFROMPAD_Msk (0x20000UL)             /*!< INFROMPAD (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO8_STATUS_OETOPAD_Pos (13UL)                    /*!< OETOPAD (Bit 13)                                      */
#define IO_BANK0_GPIO8_STATUS_OETOPAD_Msk (0x2000UL)                /*!< OETOPAD (Bitfield-Mask: 0x01)                         */
#define IO_BANK0_GPIO8_STATUS_OEFROMPERI_Pos (12UL)                 /*!< OEFROMPERI (Bit 12)                                   */
#define IO_BANK0_GPIO8_STATUS_OEFROMPERI_Msk (0x1000UL)             /*!< OEFROMPERI (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO8_STATUS_OUTTOPAD_Pos (9UL)                    /*!< OUTTOPAD (Bit 9)                                      */
#define IO_BANK0_GPIO8_STATUS_OUTTOPAD_Msk (0x200UL)                /*!< OUTTOPAD (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO8_STATUS_OUTFROMPERI_Pos (8UL)                 /*!< OUTFROMPERI (Bit 8)                                   */
#define IO_BANK0_GPIO8_STATUS_OUTFROMPERI_Msk (0x100UL)             /*!< OUTFROMPERI (Bitfield-Mask: 0x01)                     */
/* ======================================================  GPIO8_CTRL  ======================================================= */
#define IO_BANK0_GPIO8_CTRL_IRQOVER_Pos   (28UL)                    /*!< IRQOVER (Bit 28)                                      */
#define IO_BANK0_GPIO8_CTRL_IRQOVER_Msk   (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO8_CTRL_INOVER_Pos    (16UL)                    /*!< INOVER (Bit 16)                                       */
#define IO_BANK0_GPIO8_CTRL_INOVER_Msk    (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO8_CTRL_OEOVER_Pos    (12UL)                    /*!< OEOVER (Bit 12)                                       */
#define IO_BANK0_GPIO8_CTRL_OEOVER_Msk    (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO8_CTRL_OUTOVER_Pos   (8UL)                     /*!< OUTOVER (Bit 8)                                       */
#define IO_BANK0_GPIO8_CTRL_OUTOVER_Msk   (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO8_CTRL_FUNCSEL_Pos   (0UL)                     /*!< FUNCSEL (Bit 0)                                       */
#define IO_BANK0_GPIO8_CTRL_FUNCSEL_Msk   (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f)                         */
/* =====================================================  GPIO9_STATUS  ====================================================== */
#define IO_BANK0_GPIO9_STATUS_IRQTOPROC_Pos (26UL)                  /*!< IRQTOPROC (Bit 26)                                    */
#define IO_BANK0_GPIO9_STATUS_IRQTOPROC_Msk (0x4000000UL)           /*!< IRQTOPROC (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO9_STATUS_IRQFROMPAD_Pos (24UL)                 /*!< IRQFROMPAD (Bit 24)                                   */
#define IO_BANK0_GPIO9_STATUS_IRQFROMPAD_Msk (0x1000000UL)          /*!< IRQFROMPAD (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO9_STATUS_INTOPERI_Pos (19UL)                   /*!< INTOPERI (Bit 19)                                     */
#define IO_BANK0_GPIO9_STATUS_INTOPERI_Msk (0x80000UL)              /*!< INTOPERI (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO9_STATUS_INFROMPAD_Pos (17UL)                  /*!< INFROMPAD (Bit 17)                                    */
#define IO_BANK0_GPIO9_STATUS_INFROMPAD_Msk (0x20000UL)             /*!< INFROMPAD (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO9_STATUS_OETOPAD_Pos (13UL)                    /*!< OETOPAD (Bit 13)                                      */
#define IO_BANK0_GPIO9_STATUS_OETOPAD_Msk (0x2000UL)                /*!< OETOPAD (Bitfield-Mask: 0x01)                         */
#define IO_BANK0_GPIO9_STATUS_OEFROMPERI_Pos (12UL)                 /*!< OEFROMPERI (Bit 12)                                   */
#define IO_BANK0_GPIO9_STATUS_OEFROMPERI_Msk (0x1000UL)             /*!< OEFROMPERI (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO9_STATUS_OUTTOPAD_Pos (9UL)                    /*!< OUTTOPAD (Bit 9)                                      */
#define IO_BANK0_GPIO9_STATUS_OUTTOPAD_Msk (0x200UL)                /*!< OUTTOPAD (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO9_STATUS_OUTFROMPERI_Pos (8UL)                 /*!< OUTFROMPERI (Bit 8)                                   */
#define IO_BANK0_GPIO9_STATUS_OUTFROMPERI_Msk (0x100UL)             /*!< OUTFROMPERI (Bitfield-Mask: 0x01)                     */
/* ======================================================  GPIO9_CTRL  ======================================================= */
#define IO_BANK0_GPIO9_CTRL_IRQOVER_Pos   (28UL)                    /*!< IRQOVER (Bit 28)                                      */
#define IO_BANK0_GPIO9_CTRL_IRQOVER_Msk   (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO9_CTRL_INOVER_Pos    (16UL)                    /*!< INOVER (Bit 16)                                       */
#define IO_BANK0_GPIO9_CTRL_INOVER_Msk    (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO9_CTRL_OEOVER_Pos    (12UL)                    /*!< OEOVER (Bit 12)                                       */
#define IO_BANK0_GPIO9_CTRL_OEOVER_Msk    (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO9_CTRL_OUTOVER_Pos   (8UL)                     /*!< OUTOVER (Bit 8)                                       */
#define IO_BANK0_GPIO9_CTRL_OUTOVER_Msk   (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO9_CTRL_FUNCSEL_Pos   (0UL)                     /*!< FUNCSEL (Bit 0)                                       */
#define IO_BANK0_GPIO9_CTRL_FUNCSEL_Msk   (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f)                         */
/* =====================================================  GPIO10_STATUS  ===================================================== */
#define IO_BANK0_GPIO10_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26)                                    */
#define IO_BANK0_GPIO10_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO10_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24)                                   */
#define IO_BANK0_GPIO10_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO10_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19)                                     */
#define IO_BANK0_GPIO10_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO10_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17)                                    */
#define IO_BANK0_GPIO10_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO10_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13)                                      */
#define IO_BANK0_GPIO10_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01)                         */
#define IO_BANK0_GPIO10_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12)                                   */
#define IO_BANK0_GPIO10_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO10_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9)                                      */
#define IO_BANK0_GPIO10_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO10_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8)                                   */
#define IO_BANK0_GPIO10_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01)                     */
/* ======================================================  GPIO10_CTRL  ====================================================== */
#define IO_BANK0_GPIO10_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28)                                      */
#define IO_BANK0_GPIO10_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO10_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16)                                       */
#define IO_BANK0_GPIO10_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO10_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12)                                       */
#define IO_BANK0_GPIO10_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO10_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8)                                       */
#define IO_BANK0_GPIO10_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO10_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0)                                       */
#define IO_BANK0_GPIO10_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f)                         */
/* =====================================================  GPIO11_STATUS  ===================================================== */
#define IO_BANK0_GPIO11_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26)                                    */
#define IO_BANK0_GPIO11_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO11_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24)                                   */
#define IO_BANK0_GPIO11_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO11_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19)                                     */
#define IO_BANK0_GPIO11_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO11_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17)                                    */
#define IO_BANK0_GPIO11_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO11_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13)                                      */
#define IO_BANK0_GPIO11_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01)                         */
#define IO_BANK0_GPIO11_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12)                                   */
#define IO_BANK0_GPIO11_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO11_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9)                                      */
#define IO_BANK0_GPIO11_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO11_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8)                                   */
#define IO_BANK0_GPIO11_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01)                     */
/* ======================================================  GPIO11_CTRL  ====================================================== */
#define IO_BANK0_GPIO11_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28)                                      */
#define IO_BANK0_GPIO11_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO11_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16)                                       */
#define IO_BANK0_GPIO11_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO11_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12)                                       */
#define IO_BANK0_GPIO11_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO11_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8)                                       */
#define IO_BANK0_GPIO11_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO11_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0)                                       */
#define IO_BANK0_GPIO11_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f)                         */
/* =====================================================  GPIO12_STATUS  ===================================================== */
#define IO_BANK0_GPIO12_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26)                                    */
#define IO_BANK0_GPIO12_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO12_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24)                                   */
#define IO_BANK0_GPIO12_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO12_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19)                                     */
#define IO_BANK0_GPIO12_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO12_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17)                                    */
#define IO_BANK0_GPIO12_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO12_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13)                                      */
#define IO_BANK0_GPIO12_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01)                         */
#define IO_BANK0_GPIO12_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12)                                   */
#define IO_BANK0_GPIO12_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO12_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9)                                      */
#define IO_BANK0_GPIO12_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO12_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8)                                   */
#define IO_BANK0_GPIO12_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01)                     */
/* ======================================================  GPIO12_CTRL  ====================================================== */
#define IO_BANK0_GPIO12_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28)                                      */
#define IO_BANK0_GPIO12_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO12_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16)                                       */
#define IO_BANK0_GPIO12_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO12_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12)                                       */
#define IO_BANK0_GPIO12_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO12_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8)                                       */
#define IO_BANK0_GPIO12_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO12_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0)                                       */
#define IO_BANK0_GPIO12_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f)                         */
/* =====================================================  GPIO13_STATUS  ===================================================== */
#define IO_BANK0_GPIO13_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26)                                    */
#define IO_BANK0_GPIO13_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO13_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24)                                   */
#define IO_BANK0_GPIO13_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO13_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19)                                     */
#define IO_BANK0_GPIO13_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO13_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17)                                    */
#define IO_BANK0_GPIO13_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO13_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13)                                      */
#define IO_BANK0_GPIO13_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01)                         */
#define IO_BANK0_GPIO13_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12)                                   */
#define IO_BANK0_GPIO13_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO13_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9)                                      */
#define IO_BANK0_GPIO13_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO13_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8)                                   */
#define IO_BANK0_GPIO13_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01)                     */
/* ======================================================  GPIO13_CTRL  ====================================================== */
#define IO_BANK0_GPIO13_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28)                                      */
#define IO_BANK0_GPIO13_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO13_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16)                                       */
#define IO_BANK0_GPIO13_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO13_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12)                                       */
#define IO_BANK0_GPIO13_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO13_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8)                                       */
#define IO_BANK0_GPIO13_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO13_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0)                                       */
#define IO_BANK0_GPIO13_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f)                         */
/* =====================================================  GPIO14_STATUS  ===================================================== */
#define IO_BANK0_GPIO14_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26)                                    */
#define IO_BANK0_GPIO14_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO14_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24)                                   */
#define IO_BANK0_GPIO14_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO14_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19)                                     */
#define IO_BANK0_GPIO14_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO14_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17)                                    */
#define IO_BANK0_GPIO14_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO14_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13)                                      */
#define IO_BANK0_GPIO14_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01)                         */
#define IO_BANK0_GPIO14_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12)                                   */
#define IO_BANK0_GPIO14_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO14_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9)                                      */
#define IO_BANK0_GPIO14_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO14_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8)                                   */
#define IO_BANK0_GPIO14_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01)                     */
/* ======================================================  GPIO14_CTRL  ====================================================== */
#define IO_BANK0_GPIO14_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28)                                      */
#define IO_BANK0_GPIO14_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO14_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16)                                       */
#define IO_BANK0_GPIO14_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO14_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12)                                       */
#define IO_BANK0_GPIO14_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO14_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8)                                       */
#define IO_BANK0_GPIO14_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO14_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0)                                       */
#define IO_BANK0_GPIO14_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f)                         */
/* =====================================================  GPIO15_STATUS  ===================================================== */
#define IO_BANK0_GPIO15_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26)                                    */
#define IO_BANK0_GPIO15_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO15_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24)                                   */
#define IO_BANK0_GPIO15_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO15_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19)                                     */
#define IO_BANK0_GPIO15_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO15_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17)                                    */
#define IO_BANK0_GPIO15_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO15_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13)                                      */
#define IO_BANK0_GPIO15_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01)                         */
#define IO_BANK0_GPIO15_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12)                                   */
#define IO_BANK0_GPIO15_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO15_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9)                                      */
#define IO_BANK0_GPIO15_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO15_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8)                                   */
#define IO_BANK0_GPIO15_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01)                     */
/* ======================================================  GPIO15_CTRL  ====================================================== */
#define IO_BANK0_GPIO15_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28)                                      */
#define IO_BANK0_GPIO15_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO15_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16)                                       */
#define IO_BANK0_GPIO15_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO15_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12)                                       */
#define IO_BANK0_GPIO15_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO15_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8)                                       */
#define IO_BANK0_GPIO15_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO15_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0)                                       */
#define IO_BANK0_GPIO15_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f)                         */
/* =====================================================  GPIO16_STATUS  ===================================================== */
#define IO_BANK0_GPIO16_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26)                                    */
#define IO_BANK0_GPIO16_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO16_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24)                                   */
#define IO_BANK0_GPIO16_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO16_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19)                                     */
#define IO_BANK0_GPIO16_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO16_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17)                                    */
#define IO_BANK0_GPIO16_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO16_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13)                                      */
#define IO_BANK0_GPIO16_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01)                         */
#define IO_BANK0_GPIO16_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12)                                   */
#define IO_BANK0_GPIO16_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO16_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9)                                      */
#define IO_BANK0_GPIO16_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO16_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8)                                   */
#define IO_BANK0_GPIO16_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01)                     */
/* ======================================================  GPIO16_CTRL  ====================================================== */
#define IO_BANK0_GPIO16_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28)                                      */
#define IO_BANK0_GPIO16_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO16_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16)                                       */
#define IO_BANK0_GPIO16_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO16_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12)                                       */
#define IO_BANK0_GPIO16_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO16_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8)                                       */
#define IO_BANK0_GPIO16_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO16_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0)                                       */
#define IO_BANK0_GPIO16_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f)                         */
/* =====================================================  GPIO17_STATUS  ===================================================== */
#define IO_BANK0_GPIO17_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26)                                    */
#define IO_BANK0_GPIO17_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO17_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24)                                   */
#define IO_BANK0_GPIO17_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO17_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19)                                     */
#define IO_BANK0_GPIO17_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO17_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17)                                    */
#define IO_BANK0_GPIO17_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO17_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13)                                      */
#define IO_BANK0_GPIO17_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01)                         */
#define IO_BANK0_GPIO17_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12)                                   */
#define IO_BANK0_GPIO17_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO17_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9)                                      */
#define IO_BANK0_GPIO17_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO17_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8)                                   */
#define IO_BANK0_GPIO17_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01)                     */
/* ======================================================  GPIO17_CTRL  ====================================================== */
#define IO_BANK0_GPIO17_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28)                                      */
#define IO_BANK0_GPIO17_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO17_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16)                                       */
#define IO_BANK0_GPIO17_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO17_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12)                                       */
#define IO_BANK0_GPIO17_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO17_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8)                                       */
#define IO_BANK0_GPIO17_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO17_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0)                                       */
#define IO_BANK0_GPIO17_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f)                         */
/* =====================================================  GPIO18_STATUS  ===================================================== */
#define IO_BANK0_GPIO18_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26)                                    */
#define IO_BANK0_GPIO18_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO18_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24)                                   */
#define IO_BANK0_GPIO18_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO18_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19)                                     */
#define IO_BANK0_GPIO18_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO18_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17)                                    */
#define IO_BANK0_GPIO18_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO18_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13)                                      */
#define IO_BANK0_GPIO18_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01)                         */
#define IO_BANK0_GPIO18_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12)                                   */
#define IO_BANK0_GPIO18_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO18_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9)                                      */
#define IO_BANK0_GPIO18_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO18_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8)                                   */
#define IO_BANK0_GPIO18_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01)                     */
/* ======================================================  GPIO18_CTRL  ====================================================== */
#define IO_BANK0_GPIO18_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28)                                      */
#define IO_BANK0_GPIO18_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO18_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16)                                       */
#define IO_BANK0_GPIO18_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO18_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12)                                       */
#define IO_BANK0_GPIO18_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO18_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8)                                       */
#define IO_BANK0_GPIO18_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO18_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0)                                       */
#define IO_BANK0_GPIO18_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f)                         */
/* =====================================================  GPIO19_STATUS  ===================================================== */
#define IO_BANK0_GPIO19_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26)                                    */
#define IO_BANK0_GPIO19_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO19_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24)                                   */
#define IO_BANK0_GPIO19_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO19_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19)                                     */
#define IO_BANK0_GPIO19_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO19_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17)                                    */
#define IO_BANK0_GPIO19_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO19_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13)                                      */
#define IO_BANK0_GPIO19_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01)                         */
#define IO_BANK0_GPIO19_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12)                                   */
#define IO_BANK0_GPIO19_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO19_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9)                                      */
#define IO_BANK0_GPIO19_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO19_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8)                                   */
#define IO_BANK0_GPIO19_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01)                     */
/* ======================================================  GPIO19_CTRL  ====================================================== */
#define IO_BANK0_GPIO19_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28)                                      */
#define IO_BANK0_GPIO19_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO19_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16)                                       */
#define IO_BANK0_GPIO19_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO19_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12)                                       */
#define IO_BANK0_GPIO19_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO19_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8)                                       */
#define IO_BANK0_GPIO19_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO19_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0)                                       */
#define IO_BANK0_GPIO19_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f)                         */
/* =====================================================  GPIO20_STATUS  ===================================================== */
#define IO_BANK0_GPIO20_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26)                                    */
#define IO_BANK0_GPIO20_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO20_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24)                                   */
#define IO_BANK0_GPIO20_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO20_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19)                                     */
#define IO_BANK0_GPIO20_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO20_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17)                                    */
#define IO_BANK0_GPIO20_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO20_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13)                                      */
#define IO_BANK0_GPIO20_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01)                         */
#define IO_BANK0_GPIO20_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12)                                   */
#define IO_BANK0_GPIO20_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO20_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9)                                      */
#define IO_BANK0_GPIO20_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO20_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8)                                   */
#define IO_BANK0_GPIO20_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01)                     */
/* ======================================================  GPIO20_CTRL  ====================================================== */
#define IO_BANK0_GPIO20_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28)                                      */
#define IO_BANK0_GPIO20_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO20_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16)                                       */
#define IO_BANK0_GPIO20_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO20_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12)                                       */
#define IO_BANK0_GPIO20_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO20_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8)                                       */
#define IO_BANK0_GPIO20_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO20_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0)                                       */
#define IO_BANK0_GPIO20_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f)                         */
/* =====================================================  GPIO21_STATUS  ===================================================== */
#define IO_BANK0_GPIO21_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26)                                    */
#define IO_BANK0_GPIO21_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO21_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24)                                   */
#define IO_BANK0_GPIO21_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO21_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19)                                     */
#define IO_BANK0_GPIO21_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO21_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17)                                    */
#define IO_BANK0_GPIO21_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO21_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13)                                      */
#define IO_BANK0_GPIO21_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01)                         */
#define IO_BANK0_GPIO21_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12)                                   */
#define IO_BANK0_GPIO21_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO21_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9)                                      */
#define IO_BANK0_GPIO21_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO21_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8)                                   */
#define IO_BANK0_GPIO21_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01)                     */
/* ======================================================  GPIO21_CTRL  ====================================================== */
#define IO_BANK0_GPIO21_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28)                                      */
#define IO_BANK0_GPIO21_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO21_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16)                                       */
#define IO_BANK0_GPIO21_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO21_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12)                                       */
#define IO_BANK0_GPIO21_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO21_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8)                                       */
#define IO_BANK0_GPIO21_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO21_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0)                                       */
#define IO_BANK0_GPIO21_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f)                         */
/* =====================================================  GPIO22_STATUS  ===================================================== */
#define IO_BANK0_GPIO22_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26)                                    */
#define IO_BANK0_GPIO22_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO22_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24)                                   */
#define IO_BANK0_GPIO22_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO22_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19)                                     */
#define IO_BANK0_GPIO22_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO22_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17)                                    */
#define IO_BANK0_GPIO22_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO22_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13)                                      */
#define IO_BANK0_GPIO22_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01)                         */
#define IO_BANK0_GPIO22_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12)                                   */
#define IO_BANK0_GPIO22_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO22_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9)                                      */
#define IO_BANK0_GPIO22_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO22_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8)                                   */
#define IO_BANK0_GPIO22_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01)                     */
/* ======================================================  GPIO22_CTRL  ====================================================== */
#define IO_BANK0_GPIO22_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28)                                      */
#define IO_BANK0_GPIO22_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO22_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16)                                       */
#define IO_BANK0_GPIO22_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO22_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12)                                       */
#define IO_BANK0_GPIO22_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO22_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8)                                       */
#define IO_BANK0_GPIO22_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO22_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0)                                       */
#define IO_BANK0_GPIO22_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f)                         */
/* =====================================================  GPIO23_STATUS  ===================================================== */
#define IO_BANK0_GPIO23_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26)                                    */
#define IO_BANK0_GPIO23_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO23_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24)                                   */
#define IO_BANK0_GPIO23_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO23_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19)                                     */
#define IO_BANK0_GPIO23_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO23_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17)                                    */
#define IO_BANK0_GPIO23_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO23_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13)                                      */
#define IO_BANK0_GPIO23_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01)                         */
#define IO_BANK0_GPIO23_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12)                                   */
#define IO_BANK0_GPIO23_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO23_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9)                                      */
#define IO_BANK0_GPIO23_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO23_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8)                                   */
#define IO_BANK0_GPIO23_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01)                     */
/* ======================================================  GPIO23_CTRL  ====================================================== */
#define IO_BANK0_GPIO23_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28)                                      */
#define IO_BANK0_GPIO23_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO23_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16)                                       */
#define IO_BANK0_GPIO23_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO23_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12)                                       */
#define IO_BANK0_GPIO23_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO23_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8)                                       */
#define IO_BANK0_GPIO23_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO23_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0)                                       */
#define IO_BANK0_GPIO23_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f)                         */
/* =====================================================  GPIO24_STATUS  ===================================================== */
#define IO_BANK0_GPIO24_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26)                                    */
#define IO_BANK0_GPIO24_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO24_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24)                                   */
#define IO_BANK0_GPIO24_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO24_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19)                                     */
#define IO_BANK0_GPIO24_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO24_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17)                                    */
#define IO_BANK0_GPIO24_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO24_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13)                                      */
#define IO_BANK0_GPIO24_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01)                         */
#define IO_BANK0_GPIO24_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12)                                   */
#define IO_BANK0_GPIO24_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO24_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9)                                      */
#define IO_BANK0_GPIO24_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO24_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8)                                   */
#define IO_BANK0_GPIO24_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01)                     */
/* ======================================================  GPIO24_CTRL  ====================================================== */
#define IO_BANK0_GPIO24_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28)                                      */
#define IO_BANK0_GPIO24_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO24_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16)                                       */
#define IO_BANK0_GPIO24_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO24_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12)                                       */
#define IO_BANK0_GPIO24_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO24_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8)                                       */
#define IO_BANK0_GPIO24_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO24_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0)                                       */
#define IO_BANK0_GPIO24_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f)                         */
/* =====================================================  GPIO25_STATUS  ===================================================== */
#define IO_BANK0_GPIO25_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26)                                    */
#define IO_BANK0_GPIO25_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO25_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24)                                   */
#define IO_BANK0_GPIO25_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO25_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19)                                     */
#define IO_BANK0_GPIO25_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO25_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17)                                    */
#define IO_BANK0_GPIO25_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO25_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13)                                      */
#define IO_BANK0_GPIO25_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01)                         */
#define IO_BANK0_GPIO25_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12)                                   */
#define IO_BANK0_GPIO25_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO25_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9)                                      */
#define IO_BANK0_GPIO25_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO25_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8)                                   */
#define IO_BANK0_GPIO25_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01)                     */
/* ======================================================  GPIO25_CTRL  ====================================================== */
#define IO_BANK0_GPIO25_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28)                                      */
#define IO_BANK0_GPIO25_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO25_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16)                                       */
#define IO_BANK0_GPIO25_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO25_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12)                                       */
#define IO_BANK0_GPIO25_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO25_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8)                                       */
#define IO_BANK0_GPIO25_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO25_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0)                                       */
#define IO_BANK0_GPIO25_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f)                         */
/* =====================================================  GPIO26_STATUS  ===================================================== */
#define IO_BANK0_GPIO26_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26)                                    */
#define IO_BANK0_GPIO26_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO26_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24)                                   */
#define IO_BANK0_GPIO26_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO26_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19)                                     */
#define IO_BANK0_GPIO26_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO26_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17)                                    */
#define IO_BANK0_GPIO26_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO26_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13)                                      */
#define IO_BANK0_GPIO26_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01)                         */
#define IO_BANK0_GPIO26_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12)                                   */
#define IO_BANK0_GPIO26_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO26_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9)                                      */
#define IO_BANK0_GPIO26_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO26_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8)                                   */
#define IO_BANK0_GPIO26_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01)                     */
/* ======================================================  GPIO26_CTRL  ====================================================== */
#define IO_BANK0_GPIO26_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28)                                      */
#define IO_BANK0_GPIO26_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO26_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16)                                       */
#define IO_BANK0_GPIO26_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO26_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12)                                       */
#define IO_BANK0_GPIO26_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO26_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8)                                       */
#define IO_BANK0_GPIO26_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO26_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0)                                       */
#define IO_BANK0_GPIO26_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f)                         */
/* =====================================================  GPIO27_STATUS  ===================================================== */
#define IO_BANK0_GPIO27_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26)                                    */
#define IO_BANK0_GPIO27_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO27_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24)                                   */
#define IO_BANK0_GPIO27_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO27_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19)                                     */
#define IO_BANK0_GPIO27_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO27_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17)                                    */
#define IO_BANK0_GPIO27_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO27_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13)                                      */
#define IO_BANK0_GPIO27_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01)                         */
#define IO_BANK0_GPIO27_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12)                                   */
#define IO_BANK0_GPIO27_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO27_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9)                                      */
#define IO_BANK0_GPIO27_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO27_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8)                                   */
#define IO_BANK0_GPIO27_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01)                     */
/* ======================================================  GPIO27_CTRL  ====================================================== */
#define IO_BANK0_GPIO27_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28)                                      */
#define IO_BANK0_GPIO27_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO27_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16)                                       */
#define IO_BANK0_GPIO27_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO27_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12)                                       */
#define IO_BANK0_GPIO27_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO27_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8)                                       */
#define IO_BANK0_GPIO27_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO27_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0)                                       */
#define IO_BANK0_GPIO27_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f)                         */
/* =====================================================  GPIO28_STATUS  ===================================================== */
#define IO_BANK0_GPIO28_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26)                                    */
#define IO_BANK0_GPIO28_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO28_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24)                                   */
#define IO_BANK0_GPIO28_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO28_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19)                                     */
#define IO_BANK0_GPIO28_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO28_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17)                                    */
#define IO_BANK0_GPIO28_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO28_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13)                                      */
#define IO_BANK0_GPIO28_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01)                         */
#define IO_BANK0_GPIO28_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12)                                   */
#define IO_BANK0_GPIO28_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO28_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9)                                      */
#define IO_BANK0_GPIO28_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO28_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8)                                   */
#define IO_BANK0_GPIO28_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01)                     */
/* ======================================================  GPIO28_CTRL  ====================================================== */
#define IO_BANK0_GPIO28_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28)                                      */
#define IO_BANK0_GPIO28_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO28_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16)                                       */
#define IO_BANK0_GPIO28_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO28_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12)                                       */
#define IO_BANK0_GPIO28_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO28_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8)                                       */
#define IO_BANK0_GPIO28_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO28_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0)                                       */
#define IO_BANK0_GPIO28_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f)                         */
/* =====================================================  GPIO29_STATUS  ===================================================== */
#define IO_BANK0_GPIO29_STATUS_IRQTOPROC_Pos (26UL)                 /*!< IRQTOPROC (Bit 26)                                    */
#define IO_BANK0_GPIO29_STATUS_IRQTOPROC_Msk (0x4000000UL)          /*!< IRQTOPROC (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO29_STATUS_IRQFROMPAD_Pos (24UL)                /*!< IRQFROMPAD (Bit 24)                                   */
#define IO_BANK0_GPIO29_STATUS_IRQFROMPAD_Msk (0x1000000UL)         /*!< IRQFROMPAD (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO29_STATUS_INTOPERI_Pos (19UL)                  /*!< INTOPERI (Bit 19)                                     */
#define IO_BANK0_GPIO29_STATUS_INTOPERI_Msk (0x80000UL)             /*!< INTOPERI (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO29_STATUS_INFROMPAD_Pos (17UL)                 /*!< INFROMPAD (Bit 17)                                    */
#define IO_BANK0_GPIO29_STATUS_INFROMPAD_Msk (0x20000UL)            /*!< INFROMPAD (Bitfield-Mask: 0x01)                       */
#define IO_BANK0_GPIO29_STATUS_OETOPAD_Pos (13UL)                   /*!< OETOPAD (Bit 13)                                      */
#define IO_BANK0_GPIO29_STATUS_OETOPAD_Msk (0x2000UL)               /*!< OETOPAD (Bitfield-Mask: 0x01)                         */
#define IO_BANK0_GPIO29_STATUS_OEFROMPERI_Pos (12UL)                /*!< OEFROMPERI (Bit 12)                                   */
#define IO_BANK0_GPIO29_STATUS_OEFROMPERI_Msk (0x1000UL)            /*!< OEFROMPERI (Bitfield-Mask: 0x01)                      */
#define IO_BANK0_GPIO29_STATUS_OUTTOPAD_Pos (9UL)                   /*!< OUTTOPAD (Bit 9)                                      */
#define IO_BANK0_GPIO29_STATUS_OUTTOPAD_Msk (0x200UL)               /*!< OUTTOPAD (Bitfield-Mask: 0x01)                        */
#define IO_BANK0_GPIO29_STATUS_OUTFROMPERI_Pos (8UL)                /*!< OUTFROMPERI (Bit 8)                                   */
#define IO_BANK0_GPIO29_STATUS_OUTFROMPERI_Msk (0x100UL)            /*!< OUTFROMPERI (Bitfield-Mask: 0x01)                     */
/* ======================================================  GPIO29_CTRL  ====================================================== */
#define IO_BANK0_GPIO29_CTRL_IRQOVER_Pos  (28UL)                    /*!< IRQOVER (Bit 28)                                      */
#define IO_BANK0_GPIO29_CTRL_IRQOVER_Msk  (0x30000000UL)            /*!< IRQOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO29_CTRL_INOVER_Pos   (16UL)                    /*!< INOVER (Bit 16)                                       */
#define IO_BANK0_GPIO29_CTRL_INOVER_Msk   (0x30000UL)               /*!< INOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO29_CTRL_OEOVER_Pos   (12UL)                    /*!< OEOVER (Bit 12)                                       */
#define IO_BANK0_GPIO29_CTRL_OEOVER_Msk   (0x3000UL)                /*!< OEOVER (Bitfield-Mask: 0x03)                          */
#define IO_BANK0_GPIO29_CTRL_OUTOVER_Pos  (8UL)                     /*!< OUTOVER (Bit 8)                                       */
#define IO_BANK0_GPIO29_CTRL_OUTOVER_Msk  (0x300UL)                 /*!< OUTOVER (Bitfield-Mask: 0x03)                         */
#define IO_BANK0_GPIO29_CTRL_FUNCSEL_Pos  (0UL)                     /*!< FUNCSEL (Bit 0)                                       */
#define IO_BANK0_GPIO29_CTRL_FUNCSEL_Msk  (0x1fUL)                  /*!< FUNCSEL (Bitfield-Mask: 0x1f)                         */
/* =========================================================  INTR0  ========================================================= */
#define IO_BANK0_INTR0_GPIO7_EDGE_HIGH_Pos (31UL)                   /*!< GPIO7_EDGE_HIGH (Bit 31)                              */
#define IO_BANK0_INTR0_GPIO7_EDGE_HIGH_Msk (0x80000000UL)           /*!< GPIO7_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR0_GPIO7_EDGE_LOW_Pos (30UL)                    /*!< GPIO7_EDGE_LOW (Bit 30)                               */
#define IO_BANK0_INTR0_GPIO7_EDGE_LOW_Msk (0x40000000UL)            /*!< GPIO7_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_INTR0_GPIO7_LEVEL_HIGH_Pos (29UL)                  /*!< GPIO7_LEVEL_HIGH (Bit 29)                             */
#define IO_BANK0_INTR0_GPIO7_LEVEL_HIGH_Msk (0x20000000UL)          /*!< GPIO7_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR0_GPIO7_LEVEL_LOW_Pos (28UL)                   /*!< GPIO7_LEVEL_LOW (Bit 28)                              */
#define IO_BANK0_INTR0_GPIO7_LEVEL_LOW_Msk (0x10000000UL)           /*!< GPIO7_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR0_GPIO6_EDGE_HIGH_Pos (27UL)                   /*!< GPIO6_EDGE_HIGH (Bit 27)                              */
#define IO_BANK0_INTR0_GPIO6_EDGE_HIGH_Msk (0x8000000UL)            /*!< GPIO6_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR0_GPIO6_EDGE_LOW_Pos (26UL)                    /*!< GPIO6_EDGE_LOW (Bit 26)                               */
#define IO_BANK0_INTR0_GPIO6_EDGE_LOW_Msk (0x4000000UL)             /*!< GPIO6_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_INTR0_GPIO6_LEVEL_HIGH_Pos (25UL)                  /*!< GPIO6_LEVEL_HIGH (Bit 25)                             */
#define IO_BANK0_INTR0_GPIO6_LEVEL_HIGH_Msk (0x2000000UL)           /*!< GPIO6_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR0_GPIO6_LEVEL_LOW_Pos (24UL)                   /*!< GPIO6_LEVEL_LOW (Bit 24)                              */
#define IO_BANK0_INTR0_GPIO6_LEVEL_LOW_Msk (0x1000000UL)            /*!< GPIO6_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR0_GPIO5_EDGE_HIGH_Pos (23UL)                   /*!< GPIO5_EDGE_HIGH (Bit 23)                              */
#define IO_BANK0_INTR0_GPIO5_EDGE_HIGH_Msk (0x800000UL)             /*!< GPIO5_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR0_GPIO5_EDGE_LOW_Pos (22UL)                    /*!< GPIO5_EDGE_LOW (Bit 22)                               */
#define IO_BANK0_INTR0_GPIO5_EDGE_LOW_Msk (0x400000UL)              /*!< GPIO5_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_INTR0_GPIO5_LEVEL_HIGH_Pos (21UL)                  /*!< GPIO5_LEVEL_HIGH (Bit 21)                             */
#define IO_BANK0_INTR0_GPIO5_LEVEL_HIGH_Msk (0x200000UL)            /*!< GPIO5_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR0_GPIO5_LEVEL_LOW_Pos (20UL)                   /*!< GPIO5_LEVEL_LOW (Bit 20)                              */
#define IO_BANK0_INTR0_GPIO5_LEVEL_LOW_Msk (0x100000UL)             /*!< GPIO5_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR0_GPIO4_EDGE_HIGH_Pos (19UL)                   /*!< GPIO4_EDGE_HIGH (Bit 19)                              */
#define IO_BANK0_INTR0_GPIO4_EDGE_HIGH_Msk (0x80000UL)              /*!< GPIO4_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR0_GPIO4_EDGE_LOW_Pos (18UL)                    /*!< GPIO4_EDGE_LOW (Bit 18)                               */
#define IO_BANK0_INTR0_GPIO4_EDGE_LOW_Msk (0x40000UL)               /*!< GPIO4_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_INTR0_GPIO4_LEVEL_HIGH_Pos (17UL)                  /*!< GPIO4_LEVEL_HIGH (Bit 17)                             */
#define IO_BANK0_INTR0_GPIO4_LEVEL_HIGH_Msk (0x20000UL)             /*!< GPIO4_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR0_GPIO4_LEVEL_LOW_Pos (16UL)                   /*!< GPIO4_LEVEL_LOW (Bit 16)                              */
#define IO_BANK0_INTR0_GPIO4_LEVEL_LOW_Msk (0x10000UL)              /*!< GPIO4_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR0_GPIO3_EDGE_HIGH_Pos (15UL)                   /*!< GPIO3_EDGE_HIGH (Bit 15)                              */
#define IO_BANK0_INTR0_GPIO3_EDGE_HIGH_Msk (0x8000UL)               /*!< GPIO3_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR0_GPIO3_EDGE_LOW_Pos (14UL)                    /*!< GPIO3_EDGE_LOW (Bit 14)                               */
#define IO_BANK0_INTR0_GPIO3_EDGE_LOW_Msk (0x4000UL)                /*!< GPIO3_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_INTR0_GPIO3_LEVEL_HIGH_Pos (13UL)                  /*!< GPIO3_LEVEL_HIGH (Bit 13)                             */
#define IO_BANK0_INTR0_GPIO3_LEVEL_HIGH_Msk (0x2000UL)              /*!< GPIO3_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR0_GPIO3_LEVEL_LOW_Pos (12UL)                   /*!< GPIO3_LEVEL_LOW (Bit 12)                              */
#define IO_BANK0_INTR0_GPIO3_LEVEL_LOW_Msk (0x1000UL)               /*!< GPIO3_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR0_GPIO2_EDGE_HIGH_Pos (11UL)                   /*!< GPIO2_EDGE_HIGH (Bit 11)                              */
#define IO_BANK0_INTR0_GPIO2_EDGE_HIGH_Msk (0x800UL)                /*!< GPIO2_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR0_GPIO2_EDGE_LOW_Pos (10UL)                    /*!< GPIO2_EDGE_LOW (Bit 10)                               */
#define IO_BANK0_INTR0_GPIO2_EDGE_LOW_Msk (0x400UL)                 /*!< GPIO2_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_INTR0_GPIO2_LEVEL_HIGH_Pos (9UL)                   /*!< GPIO2_LEVEL_HIGH (Bit 9)                              */
#define IO_BANK0_INTR0_GPIO2_LEVEL_HIGH_Msk (0x200UL)               /*!< GPIO2_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR0_GPIO2_LEVEL_LOW_Pos (8UL)                    /*!< GPIO2_LEVEL_LOW (Bit 8)                               */
#define IO_BANK0_INTR0_GPIO2_LEVEL_LOW_Msk (0x100UL)                /*!< GPIO2_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR0_GPIO1_EDGE_HIGH_Pos (7UL)                    /*!< GPIO1_EDGE_HIGH (Bit 7)                               */
#define IO_BANK0_INTR0_GPIO1_EDGE_HIGH_Msk (0x80UL)                 /*!< GPIO1_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR0_GPIO1_EDGE_LOW_Pos (6UL)                     /*!< GPIO1_EDGE_LOW (Bit 6)                                */
#define IO_BANK0_INTR0_GPIO1_EDGE_LOW_Msk (0x40UL)                  /*!< GPIO1_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_INTR0_GPIO1_LEVEL_HIGH_Pos (5UL)                   /*!< GPIO1_LEVEL_HIGH (Bit 5)                              */
#define IO_BANK0_INTR0_GPIO1_LEVEL_HIGH_Msk (0x20UL)                /*!< GPIO1_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR0_GPIO1_LEVEL_LOW_Pos (4UL)                    /*!< GPIO1_LEVEL_LOW (Bit 4)                               */
#define IO_BANK0_INTR0_GPIO1_LEVEL_LOW_Msk (0x10UL)                 /*!< GPIO1_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR0_GPIO0_EDGE_HIGH_Pos (3UL)                    /*!< GPIO0_EDGE_HIGH (Bit 3)                               */
#define IO_BANK0_INTR0_GPIO0_EDGE_HIGH_Msk (0x8UL)                  /*!< GPIO0_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR0_GPIO0_EDGE_LOW_Pos (2UL)                     /*!< GPIO0_EDGE_LOW (Bit 2)                                */
#define IO_BANK0_INTR0_GPIO0_EDGE_LOW_Msk (0x4UL)                   /*!< GPIO0_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_INTR0_GPIO0_LEVEL_HIGH_Pos (1UL)                   /*!< GPIO0_LEVEL_HIGH (Bit 1)                              */
#define IO_BANK0_INTR0_GPIO0_LEVEL_HIGH_Msk (0x2UL)                 /*!< GPIO0_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR0_GPIO0_LEVEL_LOW_Pos (0UL)                    /*!< GPIO0_LEVEL_LOW (Bit 0)                               */
#define IO_BANK0_INTR0_GPIO0_LEVEL_LOW_Msk (0x1UL)                  /*!< GPIO0_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
/* =========================================================  INTR1  ========================================================= */
#define IO_BANK0_INTR1_GPIO15_EDGE_HIGH_Pos (31UL)                  /*!< GPIO15_EDGE_HIGH (Bit 31)                             */
#define IO_BANK0_INTR1_GPIO15_EDGE_HIGH_Msk (0x80000000UL)          /*!< GPIO15_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR1_GPIO15_EDGE_LOW_Pos (30UL)                   /*!< GPIO15_EDGE_LOW (Bit 30)                              */
#define IO_BANK0_INTR1_GPIO15_EDGE_LOW_Msk (0x40000000UL)           /*!< GPIO15_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR1_GPIO15_LEVEL_HIGH_Pos (29UL)                 /*!< GPIO15_LEVEL_HIGH (Bit 29)                            */
#define IO_BANK0_INTR1_GPIO15_LEVEL_HIGH_Msk (0x20000000UL)         /*!< GPIO15_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_INTR1_GPIO15_LEVEL_LOW_Pos (28UL)                  /*!< GPIO15_LEVEL_LOW (Bit 28)                             */
#define IO_BANK0_INTR1_GPIO15_LEVEL_LOW_Msk (0x10000000UL)          /*!< GPIO15_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR1_GPIO14_EDGE_HIGH_Pos (27UL)                  /*!< GPIO14_EDGE_HIGH (Bit 27)                             */
#define IO_BANK0_INTR1_GPIO14_EDGE_HIGH_Msk (0x8000000UL)           /*!< GPIO14_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR1_GPIO14_EDGE_LOW_Pos (26UL)                   /*!< GPIO14_EDGE_LOW (Bit 26)                              */
#define IO_BANK0_INTR1_GPIO14_EDGE_LOW_Msk (0x4000000UL)            /*!< GPIO14_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR1_GPIO14_LEVEL_HIGH_Pos (25UL)                 /*!< GPIO14_LEVEL_HIGH (Bit 25)                            */
#define IO_BANK0_INTR1_GPIO14_LEVEL_HIGH_Msk (0x2000000UL)          /*!< GPIO14_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_INTR1_GPIO14_LEVEL_LOW_Pos (24UL)                  /*!< GPIO14_LEVEL_LOW (Bit 24)                             */
#define IO_BANK0_INTR1_GPIO14_LEVEL_LOW_Msk (0x1000000UL)           /*!< GPIO14_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR1_GPIO13_EDGE_HIGH_Pos (23UL)                  /*!< GPIO13_EDGE_HIGH (Bit 23)                             */
#define IO_BANK0_INTR1_GPIO13_EDGE_HIGH_Msk (0x800000UL)            /*!< GPIO13_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR1_GPIO13_EDGE_LOW_Pos (22UL)                   /*!< GPIO13_EDGE_LOW (Bit 22)                              */
#define IO_BANK0_INTR1_GPIO13_EDGE_LOW_Msk (0x400000UL)             /*!< GPIO13_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR1_GPIO13_LEVEL_HIGH_Pos (21UL)                 /*!< GPIO13_LEVEL_HIGH (Bit 21)                            */
#define IO_BANK0_INTR1_GPIO13_LEVEL_HIGH_Msk (0x200000UL)           /*!< GPIO13_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_INTR1_GPIO13_LEVEL_LOW_Pos (20UL)                  /*!< GPIO13_LEVEL_LOW (Bit 20)                             */
#define IO_BANK0_INTR1_GPIO13_LEVEL_LOW_Msk (0x100000UL)            /*!< GPIO13_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR1_GPIO12_EDGE_HIGH_Pos (19UL)                  /*!< GPIO12_EDGE_HIGH (Bit 19)                             */
#define IO_BANK0_INTR1_GPIO12_EDGE_HIGH_Msk (0x80000UL)             /*!< GPIO12_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR1_GPIO12_EDGE_LOW_Pos (18UL)                   /*!< GPIO12_EDGE_LOW (Bit 18)                              */
#define IO_BANK0_INTR1_GPIO12_EDGE_LOW_Msk (0x40000UL)              /*!< GPIO12_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR1_GPIO12_LEVEL_HIGH_Pos (17UL)                 /*!< GPIO12_LEVEL_HIGH (Bit 17)                            */
#define IO_BANK0_INTR1_GPIO12_LEVEL_HIGH_Msk (0x20000UL)            /*!< GPIO12_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_INTR1_GPIO12_LEVEL_LOW_Pos (16UL)                  /*!< GPIO12_LEVEL_LOW (Bit 16)                             */
#define IO_BANK0_INTR1_GPIO12_LEVEL_LOW_Msk (0x10000UL)             /*!< GPIO12_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR1_GPIO11_EDGE_HIGH_Pos (15UL)                  /*!< GPIO11_EDGE_HIGH (Bit 15)                             */
#define IO_BANK0_INTR1_GPIO11_EDGE_HIGH_Msk (0x8000UL)              /*!< GPIO11_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR1_GPIO11_EDGE_LOW_Pos (14UL)                   /*!< GPIO11_EDGE_LOW (Bit 14)                              */
#define IO_BANK0_INTR1_GPIO11_EDGE_LOW_Msk (0x4000UL)               /*!< GPIO11_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR1_GPIO11_LEVEL_HIGH_Pos (13UL)                 /*!< GPIO11_LEVEL_HIGH (Bit 13)                            */
#define IO_BANK0_INTR1_GPIO11_LEVEL_HIGH_Msk (0x2000UL)             /*!< GPIO11_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_INTR1_GPIO11_LEVEL_LOW_Pos (12UL)                  /*!< GPIO11_LEVEL_LOW (Bit 12)                             */
#define IO_BANK0_INTR1_GPIO11_LEVEL_LOW_Msk (0x1000UL)              /*!< GPIO11_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR1_GPIO10_EDGE_HIGH_Pos (11UL)                  /*!< GPIO10_EDGE_HIGH (Bit 11)                             */
#define IO_BANK0_INTR1_GPIO10_EDGE_HIGH_Msk (0x800UL)               /*!< GPIO10_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR1_GPIO10_EDGE_LOW_Pos (10UL)                   /*!< GPIO10_EDGE_LOW (Bit 10)                              */
#define IO_BANK0_INTR1_GPIO10_EDGE_LOW_Msk (0x400UL)                /*!< GPIO10_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR1_GPIO10_LEVEL_HIGH_Pos (9UL)                  /*!< GPIO10_LEVEL_HIGH (Bit 9)                             */
#define IO_BANK0_INTR1_GPIO10_LEVEL_HIGH_Msk (0x200UL)              /*!< GPIO10_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_INTR1_GPIO10_LEVEL_LOW_Pos (8UL)                   /*!< GPIO10_LEVEL_LOW (Bit 8)                              */
#define IO_BANK0_INTR1_GPIO10_LEVEL_LOW_Msk (0x100UL)               /*!< GPIO10_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR1_GPIO9_EDGE_HIGH_Pos (7UL)                    /*!< GPIO9_EDGE_HIGH (Bit 7)                               */
#define IO_BANK0_INTR1_GPIO9_EDGE_HIGH_Msk (0x80UL)                 /*!< GPIO9_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR1_GPIO9_EDGE_LOW_Pos (6UL)                     /*!< GPIO9_EDGE_LOW (Bit 6)                                */
#define IO_BANK0_INTR1_GPIO9_EDGE_LOW_Msk (0x40UL)                  /*!< GPIO9_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_INTR1_GPIO9_LEVEL_HIGH_Pos (5UL)                   /*!< GPIO9_LEVEL_HIGH (Bit 5)                              */
#define IO_BANK0_INTR1_GPIO9_LEVEL_HIGH_Msk (0x20UL)                /*!< GPIO9_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR1_GPIO9_LEVEL_LOW_Pos (4UL)                    /*!< GPIO9_LEVEL_LOW (Bit 4)                               */
#define IO_BANK0_INTR1_GPIO9_LEVEL_LOW_Msk (0x10UL)                 /*!< GPIO9_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR1_GPIO8_EDGE_HIGH_Pos (3UL)                    /*!< GPIO8_EDGE_HIGH (Bit 3)                               */
#define IO_BANK0_INTR1_GPIO8_EDGE_HIGH_Msk (0x8UL)                  /*!< GPIO8_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR1_GPIO8_EDGE_LOW_Pos (2UL)                     /*!< GPIO8_EDGE_LOW (Bit 2)                                */
#define IO_BANK0_INTR1_GPIO8_EDGE_LOW_Msk (0x4UL)                   /*!< GPIO8_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_INTR1_GPIO8_LEVEL_HIGH_Pos (1UL)                   /*!< GPIO8_LEVEL_HIGH (Bit 1)                              */
#define IO_BANK0_INTR1_GPIO8_LEVEL_HIGH_Msk (0x2UL)                 /*!< GPIO8_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR1_GPIO8_LEVEL_LOW_Pos (0UL)                    /*!< GPIO8_LEVEL_LOW (Bit 0)                               */
#define IO_BANK0_INTR1_GPIO8_LEVEL_LOW_Msk (0x1UL)                  /*!< GPIO8_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
/* =========================================================  INTR2  ========================================================= */
#define IO_BANK0_INTR2_GPIO23_EDGE_HIGH_Pos (31UL)                  /*!< GPIO23_EDGE_HIGH (Bit 31)                             */
#define IO_BANK0_INTR2_GPIO23_EDGE_HIGH_Msk (0x80000000UL)          /*!< GPIO23_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR2_GPIO23_EDGE_LOW_Pos (30UL)                   /*!< GPIO23_EDGE_LOW (Bit 30)                              */
#define IO_BANK0_INTR2_GPIO23_EDGE_LOW_Msk (0x40000000UL)           /*!< GPIO23_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR2_GPIO23_LEVEL_HIGH_Pos (29UL)                 /*!< GPIO23_LEVEL_HIGH (Bit 29)                            */
#define IO_BANK0_INTR2_GPIO23_LEVEL_HIGH_Msk (0x20000000UL)         /*!< GPIO23_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_INTR2_GPIO23_LEVEL_LOW_Pos (28UL)                  /*!< GPIO23_LEVEL_LOW (Bit 28)                             */
#define IO_BANK0_INTR2_GPIO23_LEVEL_LOW_Msk (0x10000000UL)          /*!< GPIO23_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR2_GPIO22_EDGE_HIGH_Pos (27UL)                  /*!< GPIO22_EDGE_HIGH (Bit 27)                             */
#define IO_BANK0_INTR2_GPIO22_EDGE_HIGH_Msk (0x8000000UL)           /*!< GPIO22_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR2_GPIO22_EDGE_LOW_Pos (26UL)                   /*!< GPIO22_EDGE_LOW (Bit 26)                              */
#define IO_BANK0_INTR2_GPIO22_EDGE_LOW_Msk (0x4000000UL)            /*!< GPIO22_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR2_GPIO22_LEVEL_HIGH_Pos (25UL)                 /*!< GPIO22_LEVEL_HIGH (Bit 25)                            */
#define IO_BANK0_INTR2_GPIO22_LEVEL_HIGH_Msk (0x2000000UL)          /*!< GPIO22_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_INTR2_GPIO22_LEVEL_LOW_Pos (24UL)                  /*!< GPIO22_LEVEL_LOW (Bit 24)                             */
#define IO_BANK0_INTR2_GPIO22_LEVEL_LOW_Msk (0x1000000UL)           /*!< GPIO22_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR2_GPIO21_EDGE_HIGH_Pos (23UL)                  /*!< GPIO21_EDGE_HIGH (Bit 23)                             */
#define IO_BANK0_INTR2_GPIO21_EDGE_HIGH_Msk (0x800000UL)            /*!< GPIO21_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR2_GPIO21_EDGE_LOW_Pos (22UL)                   /*!< GPIO21_EDGE_LOW (Bit 22)                              */
#define IO_BANK0_INTR2_GPIO21_EDGE_LOW_Msk (0x400000UL)             /*!< GPIO21_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR2_GPIO21_LEVEL_HIGH_Pos (21UL)                 /*!< GPIO21_LEVEL_HIGH (Bit 21)                            */
#define IO_BANK0_INTR2_GPIO21_LEVEL_HIGH_Msk (0x200000UL)           /*!< GPIO21_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_INTR2_GPIO21_LEVEL_LOW_Pos (20UL)                  /*!< GPIO21_LEVEL_LOW (Bit 20)                             */
#define IO_BANK0_INTR2_GPIO21_LEVEL_LOW_Msk (0x100000UL)            /*!< GPIO21_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR2_GPIO20_EDGE_HIGH_Pos (19UL)                  /*!< GPIO20_EDGE_HIGH (Bit 19)                             */
#define IO_BANK0_INTR2_GPIO20_EDGE_HIGH_Msk (0x80000UL)             /*!< GPIO20_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR2_GPIO20_EDGE_LOW_Pos (18UL)                   /*!< GPIO20_EDGE_LOW (Bit 18)                              */
#define IO_BANK0_INTR2_GPIO20_EDGE_LOW_Msk (0x40000UL)              /*!< GPIO20_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR2_GPIO20_LEVEL_HIGH_Pos (17UL)                 /*!< GPIO20_LEVEL_HIGH (Bit 17)                            */
#define IO_BANK0_INTR2_GPIO20_LEVEL_HIGH_Msk (0x20000UL)            /*!< GPIO20_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_INTR2_GPIO20_LEVEL_LOW_Pos (16UL)                  /*!< GPIO20_LEVEL_LOW (Bit 16)                             */
#define IO_BANK0_INTR2_GPIO20_LEVEL_LOW_Msk (0x10000UL)             /*!< GPIO20_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR2_GPIO19_EDGE_HIGH_Pos (15UL)                  /*!< GPIO19_EDGE_HIGH (Bit 15)                             */
#define IO_BANK0_INTR2_GPIO19_EDGE_HIGH_Msk (0x8000UL)              /*!< GPIO19_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR2_GPIO19_EDGE_LOW_Pos (14UL)                   /*!< GPIO19_EDGE_LOW (Bit 14)                              */
#define IO_BANK0_INTR2_GPIO19_EDGE_LOW_Msk (0x4000UL)               /*!< GPIO19_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR2_GPIO19_LEVEL_HIGH_Pos (13UL)                 /*!< GPIO19_LEVEL_HIGH (Bit 13)                            */
#define IO_BANK0_INTR2_GPIO19_LEVEL_HIGH_Msk (0x2000UL)             /*!< GPIO19_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_INTR2_GPIO19_LEVEL_LOW_Pos (12UL)                  /*!< GPIO19_LEVEL_LOW (Bit 12)                             */
#define IO_BANK0_INTR2_GPIO19_LEVEL_LOW_Msk (0x1000UL)              /*!< GPIO19_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR2_GPIO18_EDGE_HIGH_Pos (11UL)                  /*!< GPIO18_EDGE_HIGH (Bit 11)                             */
#define IO_BANK0_INTR2_GPIO18_EDGE_HIGH_Msk (0x800UL)               /*!< GPIO18_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR2_GPIO18_EDGE_LOW_Pos (10UL)                   /*!< GPIO18_EDGE_LOW (Bit 10)                              */
#define IO_BANK0_INTR2_GPIO18_EDGE_LOW_Msk (0x400UL)                /*!< GPIO18_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR2_GPIO18_LEVEL_HIGH_Pos (9UL)                  /*!< GPIO18_LEVEL_HIGH (Bit 9)                             */
#define IO_BANK0_INTR2_GPIO18_LEVEL_HIGH_Msk (0x200UL)              /*!< GPIO18_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_INTR2_GPIO18_LEVEL_LOW_Pos (8UL)                   /*!< GPIO18_LEVEL_LOW (Bit 8)                              */
#define IO_BANK0_INTR2_GPIO18_LEVEL_LOW_Msk (0x100UL)               /*!< GPIO18_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR2_GPIO17_EDGE_HIGH_Pos (7UL)                   /*!< GPIO17_EDGE_HIGH (Bit 7)                              */
#define IO_BANK0_INTR2_GPIO17_EDGE_HIGH_Msk (0x80UL)                /*!< GPIO17_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR2_GPIO17_EDGE_LOW_Pos (6UL)                    /*!< GPIO17_EDGE_LOW (Bit 6)                               */
#define IO_BANK0_INTR2_GPIO17_EDGE_LOW_Msk (0x40UL)                 /*!< GPIO17_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR2_GPIO17_LEVEL_HIGH_Pos (5UL)                  /*!< GPIO17_LEVEL_HIGH (Bit 5)                             */
#define IO_BANK0_INTR2_GPIO17_LEVEL_HIGH_Msk (0x20UL)               /*!< GPIO17_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_INTR2_GPIO17_LEVEL_LOW_Pos (4UL)                   /*!< GPIO17_LEVEL_LOW (Bit 4)                              */
#define IO_BANK0_INTR2_GPIO17_LEVEL_LOW_Msk (0x10UL)                /*!< GPIO17_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR2_GPIO16_EDGE_HIGH_Pos (3UL)                   /*!< GPIO16_EDGE_HIGH (Bit 3)                              */
#define IO_BANK0_INTR2_GPIO16_EDGE_HIGH_Msk (0x8UL)                 /*!< GPIO16_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR2_GPIO16_EDGE_LOW_Pos (2UL)                    /*!< GPIO16_EDGE_LOW (Bit 2)                               */
#define IO_BANK0_INTR2_GPIO16_EDGE_LOW_Msk (0x4UL)                  /*!< GPIO16_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR2_GPIO16_LEVEL_HIGH_Pos (1UL)                  /*!< GPIO16_LEVEL_HIGH (Bit 1)                             */
#define IO_BANK0_INTR2_GPIO16_LEVEL_HIGH_Msk (0x2UL)                /*!< GPIO16_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_INTR2_GPIO16_LEVEL_LOW_Pos (0UL)                   /*!< GPIO16_LEVEL_LOW (Bit 0)                              */
#define IO_BANK0_INTR2_GPIO16_LEVEL_LOW_Msk (0x1UL)                 /*!< GPIO16_LEVEL_LOW (Bitfield-Mask: 0x01)                */
/* =========================================================  INTR3  ========================================================= */
#define IO_BANK0_INTR3_GPIO29_EDGE_HIGH_Pos (23UL)                  /*!< GPIO29_EDGE_HIGH (Bit 23)                             */
#define IO_BANK0_INTR3_GPIO29_EDGE_HIGH_Msk (0x800000UL)            /*!< GPIO29_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR3_GPIO29_EDGE_LOW_Pos (22UL)                   /*!< GPIO29_EDGE_LOW (Bit 22)                              */
#define IO_BANK0_INTR3_GPIO29_EDGE_LOW_Msk (0x400000UL)             /*!< GPIO29_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR3_GPIO29_LEVEL_HIGH_Pos (21UL)                 /*!< GPIO29_LEVEL_HIGH (Bit 21)                            */
#define IO_BANK0_INTR3_GPIO29_LEVEL_HIGH_Msk (0x200000UL)           /*!< GPIO29_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_INTR3_GPIO29_LEVEL_LOW_Pos (20UL)                  /*!< GPIO29_LEVEL_LOW (Bit 20)                             */
#define IO_BANK0_INTR3_GPIO29_LEVEL_LOW_Msk (0x100000UL)            /*!< GPIO29_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR3_GPIO28_EDGE_HIGH_Pos (19UL)                  /*!< GPIO28_EDGE_HIGH (Bit 19)                             */
#define IO_BANK0_INTR3_GPIO28_EDGE_HIGH_Msk (0x80000UL)             /*!< GPIO28_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR3_GPIO28_EDGE_LOW_Pos (18UL)                   /*!< GPIO28_EDGE_LOW (Bit 18)                              */
#define IO_BANK0_INTR3_GPIO28_EDGE_LOW_Msk (0x40000UL)              /*!< GPIO28_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR3_GPIO28_LEVEL_HIGH_Pos (17UL)                 /*!< GPIO28_LEVEL_HIGH (Bit 17)                            */
#define IO_BANK0_INTR3_GPIO28_LEVEL_HIGH_Msk (0x20000UL)            /*!< GPIO28_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_INTR3_GPIO28_LEVEL_LOW_Pos (16UL)                  /*!< GPIO28_LEVEL_LOW (Bit 16)                             */
#define IO_BANK0_INTR3_GPIO28_LEVEL_LOW_Msk (0x10000UL)             /*!< GPIO28_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR3_GPIO27_EDGE_HIGH_Pos (15UL)                  /*!< GPIO27_EDGE_HIGH (Bit 15)                             */
#define IO_BANK0_INTR3_GPIO27_EDGE_HIGH_Msk (0x8000UL)              /*!< GPIO27_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR3_GPIO27_EDGE_LOW_Pos (14UL)                   /*!< GPIO27_EDGE_LOW (Bit 14)                              */
#define IO_BANK0_INTR3_GPIO27_EDGE_LOW_Msk (0x4000UL)               /*!< GPIO27_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR3_GPIO27_LEVEL_HIGH_Pos (13UL)                 /*!< GPIO27_LEVEL_HIGH (Bit 13)                            */
#define IO_BANK0_INTR3_GPIO27_LEVEL_HIGH_Msk (0x2000UL)             /*!< GPIO27_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_INTR3_GPIO27_LEVEL_LOW_Pos (12UL)                  /*!< GPIO27_LEVEL_LOW (Bit 12)                             */
#define IO_BANK0_INTR3_GPIO27_LEVEL_LOW_Msk (0x1000UL)              /*!< GPIO27_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR3_GPIO26_EDGE_HIGH_Pos (11UL)                  /*!< GPIO26_EDGE_HIGH (Bit 11)                             */
#define IO_BANK0_INTR3_GPIO26_EDGE_HIGH_Msk (0x800UL)               /*!< GPIO26_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR3_GPIO26_EDGE_LOW_Pos (10UL)                   /*!< GPIO26_EDGE_LOW (Bit 10)                              */
#define IO_BANK0_INTR3_GPIO26_EDGE_LOW_Msk (0x400UL)                /*!< GPIO26_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR3_GPIO26_LEVEL_HIGH_Pos (9UL)                  /*!< GPIO26_LEVEL_HIGH (Bit 9)                             */
#define IO_BANK0_INTR3_GPIO26_LEVEL_HIGH_Msk (0x200UL)              /*!< GPIO26_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_INTR3_GPIO26_LEVEL_LOW_Pos (8UL)                   /*!< GPIO26_LEVEL_LOW (Bit 8)                              */
#define IO_BANK0_INTR3_GPIO26_LEVEL_LOW_Msk (0x100UL)               /*!< GPIO26_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR3_GPIO25_EDGE_HIGH_Pos (7UL)                   /*!< GPIO25_EDGE_HIGH (Bit 7)                              */
#define IO_BANK0_INTR3_GPIO25_EDGE_HIGH_Msk (0x80UL)                /*!< GPIO25_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR3_GPIO25_EDGE_LOW_Pos (6UL)                    /*!< GPIO25_EDGE_LOW (Bit 6)                               */
#define IO_BANK0_INTR3_GPIO25_EDGE_LOW_Msk (0x40UL)                 /*!< GPIO25_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR3_GPIO25_LEVEL_HIGH_Pos (5UL)                  /*!< GPIO25_LEVEL_HIGH (Bit 5)                             */
#define IO_BANK0_INTR3_GPIO25_LEVEL_HIGH_Msk (0x20UL)               /*!< GPIO25_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_INTR3_GPIO25_LEVEL_LOW_Pos (4UL)                   /*!< GPIO25_LEVEL_LOW (Bit 4)                              */
#define IO_BANK0_INTR3_GPIO25_LEVEL_LOW_Msk (0x10UL)                /*!< GPIO25_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR3_GPIO24_EDGE_HIGH_Pos (3UL)                   /*!< GPIO24_EDGE_HIGH (Bit 3)                              */
#define IO_BANK0_INTR3_GPIO24_EDGE_HIGH_Msk (0x8UL)                 /*!< GPIO24_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_INTR3_GPIO24_EDGE_LOW_Pos (2UL)                    /*!< GPIO24_EDGE_LOW (Bit 2)                               */
#define IO_BANK0_INTR3_GPIO24_EDGE_LOW_Msk (0x4UL)                  /*!< GPIO24_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_INTR3_GPIO24_LEVEL_HIGH_Pos (1UL)                  /*!< GPIO24_LEVEL_HIGH (Bit 1)                             */
#define IO_BANK0_INTR3_GPIO24_LEVEL_HIGH_Msk (0x2UL)                /*!< GPIO24_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_INTR3_GPIO24_LEVEL_LOW_Pos (0UL)                   /*!< GPIO24_LEVEL_LOW (Bit 0)                              */
#define IO_BANK0_INTR3_GPIO24_LEVEL_LOW_Msk (0x1UL)                 /*!< GPIO24_LEVEL_LOW (Bitfield-Mask: 0x01)                */
/* ======================================================  PROC0_INTE0  ====================================================== */
#define IO_BANK0_PROC0_INTE0_GPIO7_EDGE_HIGH_Pos (31UL)             /*!< GPIO7_EDGE_HIGH (Bit 31)                              */
#define IO_BANK0_PROC0_INTE0_GPIO7_EDGE_HIGH_Msk (0x80000000UL)     /*!< GPIO7_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE0_GPIO7_EDGE_LOW_Pos (30UL)              /*!< GPIO7_EDGE_LOW (Bit 30)                               */
#define IO_BANK0_PROC0_INTE0_GPIO7_EDGE_LOW_Msk (0x40000000UL)      /*!< GPIO7_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC0_INTE0_GPIO7_LEVEL_HIGH_Pos (29UL)            /*!< GPIO7_LEVEL_HIGH (Bit 29)                             */
#define IO_BANK0_PROC0_INTE0_GPIO7_LEVEL_HIGH_Msk (0x20000000UL)    /*!< GPIO7_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE0_GPIO7_LEVEL_LOW_Pos (28UL)             /*!< GPIO7_LEVEL_LOW (Bit 28)                              */
#define IO_BANK0_PROC0_INTE0_GPIO7_LEVEL_LOW_Msk (0x10000000UL)     /*!< GPIO7_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE0_GPIO6_EDGE_HIGH_Pos (27UL)             /*!< GPIO6_EDGE_HIGH (Bit 27)                              */
#define IO_BANK0_PROC0_INTE0_GPIO6_EDGE_HIGH_Msk (0x8000000UL)      /*!< GPIO6_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE0_GPIO6_EDGE_LOW_Pos (26UL)              /*!< GPIO6_EDGE_LOW (Bit 26)                               */
#define IO_BANK0_PROC0_INTE0_GPIO6_EDGE_LOW_Msk (0x4000000UL)       /*!< GPIO6_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC0_INTE0_GPIO6_LEVEL_HIGH_Pos (25UL)            /*!< GPIO6_LEVEL_HIGH (Bit 25)                             */
#define IO_BANK0_PROC0_INTE0_GPIO6_LEVEL_HIGH_Msk (0x2000000UL)     /*!< GPIO6_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE0_GPIO6_LEVEL_LOW_Pos (24UL)             /*!< GPIO6_LEVEL_LOW (Bit 24)                              */
#define IO_BANK0_PROC0_INTE0_GPIO6_LEVEL_LOW_Msk (0x1000000UL)      /*!< GPIO6_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE0_GPIO5_EDGE_HIGH_Pos (23UL)             /*!< GPIO5_EDGE_HIGH (Bit 23)                              */
#define IO_BANK0_PROC0_INTE0_GPIO5_EDGE_HIGH_Msk (0x800000UL)       /*!< GPIO5_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE0_GPIO5_EDGE_LOW_Pos (22UL)              /*!< GPIO5_EDGE_LOW (Bit 22)                               */
#define IO_BANK0_PROC0_INTE0_GPIO5_EDGE_LOW_Msk (0x400000UL)        /*!< GPIO5_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC0_INTE0_GPIO5_LEVEL_HIGH_Pos (21UL)            /*!< GPIO5_LEVEL_HIGH (Bit 21)                             */
#define IO_BANK0_PROC0_INTE0_GPIO5_LEVEL_HIGH_Msk (0x200000UL)      /*!< GPIO5_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE0_GPIO5_LEVEL_LOW_Pos (20UL)             /*!< GPIO5_LEVEL_LOW (Bit 20)                              */
#define IO_BANK0_PROC0_INTE0_GPIO5_LEVEL_LOW_Msk (0x100000UL)       /*!< GPIO5_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE0_GPIO4_EDGE_HIGH_Pos (19UL)             /*!< GPIO4_EDGE_HIGH (Bit 19)                              */
#define IO_BANK0_PROC0_INTE0_GPIO4_EDGE_HIGH_Msk (0x80000UL)        /*!< GPIO4_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE0_GPIO4_EDGE_LOW_Pos (18UL)              /*!< GPIO4_EDGE_LOW (Bit 18)                               */
#define IO_BANK0_PROC0_INTE0_GPIO4_EDGE_LOW_Msk (0x40000UL)         /*!< GPIO4_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC0_INTE0_GPIO4_LEVEL_HIGH_Pos (17UL)            /*!< GPIO4_LEVEL_HIGH (Bit 17)                             */
#define IO_BANK0_PROC0_INTE0_GPIO4_LEVEL_HIGH_Msk (0x20000UL)       /*!< GPIO4_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE0_GPIO4_LEVEL_LOW_Pos (16UL)             /*!< GPIO4_LEVEL_LOW (Bit 16)                              */
#define IO_BANK0_PROC0_INTE0_GPIO4_LEVEL_LOW_Msk (0x10000UL)        /*!< GPIO4_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE0_GPIO3_EDGE_HIGH_Pos (15UL)             /*!< GPIO3_EDGE_HIGH (Bit 15)                              */
#define IO_BANK0_PROC0_INTE0_GPIO3_EDGE_HIGH_Msk (0x8000UL)         /*!< GPIO3_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE0_GPIO3_EDGE_LOW_Pos (14UL)              /*!< GPIO3_EDGE_LOW (Bit 14)                               */
#define IO_BANK0_PROC0_INTE0_GPIO3_EDGE_LOW_Msk (0x4000UL)          /*!< GPIO3_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC0_INTE0_GPIO3_LEVEL_HIGH_Pos (13UL)            /*!< GPIO3_LEVEL_HIGH (Bit 13)                             */
#define IO_BANK0_PROC0_INTE0_GPIO3_LEVEL_HIGH_Msk (0x2000UL)        /*!< GPIO3_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE0_GPIO3_LEVEL_LOW_Pos (12UL)             /*!< GPIO3_LEVEL_LOW (Bit 12)                              */
#define IO_BANK0_PROC0_INTE0_GPIO3_LEVEL_LOW_Msk (0x1000UL)         /*!< GPIO3_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE0_GPIO2_EDGE_HIGH_Pos (11UL)             /*!< GPIO2_EDGE_HIGH (Bit 11)                              */
#define IO_BANK0_PROC0_INTE0_GPIO2_EDGE_HIGH_Msk (0x800UL)          /*!< GPIO2_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE0_GPIO2_EDGE_LOW_Pos (10UL)              /*!< GPIO2_EDGE_LOW (Bit 10)                               */
#define IO_BANK0_PROC0_INTE0_GPIO2_EDGE_LOW_Msk (0x400UL)           /*!< GPIO2_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC0_INTE0_GPIO2_LEVEL_HIGH_Pos (9UL)             /*!< GPIO2_LEVEL_HIGH (Bit 9)                              */
#define IO_BANK0_PROC0_INTE0_GPIO2_LEVEL_HIGH_Msk (0x200UL)         /*!< GPIO2_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE0_GPIO2_LEVEL_LOW_Pos (8UL)              /*!< GPIO2_LEVEL_LOW (Bit 8)                               */
#define IO_BANK0_PROC0_INTE0_GPIO2_LEVEL_LOW_Msk (0x100UL)          /*!< GPIO2_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE0_GPIO1_EDGE_HIGH_Pos (7UL)              /*!< GPIO1_EDGE_HIGH (Bit 7)                               */
#define IO_BANK0_PROC0_INTE0_GPIO1_EDGE_HIGH_Msk (0x80UL)           /*!< GPIO1_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE0_GPIO1_EDGE_LOW_Pos (6UL)               /*!< GPIO1_EDGE_LOW (Bit 6)                                */
#define IO_BANK0_PROC0_INTE0_GPIO1_EDGE_LOW_Msk (0x40UL)            /*!< GPIO1_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC0_INTE0_GPIO1_LEVEL_HIGH_Pos (5UL)             /*!< GPIO1_LEVEL_HIGH (Bit 5)                              */
#define IO_BANK0_PROC0_INTE0_GPIO1_LEVEL_HIGH_Msk (0x20UL)          /*!< GPIO1_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE0_GPIO1_LEVEL_LOW_Pos (4UL)              /*!< GPIO1_LEVEL_LOW (Bit 4)                               */
#define IO_BANK0_PROC0_INTE0_GPIO1_LEVEL_LOW_Msk (0x10UL)           /*!< GPIO1_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE0_GPIO0_EDGE_HIGH_Pos (3UL)              /*!< GPIO0_EDGE_HIGH (Bit 3)                               */
#define IO_BANK0_PROC0_INTE0_GPIO0_EDGE_HIGH_Msk (0x8UL)            /*!< GPIO0_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE0_GPIO0_EDGE_LOW_Pos (2UL)               /*!< GPIO0_EDGE_LOW (Bit 2)                                */
#define IO_BANK0_PROC0_INTE0_GPIO0_EDGE_LOW_Msk (0x4UL)             /*!< GPIO0_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC0_INTE0_GPIO0_LEVEL_HIGH_Pos (1UL)             /*!< GPIO0_LEVEL_HIGH (Bit 1)                              */
#define IO_BANK0_PROC0_INTE0_GPIO0_LEVEL_HIGH_Msk (0x2UL)           /*!< GPIO0_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE0_GPIO0_LEVEL_LOW_Pos (0UL)              /*!< GPIO0_LEVEL_LOW (Bit 0)                               */
#define IO_BANK0_PROC0_INTE0_GPIO0_LEVEL_LOW_Msk (0x1UL)            /*!< GPIO0_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
/* ======================================================  PROC0_INTE1  ====================================================== */
#define IO_BANK0_PROC0_INTE1_GPIO15_EDGE_HIGH_Pos (31UL)            /*!< GPIO15_EDGE_HIGH (Bit 31)                             */
#define IO_BANK0_PROC0_INTE1_GPIO15_EDGE_HIGH_Msk (0x80000000UL)    /*!< GPIO15_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE1_GPIO15_EDGE_LOW_Pos (30UL)             /*!< GPIO15_EDGE_LOW (Bit 30)                              */
#define IO_BANK0_PROC0_INTE1_GPIO15_EDGE_LOW_Msk (0x40000000UL)     /*!< GPIO15_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE1_GPIO15_LEVEL_HIGH_Pos (29UL)           /*!< GPIO15_LEVEL_HIGH (Bit 29)                            */
#define IO_BANK0_PROC0_INTE1_GPIO15_LEVEL_HIGH_Msk (0x20000000UL)   /*!< GPIO15_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTE1_GPIO15_LEVEL_LOW_Pos (28UL)            /*!< GPIO15_LEVEL_LOW (Bit 28)                             */
#define IO_BANK0_PROC0_INTE1_GPIO15_LEVEL_LOW_Msk (0x10000000UL)    /*!< GPIO15_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE1_GPIO14_EDGE_HIGH_Pos (27UL)            /*!< GPIO14_EDGE_HIGH (Bit 27)                             */
#define IO_BANK0_PROC0_INTE1_GPIO14_EDGE_HIGH_Msk (0x8000000UL)     /*!< GPIO14_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE1_GPIO14_EDGE_LOW_Pos (26UL)             /*!< GPIO14_EDGE_LOW (Bit 26)                              */
#define IO_BANK0_PROC0_INTE1_GPIO14_EDGE_LOW_Msk (0x4000000UL)      /*!< GPIO14_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE1_GPIO14_LEVEL_HIGH_Pos (25UL)           /*!< GPIO14_LEVEL_HIGH (Bit 25)                            */
#define IO_BANK0_PROC0_INTE1_GPIO14_LEVEL_HIGH_Msk (0x2000000UL)    /*!< GPIO14_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTE1_GPIO14_LEVEL_LOW_Pos (24UL)            /*!< GPIO14_LEVEL_LOW (Bit 24)                             */
#define IO_BANK0_PROC0_INTE1_GPIO14_LEVEL_LOW_Msk (0x1000000UL)     /*!< GPIO14_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE1_GPIO13_EDGE_HIGH_Pos (23UL)            /*!< GPIO13_EDGE_HIGH (Bit 23)                             */
#define IO_BANK0_PROC0_INTE1_GPIO13_EDGE_HIGH_Msk (0x800000UL)      /*!< GPIO13_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE1_GPIO13_EDGE_LOW_Pos (22UL)             /*!< GPIO13_EDGE_LOW (Bit 22)                              */
#define IO_BANK0_PROC0_INTE1_GPIO13_EDGE_LOW_Msk (0x400000UL)       /*!< GPIO13_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE1_GPIO13_LEVEL_HIGH_Pos (21UL)           /*!< GPIO13_LEVEL_HIGH (Bit 21)                            */
#define IO_BANK0_PROC0_INTE1_GPIO13_LEVEL_HIGH_Msk (0x200000UL)     /*!< GPIO13_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTE1_GPIO13_LEVEL_LOW_Pos (20UL)            /*!< GPIO13_LEVEL_LOW (Bit 20)                             */
#define IO_BANK0_PROC0_INTE1_GPIO13_LEVEL_LOW_Msk (0x100000UL)      /*!< GPIO13_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE1_GPIO12_EDGE_HIGH_Pos (19UL)            /*!< GPIO12_EDGE_HIGH (Bit 19)                             */
#define IO_BANK0_PROC0_INTE1_GPIO12_EDGE_HIGH_Msk (0x80000UL)       /*!< GPIO12_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE1_GPIO12_EDGE_LOW_Pos (18UL)             /*!< GPIO12_EDGE_LOW (Bit 18)                              */
#define IO_BANK0_PROC0_INTE1_GPIO12_EDGE_LOW_Msk (0x40000UL)        /*!< GPIO12_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE1_GPIO12_LEVEL_HIGH_Pos (17UL)           /*!< GPIO12_LEVEL_HIGH (Bit 17)                            */
#define IO_BANK0_PROC0_INTE1_GPIO12_LEVEL_HIGH_Msk (0x20000UL)      /*!< GPIO12_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTE1_GPIO12_LEVEL_LOW_Pos (16UL)            /*!< GPIO12_LEVEL_LOW (Bit 16)                             */
#define IO_BANK0_PROC0_INTE1_GPIO12_LEVEL_LOW_Msk (0x10000UL)       /*!< GPIO12_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE1_GPIO11_EDGE_HIGH_Pos (15UL)            /*!< GPIO11_EDGE_HIGH (Bit 15)                             */
#define IO_BANK0_PROC0_INTE1_GPIO11_EDGE_HIGH_Msk (0x8000UL)        /*!< GPIO11_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE1_GPIO11_EDGE_LOW_Pos (14UL)             /*!< GPIO11_EDGE_LOW (Bit 14)                              */
#define IO_BANK0_PROC0_INTE1_GPIO11_EDGE_LOW_Msk (0x4000UL)         /*!< GPIO11_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE1_GPIO11_LEVEL_HIGH_Pos (13UL)           /*!< GPIO11_LEVEL_HIGH (Bit 13)                            */
#define IO_BANK0_PROC0_INTE1_GPIO11_LEVEL_HIGH_Msk (0x2000UL)       /*!< GPIO11_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTE1_GPIO11_LEVEL_LOW_Pos (12UL)            /*!< GPIO11_LEVEL_LOW (Bit 12)                             */
#define IO_BANK0_PROC0_INTE1_GPIO11_LEVEL_LOW_Msk (0x1000UL)        /*!< GPIO11_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE1_GPIO10_EDGE_HIGH_Pos (11UL)            /*!< GPIO10_EDGE_HIGH (Bit 11)                             */
#define IO_BANK0_PROC0_INTE1_GPIO10_EDGE_HIGH_Msk (0x800UL)         /*!< GPIO10_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE1_GPIO10_EDGE_LOW_Pos (10UL)             /*!< GPIO10_EDGE_LOW (Bit 10)                              */
#define IO_BANK0_PROC0_INTE1_GPIO10_EDGE_LOW_Msk (0x400UL)          /*!< GPIO10_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE1_GPIO10_LEVEL_HIGH_Pos (9UL)            /*!< GPIO10_LEVEL_HIGH (Bit 9)                             */
#define IO_BANK0_PROC0_INTE1_GPIO10_LEVEL_HIGH_Msk (0x200UL)        /*!< GPIO10_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTE1_GPIO10_LEVEL_LOW_Pos (8UL)             /*!< GPIO10_LEVEL_LOW (Bit 8)                              */
#define IO_BANK0_PROC0_INTE1_GPIO10_LEVEL_LOW_Msk (0x100UL)         /*!< GPIO10_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE1_GPIO9_EDGE_HIGH_Pos (7UL)              /*!< GPIO9_EDGE_HIGH (Bit 7)                               */
#define IO_BANK0_PROC0_INTE1_GPIO9_EDGE_HIGH_Msk (0x80UL)           /*!< GPIO9_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE1_GPIO9_EDGE_LOW_Pos (6UL)               /*!< GPIO9_EDGE_LOW (Bit 6)                                */
#define IO_BANK0_PROC0_INTE1_GPIO9_EDGE_LOW_Msk (0x40UL)            /*!< GPIO9_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC0_INTE1_GPIO9_LEVEL_HIGH_Pos (5UL)             /*!< GPIO9_LEVEL_HIGH (Bit 5)                              */
#define IO_BANK0_PROC0_INTE1_GPIO9_LEVEL_HIGH_Msk (0x20UL)          /*!< GPIO9_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE1_GPIO9_LEVEL_LOW_Pos (4UL)              /*!< GPIO9_LEVEL_LOW (Bit 4)                               */
#define IO_BANK0_PROC0_INTE1_GPIO9_LEVEL_LOW_Msk (0x10UL)           /*!< GPIO9_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE1_GPIO8_EDGE_HIGH_Pos (3UL)              /*!< GPIO8_EDGE_HIGH (Bit 3)                               */
#define IO_BANK0_PROC0_INTE1_GPIO8_EDGE_HIGH_Msk (0x8UL)            /*!< GPIO8_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE1_GPIO8_EDGE_LOW_Pos (2UL)               /*!< GPIO8_EDGE_LOW (Bit 2)                                */
#define IO_BANK0_PROC0_INTE1_GPIO8_EDGE_LOW_Msk (0x4UL)             /*!< GPIO8_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC0_INTE1_GPIO8_LEVEL_HIGH_Pos (1UL)             /*!< GPIO8_LEVEL_HIGH (Bit 1)                              */
#define IO_BANK0_PROC0_INTE1_GPIO8_LEVEL_HIGH_Msk (0x2UL)           /*!< GPIO8_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE1_GPIO8_LEVEL_LOW_Pos (0UL)              /*!< GPIO8_LEVEL_LOW (Bit 0)                               */
#define IO_BANK0_PROC0_INTE1_GPIO8_LEVEL_LOW_Msk (0x1UL)            /*!< GPIO8_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
/* ======================================================  PROC0_INTE2  ====================================================== */
#define IO_BANK0_PROC0_INTE2_GPIO23_EDGE_HIGH_Pos (31UL)            /*!< GPIO23_EDGE_HIGH (Bit 31)                             */
#define IO_BANK0_PROC0_INTE2_GPIO23_EDGE_HIGH_Msk (0x80000000UL)    /*!< GPIO23_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE2_GPIO23_EDGE_LOW_Pos (30UL)             /*!< GPIO23_EDGE_LOW (Bit 30)                              */
#define IO_BANK0_PROC0_INTE2_GPIO23_EDGE_LOW_Msk (0x40000000UL)     /*!< GPIO23_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE2_GPIO23_LEVEL_HIGH_Pos (29UL)           /*!< GPIO23_LEVEL_HIGH (Bit 29)                            */
#define IO_BANK0_PROC0_INTE2_GPIO23_LEVEL_HIGH_Msk (0x20000000UL)   /*!< GPIO23_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTE2_GPIO23_LEVEL_LOW_Pos (28UL)            /*!< GPIO23_LEVEL_LOW (Bit 28)                             */
#define IO_BANK0_PROC0_INTE2_GPIO23_LEVEL_LOW_Msk (0x10000000UL)    /*!< GPIO23_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE2_GPIO22_EDGE_HIGH_Pos (27UL)            /*!< GPIO22_EDGE_HIGH (Bit 27)                             */
#define IO_BANK0_PROC0_INTE2_GPIO22_EDGE_HIGH_Msk (0x8000000UL)     /*!< GPIO22_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE2_GPIO22_EDGE_LOW_Pos (26UL)             /*!< GPIO22_EDGE_LOW (Bit 26)                              */
#define IO_BANK0_PROC0_INTE2_GPIO22_EDGE_LOW_Msk (0x4000000UL)      /*!< GPIO22_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE2_GPIO22_LEVEL_HIGH_Pos (25UL)           /*!< GPIO22_LEVEL_HIGH (Bit 25)                            */
#define IO_BANK0_PROC0_INTE2_GPIO22_LEVEL_HIGH_Msk (0x2000000UL)    /*!< GPIO22_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTE2_GPIO22_LEVEL_LOW_Pos (24UL)            /*!< GPIO22_LEVEL_LOW (Bit 24)                             */
#define IO_BANK0_PROC0_INTE2_GPIO22_LEVEL_LOW_Msk (0x1000000UL)     /*!< GPIO22_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE2_GPIO21_EDGE_HIGH_Pos (23UL)            /*!< GPIO21_EDGE_HIGH (Bit 23)                             */
#define IO_BANK0_PROC0_INTE2_GPIO21_EDGE_HIGH_Msk (0x800000UL)      /*!< GPIO21_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE2_GPIO21_EDGE_LOW_Pos (22UL)             /*!< GPIO21_EDGE_LOW (Bit 22)                              */
#define IO_BANK0_PROC0_INTE2_GPIO21_EDGE_LOW_Msk (0x400000UL)       /*!< GPIO21_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE2_GPIO21_LEVEL_HIGH_Pos (21UL)           /*!< GPIO21_LEVEL_HIGH (Bit 21)                            */
#define IO_BANK0_PROC0_INTE2_GPIO21_LEVEL_HIGH_Msk (0x200000UL)     /*!< GPIO21_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTE2_GPIO21_LEVEL_LOW_Pos (20UL)            /*!< GPIO21_LEVEL_LOW (Bit 20)                             */
#define IO_BANK0_PROC0_INTE2_GPIO21_LEVEL_LOW_Msk (0x100000UL)      /*!< GPIO21_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE2_GPIO20_EDGE_HIGH_Pos (19UL)            /*!< GPIO20_EDGE_HIGH (Bit 19)                             */
#define IO_BANK0_PROC0_INTE2_GPIO20_EDGE_HIGH_Msk (0x80000UL)       /*!< GPIO20_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE2_GPIO20_EDGE_LOW_Pos (18UL)             /*!< GPIO20_EDGE_LOW (Bit 18)                              */
#define IO_BANK0_PROC0_INTE2_GPIO20_EDGE_LOW_Msk (0x40000UL)        /*!< GPIO20_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE2_GPIO20_LEVEL_HIGH_Pos (17UL)           /*!< GPIO20_LEVEL_HIGH (Bit 17)                            */
#define IO_BANK0_PROC0_INTE2_GPIO20_LEVEL_HIGH_Msk (0x20000UL)      /*!< GPIO20_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTE2_GPIO20_LEVEL_LOW_Pos (16UL)            /*!< GPIO20_LEVEL_LOW (Bit 16)                             */
#define IO_BANK0_PROC0_INTE2_GPIO20_LEVEL_LOW_Msk (0x10000UL)       /*!< GPIO20_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE2_GPIO19_EDGE_HIGH_Pos (15UL)            /*!< GPIO19_EDGE_HIGH (Bit 15)                             */
#define IO_BANK0_PROC0_INTE2_GPIO19_EDGE_HIGH_Msk (0x8000UL)        /*!< GPIO19_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE2_GPIO19_EDGE_LOW_Pos (14UL)             /*!< GPIO19_EDGE_LOW (Bit 14)                              */
#define IO_BANK0_PROC0_INTE2_GPIO19_EDGE_LOW_Msk (0x4000UL)         /*!< GPIO19_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE2_GPIO19_LEVEL_HIGH_Pos (13UL)           /*!< GPIO19_LEVEL_HIGH (Bit 13)                            */
#define IO_BANK0_PROC0_INTE2_GPIO19_LEVEL_HIGH_Msk (0x2000UL)       /*!< GPIO19_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTE2_GPIO19_LEVEL_LOW_Pos (12UL)            /*!< GPIO19_LEVEL_LOW (Bit 12)                             */
#define IO_BANK0_PROC0_INTE2_GPIO19_LEVEL_LOW_Msk (0x1000UL)        /*!< GPIO19_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE2_GPIO18_EDGE_HIGH_Pos (11UL)            /*!< GPIO18_EDGE_HIGH (Bit 11)                             */
#define IO_BANK0_PROC0_INTE2_GPIO18_EDGE_HIGH_Msk (0x800UL)         /*!< GPIO18_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE2_GPIO18_EDGE_LOW_Pos (10UL)             /*!< GPIO18_EDGE_LOW (Bit 10)                              */
#define IO_BANK0_PROC0_INTE2_GPIO18_EDGE_LOW_Msk (0x400UL)          /*!< GPIO18_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE2_GPIO18_LEVEL_HIGH_Pos (9UL)            /*!< GPIO18_LEVEL_HIGH (Bit 9)                             */
#define IO_BANK0_PROC0_INTE2_GPIO18_LEVEL_HIGH_Msk (0x200UL)        /*!< GPIO18_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTE2_GPIO18_LEVEL_LOW_Pos (8UL)             /*!< GPIO18_LEVEL_LOW (Bit 8)                              */
#define IO_BANK0_PROC0_INTE2_GPIO18_LEVEL_LOW_Msk (0x100UL)         /*!< GPIO18_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE2_GPIO17_EDGE_HIGH_Pos (7UL)             /*!< GPIO17_EDGE_HIGH (Bit 7)                              */
#define IO_BANK0_PROC0_INTE2_GPIO17_EDGE_HIGH_Msk (0x80UL)          /*!< GPIO17_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE2_GPIO17_EDGE_LOW_Pos (6UL)              /*!< GPIO17_EDGE_LOW (Bit 6)                               */
#define IO_BANK0_PROC0_INTE2_GPIO17_EDGE_LOW_Msk (0x40UL)           /*!< GPIO17_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE2_GPIO17_LEVEL_HIGH_Pos (5UL)            /*!< GPIO17_LEVEL_HIGH (Bit 5)                             */
#define IO_BANK0_PROC0_INTE2_GPIO17_LEVEL_HIGH_Msk (0x20UL)         /*!< GPIO17_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTE2_GPIO17_LEVEL_LOW_Pos (4UL)             /*!< GPIO17_LEVEL_LOW (Bit 4)                              */
#define IO_BANK0_PROC0_INTE2_GPIO17_LEVEL_LOW_Msk (0x10UL)          /*!< GPIO17_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE2_GPIO16_EDGE_HIGH_Pos (3UL)             /*!< GPIO16_EDGE_HIGH (Bit 3)                              */
#define IO_BANK0_PROC0_INTE2_GPIO16_EDGE_HIGH_Msk (0x8UL)           /*!< GPIO16_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE2_GPIO16_EDGE_LOW_Pos (2UL)              /*!< GPIO16_EDGE_LOW (Bit 2)                               */
#define IO_BANK0_PROC0_INTE2_GPIO16_EDGE_LOW_Msk (0x4UL)            /*!< GPIO16_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE2_GPIO16_LEVEL_HIGH_Pos (1UL)            /*!< GPIO16_LEVEL_HIGH (Bit 1)                             */
#define IO_BANK0_PROC0_INTE2_GPIO16_LEVEL_HIGH_Msk (0x2UL)          /*!< GPIO16_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTE2_GPIO16_LEVEL_LOW_Pos (0UL)             /*!< GPIO16_LEVEL_LOW (Bit 0)                              */
#define IO_BANK0_PROC0_INTE2_GPIO16_LEVEL_LOW_Msk (0x1UL)           /*!< GPIO16_LEVEL_LOW (Bitfield-Mask: 0x01)                */
/* ======================================================  PROC0_INTE3  ====================================================== */
#define IO_BANK0_PROC0_INTE3_GPIO29_EDGE_HIGH_Pos (23UL)            /*!< GPIO29_EDGE_HIGH (Bit 23)                             */
#define IO_BANK0_PROC0_INTE3_GPIO29_EDGE_HIGH_Msk (0x800000UL)      /*!< GPIO29_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE3_GPIO29_EDGE_LOW_Pos (22UL)             /*!< GPIO29_EDGE_LOW (Bit 22)                              */
#define IO_BANK0_PROC0_INTE3_GPIO29_EDGE_LOW_Msk (0x400000UL)       /*!< GPIO29_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE3_GPIO29_LEVEL_HIGH_Pos (21UL)           /*!< GPIO29_LEVEL_HIGH (Bit 21)                            */
#define IO_BANK0_PROC0_INTE3_GPIO29_LEVEL_HIGH_Msk (0x200000UL)     /*!< GPIO29_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTE3_GPIO29_LEVEL_LOW_Pos (20UL)            /*!< GPIO29_LEVEL_LOW (Bit 20)                             */
#define IO_BANK0_PROC0_INTE3_GPIO29_LEVEL_LOW_Msk (0x100000UL)      /*!< GPIO29_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE3_GPIO28_EDGE_HIGH_Pos (19UL)            /*!< GPIO28_EDGE_HIGH (Bit 19)                             */
#define IO_BANK0_PROC0_INTE3_GPIO28_EDGE_HIGH_Msk (0x80000UL)       /*!< GPIO28_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE3_GPIO28_EDGE_LOW_Pos (18UL)             /*!< GPIO28_EDGE_LOW (Bit 18)                              */
#define IO_BANK0_PROC0_INTE3_GPIO28_EDGE_LOW_Msk (0x40000UL)        /*!< GPIO28_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE3_GPIO28_LEVEL_HIGH_Pos (17UL)           /*!< GPIO28_LEVEL_HIGH (Bit 17)                            */
#define IO_BANK0_PROC0_INTE3_GPIO28_LEVEL_HIGH_Msk (0x20000UL)      /*!< GPIO28_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTE3_GPIO28_LEVEL_LOW_Pos (16UL)            /*!< GPIO28_LEVEL_LOW (Bit 16)                             */
#define IO_BANK0_PROC0_INTE3_GPIO28_LEVEL_LOW_Msk (0x10000UL)       /*!< GPIO28_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE3_GPIO27_EDGE_HIGH_Pos (15UL)            /*!< GPIO27_EDGE_HIGH (Bit 15)                             */
#define IO_BANK0_PROC0_INTE3_GPIO27_EDGE_HIGH_Msk (0x8000UL)        /*!< GPIO27_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE3_GPIO27_EDGE_LOW_Pos (14UL)             /*!< GPIO27_EDGE_LOW (Bit 14)                              */
#define IO_BANK0_PROC0_INTE3_GPIO27_EDGE_LOW_Msk (0x4000UL)         /*!< GPIO27_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE3_GPIO27_LEVEL_HIGH_Pos (13UL)           /*!< GPIO27_LEVEL_HIGH (Bit 13)                            */
#define IO_BANK0_PROC0_INTE3_GPIO27_LEVEL_HIGH_Msk (0x2000UL)       /*!< GPIO27_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTE3_GPIO27_LEVEL_LOW_Pos (12UL)            /*!< GPIO27_LEVEL_LOW (Bit 12)                             */
#define IO_BANK0_PROC0_INTE3_GPIO27_LEVEL_LOW_Msk (0x1000UL)        /*!< GPIO27_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE3_GPIO26_EDGE_HIGH_Pos (11UL)            /*!< GPIO26_EDGE_HIGH (Bit 11)                             */
#define IO_BANK0_PROC0_INTE3_GPIO26_EDGE_HIGH_Msk (0x800UL)         /*!< GPIO26_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE3_GPIO26_EDGE_LOW_Pos (10UL)             /*!< GPIO26_EDGE_LOW (Bit 10)                              */
#define IO_BANK0_PROC0_INTE3_GPIO26_EDGE_LOW_Msk (0x400UL)          /*!< GPIO26_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE3_GPIO26_LEVEL_HIGH_Pos (9UL)            /*!< GPIO26_LEVEL_HIGH (Bit 9)                             */
#define IO_BANK0_PROC0_INTE3_GPIO26_LEVEL_HIGH_Msk (0x200UL)        /*!< GPIO26_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTE3_GPIO26_LEVEL_LOW_Pos (8UL)             /*!< GPIO26_LEVEL_LOW (Bit 8)                              */
#define IO_BANK0_PROC0_INTE3_GPIO26_LEVEL_LOW_Msk (0x100UL)         /*!< GPIO26_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE3_GPIO25_EDGE_HIGH_Pos (7UL)             /*!< GPIO25_EDGE_HIGH (Bit 7)                              */
#define IO_BANK0_PROC0_INTE3_GPIO25_EDGE_HIGH_Msk (0x80UL)          /*!< GPIO25_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE3_GPIO25_EDGE_LOW_Pos (6UL)              /*!< GPIO25_EDGE_LOW (Bit 6)                               */
#define IO_BANK0_PROC0_INTE3_GPIO25_EDGE_LOW_Msk (0x40UL)           /*!< GPIO25_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE3_GPIO25_LEVEL_HIGH_Pos (5UL)            /*!< GPIO25_LEVEL_HIGH (Bit 5)                             */
#define IO_BANK0_PROC0_INTE3_GPIO25_LEVEL_HIGH_Msk (0x20UL)         /*!< GPIO25_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTE3_GPIO25_LEVEL_LOW_Pos (4UL)             /*!< GPIO25_LEVEL_LOW (Bit 4)                              */
#define IO_BANK0_PROC0_INTE3_GPIO25_LEVEL_LOW_Msk (0x10UL)          /*!< GPIO25_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE3_GPIO24_EDGE_HIGH_Pos (3UL)             /*!< GPIO24_EDGE_HIGH (Bit 3)                              */
#define IO_BANK0_PROC0_INTE3_GPIO24_EDGE_HIGH_Msk (0x8UL)           /*!< GPIO24_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTE3_GPIO24_EDGE_LOW_Pos (2UL)              /*!< GPIO24_EDGE_LOW (Bit 2)                               */
#define IO_BANK0_PROC0_INTE3_GPIO24_EDGE_LOW_Msk (0x4UL)            /*!< GPIO24_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTE3_GPIO24_LEVEL_HIGH_Pos (1UL)            /*!< GPIO24_LEVEL_HIGH (Bit 1)                             */
#define IO_BANK0_PROC0_INTE3_GPIO24_LEVEL_HIGH_Msk (0x2UL)          /*!< GPIO24_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTE3_GPIO24_LEVEL_LOW_Pos (0UL)             /*!< GPIO24_LEVEL_LOW (Bit 0)                              */
#define IO_BANK0_PROC0_INTE3_GPIO24_LEVEL_LOW_Msk (0x1UL)           /*!< GPIO24_LEVEL_LOW (Bitfield-Mask: 0x01)                */
/* ======================================================  PROC0_INTF0  ====================================================== */
#define IO_BANK0_PROC0_INTF0_GPIO7_EDGE_HIGH_Pos (31UL)             /*!< GPIO7_EDGE_HIGH (Bit 31)                              */
#define IO_BANK0_PROC0_INTF0_GPIO7_EDGE_HIGH_Msk (0x80000000UL)     /*!< GPIO7_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF0_GPIO7_EDGE_LOW_Pos (30UL)              /*!< GPIO7_EDGE_LOW (Bit 30)                               */
#define IO_BANK0_PROC0_INTF0_GPIO7_EDGE_LOW_Msk (0x40000000UL)      /*!< GPIO7_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC0_INTF0_GPIO7_LEVEL_HIGH_Pos (29UL)            /*!< GPIO7_LEVEL_HIGH (Bit 29)                             */
#define IO_BANK0_PROC0_INTF0_GPIO7_LEVEL_HIGH_Msk (0x20000000UL)    /*!< GPIO7_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF0_GPIO7_LEVEL_LOW_Pos (28UL)             /*!< GPIO7_LEVEL_LOW (Bit 28)                              */
#define IO_BANK0_PROC0_INTF0_GPIO7_LEVEL_LOW_Msk (0x10000000UL)     /*!< GPIO7_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF0_GPIO6_EDGE_HIGH_Pos (27UL)             /*!< GPIO6_EDGE_HIGH (Bit 27)                              */
#define IO_BANK0_PROC0_INTF0_GPIO6_EDGE_HIGH_Msk (0x8000000UL)      /*!< GPIO6_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF0_GPIO6_EDGE_LOW_Pos (26UL)              /*!< GPIO6_EDGE_LOW (Bit 26)                               */
#define IO_BANK0_PROC0_INTF0_GPIO6_EDGE_LOW_Msk (0x4000000UL)       /*!< GPIO6_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC0_INTF0_GPIO6_LEVEL_HIGH_Pos (25UL)            /*!< GPIO6_LEVEL_HIGH (Bit 25)                             */
#define IO_BANK0_PROC0_INTF0_GPIO6_LEVEL_HIGH_Msk (0x2000000UL)     /*!< GPIO6_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF0_GPIO6_LEVEL_LOW_Pos (24UL)             /*!< GPIO6_LEVEL_LOW (Bit 24)                              */
#define IO_BANK0_PROC0_INTF0_GPIO6_LEVEL_LOW_Msk (0x1000000UL)      /*!< GPIO6_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF0_GPIO5_EDGE_HIGH_Pos (23UL)             /*!< GPIO5_EDGE_HIGH (Bit 23)                              */
#define IO_BANK0_PROC0_INTF0_GPIO5_EDGE_HIGH_Msk (0x800000UL)       /*!< GPIO5_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF0_GPIO5_EDGE_LOW_Pos (22UL)              /*!< GPIO5_EDGE_LOW (Bit 22)                               */
#define IO_BANK0_PROC0_INTF0_GPIO5_EDGE_LOW_Msk (0x400000UL)        /*!< GPIO5_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC0_INTF0_GPIO5_LEVEL_HIGH_Pos (21UL)            /*!< GPIO5_LEVEL_HIGH (Bit 21)                             */
#define IO_BANK0_PROC0_INTF0_GPIO5_LEVEL_HIGH_Msk (0x200000UL)      /*!< GPIO5_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF0_GPIO5_LEVEL_LOW_Pos (20UL)             /*!< GPIO5_LEVEL_LOW (Bit 20)                              */
#define IO_BANK0_PROC0_INTF0_GPIO5_LEVEL_LOW_Msk (0x100000UL)       /*!< GPIO5_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF0_GPIO4_EDGE_HIGH_Pos (19UL)             /*!< GPIO4_EDGE_HIGH (Bit 19)                              */
#define IO_BANK0_PROC0_INTF0_GPIO4_EDGE_HIGH_Msk (0x80000UL)        /*!< GPIO4_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF0_GPIO4_EDGE_LOW_Pos (18UL)              /*!< GPIO4_EDGE_LOW (Bit 18)                               */
#define IO_BANK0_PROC0_INTF0_GPIO4_EDGE_LOW_Msk (0x40000UL)         /*!< GPIO4_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC0_INTF0_GPIO4_LEVEL_HIGH_Pos (17UL)            /*!< GPIO4_LEVEL_HIGH (Bit 17)                             */
#define IO_BANK0_PROC0_INTF0_GPIO4_LEVEL_HIGH_Msk (0x20000UL)       /*!< GPIO4_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF0_GPIO4_LEVEL_LOW_Pos (16UL)             /*!< GPIO4_LEVEL_LOW (Bit 16)                              */
#define IO_BANK0_PROC0_INTF0_GPIO4_LEVEL_LOW_Msk (0x10000UL)        /*!< GPIO4_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF0_GPIO3_EDGE_HIGH_Pos (15UL)             /*!< GPIO3_EDGE_HIGH (Bit 15)                              */
#define IO_BANK0_PROC0_INTF0_GPIO3_EDGE_HIGH_Msk (0x8000UL)         /*!< GPIO3_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF0_GPIO3_EDGE_LOW_Pos (14UL)              /*!< GPIO3_EDGE_LOW (Bit 14)                               */
#define IO_BANK0_PROC0_INTF0_GPIO3_EDGE_LOW_Msk (0x4000UL)          /*!< GPIO3_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC0_INTF0_GPIO3_LEVEL_HIGH_Pos (13UL)            /*!< GPIO3_LEVEL_HIGH (Bit 13)                             */
#define IO_BANK0_PROC0_INTF0_GPIO3_LEVEL_HIGH_Msk (0x2000UL)        /*!< GPIO3_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF0_GPIO3_LEVEL_LOW_Pos (12UL)             /*!< GPIO3_LEVEL_LOW (Bit 12)                              */
#define IO_BANK0_PROC0_INTF0_GPIO3_LEVEL_LOW_Msk (0x1000UL)         /*!< GPIO3_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF0_GPIO2_EDGE_HIGH_Pos (11UL)             /*!< GPIO2_EDGE_HIGH (Bit 11)                              */
#define IO_BANK0_PROC0_INTF0_GPIO2_EDGE_HIGH_Msk (0x800UL)          /*!< GPIO2_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF0_GPIO2_EDGE_LOW_Pos (10UL)              /*!< GPIO2_EDGE_LOW (Bit 10)                               */
#define IO_BANK0_PROC0_INTF0_GPIO2_EDGE_LOW_Msk (0x400UL)           /*!< GPIO2_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC0_INTF0_GPIO2_LEVEL_HIGH_Pos (9UL)             /*!< GPIO2_LEVEL_HIGH (Bit 9)                              */
#define IO_BANK0_PROC0_INTF0_GPIO2_LEVEL_HIGH_Msk (0x200UL)         /*!< GPIO2_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF0_GPIO2_LEVEL_LOW_Pos (8UL)              /*!< GPIO2_LEVEL_LOW (Bit 8)                               */
#define IO_BANK0_PROC0_INTF0_GPIO2_LEVEL_LOW_Msk (0x100UL)          /*!< GPIO2_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF0_GPIO1_EDGE_HIGH_Pos (7UL)              /*!< GPIO1_EDGE_HIGH (Bit 7)                               */
#define IO_BANK0_PROC0_INTF0_GPIO1_EDGE_HIGH_Msk (0x80UL)           /*!< GPIO1_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF0_GPIO1_EDGE_LOW_Pos (6UL)               /*!< GPIO1_EDGE_LOW (Bit 6)                                */
#define IO_BANK0_PROC0_INTF0_GPIO1_EDGE_LOW_Msk (0x40UL)            /*!< GPIO1_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC0_INTF0_GPIO1_LEVEL_HIGH_Pos (5UL)             /*!< GPIO1_LEVEL_HIGH (Bit 5)                              */
#define IO_BANK0_PROC0_INTF0_GPIO1_LEVEL_HIGH_Msk (0x20UL)          /*!< GPIO1_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF0_GPIO1_LEVEL_LOW_Pos (4UL)              /*!< GPIO1_LEVEL_LOW (Bit 4)                               */
#define IO_BANK0_PROC0_INTF0_GPIO1_LEVEL_LOW_Msk (0x10UL)           /*!< GPIO1_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF0_GPIO0_EDGE_HIGH_Pos (3UL)              /*!< GPIO0_EDGE_HIGH (Bit 3)                               */
#define IO_BANK0_PROC0_INTF0_GPIO0_EDGE_HIGH_Msk (0x8UL)            /*!< GPIO0_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF0_GPIO0_EDGE_LOW_Pos (2UL)               /*!< GPIO0_EDGE_LOW (Bit 2)                                */
#define IO_BANK0_PROC0_INTF0_GPIO0_EDGE_LOW_Msk (0x4UL)             /*!< GPIO0_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC0_INTF0_GPIO0_LEVEL_HIGH_Pos (1UL)             /*!< GPIO0_LEVEL_HIGH (Bit 1)                              */
#define IO_BANK0_PROC0_INTF0_GPIO0_LEVEL_HIGH_Msk (0x2UL)           /*!< GPIO0_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF0_GPIO0_LEVEL_LOW_Pos (0UL)              /*!< GPIO0_LEVEL_LOW (Bit 0)                               */
#define IO_BANK0_PROC0_INTF0_GPIO0_LEVEL_LOW_Msk (0x1UL)            /*!< GPIO0_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
/* ======================================================  PROC0_INTF1  ====================================================== */
#define IO_BANK0_PROC0_INTF1_GPIO15_EDGE_HIGH_Pos (31UL)            /*!< GPIO15_EDGE_HIGH (Bit 31)                             */
#define IO_BANK0_PROC0_INTF1_GPIO15_EDGE_HIGH_Msk (0x80000000UL)    /*!< GPIO15_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF1_GPIO15_EDGE_LOW_Pos (30UL)             /*!< GPIO15_EDGE_LOW (Bit 30)                              */
#define IO_BANK0_PROC0_INTF1_GPIO15_EDGE_LOW_Msk (0x40000000UL)     /*!< GPIO15_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF1_GPIO15_LEVEL_HIGH_Pos (29UL)           /*!< GPIO15_LEVEL_HIGH (Bit 29)                            */
#define IO_BANK0_PROC0_INTF1_GPIO15_LEVEL_HIGH_Msk (0x20000000UL)   /*!< GPIO15_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTF1_GPIO15_LEVEL_LOW_Pos (28UL)            /*!< GPIO15_LEVEL_LOW (Bit 28)                             */
#define IO_BANK0_PROC0_INTF1_GPIO15_LEVEL_LOW_Msk (0x10000000UL)    /*!< GPIO15_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF1_GPIO14_EDGE_HIGH_Pos (27UL)            /*!< GPIO14_EDGE_HIGH (Bit 27)                             */
#define IO_BANK0_PROC0_INTF1_GPIO14_EDGE_HIGH_Msk (0x8000000UL)     /*!< GPIO14_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF1_GPIO14_EDGE_LOW_Pos (26UL)             /*!< GPIO14_EDGE_LOW (Bit 26)                              */
#define IO_BANK0_PROC0_INTF1_GPIO14_EDGE_LOW_Msk (0x4000000UL)      /*!< GPIO14_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF1_GPIO14_LEVEL_HIGH_Pos (25UL)           /*!< GPIO14_LEVEL_HIGH (Bit 25)                            */
#define IO_BANK0_PROC0_INTF1_GPIO14_LEVEL_HIGH_Msk (0x2000000UL)    /*!< GPIO14_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTF1_GPIO14_LEVEL_LOW_Pos (24UL)            /*!< GPIO14_LEVEL_LOW (Bit 24)                             */
#define IO_BANK0_PROC0_INTF1_GPIO14_LEVEL_LOW_Msk (0x1000000UL)     /*!< GPIO14_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF1_GPIO13_EDGE_HIGH_Pos (23UL)            /*!< GPIO13_EDGE_HIGH (Bit 23)                             */
#define IO_BANK0_PROC0_INTF1_GPIO13_EDGE_HIGH_Msk (0x800000UL)      /*!< GPIO13_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF1_GPIO13_EDGE_LOW_Pos (22UL)             /*!< GPIO13_EDGE_LOW (Bit 22)                              */
#define IO_BANK0_PROC0_INTF1_GPIO13_EDGE_LOW_Msk (0x400000UL)       /*!< GPIO13_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF1_GPIO13_LEVEL_HIGH_Pos (21UL)           /*!< GPIO13_LEVEL_HIGH (Bit 21)                            */
#define IO_BANK0_PROC0_INTF1_GPIO13_LEVEL_HIGH_Msk (0x200000UL)     /*!< GPIO13_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTF1_GPIO13_LEVEL_LOW_Pos (20UL)            /*!< GPIO13_LEVEL_LOW (Bit 20)                             */
#define IO_BANK0_PROC0_INTF1_GPIO13_LEVEL_LOW_Msk (0x100000UL)      /*!< GPIO13_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF1_GPIO12_EDGE_HIGH_Pos (19UL)            /*!< GPIO12_EDGE_HIGH (Bit 19)                             */
#define IO_BANK0_PROC0_INTF1_GPIO12_EDGE_HIGH_Msk (0x80000UL)       /*!< GPIO12_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF1_GPIO12_EDGE_LOW_Pos (18UL)             /*!< GPIO12_EDGE_LOW (Bit 18)                              */
#define IO_BANK0_PROC0_INTF1_GPIO12_EDGE_LOW_Msk (0x40000UL)        /*!< GPIO12_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF1_GPIO12_LEVEL_HIGH_Pos (17UL)           /*!< GPIO12_LEVEL_HIGH (Bit 17)                            */
#define IO_BANK0_PROC0_INTF1_GPIO12_LEVEL_HIGH_Msk (0x20000UL)      /*!< GPIO12_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTF1_GPIO12_LEVEL_LOW_Pos (16UL)            /*!< GPIO12_LEVEL_LOW (Bit 16)                             */
#define IO_BANK0_PROC0_INTF1_GPIO12_LEVEL_LOW_Msk (0x10000UL)       /*!< GPIO12_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF1_GPIO11_EDGE_HIGH_Pos (15UL)            /*!< GPIO11_EDGE_HIGH (Bit 15)                             */
#define IO_BANK0_PROC0_INTF1_GPIO11_EDGE_HIGH_Msk (0x8000UL)        /*!< GPIO11_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF1_GPIO11_EDGE_LOW_Pos (14UL)             /*!< GPIO11_EDGE_LOW (Bit 14)                              */
#define IO_BANK0_PROC0_INTF1_GPIO11_EDGE_LOW_Msk (0x4000UL)         /*!< GPIO11_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF1_GPIO11_LEVEL_HIGH_Pos (13UL)           /*!< GPIO11_LEVEL_HIGH (Bit 13)                            */
#define IO_BANK0_PROC0_INTF1_GPIO11_LEVEL_HIGH_Msk (0x2000UL)       /*!< GPIO11_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTF1_GPIO11_LEVEL_LOW_Pos (12UL)            /*!< GPIO11_LEVEL_LOW (Bit 12)                             */
#define IO_BANK0_PROC0_INTF1_GPIO11_LEVEL_LOW_Msk (0x1000UL)        /*!< GPIO11_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF1_GPIO10_EDGE_HIGH_Pos (11UL)            /*!< GPIO10_EDGE_HIGH (Bit 11)                             */
#define IO_BANK0_PROC0_INTF1_GPIO10_EDGE_HIGH_Msk (0x800UL)         /*!< GPIO10_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF1_GPIO10_EDGE_LOW_Pos (10UL)             /*!< GPIO10_EDGE_LOW (Bit 10)                              */
#define IO_BANK0_PROC0_INTF1_GPIO10_EDGE_LOW_Msk (0x400UL)          /*!< GPIO10_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF1_GPIO10_LEVEL_HIGH_Pos (9UL)            /*!< GPIO10_LEVEL_HIGH (Bit 9)                             */
#define IO_BANK0_PROC0_INTF1_GPIO10_LEVEL_HIGH_Msk (0x200UL)        /*!< GPIO10_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTF1_GPIO10_LEVEL_LOW_Pos (8UL)             /*!< GPIO10_LEVEL_LOW (Bit 8)                              */
#define IO_BANK0_PROC0_INTF1_GPIO10_LEVEL_LOW_Msk (0x100UL)         /*!< GPIO10_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF1_GPIO9_EDGE_HIGH_Pos (7UL)              /*!< GPIO9_EDGE_HIGH (Bit 7)                               */
#define IO_BANK0_PROC0_INTF1_GPIO9_EDGE_HIGH_Msk (0x80UL)           /*!< GPIO9_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF1_GPIO9_EDGE_LOW_Pos (6UL)               /*!< GPIO9_EDGE_LOW (Bit 6)                                */
#define IO_BANK0_PROC0_INTF1_GPIO9_EDGE_LOW_Msk (0x40UL)            /*!< GPIO9_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC0_INTF1_GPIO9_LEVEL_HIGH_Pos (5UL)             /*!< GPIO9_LEVEL_HIGH (Bit 5)                              */
#define IO_BANK0_PROC0_INTF1_GPIO9_LEVEL_HIGH_Msk (0x20UL)          /*!< GPIO9_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF1_GPIO9_LEVEL_LOW_Pos (4UL)              /*!< GPIO9_LEVEL_LOW (Bit 4)                               */
#define IO_BANK0_PROC0_INTF1_GPIO9_LEVEL_LOW_Msk (0x10UL)           /*!< GPIO9_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF1_GPIO8_EDGE_HIGH_Pos (3UL)              /*!< GPIO8_EDGE_HIGH (Bit 3)                               */
#define IO_BANK0_PROC0_INTF1_GPIO8_EDGE_HIGH_Msk (0x8UL)            /*!< GPIO8_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF1_GPIO8_EDGE_LOW_Pos (2UL)               /*!< GPIO8_EDGE_LOW (Bit 2)                                */
#define IO_BANK0_PROC0_INTF1_GPIO8_EDGE_LOW_Msk (0x4UL)             /*!< GPIO8_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC0_INTF1_GPIO8_LEVEL_HIGH_Pos (1UL)             /*!< GPIO8_LEVEL_HIGH (Bit 1)                              */
#define IO_BANK0_PROC0_INTF1_GPIO8_LEVEL_HIGH_Msk (0x2UL)           /*!< GPIO8_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF1_GPIO8_LEVEL_LOW_Pos (0UL)              /*!< GPIO8_LEVEL_LOW (Bit 0)                               */
#define IO_BANK0_PROC0_INTF1_GPIO8_LEVEL_LOW_Msk (0x1UL)            /*!< GPIO8_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
/* ======================================================  PROC0_INTF2  ====================================================== */
#define IO_BANK0_PROC0_INTF2_GPIO23_EDGE_HIGH_Pos (31UL)            /*!< GPIO23_EDGE_HIGH (Bit 31)                             */
#define IO_BANK0_PROC0_INTF2_GPIO23_EDGE_HIGH_Msk (0x80000000UL)    /*!< GPIO23_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF2_GPIO23_EDGE_LOW_Pos (30UL)             /*!< GPIO23_EDGE_LOW (Bit 30)                              */
#define IO_BANK0_PROC0_INTF2_GPIO23_EDGE_LOW_Msk (0x40000000UL)     /*!< GPIO23_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF2_GPIO23_LEVEL_HIGH_Pos (29UL)           /*!< GPIO23_LEVEL_HIGH (Bit 29)                            */
#define IO_BANK0_PROC0_INTF2_GPIO23_LEVEL_HIGH_Msk (0x20000000UL)   /*!< GPIO23_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTF2_GPIO23_LEVEL_LOW_Pos (28UL)            /*!< GPIO23_LEVEL_LOW (Bit 28)                             */
#define IO_BANK0_PROC0_INTF2_GPIO23_LEVEL_LOW_Msk (0x10000000UL)    /*!< GPIO23_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF2_GPIO22_EDGE_HIGH_Pos (27UL)            /*!< GPIO22_EDGE_HIGH (Bit 27)                             */
#define IO_BANK0_PROC0_INTF2_GPIO22_EDGE_HIGH_Msk (0x8000000UL)     /*!< GPIO22_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF2_GPIO22_EDGE_LOW_Pos (26UL)             /*!< GPIO22_EDGE_LOW (Bit 26)                              */
#define IO_BANK0_PROC0_INTF2_GPIO22_EDGE_LOW_Msk (0x4000000UL)      /*!< GPIO22_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF2_GPIO22_LEVEL_HIGH_Pos (25UL)           /*!< GPIO22_LEVEL_HIGH (Bit 25)                            */
#define IO_BANK0_PROC0_INTF2_GPIO22_LEVEL_HIGH_Msk (0x2000000UL)    /*!< GPIO22_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTF2_GPIO22_LEVEL_LOW_Pos (24UL)            /*!< GPIO22_LEVEL_LOW (Bit 24)                             */
#define IO_BANK0_PROC0_INTF2_GPIO22_LEVEL_LOW_Msk (0x1000000UL)     /*!< GPIO22_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF2_GPIO21_EDGE_HIGH_Pos (23UL)            /*!< GPIO21_EDGE_HIGH (Bit 23)                             */
#define IO_BANK0_PROC0_INTF2_GPIO21_EDGE_HIGH_Msk (0x800000UL)      /*!< GPIO21_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF2_GPIO21_EDGE_LOW_Pos (22UL)             /*!< GPIO21_EDGE_LOW (Bit 22)                              */
#define IO_BANK0_PROC0_INTF2_GPIO21_EDGE_LOW_Msk (0x400000UL)       /*!< GPIO21_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF2_GPIO21_LEVEL_HIGH_Pos (21UL)           /*!< GPIO21_LEVEL_HIGH (Bit 21)                            */
#define IO_BANK0_PROC0_INTF2_GPIO21_LEVEL_HIGH_Msk (0x200000UL)     /*!< GPIO21_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTF2_GPIO21_LEVEL_LOW_Pos (20UL)            /*!< GPIO21_LEVEL_LOW (Bit 20)                             */
#define IO_BANK0_PROC0_INTF2_GPIO21_LEVEL_LOW_Msk (0x100000UL)      /*!< GPIO21_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF2_GPIO20_EDGE_HIGH_Pos (19UL)            /*!< GPIO20_EDGE_HIGH (Bit 19)                             */
#define IO_BANK0_PROC0_INTF2_GPIO20_EDGE_HIGH_Msk (0x80000UL)       /*!< GPIO20_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF2_GPIO20_EDGE_LOW_Pos (18UL)             /*!< GPIO20_EDGE_LOW (Bit 18)                              */
#define IO_BANK0_PROC0_INTF2_GPIO20_EDGE_LOW_Msk (0x40000UL)        /*!< GPIO20_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF2_GPIO20_LEVEL_HIGH_Pos (17UL)           /*!< GPIO20_LEVEL_HIGH (Bit 17)                            */
#define IO_BANK0_PROC0_INTF2_GPIO20_LEVEL_HIGH_Msk (0x20000UL)      /*!< GPIO20_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTF2_GPIO20_LEVEL_LOW_Pos (16UL)            /*!< GPIO20_LEVEL_LOW (Bit 16)                             */
#define IO_BANK0_PROC0_INTF2_GPIO20_LEVEL_LOW_Msk (0x10000UL)       /*!< GPIO20_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF2_GPIO19_EDGE_HIGH_Pos (15UL)            /*!< GPIO19_EDGE_HIGH (Bit 15)                             */
#define IO_BANK0_PROC0_INTF2_GPIO19_EDGE_HIGH_Msk (0x8000UL)        /*!< GPIO19_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF2_GPIO19_EDGE_LOW_Pos (14UL)             /*!< GPIO19_EDGE_LOW (Bit 14)                              */
#define IO_BANK0_PROC0_INTF2_GPIO19_EDGE_LOW_Msk (0x4000UL)         /*!< GPIO19_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF2_GPIO19_LEVEL_HIGH_Pos (13UL)           /*!< GPIO19_LEVEL_HIGH (Bit 13)                            */
#define IO_BANK0_PROC0_INTF2_GPIO19_LEVEL_HIGH_Msk (0x2000UL)       /*!< GPIO19_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTF2_GPIO19_LEVEL_LOW_Pos (12UL)            /*!< GPIO19_LEVEL_LOW (Bit 12)                             */
#define IO_BANK0_PROC0_INTF2_GPIO19_LEVEL_LOW_Msk (0x1000UL)        /*!< GPIO19_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF2_GPIO18_EDGE_HIGH_Pos (11UL)            /*!< GPIO18_EDGE_HIGH (Bit 11)                             */
#define IO_BANK0_PROC0_INTF2_GPIO18_EDGE_HIGH_Msk (0x800UL)         /*!< GPIO18_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF2_GPIO18_EDGE_LOW_Pos (10UL)             /*!< GPIO18_EDGE_LOW (Bit 10)                              */
#define IO_BANK0_PROC0_INTF2_GPIO18_EDGE_LOW_Msk (0x400UL)          /*!< GPIO18_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF2_GPIO18_LEVEL_HIGH_Pos (9UL)            /*!< GPIO18_LEVEL_HIGH (Bit 9)                             */
#define IO_BANK0_PROC0_INTF2_GPIO18_LEVEL_HIGH_Msk (0x200UL)        /*!< GPIO18_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTF2_GPIO18_LEVEL_LOW_Pos (8UL)             /*!< GPIO18_LEVEL_LOW (Bit 8)                              */
#define IO_BANK0_PROC0_INTF2_GPIO18_LEVEL_LOW_Msk (0x100UL)         /*!< GPIO18_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF2_GPIO17_EDGE_HIGH_Pos (7UL)             /*!< GPIO17_EDGE_HIGH (Bit 7)                              */
#define IO_BANK0_PROC0_INTF2_GPIO17_EDGE_HIGH_Msk (0x80UL)          /*!< GPIO17_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF2_GPIO17_EDGE_LOW_Pos (6UL)              /*!< GPIO17_EDGE_LOW (Bit 6)                               */
#define IO_BANK0_PROC0_INTF2_GPIO17_EDGE_LOW_Msk (0x40UL)           /*!< GPIO17_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF2_GPIO17_LEVEL_HIGH_Pos (5UL)            /*!< GPIO17_LEVEL_HIGH (Bit 5)                             */
#define IO_BANK0_PROC0_INTF2_GPIO17_LEVEL_HIGH_Msk (0x20UL)         /*!< GPIO17_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTF2_GPIO17_LEVEL_LOW_Pos (4UL)             /*!< GPIO17_LEVEL_LOW (Bit 4)                              */
#define IO_BANK0_PROC0_INTF2_GPIO17_LEVEL_LOW_Msk (0x10UL)          /*!< GPIO17_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF2_GPIO16_EDGE_HIGH_Pos (3UL)             /*!< GPIO16_EDGE_HIGH (Bit 3)                              */
#define IO_BANK0_PROC0_INTF2_GPIO16_EDGE_HIGH_Msk (0x8UL)           /*!< GPIO16_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF2_GPIO16_EDGE_LOW_Pos (2UL)              /*!< GPIO16_EDGE_LOW (Bit 2)                               */
#define IO_BANK0_PROC0_INTF2_GPIO16_EDGE_LOW_Msk (0x4UL)            /*!< GPIO16_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF2_GPIO16_LEVEL_HIGH_Pos (1UL)            /*!< GPIO16_LEVEL_HIGH (Bit 1)                             */
#define IO_BANK0_PROC0_INTF2_GPIO16_LEVEL_HIGH_Msk (0x2UL)          /*!< GPIO16_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTF2_GPIO16_LEVEL_LOW_Pos (0UL)             /*!< GPIO16_LEVEL_LOW (Bit 0)                              */
#define IO_BANK0_PROC0_INTF2_GPIO16_LEVEL_LOW_Msk (0x1UL)           /*!< GPIO16_LEVEL_LOW (Bitfield-Mask: 0x01)                */
/* ======================================================  PROC0_INTF3  ====================================================== */
#define IO_BANK0_PROC0_INTF3_GPIO29_EDGE_HIGH_Pos (23UL)            /*!< GPIO29_EDGE_HIGH (Bit 23)                             */
#define IO_BANK0_PROC0_INTF3_GPIO29_EDGE_HIGH_Msk (0x800000UL)      /*!< GPIO29_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF3_GPIO29_EDGE_LOW_Pos (22UL)             /*!< GPIO29_EDGE_LOW (Bit 22)                              */
#define IO_BANK0_PROC0_INTF3_GPIO29_EDGE_LOW_Msk (0x400000UL)       /*!< GPIO29_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF3_GPIO29_LEVEL_HIGH_Pos (21UL)           /*!< GPIO29_LEVEL_HIGH (Bit 21)                            */
#define IO_BANK0_PROC0_INTF3_GPIO29_LEVEL_HIGH_Msk (0x200000UL)     /*!< GPIO29_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTF3_GPIO29_LEVEL_LOW_Pos (20UL)            /*!< GPIO29_LEVEL_LOW (Bit 20)                             */
#define IO_BANK0_PROC0_INTF3_GPIO29_LEVEL_LOW_Msk (0x100000UL)      /*!< GPIO29_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF3_GPIO28_EDGE_HIGH_Pos (19UL)            /*!< GPIO28_EDGE_HIGH (Bit 19)                             */
#define IO_BANK0_PROC0_INTF3_GPIO28_EDGE_HIGH_Msk (0x80000UL)       /*!< GPIO28_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF3_GPIO28_EDGE_LOW_Pos (18UL)             /*!< GPIO28_EDGE_LOW (Bit 18)                              */
#define IO_BANK0_PROC0_INTF3_GPIO28_EDGE_LOW_Msk (0x40000UL)        /*!< GPIO28_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF3_GPIO28_LEVEL_HIGH_Pos (17UL)           /*!< GPIO28_LEVEL_HIGH (Bit 17)                            */
#define IO_BANK0_PROC0_INTF3_GPIO28_LEVEL_HIGH_Msk (0x20000UL)      /*!< GPIO28_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTF3_GPIO28_LEVEL_LOW_Pos (16UL)            /*!< GPIO28_LEVEL_LOW (Bit 16)                             */
#define IO_BANK0_PROC0_INTF3_GPIO28_LEVEL_LOW_Msk (0x10000UL)       /*!< GPIO28_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF3_GPIO27_EDGE_HIGH_Pos (15UL)            /*!< GPIO27_EDGE_HIGH (Bit 15)                             */
#define IO_BANK0_PROC0_INTF3_GPIO27_EDGE_HIGH_Msk (0x8000UL)        /*!< GPIO27_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF3_GPIO27_EDGE_LOW_Pos (14UL)             /*!< GPIO27_EDGE_LOW (Bit 14)                              */
#define IO_BANK0_PROC0_INTF3_GPIO27_EDGE_LOW_Msk (0x4000UL)         /*!< GPIO27_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF3_GPIO27_LEVEL_HIGH_Pos (13UL)           /*!< GPIO27_LEVEL_HIGH (Bit 13)                            */
#define IO_BANK0_PROC0_INTF3_GPIO27_LEVEL_HIGH_Msk (0x2000UL)       /*!< GPIO27_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTF3_GPIO27_LEVEL_LOW_Pos (12UL)            /*!< GPIO27_LEVEL_LOW (Bit 12)                             */
#define IO_BANK0_PROC0_INTF3_GPIO27_LEVEL_LOW_Msk (0x1000UL)        /*!< GPIO27_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF3_GPIO26_EDGE_HIGH_Pos (11UL)            /*!< GPIO26_EDGE_HIGH (Bit 11)                             */
#define IO_BANK0_PROC0_INTF3_GPIO26_EDGE_HIGH_Msk (0x800UL)         /*!< GPIO26_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF3_GPIO26_EDGE_LOW_Pos (10UL)             /*!< GPIO26_EDGE_LOW (Bit 10)                              */
#define IO_BANK0_PROC0_INTF3_GPIO26_EDGE_LOW_Msk (0x400UL)          /*!< GPIO26_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF3_GPIO26_LEVEL_HIGH_Pos (9UL)            /*!< GPIO26_LEVEL_HIGH (Bit 9)                             */
#define IO_BANK0_PROC0_INTF3_GPIO26_LEVEL_HIGH_Msk (0x200UL)        /*!< GPIO26_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTF3_GPIO26_LEVEL_LOW_Pos (8UL)             /*!< GPIO26_LEVEL_LOW (Bit 8)                              */
#define IO_BANK0_PROC0_INTF3_GPIO26_LEVEL_LOW_Msk (0x100UL)         /*!< GPIO26_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF3_GPIO25_EDGE_HIGH_Pos (7UL)             /*!< GPIO25_EDGE_HIGH (Bit 7)                              */
#define IO_BANK0_PROC0_INTF3_GPIO25_EDGE_HIGH_Msk (0x80UL)          /*!< GPIO25_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF3_GPIO25_EDGE_LOW_Pos (6UL)              /*!< GPIO25_EDGE_LOW (Bit 6)                               */
#define IO_BANK0_PROC0_INTF3_GPIO25_EDGE_LOW_Msk (0x40UL)           /*!< GPIO25_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF3_GPIO25_LEVEL_HIGH_Pos (5UL)            /*!< GPIO25_LEVEL_HIGH (Bit 5)                             */
#define IO_BANK0_PROC0_INTF3_GPIO25_LEVEL_HIGH_Msk (0x20UL)         /*!< GPIO25_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTF3_GPIO25_LEVEL_LOW_Pos (4UL)             /*!< GPIO25_LEVEL_LOW (Bit 4)                              */
#define IO_BANK0_PROC0_INTF3_GPIO25_LEVEL_LOW_Msk (0x10UL)          /*!< GPIO25_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF3_GPIO24_EDGE_HIGH_Pos (3UL)             /*!< GPIO24_EDGE_HIGH (Bit 3)                              */
#define IO_BANK0_PROC0_INTF3_GPIO24_EDGE_HIGH_Msk (0x8UL)           /*!< GPIO24_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTF3_GPIO24_EDGE_LOW_Pos (2UL)              /*!< GPIO24_EDGE_LOW (Bit 2)                               */
#define IO_BANK0_PROC0_INTF3_GPIO24_EDGE_LOW_Msk (0x4UL)            /*!< GPIO24_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTF3_GPIO24_LEVEL_HIGH_Pos (1UL)            /*!< GPIO24_LEVEL_HIGH (Bit 1)                             */
#define IO_BANK0_PROC0_INTF3_GPIO24_LEVEL_HIGH_Msk (0x2UL)          /*!< GPIO24_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTF3_GPIO24_LEVEL_LOW_Pos (0UL)             /*!< GPIO24_LEVEL_LOW (Bit 0)                              */
#define IO_BANK0_PROC0_INTF3_GPIO24_LEVEL_LOW_Msk (0x1UL)           /*!< GPIO24_LEVEL_LOW (Bitfield-Mask: 0x01)                */
/* ======================================================  PROC0_INTS0  ====================================================== */
#define IO_BANK0_PROC0_INTS0_GPIO7_EDGE_HIGH_Pos (31UL)             /*!< GPIO7_EDGE_HIGH (Bit 31)                              */
#define IO_BANK0_PROC0_INTS0_GPIO7_EDGE_HIGH_Msk (0x80000000UL)     /*!< GPIO7_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS0_GPIO7_EDGE_LOW_Pos (30UL)              /*!< GPIO7_EDGE_LOW (Bit 30)                               */
#define IO_BANK0_PROC0_INTS0_GPIO7_EDGE_LOW_Msk (0x40000000UL)      /*!< GPIO7_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC0_INTS0_GPIO7_LEVEL_HIGH_Pos (29UL)            /*!< GPIO7_LEVEL_HIGH (Bit 29)                             */
#define IO_BANK0_PROC0_INTS0_GPIO7_LEVEL_HIGH_Msk (0x20000000UL)    /*!< GPIO7_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS0_GPIO7_LEVEL_LOW_Pos (28UL)             /*!< GPIO7_LEVEL_LOW (Bit 28)                              */
#define IO_BANK0_PROC0_INTS0_GPIO7_LEVEL_LOW_Msk (0x10000000UL)     /*!< GPIO7_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS0_GPIO6_EDGE_HIGH_Pos (27UL)             /*!< GPIO6_EDGE_HIGH (Bit 27)                              */
#define IO_BANK0_PROC0_INTS0_GPIO6_EDGE_HIGH_Msk (0x8000000UL)      /*!< GPIO6_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS0_GPIO6_EDGE_LOW_Pos (26UL)              /*!< GPIO6_EDGE_LOW (Bit 26)                               */
#define IO_BANK0_PROC0_INTS0_GPIO6_EDGE_LOW_Msk (0x4000000UL)       /*!< GPIO6_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC0_INTS0_GPIO6_LEVEL_HIGH_Pos (25UL)            /*!< GPIO6_LEVEL_HIGH (Bit 25)                             */
#define IO_BANK0_PROC0_INTS0_GPIO6_LEVEL_HIGH_Msk (0x2000000UL)     /*!< GPIO6_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS0_GPIO6_LEVEL_LOW_Pos (24UL)             /*!< GPIO6_LEVEL_LOW (Bit 24)                              */
#define IO_BANK0_PROC0_INTS0_GPIO6_LEVEL_LOW_Msk (0x1000000UL)      /*!< GPIO6_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS0_GPIO5_EDGE_HIGH_Pos (23UL)             /*!< GPIO5_EDGE_HIGH (Bit 23)                              */
#define IO_BANK0_PROC0_INTS0_GPIO5_EDGE_HIGH_Msk (0x800000UL)       /*!< GPIO5_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS0_GPIO5_EDGE_LOW_Pos (22UL)              /*!< GPIO5_EDGE_LOW (Bit 22)                               */
#define IO_BANK0_PROC0_INTS0_GPIO5_EDGE_LOW_Msk (0x400000UL)        /*!< GPIO5_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC0_INTS0_GPIO5_LEVEL_HIGH_Pos (21UL)            /*!< GPIO5_LEVEL_HIGH (Bit 21)                             */
#define IO_BANK0_PROC0_INTS0_GPIO5_LEVEL_HIGH_Msk (0x200000UL)      /*!< GPIO5_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS0_GPIO5_LEVEL_LOW_Pos (20UL)             /*!< GPIO5_LEVEL_LOW (Bit 20)                              */
#define IO_BANK0_PROC0_INTS0_GPIO5_LEVEL_LOW_Msk (0x100000UL)       /*!< GPIO5_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS0_GPIO4_EDGE_HIGH_Pos (19UL)             /*!< GPIO4_EDGE_HIGH (Bit 19)                              */
#define IO_BANK0_PROC0_INTS0_GPIO4_EDGE_HIGH_Msk (0x80000UL)        /*!< GPIO4_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS0_GPIO4_EDGE_LOW_Pos (18UL)              /*!< GPIO4_EDGE_LOW (Bit 18)                               */
#define IO_BANK0_PROC0_INTS0_GPIO4_EDGE_LOW_Msk (0x40000UL)         /*!< GPIO4_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC0_INTS0_GPIO4_LEVEL_HIGH_Pos (17UL)            /*!< GPIO4_LEVEL_HIGH (Bit 17)                             */
#define IO_BANK0_PROC0_INTS0_GPIO4_LEVEL_HIGH_Msk (0x20000UL)       /*!< GPIO4_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS0_GPIO4_LEVEL_LOW_Pos (16UL)             /*!< GPIO4_LEVEL_LOW (Bit 16)                              */
#define IO_BANK0_PROC0_INTS0_GPIO4_LEVEL_LOW_Msk (0x10000UL)        /*!< GPIO4_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS0_GPIO3_EDGE_HIGH_Pos (15UL)             /*!< GPIO3_EDGE_HIGH (Bit 15)                              */
#define IO_BANK0_PROC0_INTS0_GPIO3_EDGE_HIGH_Msk (0x8000UL)         /*!< GPIO3_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS0_GPIO3_EDGE_LOW_Pos (14UL)              /*!< GPIO3_EDGE_LOW (Bit 14)                               */
#define IO_BANK0_PROC0_INTS0_GPIO3_EDGE_LOW_Msk (0x4000UL)          /*!< GPIO3_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC0_INTS0_GPIO3_LEVEL_HIGH_Pos (13UL)            /*!< GPIO3_LEVEL_HIGH (Bit 13)                             */
#define IO_BANK0_PROC0_INTS0_GPIO3_LEVEL_HIGH_Msk (0x2000UL)        /*!< GPIO3_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS0_GPIO3_LEVEL_LOW_Pos (12UL)             /*!< GPIO3_LEVEL_LOW (Bit 12)                              */
#define IO_BANK0_PROC0_INTS0_GPIO3_LEVEL_LOW_Msk (0x1000UL)         /*!< GPIO3_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS0_GPIO2_EDGE_HIGH_Pos (11UL)             /*!< GPIO2_EDGE_HIGH (Bit 11)                              */
#define IO_BANK0_PROC0_INTS0_GPIO2_EDGE_HIGH_Msk (0x800UL)          /*!< GPIO2_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS0_GPIO2_EDGE_LOW_Pos (10UL)              /*!< GPIO2_EDGE_LOW (Bit 10)                               */
#define IO_BANK0_PROC0_INTS0_GPIO2_EDGE_LOW_Msk (0x400UL)           /*!< GPIO2_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC0_INTS0_GPIO2_LEVEL_HIGH_Pos (9UL)             /*!< GPIO2_LEVEL_HIGH (Bit 9)                              */
#define IO_BANK0_PROC0_INTS0_GPIO2_LEVEL_HIGH_Msk (0x200UL)         /*!< GPIO2_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS0_GPIO2_LEVEL_LOW_Pos (8UL)              /*!< GPIO2_LEVEL_LOW (Bit 8)                               */
#define IO_BANK0_PROC0_INTS0_GPIO2_LEVEL_LOW_Msk (0x100UL)          /*!< GPIO2_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS0_GPIO1_EDGE_HIGH_Pos (7UL)              /*!< GPIO1_EDGE_HIGH (Bit 7)                               */
#define IO_BANK0_PROC0_INTS0_GPIO1_EDGE_HIGH_Msk (0x80UL)           /*!< GPIO1_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS0_GPIO1_EDGE_LOW_Pos (6UL)               /*!< GPIO1_EDGE_LOW (Bit 6)                                */
#define IO_BANK0_PROC0_INTS0_GPIO1_EDGE_LOW_Msk (0x40UL)            /*!< GPIO1_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC0_INTS0_GPIO1_LEVEL_HIGH_Pos (5UL)             /*!< GPIO1_LEVEL_HIGH (Bit 5)                              */
#define IO_BANK0_PROC0_INTS0_GPIO1_LEVEL_HIGH_Msk (0x20UL)          /*!< GPIO1_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS0_GPIO1_LEVEL_LOW_Pos (4UL)              /*!< GPIO1_LEVEL_LOW (Bit 4)                               */
#define IO_BANK0_PROC0_INTS0_GPIO1_LEVEL_LOW_Msk (0x10UL)           /*!< GPIO1_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS0_GPIO0_EDGE_HIGH_Pos (3UL)              /*!< GPIO0_EDGE_HIGH (Bit 3)                               */
#define IO_BANK0_PROC0_INTS0_GPIO0_EDGE_HIGH_Msk (0x8UL)            /*!< GPIO0_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS0_GPIO0_EDGE_LOW_Pos (2UL)               /*!< GPIO0_EDGE_LOW (Bit 2)                                */
#define IO_BANK0_PROC0_INTS0_GPIO0_EDGE_LOW_Msk (0x4UL)             /*!< GPIO0_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC0_INTS0_GPIO0_LEVEL_HIGH_Pos (1UL)             /*!< GPIO0_LEVEL_HIGH (Bit 1)                              */
#define IO_BANK0_PROC0_INTS0_GPIO0_LEVEL_HIGH_Msk (0x2UL)           /*!< GPIO0_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS0_GPIO0_LEVEL_LOW_Pos (0UL)              /*!< GPIO0_LEVEL_LOW (Bit 0)                               */
#define IO_BANK0_PROC0_INTS0_GPIO0_LEVEL_LOW_Msk (0x1UL)            /*!< GPIO0_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
/* ======================================================  PROC0_INTS1  ====================================================== */
#define IO_BANK0_PROC0_INTS1_GPIO15_EDGE_HIGH_Pos (31UL)            /*!< GPIO15_EDGE_HIGH (Bit 31)                             */
#define IO_BANK0_PROC0_INTS1_GPIO15_EDGE_HIGH_Msk (0x80000000UL)    /*!< GPIO15_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS1_GPIO15_EDGE_LOW_Pos (30UL)             /*!< GPIO15_EDGE_LOW (Bit 30)                              */
#define IO_BANK0_PROC0_INTS1_GPIO15_EDGE_LOW_Msk (0x40000000UL)     /*!< GPIO15_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS1_GPIO15_LEVEL_HIGH_Pos (29UL)           /*!< GPIO15_LEVEL_HIGH (Bit 29)                            */
#define IO_BANK0_PROC0_INTS1_GPIO15_LEVEL_HIGH_Msk (0x20000000UL)   /*!< GPIO15_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTS1_GPIO15_LEVEL_LOW_Pos (28UL)            /*!< GPIO15_LEVEL_LOW (Bit 28)                             */
#define IO_BANK0_PROC0_INTS1_GPIO15_LEVEL_LOW_Msk (0x10000000UL)    /*!< GPIO15_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS1_GPIO14_EDGE_HIGH_Pos (27UL)            /*!< GPIO14_EDGE_HIGH (Bit 27)                             */
#define IO_BANK0_PROC0_INTS1_GPIO14_EDGE_HIGH_Msk (0x8000000UL)     /*!< GPIO14_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS1_GPIO14_EDGE_LOW_Pos (26UL)             /*!< GPIO14_EDGE_LOW (Bit 26)                              */
#define IO_BANK0_PROC0_INTS1_GPIO14_EDGE_LOW_Msk (0x4000000UL)      /*!< GPIO14_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS1_GPIO14_LEVEL_HIGH_Pos (25UL)           /*!< GPIO14_LEVEL_HIGH (Bit 25)                            */
#define IO_BANK0_PROC0_INTS1_GPIO14_LEVEL_HIGH_Msk (0x2000000UL)    /*!< GPIO14_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTS1_GPIO14_LEVEL_LOW_Pos (24UL)            /*!< GPIO14_LEVEL_LOW (Bit 24)                             */
#define IO_BANK0_PROC0_INTS1_GPIO14_LEVEL_LOW_Msk (0x1000000UL)     /*!< GPIO14_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS1_GPIO13_EDGE_HIGH_Pos (23UL)            /*!< GPIO13_EDGE_HIGH (Bit 23)                             */
#define IO_BANK0_PROC0_INTS1_GPIO13_EDGE_HIGH_Msk (0x800000UL)      /*!< GPIO13_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS1_GPIO13_EDGE_LOW_Pos (22UL)             /*!< GPIO13_EDGE_LOW (Bit 22)                              */
#define IO_BANK0_PROC0_INTS1_GPIO13_EDGE_LOW_Msk (0x400000UL)       /*!< GPIO13_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS1_GPIO13_LEVEL_HIGH_Pos (21UL)           /*!< GPIO13_LEVEL_HIGH (Bit 21)                            */
#define IO_BANK0_PROC0_INTS1_GPIO13_LEVEL_HIGH_Msk (0x200000UL)     /*!< GPIO13_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTS1_GPIO13_LEVEL_LOW_Pos (20UL)            /*!< GPIO13_LEVEL_LOW (Bit 20)                             */
#define IO_BANK0_PROC0_INTS1_GPIO13_LEVEL_LOW_Msk (0x100000UL)      /*!< GPIO13_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS1_GPIO12_EDGE_HIGH_Pos (19UL)            /*!< GPIO12_EDGE_HIGH (Bit 19)                             */
#define IO_BANK0_PROC0_INTS1_GPIO12_EDGE_HIGH_Msk (0x80000UL)       /*!< GPIO12_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS1_GPIO12_EDGE_LOW_Pos (18UL)             /*!< GPIO12_EDGE_LOW (Bit 18)                              */
#define IO_BANK0_PROC0_INTS1_GPIO12_EDGE_LOW_Msk (0x40000UL)        /*!< GPIO12_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS1_GPIO12_LEVEL_HIGH_Pos (17UL)           /*!< GPIO12_LEVEL_HIGH (Bit 17)                            */
#define IO_BANK0_PROC0_INTS1_GPIO12_LEVEL_HIGH_Msk (0x20000UL)      /*!< GPIO12_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTS1_GPIO12_LEVEL_LOW_Pos (16UL)            /*!< GPIO12_LEVEL_LOW (Bit 16)                             */
#define IO_BANK0_PROC0_INTS1_GPIO12_LEVEL_LOW_Msk (0x10000UL)       /*!< GPIO12_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS1_GPIO11_EDGE_HIGH_Pos (15UL)            /*!< GPIO11_EDGE_HIGH (Bit 15)                             */
#define IO_BANK0_PROC0_INTS1_GPIO11_EDGE_HIGH_Msk (0x8000UL)        /*!< GPIO11_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS1_GPIO11_EDGE_LOW_Pos (14UL)             /*!< GPIO11_EDGE_LOW (Bit 14)                              */
#define IO_BANK0_PROC0_INTS1_GPIO11_EDGE_LOW_Msk (0x4000UL)         /*!< GPIO11_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS1_GPIO11_LEVEL_HIGH_Pos (13UL)           /*!< GPIO11_LEVEL_HIGH (Bit 13)                            */
#define IO_BANK0_PROC0_INTS1_GPIO11_LEVEL_HIGH_Msk (0x2000UL)       /*!< GPIO11_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTS1_GPIO11_LEVEL_LOW_Pos (12UL)            /*!< GPIO11_LEVEL_LOW (Bit 12)                             */
#define IO_BANK0_PROC0_INTS1_GPIO11_LEVEL_LOW_Msk (0x1000UL)        /*!< GPIO11_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS1_GPIO10_EDGE_HIGH_Pos (11UL)            /*!< GPIO10_EDGE_HIGH (Bit 11)                             */
#define IO_BANK0_PROC0_INTS1_GPIO10_EDGE_HIGH_Msk (0x800UL)         /*!< GPIO10_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS1_GPIO10_EDGE_LOW_Pos (10UL)             /*!< GPIO10_EDGE_LOW (Bit 10)                              */
#define IO_BANK0_PROC0_INTS1_GPIO10_EDGE_LOW_Msk (0x400UL)          /*!< GPIO10_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS1_GPIO10_LEVEL_HIGH_Pos (9UL)            /*!< GPIO10_LEVEL_HIGH (Bit 9)                             */
#define IO_BANK0_PROC0_INTS1_GPIO10_LEVEL_HIGH_Msk (0x200UL)        /*!< GPIO10_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTS1_GPIO10_LEVEL_LOW_Pos (8UL)             /*!< GPIO10_LEVEL_LOW (Bit 8)                              */
#define IO_BANK0_PROC0_INTS1_GPIO10_LEVEL_LOW_Msk (0x100UL)         /*!< GPIO10_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS1_GPIO9_EDGE_HIGH_Pos (7UL)              /*!< GPIO9_EDGE_HIGH (Bit 7)                               */
#define IO_BANK0_PROC0_INTS1_GPIO9_EDGE_HIGH_Msk (0x80UL)           /*!< GPIO9_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS1_GPIO9_EDGE_LOW_Pos (6UL)               /*!< GPIO9_EDGE_LOW (Bit 6)                                */
#define IO_BANK0_PROC0_INTS1_GPIO9_EDGE_LOW_Msk (0x40UL)            /*!< GPIO9_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC0_INTS1_GPIO9_LEVEL_HIGH_Pos (5UL)             /*!< GPIO9_LEVEL_HIGH (Bit 5)                              */
#define IO_BANK0_PROC0_INTS1_GPIO9_LEVEL_HIGH_Msk (0x20UL)          /*!< GPIO9_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS1_GPIO9_LEVEL_LOW_Pos (4UL)              /*!< GPIO9_LEVEL_LOW (Bit 4)                               */
#define IO_BANK0_PROC0_INTS1_GPIO9_LEVEL_LOW_Msk (0x10UL)           /*!< GPIO9_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS1_GPIO8_EDGE_HIGH_Pos (3UL)              /*!< GPIO8_EDGE_HIGH (Bit 3)                               */
#define IO_BANK0_PROC0_INTS1_GPIO8_EDGE_HIGH_Msk (0x8UL)            /*!< GPIO8_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS1_GPIO8_EDGE_LOW_Pos (2UL)               /*!< GPIO8_EDGE_LOW (Bit 2)                                */
#define IO_BANK0_PROC0_INTS1_GPIO8_EDGE_LOW_Msk (0x4UL)             /*!< GPIO8_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC0_INTS1_GPIO8_LEVEL_HIGH_Pos (1UL)             /*!< GPIO8_LEVEL_HIGH (Bit 1)                              */
#define IO_BANK0_PROC0_INTS1_GPIO8_LEVEL_HIGH_Msk (0x2UL)           /*!< GPIO8_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS1_GPIO8_LEVEL_LOW_Pos (0UL)              /*!< GPIO8_LEVEL_LOW (Bit 0)                               */
#define IO_BANK0_PROC0_INTS1_GPIO8_LEVEL_LOW_Msk (0x1UL)            /*!< GPIO8_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
/* ======================================================  PROC0_INTS2  ====================================================== */
#define IO_BANK0_PROC0_INTS2_GPIO23_EDGE_HIGH_Pos (31UL)            /*!< GPIO23_EDGE_HIGH (Bit 31)                             */
#define IO_BANK0_PROC0_INTS2_GPIO23_EDGE_HIGH_Msk (0x80000000UL)    /*!< GPIO23_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS2_GPIO23_EDGE_LOW_Pos (30UL)             /*!< GPIO23_EDGE_LOW (Bit 30)                              */
#define IO_BANK0_PROC0_INTS2_GPIO23_EDGE_LOW_Msk (0x40000000UL)     /*!< GPIO23_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS2_GPIO23_LEVEL_HIGH_Pos (29UL)           /*!< GPIO23_LEVEL_HIGH (Bit 29)                            */
#define IO_BANK0_PROC0_INTS2_GPIO23_LEVEL_HIGH_Msk (0x20000000UL)   /*!< GPIO23_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTS2_GPIO23_LEVEL_LOW_Pos (28UL)            /*!< GPIO23_LEVEL_LOW (Bit 28)                             */
#define IO_BANK0_PROC0_INTS2_GPIO23_LEVEL_LOW_Msk (0x10000000UL)    /*!< GPIO23_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS2_GPIO22_EDGE_HIGH_Pos (27UL)            /*!< GPIO22_EDGE_HIGH (Bit 27)                             */
#define IO_BANK0_PROC0_INTS2_GPIO22_EDGE_HIGH_Msk (0x8000000UL)     /*!< GPIO22_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS2_GPIO22_EDGE_LOW_Pos (26UL)             /*!< GPIO22_EDGE_LOW (Bit 26)                              */
#define IO_BANK0_PROC0_INTS2_GPIO22_EDGE_LOW_Msk (0x4000000UL)      /*!< GPIO22_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS2_GPIO22_LEVEL_HIGH_Pos (25UL)           /*!< GPIO22_LEVEL_HIGH (Bit 25)                            */
#define IO_BANK0_PROC0_INTS2_GPIO22_LEVEL_HIGH_Msk (0x2000000UL)    /*!< GPIO22_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTS2_GPIO22_LEVEL_LOW_Pos (24UL)            /*!< GPIO22_LEVEL_LOW (Bit 24)                             */
#define IO_BANK0_PROC0_INTS2_GPIO22_LEVEL_LOW_Msk (0x1000000UL)     /*!< GPIO22_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS2_GPIO21_EDGE_HIGH_Pos (23UL)            /*!< GPIO21_EDGE_HIGH (Bit 23)                             */
#define IO_BANK0_PROC0_INTS2_GPIO21_EDGE_HIGH_Msk (0x800000UL)      /*!< GPIO21_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS2_GPIO21_EDGE_LOW_Pos (22UL)             /*!< GPIO21_EDGE_LOW (Bit 22)                              */
#define IO_BANK0_PROC0_INTS2_GPIO21_EDGE_LOW_Msk (0x400000UL)       /*!< GPIO21_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS2_GPIO21_LEVEL_HIGH_Pos (21UL)           /*!< GPIO21_LEVEL_HIGH (Bit 21)                            */
#define IO_BANK0_PROC0_INTS2_GPIO21_LEVEL_HIGH_Msk (0x200000UL)     /*!< GPIO21_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTS2_GPIO21_LEVEL_LOW_Pos (20UL)            /*!< GPIO21_LEVEL_LOW (Bit 20)                             */
#define IO_BANK0_PROC0_INTS2_GPIO21_LEVEL_LOW_Msk (0x100000UL)      /*!< GPIO21_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS2_GPIO20_EDGE_HIGH_Pos (19UL)            /*!< GPIO20_EDGE_HIGH (Bit 19)                             */
#define IO_BANK0_PROC0_INTS2_GPIO20_EDGE_HIGH_Msk (0x80000UL)       /*!< GPIO20_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS2_GPIO20_EDGE_LOW_Pos (18UL)             /*!< GPIO20_EDGE_LOW (Bit 18)                              */
#define IO_BANK0_PROC0_INTS2_GPIO20_EDGE_LOW_Msk (0x40000UL)        /*!< GPIO20_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS2_GPIO20_LEVEL_HIGH_Pos (17UL)           /*!< GPIO20_LEVEL_HIGH (Bit 17)                            */
#define IO_BANK0_PROC0_INTS2_GPIO20_LEVEL_HIGH_Msk (0x20000UL)      /*!< GPIO20_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTS2_GPIO20_LEVEL_LOW_Pos (16UL)            /*!< GPIO20_LEVEL_LOW (Bit 16)                             */
#define IO_BANK0_PROC0_INTS2_GPIO20_LEVEL_LOW_Msk (0x10000UL)       /*!< GPIO20_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS2_GPIO19_EDGE_HIGH_Pos (15UL)            /*!< GPIO19_EDGE_HIGH (Bit 15)                             */
#define IO_BANK0_PROC0_INTS2_GPIO19_EDGE_HIGH_Msk (0x8000UL)        /*!< GPIO19_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS2_GPIO19_EDGE_LOW_Pos (14UL)             /*!< GPIO19_EDGE_LOW (Bit 14)                              */
#define IO_BANK0_PROC0_INTS2_GPIO19_EDGE_LOW_Msk (0x4000UL)         /*!< GPIO19_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS2_GPIO19_LEVEL_HIGH_Pos (13UL)           /*!< GPIO19_LEVEL_HIGH (Bit 13)                            */
#define IO_BANK0_PROC0_INTS2_GPIO19_LEVEL_HIGH_Msk (0x2000UL)       /*!< GPIO19_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTS2_GPIO19_LEVEL_LOW_Pos (12UL)            /*!< GPIO19_LEVEL_LOW (Bit 12)                             */
#define IO_BANK0_PROC0_INTS2_GPIO19_LEVEL_LOW_Msk (0x1000UL)        /*!< GPIO19_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS2_GPIO18_EDGE_HIGH_Pos (11UL)            /*!< GPIO18_EDGE_HIGH (Bit 11)                             */
#define IO_BANK0_PROC0_INTS2_GPIO18_EDGE_HIGH_Msk (0x800UL)         /*!< GPIO18_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS2_GPIO18_EDGE_LOW_Pos (10UL)             /*!< GPIO18_EDGE_LOW (Bit 10)                              */
#define IO_BANK0_PROC0_INTS2_GPIO18_EDGE_LOW_Msk (0x400UL)          /*!< GPIO18_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS2_GPIO18_LEVEL_HIGH_Pos (9UL)            /*!< GPIO18_LEVEL_HIGH (Bit 9)                             */
#define IO_BANK0_PROC0_INTS2_GPIO18_LEVEL_HIGH_Msk (0x200UL)        /*!< GPIO18_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTS2_GPIO18_LEVEL_LOW_Pos (8UL)             /*!< GPIO18_LEVEL_LOW (Bit 8)                              */
#define IO_BANK0_PROC0_INTS2_GPIO18_LEVEL_LOW_Msk (0x100UL)         /*!< GPIO18_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS2_GPIO17_EDGE_HIGH_Pos (7UL)             /*!< GPIO17_EDGE_HIGH (Bit 7)                              */
#define IO_BANK0_PROC0_INTS2_GPIO17_EDGE_HIGH_Msk (0x80UL)          /*!< GPIO17_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS2_GPIO17_EDGE_LOW_Pos (6UL)              /*!< GPIO17_EDGE_LOW (Bit 6)                               */
#define IO_BANK0_PROC0_INTS2_GPIO17_EDGE_LOW_Msk (0x40UL)           /*!< GPIO17_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS2_GPIO17_LEVEL_HIGH_Pos (5UL)            /*!< GPIO17_LEVEL_HIGH (Bit 5)                             */
#define IO_BANK0_PROC0_INTS2_GPIO17_LEVEL_HIGH_Msk (0x20UL)         /*!< GPIO17_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTS2_GPIO17_LEVEL_LOW_Pos (4UL)             /*!< GPIO17_LEVEL_LOW (Bit 4)                              */
#define IO_BANK0_PROC0_INTS2_GPIO17_LEVEL_LOW_Msk (0x10UL)          /*!< GPIO17_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS2_GPIO16_EDGE_HIGH_Pos (3UL)             /*!< GPIO16_EDGE_HIGH (Bit 3)                              */
#define IO_BANK0_PROC0_INTS2_GPIO16_EDGE_HIGH_Msk (0x8UL)           /*!< GPIO16_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS2_GPIO16_EDGE_LOW_Pos (2UL)              /*!< GPIO16_EDGE_LOW (Bit 2)                               */
#define IO_BANK0_PROC0_INTS2_GPIO16_EDGE_LOW_Msk (0x4UL)            /*!< GPIO16_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS2_GPIO16_LEVEL_HIGH_Pos (1UL)            /*!< GPIO16_LEVEL_HIGH (Bit 1)                             */
#define IO_BANK0_PROC0_INTS2_GPIO16_LEVEL_HIGH_Msk (0x2UL)          /*!< GPIO16_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTS2_GPIO16_LEVEL_LOW_Pos (0UL)             /*!< GPIO16_LEVEL_LOW (Bit 0)                              */
#define IO_BANK0_PROC0_INTS2_GPIO16_LEVEL_LOW_Msk (0x1UL)           /*!< GPIO16_LEVEL_LOW (Bitfield-Mask: 0x01)                */
/* ======================================================  PROC0_INTS3  ====================================================== */
#define IO_BANK0_PROC0_INTS3_GPIO29_EDGE_HIGH_Pos (23UL)            /*!< GPIO29_EDGE_HIGH (Bit 23)                             */
#define IO_BANK0_PROC0_INTS3_GPIO29_EDGE_HIGH_Msk (0x800000UL)      /*!< GPIO29_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS3_GPIO29_EDGE_LOW_Pos (22UL)             /*!< GPIO29_EDGE_LOW (Bit 22)                              */
#define IO_BANK0_PROC0_INTS3_GPIO29_EDGE_LOW_Msk (0x400000UL)       /*!< GPIO29_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS3_GPIO29_LEVEL_HIGH_Pos (21UL)           /*!< GPIO29_LEVEL_HIGH (Bit 21)                            */
#define IO_BANK0_PROC0_INTS3_GPIO29_LEVEL_HIGH_Msk (0x200000UL)     /*!< GPIO29_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTS3_GPIO29_LEVEL_LOW_Pos (20UL)            /*!< GPIO29_LEVEL_LOW (Bit 20)                             */
#define IO_BANK0_PROC0_INTS3_GPIO29_LEVEL_LOW_Msk (0x100000UL)      /*!< GPIO29_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS3_GPIO28_EDGE_HIGH_Pos (19UL)            /*!< GPIO28_EDGE_HIGH (Bit 19)                             */
#define IO_BANK0_PROC0_INTS3_GPIO28_EDGE_HIGH_Msk (0x80000UL)       /*!< GPIO28_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS3_GPIO28_EDGE_LOW_Pos (18UL)             /*!< GPIO28_EDGE_LOW (Bit 18)                              */
#define IO_BANK0_PROC0_INTS3_GPIO28_EDGE_LOW_Msk (0x40000UL)        /*!< GPIO28_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS3_GPIO28_LEVEL_HIGH_Pos (17UL)           /*!< GPIO28_LEVEL_HIGH (Bit 17)                            */
#define IO_BANK0_PROC0_INTS3_GPIO28_LEVEL_HIGH_Msk (0x20000UL)      /*!< GPIO28_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTS3_GPIO28_LEVEL_LOW_Pos (16UL)            /*!< GPIO28_LEVEL_LOW (Bit 16)                             */
#define IO_BANK0_PROC0_INTS3_GPIO28_LEVEL_LOW_Msk (0x10000UL)       /*!< GPIO28_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS3_GPIO27_EDGE_HIGH_Pos (15UL)            /*!< GPIO27_EDGE_HIGH (Bit 15)                             */
#define IO_BANK0_PROC0_INTS3_GPIO27_EDGE_HIGH_Msk (0x8000UL)        /*!< GPIO27_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS3_GPIO27_EDGE_LOW_Pos (14UL)             /*!< GPIO27_EDGE_LOW (Bit 14)                              */
#define IO_BANK0_PROC0_INTS3_GPIO27_EDGE_LOW_Msk (0x4000UL)         /*!< GPIO27_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS3_GPIO27_LEVEL_HIGH_Pos (13UL)           /*!< GPIO27_LEVEL_HIGH (Bit 13)                            */
#define IO_BANK0_PROC0_INTS3_GPIO27_LEVEL_HIGH_Msk (0x2000UL)       /*!< GPIO27_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTS3_GPIO27_LEVEL_LOW_Pos (12UL)            /*!< GPIO27_LEVEL_LOW (Bit 12)                             */
#define IO_BANK0_PROC0_INTS3_GPIO27_LEVEL_LOW_Msk (0x1000UL)        /*!< GPIO27_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS3_GPIO26_EDGE_HIGH_Pos (11UL)            /*!< GPIO26_EDGE_HIGH (Bit 11)                             */
#define IO_BANK0_PROC0_INTS3_GPIO26_EDGE_HIGH_Msk (0x800UL)         /*!< GPIO26_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS3_GPIO26_EDGE_LOW_Pos (10UL)             /*!< GPIO26_EDGE_LOW (Bit 10)                              */
#define IO_BANK0_PROC0_INTS3_GPIO26_EDGE_LOW_Msk (0x400UL)          /*!< GPIO26_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS3_GPIO26_LEVEL_HIGH_Pos (9UL)            /*!< GPIO26_LEVEL_HIGH (Bit 9)                             */
#define IO_BANK0_PROC0_INTS3_GPIO26_LEVEL_HIGH_Msk (0x200UL)        /*!< GPIO26_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTS3_GPIO26_LEVEL_LOW_Pos (8UL)             /*!< GPIO26_LEVEL_LOW (Bit 8)                              */
#define IO_BANK0_PROC0_INTS3_GPIO26_LEVEL_LOW_Msk (0x100UL)         /*!< GPIO26_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS3_GPIO25_EDGE_HIGH_Pos (7UL)             /*!< GPIO25_EDGE_HIGH (Bit 7)                              */
#define IO_BANK0_PROC0_INTS3_GPIO25_EDGE_HIGH_Msk (0x80UL)          /*!< GPIO25_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS3_GPIO25_EDGE_LOW_Pos (6UL)              /*!< GPIO25_EDGE_LOW (Bit 6)                               */
#define IO_BANK0_PROC0_INTS3_GPIO25_EDGE_LOW_Msk (0x40UL)           /*!< GPIO25_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS3_GPIO25_LEVEL_HIGH_Pos (5UL)            /*!< GPIO25_LEVEL_HIGH (Bit 5)                             */
#define IO_BANK0_PROC0_INTS3_GPIO25_LEVEL_HIGH_Msk (0x20UL)         /*!< GPIO25_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTS3_GPIO25_LEVEL_LOW_Pos (4UL)             /*!< GPIO25_LEVEL_LOW (Bit 4)                              */
#define IO_BANK0_PROC0_INTS3_GPIO25_LEVEL_LOW_Msk (0x10UL)          /*!< GPIO25_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS3_GPIO24_EDGE_HIGH_Pos (3UL)             /*!< GPIO24_EDGE_HIGH (Bit 3)                              */
#define IO_BANK0_PROC0_INTS3_GPIO24_EDGE_HIGH_Msk (0x8UL)           /*!< GPIO24_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC0_INTS3_GPIO24_EDGE_LOW_Pos (2UL)              /*!< GPIO24_EDGE_LOW (Bit 2)                               */
#define IO_BANK0_PROC0_INTS3_GPIO24_EDGE_LOW_Msk (0x4UL)            /*!< GPIO24_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC0_INTS3_GPIO24_LEVEL_HIGH_Pos (1UL)            /*!< GPIO24_LEVEL_HIGH (Bit 1)                             */
#define IO_BANK0_PROC0_INTS3_GPIO24_LEVEL_HIGH_Msk (0x2UL)          /*!< GPIO24_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC0_INTS3_GPIO24_LEVEL_LOW_Pos (0UL)             /*!< GPIO24_LEVEL_LOW (Bit 0)                              */
#define IO_BANK0_PROC0_INTS3_GPIO24_LEVEL_LOW_Msk (0x1UL)           /*!< GPIO24_LEVEL_LOW (Bitfield-Mask: 0x01)                */
/* ======================================================  PROC1_INTE0  ====================================================== */
#define IO_BANK0_PROC1_INTE0_GPIO7_EDGE_HIGH_Pos (31UL)             /*!< GPIO7_EDGE_HIGH (Bit 31)                              */
#define IO_BANK0_PROC1_INTE0_GPIO7_EDGE_HIGH_Msk (0x80000000UL)     /*!< GPIO7_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE0_GPIO7_EDGE_LOW_Pos (30UL)              /*!< GPIO7_EDGE_LOW (Bit 30)                               */
#define IO_BANK0_PROC1_INTE0_GPIO7_EDGE_LOW_Msk (0x40000000UL)      /*!< GPIO7_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC1_INTE0_GPIO7_LEVEL_HIGH_Pos (29UL)            /*!< GPIO7_LEVEL_HIGH (Bit 29)                             */
#define IO_BANK0_PROC1_INTE0_GPIO7_LEVEL_HIGH_Msk (0x20000000UL)    /*!< GPIO7_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE0_GPIO7_LEVEL_LOW_Pos (28UL)             /*!< GPIO7_LEVEL_LOW (Bit 28)                              */
#define IO_BANK0_PROC1_INTE0_GPIO7_LEVEL_LOW_Msk (0x10000000UL)     /*!< GPIO7_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE0_GPIO6_EDGE_HIGH_Pos (27UL)             /*!< GPIO6_EDGE_HIGH (Bit 27)                              */
#define IO_BANK0_PROC1_INTE0_GPIO6_EDGE_HIGH_Msk (0x8000000UL)      /*!< GPIO6_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE0_GPIO6_EDGE_LOW_Pos (26UL)              /*!< GPIO6_EDGE_LOW (Bit 26)                               */
#define IO_BANK0_PROC1_INTE0_GPIO6_EDGE_LOW_Msk (0x4000000UL)       /*!< GPIO6_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC1_INTE0_GPIO6_LEVEL_HIGH_Pos (25UL)            /*!< GPIO6_LEVEL_HIGH (Bit 25)                             */
#define IO_BANK0_PROC1_INTE0_GPIO6_LEVEL_HIGH_Msk (0x2000000UL)     /*!< GPIO6_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE0_GPIO6_LEVEL_LOW_Pos (24UL)             /*!< GPIO6_LEVEL_LOW (Bit 24)                              */
#define IO_BANK0_PROC1_INTE0_GPIO6_LEVEL_LOW_Msk (0x1000000UL)      /*!< GPIO6_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE0_GPIO5_EDGE_HIGH_Pos (23UL)             /*!< GPIO5_EDGE_HIGH (Bit 23)                              */
#define IO_BANK0_PROC1_INTE0_GPIO5_EDGE_HIGH_Msk (0x800000UL)       /*!< GPIO5_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE0_GPIO5_EDGE_LOW_Pos (22UL)              /*!< GPIO5_EDGE_LOW (Bit 22)                               */
#define IO_BANK0_PROC1_INTE0_GPIO5_EDGE_LOW_Msk (0x400000UL)        /*!< GPIO5_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC1_INTE0_GPIO5_LEVEL_HIGH_Pos (21UL)            /*!< GPIO5_LEVEL_HIGH (Bit 21)                             */
#define IO_BANK0_PROC1_INTE0_GPIO5_LEVEL_HIGH_Msk (0x200000UL)      /*!< GPIO5_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE0_GPIO5_LEVEL_LOW_Pos (20UL)             /*!< GPIO5_LEVEL_LOW (Bit 20)                              */
#define IO_BANK0_PROC1_INTE0_GPIO5_LEVEL_LOW_Msk (0x100000UL)       /*!< GPIO5_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE0_GPIO4_EDGE_HIGH_Pos (19UL)             /*!< GPIO4_EDGE_HIGH (Bit 19)                              */
#define IO_BANK0_PROC1_INTE0_GPIO4_EDGE_HIGH_Msk (0x80000UL)        /*!< GPIO4_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE0_GPIO4_EDGE_LOW_Pos (18UL)              /*!< GPIO4_EDGE_LOW (Bit 18)                               */
#define IO_BANK0_PROC1_INTE0_GPIO4_EDGE_LOW_Msk (0x40000UL)         /*!< GPIO4_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC1_INTE0_GPIO4_LEVEL_HIGH_Pos (17UL)            /*!< GPIO4_LEVEL_HIGH (Bit 17)                             */
#define IO_BANK0_PROC1_INTE0_GPIO4_LEVEL_HIGH_Msk (0x20000UL)       /*!< GPIO4_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE0_GPIO4_LEVEL_LOW_Pos (16UL)             /*!< GPIO4_LEVEL_LOW (Bit 16)                              */
#define IO_BANK0_PROC1_INTE0_GPIO4_LEVEL_LOW_Msk (0x10000UL)        /*!< GPIO4_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE0_GPIO3_EDGE_HIGH_Pos (15UL)             /*!< GPIO3_EDGE_HIGH (Bit 15)                              */
#define IO_BANK0_PROC1_INTE0_GPIO3_EDGE_HIGH_Msk (0x8000UL)         /*!< GPIO3_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE0_GPIO3_EDGE_LOW_Pos (14UL)              /*!< GPIO3_EDGE_LOW (Bit 14)                               */
#define IO_BANK0_PROC1_INTE0_GPIO3_EDGE_LOW_Msk (0x4000UL)          /*!< GPIO3_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC1_INTE0_GPIO3_LEVEL_HIGH_Pos (13UL)            /*!< GPIO3_LEVEL_HIGH (Bit 13)                             */
#define IO_BANK0_PROC1_INTE0_GPIO3_LEVEL_HIGH_Msk (0x2000UL)        /*!< GPIO3_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE0_GPIO3_LEVEL_LOW_Pos (12UL)             /*!< GPIO3_LEVEL_LOW (Bit 12)                              */
#define IO_BANK0_PROC1_INTE0_GPIO3_LEVEL_LOW_Msk (0x1000UL)         /*!< GPIO3_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE0_GPIO2_EDGE_HIGH_Pos (11UL)             /*!< GPIO2_EDGE_HIGH (Bit 11)                              */
#define IO_BANK0_PROC1_INTE0_GPIO2_EDGE_HIGH_Msk (0x800UL)          /*!< GPIO2_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE0_GPIO2_EDGE_LOW_Pos (10UL)              /*!< GPIO2_EDGE_LOW (Bit 10)                               */
#define IO_BANK0_PROC1_INTE0_GPIO2_EDGE_LOW_Msk (0x400UL)           /*!< GPIO2_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC1_INTE0_GPIO2_LEVEL_HIGH_Pos (9UL)             /*!< GPIO2_LEVEL_HIGH (Bit 9)                              */
#define IO_BANK0_PROC1_INTE0_GPIO2_LEVEL_HIGH_Msk (0x200UL)         /*!< GPIO2_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE0_GPIO2_LEVEL_LOW_Pos (8UL)              /*!< GPIO2_LEVEL_LOW (Bit 8)                               */
#define IO_BANK0_PROC1_INTE0_GPIO2_LEVEL_LOW_Msk (0x100UL)          /*!< GPIO2_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE0_GPIO1_EDGE_HIGH_Pos (7UL)              /*!< GPIO1_EDGE_HIGH (Bit 7)                               */
#define IO_BANK0_PROC1_INTE0_GPIO1_EDGE_HIGH_Msk (0x80UL)           /*!< GPIO1_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE0_GPIO1_EDGE_LOW_Pos (6UL)               /*!< GPIO1_EDGE_LOW (Bit 6)                                */
#define IO_BANK0_PROC1_INTE0_GPIO1_EDGE_LOW_Msk (0x40UL)            /*!< GPIO1_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC1_INTE0_GPIO1_LEVEL_HIGH_Pos (5UL)             /*!< GPIO1_LEVEL_HIGH (Bit 5)                              */
#define IO_BANK0_PROC1_INTE0_GPIO1_LEVEL_HIGH_Msk (0x20UL)          /*!< GPIO1_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE0_GPIO1_LEVEL_LOW_Pos (4UL)              /*!< GPIO1_LEVEL_LOW (Bit 4)                               */
#define IO_BANK0_PROC1_INTE0_GPIO1_LEVEL_LOW_Msk (0x10UL)           /*!< GPIO1_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE0_GPIO0_EDGE_HIGH_Pos (3UL)              /*!< GPIO0_EDGE_HIGH (Bit 3)                               */
#define IO_BANK0_PROC1_INTE0_GPIO0_EDGE_HIGH_Msk (0x8UL)            /*!< GPIO0_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE0_GPIO0_EDGE_LOW_Pos (2UL)               /*!< GPIO0_EDGE_LOW (Bit 2)                                */
#define IO_BANK0_PROC1_INTE0_GPIO0_EDGE_LOW_Msk (0x4UL)             /*!< GPIO0_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC1_INTE0_GPIO0_LEVEL_HIGH_Pos (1UL)             /*!< GPIO0_LEVEL_HIGH (Bit 1)                              */
#define IO_BANK0_PROC1_INTE0_GPIO0_LEVEL_HIGH_Msk (0x2UL)           /*!< GPIO0_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE0_GPIO0_LEVEL_LOW_Pos (0UL)              /*!< GPIO0_LEVEL_LOW (Bit 0)                               */
#define IO_BANK0_PROC1_INTE0_GPIO0_LEVEL_LOW_Msk (0x1UL)            /*!< GPIO0_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
/* ======================================================  PROC1_INTE1  ====================================================== */
#define IO_BANK0_PROC1_INTE1_GPIO15_EDGE_HIGH_Pos (31UL)            /*!< GPIO15_EDGE_HIGH (Bit 31)                             */
#define IO_BANK0_PROC1_INTE1_GPIO15_EDGE_HIGH_Msk (0x80000000UL)    /*!< GPIO15_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE1_GPIO15_EDGE_LOW_Pos (30UL)             /*!< GPIO15_EDGE_LOW (Bit 30)                              */
#define IO_BANK0_PROC1_INTE1_GPIO15_EDGE_LOW_Msk (0x40000000UL)     /*!< GPIO15_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE1_GPIO15_LEVEL_HIGH_Pos (29UL)           /*!< GPIO15_LEVEL_HIGH (Bit 29)                            */
#define IO_BANK0_PROC1_INTE1_GPIO15_LEVEL_HIGH_Msk (0x20000000UL)   /*!< GPIO15_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTE1_GPIO15_LEVEL_LOW_Pos (28UL)            /*!< GPIO15_LEVEL_LOW (Bit 28)                             */
#define IO_BANK0_PROC1_INTE1_GPIO15_LEVEL_LOW_Msk (0x10000000UL)    /*!< GPIO15_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE1_GPIO14_EDGE_HIGH_Pos (27UL)            /*!< GPIO14_EDGE_HIGH (Bit 27)                             */
#define IO_BANK0_PROC1_INTE1_GPIO14_EDGE_HIGH_Msk (0x8000000UL)     /*!< GPIO14_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE1_GPIO14_EDGE_LOW_Pos (26UL)             /*!< GPIO14_EDGE_LOW (Bit 26)                              */
#define IO_BANK0_PROC1_INTE1_GPIO14_EDGE_LOW_Msk (0x4000000UL)      /*!< GPIO14_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE1_GPIO14_LEVEL_HIGH_Pos (25UL)           /*!< GPIO14_LEVEL_HIGH (Bit 25)                            */
#define IO_BANK0_PROC1_INTE1_GPIO14_LEVEL_HIGH_Msk (0x2000000UL)    /*!< GPIO14_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTE1_GPIO14_LEVEL_LOW_Pos (24UL)            /*!< GPIO14_LEVEL_LOW (Bit 24)                             */
#define IO_BANK0_PROC1_INTE1_GPIO14_LEVEL_LOW_Msk (0x1000000UL)     /*!< GPIO14_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE1_GPIO13_EDGE_HIGH_Pos (23UL)            /*!< GPIO13_EDGE_HIGH (Bit 23)                             */
#define IO_BANK0_PROC1_INTE1_GPIO13_EDGE_HIGH_Msk (0x800000UL)      /*!< GPIO13_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE1_GPIO13_EDGE_LOW_Pos (22UL)             /*!< GPIO13_EDGE_LOW (Bit 22)                              */
#define IO_BANK0_PROC1_INTE1_GPIO13_EDGE_LOW_Msk (0x400000UL)       /*!< GPIO13_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE1_GPIO13_LEVEL_HIGH_Pos (21UL)           /*!< GPIO13_LEVEL_HIGH (Bit 21)                            */
#define IO_BANK0_PROC1_INTE1_GPIO13_LEVEL_HIGH_Msk (0x200000UL)     /*!< GPIO13_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTE1_GPIO13_LEVEL_LOW_Pos (20UL)            /*!< GPIO13_LEVEL_LOW (Bit 20)                             */
#define IO_BANK0_PROC1_INTE1_GPIO13_LEVEL_LOW_Msk (0x100000UL)      /*!< GPIO13_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE1_GPIO12_EDGE_HIGH_Pos (19UL)            /*!< GPIO12_EDGE_HIGH (Bit 19)                             */
#define IO_BANK0_PROC1_INTE1_GPIO12_EDGE_HIGH_Msk (0x80000UL)       /*!< GPIO12_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE1_GPIO12_EDGE_LOW_Pos (18UL)             /*!< GPIO12_EDGE_LOW (Bit 18)                              */
#define IO_BANK0_PROC1_INTE1_GPIO12_EDGE_LOW_Msk (0x40000UL)        /*!< GPIO12_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE1_GPIO12_LEVEL_HIGH_Pos (17UL)           /*!< GPIO12_LEVEL_HIGH (Bit 17)                            */
#define IO_BANK0_PROC1_INTE1_GPIO12_LEVEL_HIGH_Msk (0x20000UL)      /*!< GPIO12_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTE1_GPIO12_LEVEL_LOW_Pos (16UL)            /*!< GPIO12_LEVEL_LOW (Bit 16)                             */
#define IO_BANK0_PROC1_INTE1_GPIO12_LEVEL_LOW_Msk (0x10000UL)       /*!< GPIO12_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE1_GPIO11_EDGE_HIGH_Pos (15UL)            /*!< GPIO11_EDGE_HIGH (Bit 15)                             */
#define IO_BANK0_PROC1_INTE1_GPIO11_EDGE_HIGH_Msk (0x8000UL)        /*!< GPIO11_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE1_GPIO11_EDGE_LOW_Pos (14UL)             /*!< GPIO11_EDGE_LOW (Bit 14)                              */
#define IO_BANK0_PROC1_INTE1_GPIO11_EDGE_LOW_Msk (0x4000UL)         /*!< GPIO11_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE1_GPIO11_LEVEL_HIGH_Pos (13UL)           /*!< GPIO11_LEVEL_HIGH (Bit 13)                            */
#define IO_BANK0_PROC1_INTE1_GPIO11_LEVEL_HIGH_Msk (0x2000UL)       /*!< GPIO11_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTE1_GPIO11_LEVEL_LOW_Pos (12UL)            /*!< GPIO11_LEVEL_LOW (Bit 12)                             */
#define IO_BANK0_PROC1_INTE1_GPIO11_LEVEL_LOW_Msk (0x1000UL)        /*!< GPIO11_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE1_GPIO10_EDGE_HIGH_Pos (11UL)            /*!< GPIO10_EDGE_HIGH (Bit 11)                             */
#define IO_BANK0_PROC1_INTE1_GPIO10_EDGE_HIGH_Msk (0x800UL)         /*!< GPIO10_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE1_GPIO10_EDGE_LOW_Pos (10UL)             /*!< GPIO10_EDGE_LOW (Bit 10)                              */
#define IO_BANK0_PROC1_INTE1_GPIO10_EDGE_LOW_Msk (0x400UL)          /*!< GPIO10_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE1_GPIO10_LEVEL_HIGH_Pos (9UL)            /*!< GPIO10_LEVEL_HIGH (Bit 9)                             */
#define IO_BANK0_PROC1_INTE1_GPIO10_LEVEL_HIGH_Msk (0x200UL)        /*!< GPIO10_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTE1_GPIO10_LEVEL_LOW_Pos (8UL)             /*!< GPIO10_LEVEL_LOW (Bit 8)                              */
#define IO_BANK0_PROC1_INTE1_GPIO10_LEVEL_LOW_Msk (0x100UL)         /*!< GPIO10_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE1_GPIO9_EDGE_HIGH_Pos (7UL)              /*!< GPIO9_EDGE_HIGH (Bit 7)                               */
#define IO_BANK0_PROC1_INTE1_GPIO9_EDGE_HIGH_Msk (0x80UL)           /*!< GPIO9_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE1_GPIO9_EDGE_LOW_Pos (6UL)               /*!< GPIO9_EDGE_LOW (Bit 6)                                */
#define IO_BANK0_PROC1_INTE1_GPIO9_EDGE_LOW_Msk (0x40UL)            /*!< GPIO9_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC1_INTE1_GPIO9_LEVEL_HIGH_Pos (5UL)             /*!< GPIO9_LEVEL_HIGH (Bit 5)                              */
#define IO_BANK0_PROC1_INTE1_GPIO9_LEVEL_HIGH_Msk (0x20UL)          /*!< GPIO9_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE1_GPIO9_LEVEL_LOW_Pos (4UL)              /*!< GPIO9_LEVEL_LOW (Bit 4)                               */
#define IO_BANK0_PROC1_INTE1_GPIO9_LEVEL_LOW_Msk (0x10UL)           /*!< GPIO9_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE1_GPIO8_EDGE_HIGH_Pos (3UL)              /*!< GPIO8_EDGE_HIGH (Bit 3)                               */
#define IO_BANK0_PROC1_INTE1_GPIO8_EDGE_HIGH_Msk (0x8UL)            /*!< GPIO8_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE1_GPIO8_EDGE_LOW_Pos (2UL)               /*!< GPIO8_EDGE_LOW (Bit 2)                                */
#define IO_BANK0_PROC1_INTE1_GPIO8_EDGE_LOW_Msk (0x4UL)             /*!< GPIO8_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC1_INTE1_GPIO8_LEVEL_HIGH_Pos (1UL)             /*!< GPIO8_LEVEL_HIGH (Bit 1)                              */
#define IO_BANK0_PROC1_INTE1_GPIO8_LEVEL_HIGH_Msk (0x2UL)           /*!< GPIO8_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE1_GPIO8_LEVEL_LOW_Pos (0UL)              /*!< GPIO8_LEVEL_LOW (Bit 0)                               */
#define IO_BANK0_PROC1_INTE1_GPIO8_LEVEL_LOW_Msk (0x1UL)            /*!< GPIO8_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
/* ======================================================  PROC1_INTE2  ====================================================== */
#define IO_BANK0_PROC1_INTE2_GPIO23_EDGE_HIGH_Pos (31UL)            /*!< GPIO23_EDGE_HIGH (Bit 31)                             */
#define IO_BANK0_PROC1_INTE2_GPIO23_EDGE_HIGH_Msk (0x80000000UL)    /*!< GPIO23_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE2_GPIO23_EDGE_LOW_Pos (30UL)             /*!< GPIO23_EDGE_LOW (Bit 30)                              */
#define IO_BANK0_PROC1_INTE2_GPIO23_EDGE_LOW_Msk (0x40000000UL)     /*!< GPIO23_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE2_GPIO23_LEVEL_HIGH_Pos (29UL)           /*!< GPIO23_LEVEL_HIGH (Bit 29)                            */
#define IO_BANK0_PROC1_INTE2_GPIO23_LEVEL_HIGH_Msk (0x20000000UL)   /*!< GPIO23_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTE2_GPIO23_LEVEL_LOW_Pos (28UL)            /*!< GPIO23_LEVEL_LOW (Bit 28)                             */
#define IO_BANK0_PROC1_INTE2_GPIO23_LEVEL_LOW_Msk (0x10000000UL)    /*!< GPIO23_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE2_GPIO22_EDGE_HIGH_Pos (27UL)            /*!< GPIO22_EDGE_HIGH (Bit 27)                             */
#define IO_BANK0_PROC1_INTE2_GPIO22_EDGE_HIGH_Msk (0x8000000UL)     /*!< GPIO22_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE2_GPIO22_EDGE_LOW_Pos (26UL)             /*!< GPIO22_EDGE_LOW (Bit 26)                              */
#define IO_BANK0_PROC1_INTE2_GPIO22_EDGE_LOW_Msk (0x4000000UL)      /*!< GPIO22_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE2_GPIO22_LEVEL_HIGH_Pos (25UL)           /*!< GPIO22_LEVEL_HIGH (Bit 25)                            */
#define IO_BANK0_PROC1_INTE2_GPIO22_LEVEL_HIGH_Msk (0x2000000UL)    /*!< GPIO22_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTE2_GPIO22_LEVEL_LOW_Pos (24UL)            /*!< GPIO22_LEVEL_LOW (Bit 24)                             */
#define IO_BANK0_PROC1_INTE2_GPIO22_LEVEL_LOW_Msk (0x1000000UL)     /*!< GPIO22_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE2_GPIO21_EDGE_HIGH_Pos (23UL)            /*!< GPIO21_EDGE_HIGH (Bit 23)                             */
#define IO_BANK0_PROC1_INTE2_GPIO21_EDGE_HIGH_Msk (0x800000UL)      /*!< GPIO21_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE2_GPIO21_EDGE_LOW_Pos (22UL)             /*!< GPIO21_EDGE_LOW (Bit 22)                              */
#define IO_BANK0_PROC1_INTE2_GPIO21_EDGE_LOW_Msk (0x400000UL)       /*!< GPIO21_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE2_GPIO21_LEVEL_HIGH_Pos (21UL)           /*!< GPIO21_LEVEL_HIGH (Bit 21)                            */
#define IO_BANK0_PROC1_INTE2_GPIO21_LEVEL_HIGH_Msk (0x200000UL)     /*!< GPIO21_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTE2_GPIO21_LEVEL_LOW_Pos (20UL)            /*!< GPIO21_LEVEL_LOW (Bit 20)                             */
#define IO_BANK0_PROC1_INTE2_GPIO21_LEVEL_LOW_Msk (0x100000UL)      /*!< GPIO21_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE2_GPIO20_EDGE_HIGH_Pos (19UL)            /*!< GPIO20_EDGE_HIGH (Bit 19)                             */
#define IO_BANK0_PROC1_INTE2_GPIO20_EDGE_HIGH_Msk (0x80000UL)       /*!< GPIO20_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE2_GPIO20_EDGE_LOW_Pos (18UL)             /*!< GPIO20_EDGE_LOW (Bit 18)                              */
#define IO_BANK0_PROC1_INTE2_GPIO20_EDGE_LOW_Msk (0x40000UL)        /*!< GPIO20_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE2_GPIO20_LEVEL_HIGH_Pos (17UL)           /*!< GPIO20_LEVEL_HIGH (Bit 17)                            */
#define IO_BANK0_PROC1_INTE2_GPIO20_LEVEL_HIGH_Msk (0x20000UL)      /*!< GPIO20_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTE2_GPIO20_LEVEL_LOW_Pos (16UL)            /*!< GPIO20_LEVEL_LOW (Bit 16)                             */
#define IO_BANK0_PROC1_INTE2_GPIO20_LEVEL_LOW_Msk (0x10000UL)       /*!< GPIO20_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE2_GPIO19_EDGE_HIGH_Pos (15UL)            /*!< GPIO19_EDGE_HIGH (Bit 15)                             */
#define IO_BANK0_PROC1_INTE2_GPIO19_EDGE_HIGH_Msk (0x8000UL)        /*!< GPIO19_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE2_GPIO19_EDGE_LOW_Pos (14UL)             /*!< GPIO19_EDGE_LOW (Bit 14)                              */
#define IO_BANK0_PROC1_INTE2_GPIO19_EDGE_LOW_Msk (0x4000UL)         /*!< GPIO19_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE2_GPIO19_LEVEL_HIGH_Pos (13UL)           /*!< GPIO19_LEVEL_HIGH (Bit 13)                            */
#define IO_BANK0_PROC1_INTE2_GPIO19_LEVEL_HIGH_Msk (0x2000UL)       /*!< GPIO19_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTE2_GPIO19_LEVEL_LOW_Pos (12UL)            /*!< GPIO19_LEVEL_LOW (Bit 12)                             */
#define IO_BANK0_PROC1_INTE2_GPIO19_LEVEL_LOW_Msk (0x1000UL)        /*!< GPIO19_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE2_GPIO18_EDGE_HIGH_Pos (11UL)            /*!< GPIO18_EDGE_HIGH (Bit 11)                             */
#define IO_BANK0_PROC1_INTE2_GPIO18_EDGE_HIGH_Msk (0x800UL)         /*!< GPIO18_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE2_GPIO18_EDGE_LOW_Pos (10UL)             /*!< GPIO18_EDGE_LOW (Bit 10)                              */
#define IO_BANK0_PROC1_INTE2_GPIO18_EDGE_LOW_Msk (0x400UL)          /*!< GPIO18_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE2_GPIO18_LEVEL_HIGH_Pos (9UL)            /*!< GPIO18_LEVEL_HIGH (Bit 9)                             */
#define IO_BANK0_PROC1_INTE2_GPIO18_LEVEL_HIGH_Msk (0x200UL)        /*!< GPIO18_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTE2_GPIO18_LEVEL_LOW_Pos (8UL)             /*!< GPIO18_LEVEL_LOW (Bit 8)                              */
#define IO_BANK0_PROC1_INTE2_GPIO18_LEVEL_LOW_Msk (0x100UL)         /*!< GPIO18_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE2_GPIO17_EDGE_HIGH_Pos (7UL)             /*!< GPIO17_EDGE_HIGH (Bit 7)                              */
#define IO_BANK0_PROC1_INTE2_GPIO17_EDGE_HIGH_Msk (0x80UL)          /*!< GPIO17_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE2_GPIO17_EDGE_LOW_Pos (6UL)              /*!< GPIO17_EDGE_LOW (Bit 6)                               */
#define IO_BANK0_PROC1_INTE2_GPIO17_EDGE_LOW_Msk (0x40UL)           /*!< GPIO17_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE2_GPIO17_LEVEL_HIGH_Pos (5UL)            /*!< GPIO17_LEVEL_HIGH (Bit 5)                             */
#define IO_BANK0_PROC1_INTE2_GPIO17_LEVEL_HIGH_Msk (0x20UL)         /*!< GPIO17_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTE2_GPIO17_LEVEL_LOW_Pos (4UL)             /*!< GPIO17_LEVEL_LOW (Bit 4)                              */
#define IO_BANK0_PROC1_INTE2_GPIO17_LEVEL_LOW_Msk (0x10UL)          /*!< GPIO17_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE2_GPIO16_EDGE_HIGH_Pos (3UL)             /*!< GPIO16_EDGE_HIGH (Bit 3)                              */
#define IO_BANK0_PROC1_INTE2_GPIO16_EDGE_HIGH_Msk (0x8UL)           /*!< GPIO16_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE2_GPIO16_EDGE_LOW_Pos (2UL)              /*!< GPIO16_EDGE_LOW (Bit 2)                               */
#define IO_BANK0_PROC1_INTE2_GPIO16_EDGE_LOW_Msk (0x4UL)            /*!< GPIO16_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE2_GPIO16_LEVEL_HIGH_Pos (1UL)            /*!< GPIO16_LEVEL_HIGH (Bit 1)                             */
#define IO_BANK0_PROC1_INTE2_GPIO16_LEVEL_HIGH_Msk (0x2UL)          /*!< GPIO16_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTE2_GPIO16_LEVEL_LOW_Pos (0UL)             /*!< GPIO16_LEVEL_LOW (Bit 0)                              */
#define IO_BANK0_PROC1_INTE2_GPIO16_LEVEL_LOW_Msk (0x1UL)           /*!< GPIO16_LEVEL_LOW (Bitfield-Mask: 0x01)                */
/* ======================================================  PROC1_INTE3  ====================================================== */
#define IO_BANK0_PROC1_INTE3_GPIO29_EDGE_HIGH_Pos (23UL)            /*!< GPIO29_EDGE_HIGH (Bit 23)                             */
#define IO_BANK0_PROC1_INTE3_GPIO29_EDGE_HIGH_Msk (0x800000UL)      /*!< GPIO29_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE3_GPIO29_EDGE_LOW_Pos (22UL)             /*!< GPIO29_EDGE_LOW (Bit 22)                              */
#define IO_BANK0_PROC1_INTE3_GPIO29_EDGE_LOW_Msk (0x400000UL)       /*!< GPIO29_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE3_GPIO29_LEVEL_HIGH_Pos (21UL)           /*!< GPIO29_LEVEL_HIGH (Bit 21)                            */
#define IO_BANK0_PROC1_INTE3_GPIO29_LEVEL_HIGH_Msk (0x200000UL)     /*!< GPIO29_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTE3_GPIO29_LEVEL_LOW_Pos (20UL)            /*!< GPIO29_LEVEL_LOW (Bit 20)                             */
#define IO_BANK0_PROC1_INTE3_GPIO29_LEVEL_LOW_Msk (0x100000UL)      /*!< GPIO29_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE3_GPIO28_EDGE_HIGH_Pos (19UL)            /*!< GPIO28_EDGE_HIGH (Bit 19)                             */
#define IO_BANK0_PROC1_INTE3_GPIO28_EDGE_HIGH_Msk (0x80000UL)       /*!< GPIO28_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE3_GPIO28_EDGE_LOW_Pos (18UL)             /*!< GPIO28_EDGE_LOW (Bit 18)                              */
#define IO_BANK0_PROC1_INTE3_GPIO28_EDGE_LOW_Msk (0x40000UL)        /*!< GPIO28_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE3_GPIO28_LEVEL_HIGH_Pos (17UL)           /*!< GPIO28_LEVEL_HIGH (Bit 17)                            */
#define IO_BANK0_PROC1_INTE3_GPIO28_LEVEL_HIGH_Msk (0x20000UL)      /*!< GPIO28_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTE3_GPIO28_LEVEL_LOW_Pos (16UL)            /*!< GPIO28_LEVEL_LOW (Bit 16)                             */
#define IO_BANK0_PROC1_INTE3_GPIO28_LEVEL_LOW_Msk (0x10000UL)       /*!< GPIO28_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE3_GPIO27_EDGE_HIGH_Pos (15UL)            /*!< GPIO27_EDGE_HIGH (Bit 15)                             */
#define IO_BANK0_PROC1_INTE3_GPIO27_EDGE_HIGH_Msk (0x8000UL)        /*!< GPIO27_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE3_GPIO27_EDGE_LOW_Pos (14UL)             /*!< GPIO27_EDGE_LOW (Bit 14)                              */
#define IO_BANK0_PROC1_INTE3_GPIO27_EDGE_LOW_Msk (0x4000UL)         /*!< GPIO27_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE3_GPIO27_LEVEL_HIGH_Pos (13UL)           /*!< GPIO27_LEVEL_HIGH (Bit 13)                            */
#define IO_BANK0_PROC1_INTE3_GPIO27_LEVEL_HIGH_Msk (0x2000UL)       /*!< GPIO27_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTE3_GPIO27_LEVEL_LOW_Pos (12UL)            /*!< GPIO27_LEVEL_LOW (Bit 12)                             */
#define IO_BANK0_PROC1_INTE3_GPIO27_LEVEL_LOW_Msk (0x1000UL)        /*!< GPIO27_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE3_GPIO26_EDGE_HIGH_Pos (11UL)            /*!< GPIO26_EDGE_HIGH (Bit 11)                             */
#define IO_BANK0_PROC1_INTE3_GPIO26_EDGE_HIGH_Msk (0x800UL)         /*!< GPIO26_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE3_GPIO26_EDGE_LOW_Pos (10UL)             /*!< GPIO26_EDGE_LOW (Bit 10)                              */
#define IO_BANK0_PROC1_INTE3_GPIO26_EDGE_LOW_Msk (0x400UL)          /*!< GPIO26_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE3_GPIO26_LEVEL_HIGH_Pos (9UL)            /*!< GPIO26_LEVEL_HIGH (Bit 9)                             */
#define IO_BANK0_PROC1_INTE3_GPIO26_LEVEL_HIGH_Msk (0x200UL)        /*!< GPIO26_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTE3_GPIO26_LEVEL_LOW_Pos (8UL)             /*!< GPIO26_LEVEL_LOW (Bit 8)                              */
#define IO_BANK0_PROC1_INTE3_GPIO26_LEVEL_LOW_Msk (0x100UL)         /*!< GPIO26_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE3_GPIO25_EDGE_HIGH_Pos (7UL)             /*!< GPIO25_EDGE_HIGH (Bit 7)                              */
#define IO_BANK0_PROC1_INTE3_GPIO25_EDGE_HIGH_Msk (0x80UL)          /*!< GPIO25_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE3_GPIO25_EDGE_LOW_Pos (6UL)              /*!< GPIO25_EDGE_LOW (Bit 6)                               */
#define IO_BANK0_PROC1_INTE3_GPIO25_EDGE_LOW_Msk (0x40UL)           /*!< GPIO25_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE3_GPIO25_LEVEL_HIGH_Pos (5UL)            /*!< GPIO25_LEVEL_HIGH (Bit 5)                             */
#define IO_BANK0_PROC1_INTE3_GPIO25_LEVEL_HIGH_Msk (0x20UL)         /*!< GPIO25_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTE3_GPIO25_LEVEL_LOW_Pos (4UL)             /*!< GPIO25_LEVEL_LOW (Bit 4)                              */
#define IO_BANK0_PROC1_INTE3_GPIO25_LEVEL_LOW_Msk (0x10UL)          /*!< GPIO25_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE3_GPIO24_EDGE_HIGH_Pos (3UL)             /*!< GPIO24_EDGE_HIGH (Bit 3)                              */
#define IO_BANK0_PROC1_INTE3_GPIO24_EDGE_HIGH_Msk (0x8UL)           /*!< GPIO24_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTE3_GPIO24_EDGE_LOW_Pos (2UL)              /*!< GPIO24_EDGE_LOW (Bit 2)                               */
#define IO_BANK0_PROC1_INTE3_GPIO24_EDGE_LOW_Msk (0x4UL)            /*!< GPIO24_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTE3_GPIO24_LEVEL_HIGH_Pos (1UL)            /*!< GPIO24_LEVEL_HIGH (Bit 1)                             */
#define IO_BANK0_PROC1_INTE3_GPIO24_LEVEL_HIGH_Msk (0x2UL)          /*!< GPIO24_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTE3_GPIO24_LEVEL_LOW_Pos (0UL)             /*!< GPIO24_LEVEL_LOW (Bit 0)                              */
#define IO_BANK0_PROC1_INTE3_GPIO24_LEVEL_LOW_Msk (0x1UL)           /*!< GPIO24_LEVEL_LOW (Bitfield-Mask: 0x01)                */
/* ======================================================  PROC1_INTF0  ====================================================== */
#define IO_BANK0_PROC1_INTF0_GPIO7_EDGE_HIGH_Pos (31UL)             /*!< GPIO7_EDGE_HIGH (Bit 31)                              */
#define IO_BANK0_PROC1_INTF0_GPIO7_EDGE_HIGH_Msk (0x80000000UL)     /*!< GPIO7_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF0_GPIO7_EDGE_LOW_Pos (30UL)              /*!< GPIO7_EDGE_LOW (Bit 30)                               */
#define IO_BANK0_PROC1_INTF0_GPIO7_EDGE_LOW_Msk (0x40000000UL)      /*!< GPIO7_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC1_INTF0_GPIO7_LEVEL_HIGH_Pos (29UL)            /*!< GPIO7_LEVEL_HIGH (Bit 29)                             */
#define IO_BANK0_PROC1_INTF0_GPIO7_LEVEL_HIGH_Msk (0x20000000UL)    /*!< GPIO7_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF0_GPIO7_LEVEL_LOW_Pos (28UL)             /*!< GPIO7_LEVEL_LOW (Bit 28)                              */
#define IO_BANK0_PROC1_INTF0_GPIO7_LEVEL_LOW_Msk (0x10000000UL)     /*!< GPIO7_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF0_GPIO6_EDGE_HIGH_Pos (27UL)             /*!< GPIO6_EDGE_HIGH (Bit 27)                              */
#define IO_BANK0_PROC1_INTF0_GPIO6_EDGE_HIGH_Msk (0x8000000UL)      /*!< GPIO6_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF0_GPIO6_EDGE_LOW_Pos (26UL)              /*!< GPIO6_EDGE_LOW (Bit 26)                               */
#define IO_BANK0_PROC1_INTF0_GPIO6_EDGE_LOW_Msk (0x4000000UL)       /*!< GPIO6_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC1_INTF0_GPIO6_LEVEL_HIGH_Pos (25UL)            /*!< GPIO6_LEVEL_HIGH (Bit 25)                             */
#define IO_BANK0_PROC1_INTF0_GPIO6_LEVEL_HIGH_Msk (0x2000000UL)     /*!< GPIO6_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF0_GPIO6_LEVEL_LOW_Pos (24UL)             /*!< GPIO6_LEVEL_LOW (Bit 24)                              */
#define IO_BANK0_PROC1_INTF0_GPIO6_LEVEL_LOW_Msk (0x1000000UL)      /*!< GPIO6_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF0_GPIO5_EDGE_HIGH_Pos (23UL)             /*!< GPIO5_EDGE_HIGH (Bit 23)                              */
#define IO_BANK0_PROC1_INTF0_GPIO5_EDGE_HIGH_Msk (0x800000UL)       /*!< GPIO5_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF0_GPIO5_EDGE_LOW_Pos (22UL)              /*!< GPIO5_EDGE_LOW (Bit 22)                               */
#define IO_BANK0_PROC1_INTF0_GPIO5_EDGE_LOW_Msk (0x400000UL)        /*!< GPIO5_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC1_INTF0_GPIO5_LEVEL_HIGH_Pos (21UL)            /*!< GPIO5_LEVEL_HIGH (Bit 21)                             */
#define IO_BANK0_PROC1_INTF0_GPIO5_LEVEL_HIGH_Msk (0x200000UL)      /*!< GPIO5_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF0_GPIO5_LEVEL_LOW_Pos (20UL)             /*!< GPIO5_LEVEL_LOW (Bit 20)                              */
#define IO_BANK0_PROC1_INTF0_GPIO5_LEVEL_LOW_Msk (0x100000UL)       /*!< GPIO5_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF0_GPIO4_EDGE_HIGH_Pos (19UL)             /*!< GPIO4_EDGE_HIGH (Bit 19)                              */
#define IO_BANK0_PROC1_INTF0_GPIO4_EDGE_HIGH_Msk (0x80000UL)        /*!< GPIO4_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF0_GPIO4_EDGE_LOW_Pos (18UL)              /*!< GPIO4_EDGE_LOW (Bit 18)                               */
#define IO_BANK0_PROC1_INTF0_GPIO4_EDGE_LOW_Msk (0x40000UL)         /*!< GPIO4_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC1_INTF0_GPIO4_LEVEL_HIGH_Pos (17UL)            /*!< GPIO4_LEVEL_HIGH (Bit 17)                             */
#define IO_BANK0_PROC1_INTF0_GPIO4_LEVEL_HIGH_Msk (0x20000UL)       /*!< GPIO4_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF0_GPIO4_LEVEL_LOW_Pos (16UL)             /*!< GPIO4_LEVEL_LOW (Bit 16)                              */
#define IO_BANK0_PROC1_INTF0_GPIO4_LEVEL_LOW_Msk (0x10000UL)        /*!< GPIO4_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF0_GPIO3_EDGE_HIGH_Pos (15UL)             /*!< GPIO3_EDGE_HIGH (Bit 15)                              */
#define IO_BANK0_PROC1_INTF0_GPIO3_EDGE_HIGH_Msk (0x8000UL)         /*!< GPIO3_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF0_GPIO3_EDGE_LOW_Pos (14UL)              /*!< GPIO3_EDGE_LOW (Bit 14)                               */
#define IO_BANK0_PROC1_INTF0_GPIO3_EDGE_LOW_Msk (0x4000UL)          /*!< GPIO3_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC1_INTF0_GPIO3_LEVEL_HIGH_Pos (13UL)            /*!< GPIO3_LEVEL_HIGH (Bit 13)                             */
#define IO_BANK0_PROC1_INTF0_GPIO3_LEVEL_HIGH_Msk (0x2000UL)        /*!< GPIO3_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF0_GPIO3_LEVEL_LOW_Pos (12UL)             /*!< GPIO3_LEVEL_LOW (Bit 12)                              */
#define IO_BANK0_PROC1_INTF0_GPIO3_LEVEL_LOW_Msk (0x1000UL)         /*!< GPIO3_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF0_GPIO2_EDGE_HIGH_Pos (11UL)             /*!< GPIO2_EDGE_HIGH (Bit 11)                              */
#define IO_BANK0_PROC1_INTF0_GPIO2_EDGE_HIGH_Msk (0x800UL)          /*!< GPIO2_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF0_GPIO2_EDGE_LOW_Pos (10UL)              /*!< GPIO2_EDGE_LOW (Bit 10)                               */
#define IO_BANK0_PROC1_INTF0_GPIO2_EDGE_LOW_Msk (0x400UL)           /*!< GPIO2_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC1_INTF0_GPIO2_LEVEL_HIGH_Pos (9UL)             /*!< GPIO2_LEVEL_HIGH (Bit 9)                              */
#define IO_BANK0_PROC1_INTF0_GPIO2_LEVEL_HIGH_Msk (0x200UL)         /*!< GPIO2_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF0_GPIO2_LEVEL_LOW_Pos (8UL)              /*!< GPIO2_LEVEL_LOW (Bit 8)                               */
#define IO_BANK0_PROC1_INTF0_GPIO2_LEVEL_LOW_Msk (0x100UL)          /*!< GPIO2_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF0_GPIO1_EDGE_HIGH_Pos (7UL)              /*!< GPIO1_EDGE_HIGH (Bit 7)                               */
#define IO_BANK0_PROC1_INTF0_GPIO1_EDGE_HIGH_Msk (0x80UL)           /*!< GPIO1_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF0_GPIO1_EDGE_LOW_Pos (6UL)               /*!< GPIO1_EDGE_LOW (Bit 6)                                */
#define IO_BANK0_PROC1_INTF0_GPIO1_EDGE_LOW_Msk (0x40UL)            /*!< GPIO1_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC1_INTF0_GPIO1_LEVEL_HIGH_Pos (5UL)             /*!< GPIO1_LEVEL_HIGH (Bit 5)                              */
#define IO_BANK0_PROC1_INTF0_GPIO1_LEVEL_HIGH_Msk (0x20UL)          /*!< GPIO1_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF0_GPIO1_LEVEL_LOW_Pos (4UL)              /*!< GPIO1_LEVEL_LOW (Bit 4)                               */
#define IO_BANK0_PROC1_INTF0_GPIO1_LEVEL_LOW_Msk (0x10UL)           /*!< GPIO1_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF0_GPIO0_EDGE_HIGH_Pos (3UL)              /*!< GPIO0_EDGE_HIGH (Bit 3)                               */
#define IO_BANK0_PROC1_INTF0_GPIO0_EDGE_HIGH_Msk (0x8UL)            /*!< GPIO0_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF0_GPIO0_EDGE_LOW_Pos (2UL)               /*!< GPIO0_EDGE_LOW (Bit 2)                                */
#define IO_BANK0_PROC1_INTF0_GPIO0_EDGE_LOW_Msk (0x4UL)             /*!< GPIO0_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC1_INTF0_GPIO0_LEVEL_HIGH_Pos (1UL)             /*!< GPIO0_LEVEL_HIGH (Bit 1)                              */
#define IO_BANK0_PROC1_INTF0_GPIO0_LEVEL_HIGH_Msk (0x2UL)           /*!< GPIO0_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF0_GPIO0_LEVEL_LOW_Pos (0UL)              /*!< GPIO0_LEVEL_LOW (Bit 0)                               */
#define IO_BANK0_PROC1_INTF0_GPIO0_LEVEL_LOW_Msk (0x1UL)            /*!< GPIO0_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
/* ======================================================  PROC1_INTF1  ====================================================== */
#define IO_BANK0_PROC1_INTF1_GPIO15_EDGE_HIGH_Pos (31UL)            /*!< GPIO15_EDGE_HIGH (Bit 31)                             */
#define IO_BANK0_PROC1_INTF1_GPIO15_EDGE_HIGH_Msk (0x80000000UL)    /*!< GPIO15_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF1_GPIO15_EDGE_LOW_Pos (30UL)             /*!< GPIO15_EDGE_LOW (Bit 30)                              */
#define IO_BANK0_PROC1_INTF1_GPIO15_EDGE_LOW_Msk (0x40000000UL)     /*!< GPIO15_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF1_GPIO15_LEVEL_HIGH_Pos (29UL)           /*!< GPIO15_LEVEL_HIGH (Bit 29)                            */
#define IO_BANK0_PROC1_INTF1_GPIO15_LEVEL_HIGH_Msk (0x20000000UL)   /*!< GPIO15_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTF1_GPIO15_LEVEL_LOW_Pos (28UL)            /*!< GPIO15_LEVEL_LOW (Bit 28)                             */
#define IO_BANK0_PROC1_INTF1_GPIO15_LEVEL_LOW_Msk (0x10000000UL)    /*!< GPIO15_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF1_GPIO14_EDGE_HIGH_Pos (27UL)            /*!< GPIO14_EDGE_HIGH (Bit 27)                             */
#define IO_BANK0_PROC1_INTF1_GPIO14_EDGE_HIGH_Msk (0x8000000UL)     /*!< GPIO14_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF1_GPIO14_EDGE_LOW_Pos (26UL)             /*!< GPIO14_EDGE_LOW (Bit 26)                              */
#define IO_BANK0_PROC1_INTF1_GPIO14_EDGE_LOW_Msk (0x4000000UL)      /*!< GPIO14_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF1_GPIO14_LEVEL_HIGH_Pos (25UL)           /*!< GPIO14_LEVEL_HIGH (Bit 25)                            */
#define IO_BANK0_PROC1_INTF1_GPIO14_LEVEL_HIGH_Msk (0x2000000UL)    /*!< GPIO14_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTF1_GPIO14_LEVEL_LOW_Pos (24UL)            /*!< GPIO14_LEVEL_LOW (Bit 24)                             */
#define IO_BANK0_PROC1_INTF1_GPIO14_LEVEL_LOW_Msk (0x1000000UL)     /*!< GPIO14_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF1_GPIO13_EDGE_HIGH_Pos (23UL)            /*!< GPIO13_EDGE_HIGH (Bit 23)                             */
#define IO_BANK0_PROC1_INTF1_GPIO13_EDGE_HIGH_Msk (0x800000UL)      /*!< GPIO13_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF1_GPIO13_EDGE_LOW_Pos (22UL)             /*!< GPIO13_EDGE_LOW (Bit 22)                              */
#define IO_BANK0_PROC1_INTF1_GPIO13_EDGE_LOW_Msk (0x400000UL)       /*!< GPIO13_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF1_GPIO13_LEVEL_HIGH_Pos (21UL)           /*!< GPIO13_LEVEL_HIGH (Bit 21)                            */
#define IO_BANK0_PROC1_INTF1_GPIO13_LEVEL_HIGH_Msk (0x200000UL)     /*!< GPIO13_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTF1_GPIO13_LEVEL_LOW_Pos (20UL)            /*!< GPIO13_LEVEL_LOW (Bit 20)                             */
#define IO_BANK0_PROC1_INTF1_GPIO13_LEVEL_LOW_Msk (0x100000UL)      /*!< GPIO13_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF1_GPIO12_EDGE_HIGH_Pos (19UL)            /*!< GPIO12_EDGE_HIGH (Bit 19)                             */
#define IO_BANK0_PROC1_INTF1_GPIO12_EDGE_HIGH_Msk (0x80000UL)       /*!< GPIO12_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF1_GPIO12_EDGE_LOW_Pos (18UL)             /*!< GPIO12_EDGE_LOW (Bit 18)                              */
#define IO_BANK0_PROC1_INTF1_GPIO12_EDGE_LOW_Msk (0x40000UL)        /*!< GPIO12_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF1_GPIO12_LEVEL_HIGH_Pos (17UL)           /*!< GPIO12_LEVEL_HIGH (Bit 17)                            */
#define IO_BANK0_PROC1_INTF1_GPIO12_LEVEL_HIGH_Msk (0x20000UL)      /*!< GPIO12_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTF1_GPIO12_LEVEL_LOW_Pos (16UL)            /*!< GPIO12_LEVEL_LOW (Bit 16)                             */
#define IO_BANK0_PROC1_INTF1_GPIO12_LEVEL_LOW_Msk (0x10000UL)       /*!< GPIO12_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF1_GPIO11_EDGE_HIGH_Pos (15UL)            /*!< GPIO11_EDGE_HIGH (Bit 15)                             */
#define IO_BANK0_PROC1_INTF1_GPIO11_EDGE_HIGH_Msk (0x8000UL)        /*!< GPIO11_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF1_GPIO11_EDGE_LOW_Pos (14UL)             /*!< GPIO11_EDGE_LOW (Bit 14)                              */
#define IO_BANK0_PROC1_INTF1_GPIO11_EDGE_LOW_Msk (0x4000UL)         /*!< GPIO11_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF1_GPIO11_LEVEL_HIGH_Pos (13UL)           /*!< GPIO11_LEVEL_HIGH (Bit 13)                            */
#define IO_BANK0_PROC1_INTF1_GPIO11_LEVEL_HIGH_Msk (0x2000UL)       /*!< GPIO11_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTF1_GPIO11_LEVEL_LOW_Pos (12UL)            /*!< GPIO11_LEVEL_LOW (Bit 12)                             */
#define IO_BANK0_PROC1_INTF1_GPIO11_LEVEL_LOW_Msk (0x1000UL)        /*!< GPIO11_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF1_GPIO10_EDGE_HIGH_Pos (11UL)            /*!< GPIO10_EDGE_HIGH (Bit 11)                             */
#define IO_BANK0_PROC1_INTF1_GPIO10_EDGE_HIGH_Msk (0x800UL)         /*!< GPIO10_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF1_GPIO10_EDGE_LOW_Pos (10UL)             /*!< GPIO10_EDGE_LOW (Bit 10)                              */
#define IO_BANK0_PROC1_INTF1_GPIO10_EDGE_LOW_Msk (0x400UL)          /*!< GPIO10_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF1_GPIO10_LEVEL_HIGH_Pos (9UL)            /*!< GPIO10_LEVEL_HIGH (Bit 9)                             */
#define IO_BANK0_PROC1_INTF1_GPIO10_LEVEL_HIGH_Msk (0x200UL)        /*!< GPIO10_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTF1_GPIO10_LEVEL_LOW_Pos (8UL)             /*!< GPIO10_LEVEL_LOW (Bit 8)                              */
#define IO_BANK0_PROC1_INTF1_GPIO10_LEVEL_LOW_Msk (0x100UL)         /*!< GPIO10_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF1_GPIO9_EDGE_HIGH_Pos (7UL)              /*!< GPIO9_EDGE_HIGH (Bit 7)                               */
#define IO_BANK0_PROC1_INTF1_GPIO9_EDGE_HIGH_Msk (0x80UL)           /*!< GPIO9_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF1_GPIO9_EDGE_LOW_Pos (6UL)               /*!< GPIO9_EDGE_LOW (Bit 6)                                */
#define IO_BANK0_PROC1_INTF1_GPIO9_EDGE_LOW_Msk (0x40UL)            /*!< GPIO9_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC1_INTF1_GPIO9_LEVEL_HIGH_Pos (5UL)             /*!< GPIO9_LEVEL_HIGH (Bit 5)                              */
#define IO_BANK0_PROC1_INTF1_GPIO9_LEVEL_HIGH_Msk (0x20UL)          /*!< GPIO9_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF1_GPIO9_LEVEL_LOW_Pos (4UL)              /*!< GPIO9_LEVEL_LOW (Bit 4)                               */
#define IO_BANK0_PROC1_INTF1_GPIO9_LEVEL_LOW_Msk (0x10UL)           /*!< GPIO9_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF1_GPIO8_EDGE_HIGH_Pos (3UL)              /*!< GPIO8_EDGE_HIGH (Bit 3)                               */
#define IO_BANK0_PROC1_INTF1_GPIO8_EDGE_HIGH_Msk (0x8UL)            /*!< GPIO8_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF1_GPIO8_EDGE_LOW_Pos (2UL)               /*!< GPIO8_EDGE_LOW (Bit 2)                                */
#define IO_BANK0_PROC1_INTF1_GPIO8_EDGE_LOW_Msk (0x4UL)             /*!< GPIO8_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC1_INTF1_GPIO8_LEVEL_HIGH_Pos (1UL)             /*!< GPIO8_LEVEL_HIGH (Bit 1)                              */
#define IO_BANK0_PROC1_INTF1_GPIO8_LEVEL_HIGH_Msk (0x2UL)           /*!< GPIO8_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF1_GPIO8_LEVEL_LOW_Pos (0UL)              /*!< GPIO8_LEVEL_LOW (Bit 0)                               */
#define IO_BANK0_PROC1_INTF1_GPIO8_LEVEL_LOW_Msk (0x1UL)            /*!< GPIO8_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
/* ======================================================  PROC1_INTF2  ====================================================== */
#define IO_BANK0_PROC1_INTF2_GPIO23_EDGE_HIGH_Pos (31UL)            /*!< GPIO23_EDGE_HIGH (Bit 31)                             */
#define IO_BANK0_PROC1_INTF2_GPIO23_EDGE_HIGH_Msk (0x80000000UL)    /*!< GPIO23_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF2_GPIO23_EDGE_LOW_Pos (30UL)             /*!< GPIO23_EDGE_LOW (Bit 30)                              */
#define IO_BANK0_PROC1_INTF2_GPIO23_EDGE_LOW_Msk (0x40000000UL)     /*!< GPIO23_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF2_GPIO23_LEVEL_HIGH_Pos (29UL)           /*!< GPIO23_LEVEL_HIGH (Bit 29)                            */
#define IO_BANK0_PROC1_INTF2_GPIO23_LEVEL_HIGH_Msk (0x20000000UL)   /*!< GPIO23_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTF2_GPIO23_LEVEL_LOW_Pos (28UL)            /*!< GPIO23_LEVEL_LOW (Bit 28)                             */
#define IO_BANK0_PROC1_INTF2_GPIO23_LEVEL_LOW_Msk (0x10000000UL)    /*!< GPIO23_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF2_GPIO22_EDGE_HIGH_Pos (27UL)            /*!< GPIO22_EDGE_HIGH (Bit 27)                             */
#define IO_BANK0_PROC1_INTF2_GPIO22_EDGE_HIGH_Msk (0x8000000UL)     /*!< GPIO22_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF2_GPIO22_EDGE_LOW_Pos (26UL)             /*!< GPIO22_EDGE_LOW (Bit 26)                              */
#define IO_BANK0_PROC1_INTF2_GPIO22_EDGE_LOW_Msk (0x4000000UL)      /*!< GPIO22_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF2_GPIO22_LEVEL_HIGH_Pos (25UL)           /*!< GPIO22_LEVEL_HIGH (Bit 25)                            */
#define IO_BANK0_PROC1_INTF2_GPIO22_LEVEL_HIGH_Msk (0x2000000UL)    /*!< GPIO22_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTF2_GPIO22_LEVEL_LOW_Pos (24UL)            /*!< GPIO22_LEVEL_LOW (Bit 24)                             */
#define IO_BANK0_PROC1_INTF2_GPIO22_LEVEL_LOW_Msk (0x1000000UL)     /*!< GPIO22_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF2_GPIO21_EDGE_HIGH_Pos (23UL)            /*!< GPIO21_EDGE_HIGH (Bit 23)                             */
#define IO_BANK0_PROC1_INTF2_GPIO21_EDGE_HIGH_Msk (0x800000UL)      /*!< GPIO21_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF2_GPIO21_EDGE_LOW_Pos (22UL)             /*!< GPIO21_EDGE_LOW (Bit 22)                              */
#define IO_BANK0_PROC1_INTF2_GPIO21_EDGE_LOW_Msk (0x400000UL)       /*!< GPIO21_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF2_GPIO21_LEVEL_HIGH_Pos (21UL)           /*!< GPIO21_LEVEL_HIGH (Bit 21)                            */
#define IO_BANK0_PROC1_INTF2_GPIO21_LEVEL_HIGH_Msk (0x200000UL)     /*!< GPIO21_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTF2_GPIO21_LEVEL_LOW_Pos (20UL)            /*!< GPIO21_LEVEL_LOW (Bit 20)                             */
#define IO_BANK0_PROC1_INTF2_GPIO21_LEVEL_LOW_Msk (0x100000UL)      /*!< GPIO21_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF2_GPIO20_EDGE_HIGH_Pos (19UL)            /*!< GPIO20_EDGE_HIGH (Bit 19)                             */
#define IO_BANK0_PROC1_INTF2_GPIO20_EDGE_HIGH_Msk (0x80000UL)       /*!< GPIO20_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF2_GPIO20_EDGE_LOW_Pos (18UL)             /*!< GPIO20_EDGE_LOW (Bit 18)                              */
#define IO_BANK0_PROC1_INTF2_GPIO20_EDGE_LOW_Msk (0x40000UL)        /*!< GPIO20_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF2_GPIO20_LEVEL_HIGH_Pos (17UL)           /*!< GPIO20_LEVEL_HIGH (Bit 17)                            */
#define IO_BANK0_PROC1_INTF2_GPIO20_LEVEL_HIGH_Msk (0x20000UL)      /*!< GPIO20_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTF2_GPIO20_LEVEL_LOW_Pos (16UL)            /*!< GPIO20_LEVEL_LOW (Bit 16)                             */
#define IO_BANK0_PROC1_INTF2_GPIO20_LEVEL_LOW_Msk (0x10000UL)       /*!< GPIO20_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF2_GPIO19_EDGE_HIGH_Pos (15UL)            /*!< GPIO19_EDGE_HIGH (Bit 15)                             */
#define IO_BANK0_PROC1_INTF2_GPIO19_EDGE_HIGH_Msk (0x8000UL)        /*!< GPIO19_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF2_GPIO19_EDGE_LOW_Pos (14UL)             /*!< GPIO19_EDGE_LOW (Bit 14)                              */
#define IO_BANK0_PROC1_INTF2_GPIO19_EDGE_LOW_Msk (0x4000UL)         /*!< GPIO19_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF2_GPIO19_LEVEL_HIGH_Pos (13UL)           /*!< GPIO19_LEVEL_HIGH (Bit 13)                            */
#define IO_BANK0_PROC1_INTF2_GPIO19_LEVEL_HIGH_Msk (0x2000UL)       /*!< GPIO19_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTF2_GPIO19_LEVEL_LOW_Pos (12UL)            /*!< GPIO19_LEVEL_LOW (Bit 12)                             */
#define IO_BANK0_PROC1_INTF2_GPIO19_LEVEL_LOW_Msk (0x1000UL)        /*!< GPIO19_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF2_GPIO18_EDGE_HIGH_Pos (11UL)            /*!< GPIO18_EDGE_HIGH (Bit 11)                             */
#define IO_BANK0_PROC1_INTF2_GPIO18_EDGE_HIGH_Msk (0x800UL)         /*!< GPIO18_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF2_GPIO18_EDGE_LOW_Pos (10UL)             /*!< GPIO18_EDGE_LOW (Bit 10)                              */
#define IO_BANK0_PROC1_INTF2_GPIO18_EDGE_LOW_Msk (0x400UL)          /*!< GPIO18_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF2_GPIO18_LEVEL_HIGH_Pos (9UL)            /*!< GPIO18_LEVEL_HIGH (Bit 9)                             */
#define IO_BANK0_PROC1_INTF2_GPIO18_LEVEL_HIGH_Msk (0x200UL)        /*!< GPIO18_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTF2_GPIO18_LEVEL_LOW_Pos (8UL)             /*!< GPIO18_LEVEL_LOW (Bit 8)                              */
#define IO_BANK0_PROC1_INTF2_GPIO18_LEVEL_LOW_Msk (0x100UL)         /*!< GPIO18_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF2_GPIO17_EDGE_HIGH_Pos (7UL)             /*!< GPIO17_EDGE_HIGH (Bit 7)                              */
#define IO_BANK0_PROC1_INTF2_GPIO17_EDGE_HIGH_Msk (0x80UL)          /*!< GPIO17_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF2_GPIO17_EDGE_LOW_Pos (6UL)              /*!< GPIO17_EDGE_LOW (Bit 6)                               */
#define IO_BANK0_PROC1_INTF2_GPIO17_EDGE_LOW_Msk (0x40UL)           /*!< GPIO17_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF2_GPIO17_LEVEL_HIGH_Pos (5UL)            /*!< GPIO17_LEVEL_HIGH (Bit 5)                             */
#define IO_BANK0_PROC1_INTF2_GPIO17_LEVEL_HIGH_Msk (0x20UL)         /*!< GPIO17_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTF2_GPIO17_LEVEL_LOW_Pos (4UL)             /*!< GPIO17_LEVEL_LOW (Bit 4)                              */
#define IO_BANK0_PROC1_INTF2_GPIO17_LEVEL_LOW_Msk (0x10UL)          /*!< GPIO17_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF2_GPIO16_EDGE_HIGH_Pos (3UL)             /*!< GPIO16_EDGE_HIGH (Bit 3)                              */
#define IO_BANK0_PROC1_INTF2_GPIO16_EDGE_HIGH_Msk (0x8UL)           /*!< GPIO16_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF2_GPIO16_EDGE_LOW_Pos (2UL)              /*!< GPIO16_EDGE_LOW (Bit 2)                               */
#define IO_BANK0_PROC1_INTF2_GPIO16_EDGE_LOW_Msk (0x4UL)            /*!< GPIO16_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF2_GPIO16_LEVEL_HIGH_Pos (1UL)            /*!< GPIO16_LEVEL_HIGH (Bit 1)                             */
#define IO_BANK0_PROC1_INTF2_GPIO16_LEVEL_HIGH_Msk (0x2UL)          /*!< GPIO16_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTF2_GPIO16_LEVEL_LOW_Pos (0UL)             /*!< GPIO16_LEVEL_LOW (Bit 0)                              */
#define IO_BANK0_PROC1_INTF2_GPIO16_LEVEL_LOW_Msk (0x1UL)           /*!< GPIO16_LEVEL_LOW (Bitfield-Mask: 0x01)                */
/* ======================================================  PROC1_INTF3  ====================================================== */
#define IO_BANK0_PROC1_INTF3_GPIO29_EDGE_HIGH_Pos (23UL)            /*!< GPIO29_EDGE_HIGH (Bit 23)                             */
#define IO_BANK0_PROC1_INTF3_GPIO29_EDGE_HIGH_Msk (0x800000UL)      /*!< GPIO29_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF3_GPIO29_EDGE_LOW_Pos (22UL)             /*!< GPIO29_EDGE_LOW (Bit 22)                              */
#define IO_BANK0_PROC1_INTF3_GPIO29_EDGE_LOW_Msk (0x400000UL)       /*!< GPIO29_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF3_GPIO29_LEVEL_HIGH_Pos (21UL)           /*!< GPIO29_LEVEL_HIGH (Bit 21)                            */
#define IO_BANK0_PROC1_INTF3_GPIO29_LEVEL_HIGH_Msk (0x200000UL)     /*!< GPIO29_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTF3_GPIO29_LEVEL_LOW_Pos (20UL)            /*!< GPIO29_LEVEL_LOW (Bit 20)                             */
#define IO_BANK0_PROC1_INTF3_GPIO29_LEVEL_LOW_Msk (0x100000UL)      /*!< GPIO29_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF3_GPIO28_EDGE_HIGH_Pos (19UL)            /*!< GPIO28_EDGE_HIGH (Bit 19)                             */
#define IO_BANK0_PROC1_INTF3_GPIO28_EDGE_HIGH_Msk (0x80000UL)       /*!< GPIO28_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF3_GPIO28_EDGE_LOW_Pos (18UL)             /*!< GPIO28_EDGE_LOW (Bit 18)                              */
#define IO_BANK0_PROC1_INTF3_GPIO28_EDGE_LOW_Msk (0x40000UL)        /*!< GPIO28_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF3_GPIO28_LEVEL_HIGH_Pos (17UL)           /*!< GPIO28_LEVEL_HIGH (Bit 17)                            */
#define IO_BANK0_PROC1_INTF3_GPIO28_LEVEL_HIGH_Msk (0x20000UL)      /*!< GPIO28_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTF3_GPIO28_LEVEL_LOW_Pos (16UL)            /*!< GPIO28_LEVEL_LOW (Bit 16)                             */
#define IO_BANK0_PROC1_INTF3_GPIO28_LEVEL_LOW_Msk (0x10000UL)       /*!< GPIO28_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF3_GPIO27_EDGE_HIGH_Pos (15UL)            /*!< GPIO27_EDGE_HIGH (Bit 15)                             */
#define IO_BANK0_PROC1_INTF3_GPIO27_EDGE_HIGH_Msk (0x8000UL)        /*!< GPIO27_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF3_GPIO27_EDGE_LOW_Pos (14UL)             /*!< GPIO27_EDGE_LOW (Bit 14)                              */
#define IO_BANK0_PROC1_INTF3_GPIO27_EDGE_LOW_Msk (0x4000UL)         /*!< GPIO27_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF3_GPIO27_LEVEL_HIGH_Pos (13UL)           /*!< GPIO27_LEVEL_HIGH (Bit 13)                            */
#define IO_BANK0_PROC1_INTF3_GPIO27_LEVEL_HIGH_Msk (0x2000UL)       /*!< GPIO27_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTF3_GPIO27_LEVEL_LOW_Pos (12UL)            /*!< GPIO27_LEVEL_LOW (Bit 12)                             */
#define IO_BANK0_PROC1_INTF3_GPIO27_LEVEL_LOW_Msk (0x1000UL)        /*!< GPIO27_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF3_GPIO26_EDGE_HIGH_Pos (11UL)            /*!< GPIO26_EDGE_HIGH (Bit 11)                             */
#define IO_BANK0_PROC1_INTF3_GPIO26_EDGE_HIGH_Msk (0x800UL)         /*!< GPIO26_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF3_GPIO26_EDGE_LOW_Pos (10UL)             /*!< GPIO26_EDGE_LOW (Bit 10)                              */
#define IO_BANK0_PROC1_INTF3_GPIO26_EDGE_LOW_Msk (0x400UL)          /*!< GPIO26_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF3_GPIO26_LEVEL_HIGH_Pos (9UL)            /*!< GPIO26_LEVEL_HIGH (Bit 9)                             */
#define IO_BANK0_PROC1_INTF3_GPIO26_LEVEL_HIGH_Msk (0x200UL)        /*!< GPIO26_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTF3_GPIO26_LEVEL_LOW_Pos (8UL)             /*!< GPIO26_LEVEL_LOW (Bit 8)                              */
#define IO_BANK0_PROC1_INTF3_GPIO26_LEVEL_LOW_Msk (0x100UL)         /*!< GPIO26_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF3_GPIO25_EDGE_HIGH_Pos (7UL)             /*!< GPIO25_EDGE_HIGH (Bit 7)                              */
#define IO_BANK0_PROC1_INTF3_GPIO25_EDGE_HIGH_Msk (0x80UL)          /*!< GPIO25_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF3_GPIO25_EDGE_LOW_Pos (6UL)              /*!< GPIO25_EDGE_LOW (Bit 6)                               */
#define IO_BANK0_PROC1_INTF3_GPIO25_EDGE_LOW_Msk (0x40UL)           /*!< GPIO25_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF3_GPIO25_LEVEL_HIGH_Pos (5UL)            /*!< GPIO25_LEVEL_HIGH (Bit 5)                             */
#define IO_BANK0_PROC1_INTF3_GPIO25_LEVEL_HIGH_Msk (0x20UL)         /*!< GPIO25_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTF3_GPIO25_LEVEL_LOW_Pos (4UL)             /*!< GPIO25_LEVEL_LOW (Bit 4)                              */
#define IO_BANK0_PROC1_INTF3_GPIO25_LEVEL_LOW_Msk (0x10UL)          /*!< GPIO25_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF3_GPIO24_EDGE_HIGH_Pos (3UL)             /*!< GPIO24_EDGE_HIGH (Bit 3)                              */
#define IO_BANK0_PROC1_INTF3_GPIO24_EDGE_HIGH_Msk (0x8UL)           /*!< GPIO24_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTF3_GPIO24_EDGE_LOW_Pos (2UL)              /*!< GPIO24_EDGE_LOW (Bit 2)                               */
#define IO_BANK0_PROC1_INTF3_GPIO24_EDGE_LOW_Msk (0x4UL)            /*!< GPIO24_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTF3_GPIO24_LEVEL_HIGH_Pos (1UL)            /*!< GPIO24_LEVEL_HIGH (Bit 1)                             */
#define IO_BANK0_PROC1_INTF3_GPIO24_LEVEL_HIGH_Msk (0x2UL)          /*!< GPIO24_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTF3_GPIO24_LEVEL_LOW_Pos (0UL)             /*!< GPIO24_LEVEL_LOW (Bit 0)                              */
#define IO_BANK0_PROC1_INTF3_GPIO24_LEVEL_LOW_Msk (0x1UL)           /*!< GPIO24_LEVEL_LOW (Bitfield-Mask: 0x01)                */
/* ======================================================  PROC1_INTS0  ====================================================== */
#define IO_BANK0_PROC1_INTS0_GPIO7_EDGE_HIGH_Pos (31UL)             /*!< GPIO7_EDGE_HIGH (Bit 31)                              */
#define IO_BANK0_PROC1_INTS0_GPIO7_EDGE_HIGH_Msk (0x80000000UL)     /*!< GPIO7_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS0_GPIO7_EDGE_LOW_Pos (30UL)              /*!< GPIO7_EDGE_LOW (Bit 30)                               */
#define IO_BANK0_PROC1_INTS0_GPIO7_EDGE_LOW_Msk (0x40000000UL)      /*!< GPIO7_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC1_INTS0_GPIO7_LEVEL_HIGH_Pos (29UL)            /*!< GPIO7_LEVEL_HIGH (Bit 29)                             */
#define IO_BANK0_PROC1_INTS0_GPIO7_LEVEL_HIGH_Msk (0x20000000UL)    /*!< GPIO7_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS0_GPIO7_LEVEL_LOW_Pos (28UL)             /*!< GPIO7_LEVEL_LOW (Bit 28)                              */
#define IO_BANK0_PROC1_INTS0_GPIO7_LEVEL_LOW_Msk (0x10000000UL)     /*!< GPIO7_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS0_GPIO6_EDGE_HIGH_Pos (27UL)             /*!< GPIO6_EDGE_HIGH (Bit 27)                              */
#define IO_BANK0_PROC1_INTS0_GPIO6_EDGE_HIGH_Msk (0x8000000UL)      /*!< GPIO6_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS0_GPIO6_EDGE_LOW_Pos (26UL)              /*!< GPIO6_EDGE_LOW (Bit 26)                               */
#define IO_BANK0_PROC1_INTS0_GPIO6_EDGE_LOW_Msk (0x4000000UL)       /*!< GPIO6_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC1_INTS0_GPIO6_LEVEL_HIGH_Pos (25UL)            /*!< GPIO6_LEVEL_HIGH (Bit 25)                             */
#define IO_BANK0_PROC1_INTS0_GPIO6_LEVEL_HIGH_Msk (0x2000000UL)     /*!< GPIO6_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS0_GPIO6_LEVEL_LOW_Pos (24UL)             /*!< GPIO6_LEVEL_LOW (Bit 24)                              */
#define IO_BANK0_PROC1_INTS0_GPIO6_LEVEL_LOW_Msk (0x1000000UL)      /*!< GPIO6_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS0_GPIO5_EDGE_HIGH_Pos (23UL)             /*!< GPIO5_EDGE_HIGH (Bit 23)                              */
#define IO_BANK0_PROC1_INTS0_GPIO5_EDGE_HIGH_Msk (0x800000UL)       /*!< GPIO5_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS0_GPIO5_EDGE_LOW_Pos (22UL)              /*!< GPIO5_EDGE_LOW (Bit 22)                               */
#define IO_BANK0_PROC1_INTS0_GPIO5_EDGE_LOW_Msk (0x400000UL)        /*!< GPIO5_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC1_INTS0_GPIO5_LEVEL_HIGH_Pos (21UL)            /*!< GPIO5_LEVEL_HIGH (Bit 21)                             */
#define IO_BANK0_PROC1_INTS0_GPIO5_LEVEL_HIGH_Msk (0x200000UL)      /*!< GPIO5_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS0_GPIO5_LEVEL_LOW_Pos (20UL)             /*!< GPIO5_LEVEL_LOW (Bit 20)                              */
#define IO_BANK0_PROC1_INTS0_GPIO5_LEVEL_LOW_Msk (0x100000UL)       /*!< GPIO5_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS0_GPIO4_EDGE_HIGH_Pos (19UL)             /*!< GPIO4_EDGE_HIGH (Bit 19)                              */
#define IO_BANK0_PROC1_INTS0_GPIO4_EDGE_HIGH_Msk (0x80000UL)        /*!< GPIO4_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS0_GPIO4_EDGE_LOW_Pos (18UL)              /*!< GPIO4_EDGE_LOW (Bit 18)                               */
#define IO_BANK0_PROC1_INTS0_GPIO4_EDGE_LOW_Msk (0x40000UL)         /*!< GPIO4_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC1_INTS0_GPIO4_LEVEL_HIGH_Pos (17UL)            /*!< GPIO4_LEVEL_HIGH (Bit 17)                             */
#define IO_BANK0_PROC1_INTS0_GPIO4_LEVEL_HIGH_Msk (0x20000UL)       /*!< GPIO4_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS0_GPIO4_LEVEL_LOW_Pos (16UL)             /*!< GPIO4_LEVEL_LOW (Bit 16)                              */
#define IO_BANK0_PROC1_INTS0_GPIO4_LEVEL_LOW_Msk (0x10000UL)        /*!< GPIO4_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS0_GPIO3_EDGE_HIGH_Pos (15UL)             /*!< GPIO3_EDGE_HIGH (Bit 15)                              */
#define IO_BANK0_PROC1_INTS0_GPIO3_EDGE_HIGH_Msk (0x8000UL)         /*!< GPIO3_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS0_GPIO3_EDGE_LOW_Pos (14UL)              /*!< GPIO3_EDGE_LOW (Bit 14)                               */
#define IO_BANK0_PROC1_INTS0_GPIO3_EDGE_LOW_Msk (0x4000UL)          /*!< GPIO3_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC1_INTS0_GPIO3_LEVEL_HIGH_Pos (13UL)            /*!< GPIO3_LEVEL_HIGH (Bit 13)                             */
#define IO_BANK0_PROC1_INTS0_GPIO3_LEVEL_HIGH_Msk (0x2000UL)        /*!< GPIO3_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS0_GPIO3_LEVEL_LOW_Pos (12UL)             /*!< GPIO3_LEVEL_LOW (Bit 12)                              */
#define IO_BANK0_PROC1_INTS0_GPIO3_LEVEL_LOW_Msk (0x1000UL)         /*!< GPIO3_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS0_GPIO2_EDGE_HIGH_Pos (11UL)             /*!< GPIO2_EDGE_HIGH (Bit 11)                              */
#define IO_BANK0_PROC1_INTS0_GPIO2_EDGE_HIGH_Msk (0x800UL)          /*!< GPIO2_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS0_GPIO2_EDGE_LOW_Pos (10UL)              /*!< GPIO2_EDGE_LOW (Bit 10)                               */
#define IO_BANK0_PROC1_INTS0_GPIO2_EDGE_LOW_Msk (0x400UL)           /*!< GPIO2_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC1_INTS0_GPIO2_LEVEL_HIGH_Pos (9UL)             /*!< GPIO2_LEVEL_HIGH (Bit 9)                              */
#define IO_BANK0_PROC1_INTS0_GPIO2_LEVEL_HIGH_Msk (0x200UL)         /*!< GPIO2_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS0_GPIO2_LEVEL_LOW_Pos (8UL)              /*!< GPIO2_LEVEL_LOW (Bit 8)                               */
#define IO_BANK0_PROC1_INTS0_GPIO2_LEVEL_LOW_Msk (0x100UL)          /*!< GPIO2_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS0_GPIO1_EDGE_HIGH_Pos (7UL)              /*!< GPIO1_EDGE_HIGH (Bit 7)                               */
#define IO_BANK0_PROC1_INTS0_GPIO1_EDGE_HIGH_Msk (0x80UL)           /*!< GPIO1_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS0_GPIO1_EDGE_LOW_Pos (6UL)               /*!< GPIO1_EDGE_LOW (Bit 6)                                */
#define IO_BANK0_PROC1_INTS0_GPIO1_EDGE_LOW_Msk (0x40UL)            /*!< GPIO1_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC1_INTS0_GPIO1_LEVEL_HIGH_Pos (5UL)             /*!< GPIO1_LEVEL_HIGH (Bit 5)                              */
#define IO_BANK0_PROC1_INTS0_GPIO1_LEVEL_HIGH_Msk (0x20UL)          /*!< GPIO1_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS0_GPIO1_LEVEL_LOW_Pos (4UL)              /*!< GPIO1_LEVEL_LOW (Bit 4)                               */
#define IO_BANK0_PROC1_INTS0_GPIO1_LEVEL_LOW_Msk (0x10UL)           /*!< GPIO1_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS0_GPIO0_EDGE_HIGH_Pos (3UL)              /*!< GPIO0_EDGE_HIGH (Bit 3)                               */
#define IO_BANK0_PROC1_INTS0_GPIO0_EDGE_HIGH_Msk (0x8UL)            /*!< GPIO0_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS0_GPIO0_EDGE_LOW_Pos (2UL)               /*!< GPIO0_EDGE_LOW (Bit 2)                                */
#define IO_BANK0_PROC1_INTS0_GPIO0_EDGE_LOW_Msk (0x4UL)             /*!< GPIO0_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC1_INTS0_GPIO0_LEVEL_HIGH_Pos (1UL)             /*!< GPIO0_LEVEL_HIGH (Bit 1)                              */
#define IO_BANK0_PROC1_INTS0_GPIO0_LEVEL_HIGH_Msk (0x2UL)           /*!< GPIO0_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS0_GPIO0_LEVEL_LOW_Pos (0UL)              /*!< GPIO0_LEVEL_LOW (Bit 0)                               */
#define IO_BANK0_PROC1_INTS0_GPIO0_LEVEL_LOW_Msk (0x1UL)            /*!< GPIO0_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
/* ======================================================  PROC1_INTS1  ====================================================== */
#define IO_BANK0_PROC1_INTS1_GPIO15_EDGE_HIGH_Pos (31UL)            /*!< GPIO15_EDGE_HIGH (Bit 31)                             */
#define IO_BANK0_PROC1_INTS1_GPIO15_EDGE_HIGH_Msk (0x80000000UL)    /*!< GPIO15_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS1_GPIO15_EDGE_LOW_Pos (30UL)             /*!< GPIO15_EDGE_LOW (Bit 30)                              */
#define IO_BANK0_PROC1_INTS1_GPIO15_EDGE_LOW_Msk (0x40000000UL)     /*!< GPIO15_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS1_GPIO15_LEVEL_HIGH_Pos (29UL)           /*!< GPIO15_LEVEL_HIGH (Bit 29)                            */
#define IO_BANK0_PROC1_INTS1_GPIO15_LEVEL_HIGH_Msk (0x20000000UL)   /*!< GPIO15_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTS1_GPIO15_LEVEL_LOW_Pos (28UL)            /*!< GPIO15_LEVEL_LOW (Bit 28)                             */
#define IO_BANK0_PROC1_INTS1_GPIO15_LEVEL_LOW_Msk (0x10000000UL)    /*!< GPIO15_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS1_GPIO14_EDGE_HIGH_Pos (27UL)            /*!< GPIO14_EDGE_HIGH (Bit 27)                             */
#define IO_BANK0_PROC1_INTS1_GPIO14_EDGE_HIGH_Msk (0x8000000UL)     /*!< GPIO14_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS1_GPIO14_EDGE_LOW_Pos (26UL)             /*!< GPIO14_EDGE_LOW (Bit 26)                              */
#define IO_BANK0_PROC1_INTS1_GPIO14_EDGE_LOW_Msk (0x4000000UL)      /*!< GPIO14_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS1_GPIO14_LEVEL_HIGH_Pos (25UL)           /*!< GPIO14_LEVEL_HIGH (Bit 25)                            */
#define IO_BANK0_PROC1_INTS1_GPIO14_LEVEL_HIGH_Msk (0x2000000UL)    /*!< GPIO14_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTS1_GPIO14_LEVEL_LOW_Pos (24UL)            /*!< GPIO14_LEVEL_LOW (Bit 24)                             */
#define IO_BANK0_PROC1_INTS1_GPIO14_LEVEL_LOW_Msk (0x1000000UL)     /*!< GPIO14_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS1_GPIO13_EDGE_HIGH_Pos (23UL)            /*!< GPIO13_EDGE_HIGH (Bit 23)                             */
#define IO_BANK0_PROC1_INTS1_GPIO13_EDGE_HIGH_Msk (0x800000UL)      /*!< GPIO13_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS1_GPIO13_EDGE_LOW_Pos (22UL)             /*!< GPIO13_EDGE_LOW (Bit 22)                              */
#define IO_BANK0_PROC1_INTS1_GPIO13_EDGE_LOW_Msk (0x400000UL)       /*!< GPIO13_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS1_GPIO13_LEVEL_HIGH_Pos (21UL)           /*!< GPIO13_LEVEL_HIGH (Bit 21)                            */
#define IO_BANK0_PROC1_INTS1_GPIO13_LEVEL_HIGH_Msk (0x200000UL)     /*!< GPIO13_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTS1_GPIO13_LEVEL_LOW_Pos (20UL)            /*!< GPIO13_LEVEL_LOW (Bit 20)                             */
#define IO_BANK0_PROC1_INTS1_GPIO13_LEVEL_LOW_Msk (0x100000UL)      /*!< GPIO13_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS1_GPIO12_EDGE_HIGH_Pos (19UL)            /*!< GPIO12_EDGE_HIGH (Bit 19)                             */
#define IO_BANK0_PROC1_INTS1_GPIO12_EDGE_HIGH_Msk (0x80000UL)       /*!< GPIO12_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS1_GPIO12_EDGE_LOW_Pos (18UL)             /*!< GPIO12_EDGE_LOW (Bit 18)                              */
#define IO_BANK0_PROC1_INTS1_GPIO12_EDGE_LOW_Msk (0x40000UL)        /*!< GPIO12_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS1_GPIO12_LEVEL_HIGH_Pos (17UL)           /*!< GPIO12_LEVEL_HIGH (Bit 17)                            */
#define IO_BANK0_PROC1_INTS1_GPIO12_LEVEL_HIGH_Msk (0x20000UL)      /*!< GPIO12_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTS1_GPIO12_LEVEL_LOW_Pos (16UL)            /*!< GPIO12_LEVEL_LOW (Bit 16)                             */
#define IO_BANK0_PROC1_INTS1_GPIO12_LEVEL_LOW_Msk (0x10000UL)       /*!< GPIO12_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS1_GPIO11_EDGE_HIGH_Pos (15UL)            /*!< GPIO11_EDGE_HIGH (Bit 15)                             */
#define IO_BANK0_PROC1_INTS1_GPIO11_EDGE_HIGH_Msk (0x8000UL)        /*!< GPIO11_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS1_GPIO11_EDGE_LOW_Pos (14UL)             /*!< GPIO11_EDGE_LOW (Bit 14)                              */
#define IO_BANK0_PROC1_INTS1_GPIO11_EDGE_LOW_Msk (0x4000UL)         /*!< GPIO11_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS1_GPIO11_LEVEL_HIGH_Pos (13UL)           /*!< GPIO11_LEVEL_HIGH (Bit 13)                            */
#define IO_BANK0_PROC1_INTS1_GPIO11_LEVEL_HIGH_Msk (0x2000UL)       /*!< GPIO11_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTS1_GPIO11_LEVEL_LOW_Pos (12UL)            /*!< GPIO11_LEVEL_LOW (Bit 12)                             */
#define IO_BANK0_PROC1_INTS1_GPIO11_LEVEL_LOW_Msk (0x1000UL)        /*!< GPIO11_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS1_GPIO10_EDGE_HIGH_Pos (11UL)            /*!< GPIO10_EDGE_HIGH (Bit 11)                             */
#define IO_BANK0_PROC1_INTS1_GPIO10_EDGE_HIGH_Msk (0x800UL)         /*!< GPIO10_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS1_GPIO10_EDGE_LOW_Pos (10UL)             /*!< GPIO10_EDGE_LOW (Bit 10)                              */
#define IO_BANK0_PROC1_INTS1_GPIO10_EDGE_LOW_Msk (0x400UL)          /*!< GPIO10_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS1_GPIO10_LEVEL_HIGH_Pos (9UL)            /*!< GPIO10_LEVEL_HIGH (Bit 9)                             */
#define IO_BANK0_PROC1_INTS1_GPIO10_LEVEL_HIGH_Msk (0x200UL)        /*!< GPIO10_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTS1_GPIO10_LEVEL_LOW_Pos (8UL)             /*!< GPIO10_LEVEL_LOW (Bit 8)                              */
#define IO_BANK0_PROC1_INTS1_GPIO10_LEVEL_LOW_Msk (0x100UL)         /*!< GPIO10_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS1_GPIO9_EDGE_HIGH_Pos (7UL)              /*!< GPIO9_EDGE_HIGH (Bit 7)                               */
#define IO_BANK0_PROC1_INTS1_GPIO9_EDGE_HIGH_Msk (0x80UL)           /*!< GPIO9_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS1_GPIO9_EDGE_LOW_Pos (6UL)               /*!< GPIO9_EDGE_LOW (Bit 6)                                */
#define IO_BANK0_PROC1_INTS1_GPIO9_EDGE_LOW_Msk (0x40UL)            /*!< GPIO9_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC1_INTS1_GPIO9_LEVEL_HIGH_Pos (5UL)             /*!< GPIO9_LEVEL_HIGH (Bit 5)                              */
#define IO_BANK0_PROC1_INTS1_GPIO9_LEVEL_HIGH_Msk (0x20UL)          /*!< GPIO9_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS1_GPIO9_LEVEL_LOW_Pos (4UL)              /*!< GPIO9_LEVEL_LOW (Bit 4)                               */
#define IO_BANK0_PROC1_INTS1_GPIO9_LEVEL_LOW_Msk (0x10UL)           /*!< GPIO9_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS1_GPIO8_EDGE_HIGH_Pos (3UL)              /*!< GPIO8_EDGE_HIGH (Bit 3)                               */
#define IO_BANK0_PROC1_INTS1_GPIO8_EDGE_HIGH_Msk (0x8UL)            /*!< GPIO8_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS1_GPIO8_EDGE_LOW_Pos (2UL)               /*!< GPIO8_EDGE_LOW (Bit 2)                                */
#define IO_BANK0_PROC1_INTS1_GPIO8_EDGE_LOW_Msk (0x4UL)             /*!< GPIO8_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_PROC1_INTS1_GPIO8_LEVEL_HIGH_Pos (1UL)             /*!< GPIO8_LEVEL_HIGH (Bit 1)                              */
#define IO_BANK0_PROC1_INTS1_GPIO8_LEVEL_HIGH_Msk (0x2UL)           /*!< GPIO8_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS1_GPIO8_LEVEL_LOW_Pos (0UL)              /*!< GPIO8_LEVEL_LOW (Bit 0)                               */
#define IO_BANK0_PROC1_INTS1_GPIO8_LEVEL_LOW_Msk (0x1UL)            /*!< GPIO8_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
/* ======================================================  PROC1_INTS2  ====================================================== */
#define IO_BANK0_PROC1_INTS2_GPIO23_EDGE_HIGH_Pos (31UL)            /*!< GPIO23_EDGE_HIGH (Bit 31)                             */
#define IO_BANK0_PROC1_INTS2_GPIO23_EDGE_HIGH_Msk (0x80000000UL)    /*!< GPIO23_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS2_GPIO23_EDGE_LOW_Pos (30UL)             /*!< GPIO23_EDGE_LOW (Bit 30)                              */
#define IO_BANK0_PROC1_INTS2_GPIO23_EDGE_LOW_Msk (0x40000000UL)     /*!< GPIO23_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS2_GPIO23_LEVEL_HIGH_Pos (29UL)           /*!< GPIO23_LEVEL_HIGH (Bit 29)                            */
#define IO_BANK0_PROC1_INTS2_GPIO23_LEVEL_HIGH_Msk (0x20000000UL)   /*!< GPIO23_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTS2_GPIO23_LEVEL_LOW_Pos (28UL)            /*!< GPIO23_LEVEL_LOW (Bit 28)                             */
#define IO_BANK0_PROC1_INTS2_GPIO23_LEVEL_LOW_Msk (0x10000000UL)    /*!< GPIO23_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS2_GPIO22_EDGE_HIGH_Pos (27UL)            /*!< GPIO22_EDGE_HIGH (Bit 27)                             */
#define IO_BANK0_PROC1_INTS2_GPIO22_EDGE_HIGH_Msk (0x8000000UL)     /*!< GPIO22_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS2_GPIO22_EDGE_LOW_Pos (26UL)             /*!< GPIO22_EDGE_LOW (Bit 26)                              */
#define IO_BANK0_PROC1_INTS2_GPIO22_EDGE_LOW_Msk (0x4000000UL)      /*!< GPIO22_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS2_GPIO22_LEVEL_HIGH_Pos (25UL)           /*!< GPIO22_LEVEL_HIGH (Bit 25)                            */
#define IO_BANK0_PROC1_INTS2_GPIO22_LEVEL_HIGH_Msk (0x2000000UL)    /*!< GPIO22_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTS2_GPIO22_LEVEL_LOW_Pos (24UL)            /*!< GPIO22_LEVEL_LOW (Bit 24)                             */
#define IO_BANK0_PROC1_INTS2_GPIO22_LEVEL_LOW_Msk (0x1000000UL)     /*!< GPIO22_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS2_GPIO21_EDGE_HIGH_Pos (23UL)            /*!< GPIO21_EDGE_HIGH (Bit 23)                             */
#define IO_BANK0_PROC1_INTS2_GPIO21_EDGE_HIGH_Msk (0x800000UL)      /*!< GPIO21_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS2_GPIO21_EDGE_LOW_Pos (22UL)             /*!< GPIO21_EDGE_LOW (Bit 22)                              */
#define IO_BANK0_PROC1_INTS2_GPIO21_EDGE_LOW_Msk (0x400000UL)       /*!< GPIO21_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS2_GPIO21_LEVEL_HIGH_Pos (21UL)           /*!< GPIO21_LEVEL_HIGH (Bit 21)                            */
#define IO_BANK0_PROC1_INTS2_GPIO21_LEVEL_HIGH_Msk (0x200000UL)     /*!< GPIO21_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTS2_GPIO21_LEVEL_LOW_Pos (20UL)            /*!< GPIO21_LEVEL_LOW (Bit 20)                             */
#define IO_BANK0_PROC1_INTS2_GPIO21_LEVEL_LOW_Msk (0x100000UL)      /*!< GPIO21_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS2_GPIO20_EDGE_HIGH_Pos (19UL)            /*!< GPIO20_EDGE_HIGH (Bit 19)                             */
#define IO_BANK0_PROC1_INTS2_GPIO20_EDGE_HIGH_Msk (0x80000UL)       /*!< GPIO20_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS2_GPIO20_EDGE_LOW_Pos (18UL)             /*!< GPIO20_EDGE_LOW (Bit 18)                              */
#define IO_BANK0_PROC1_INTS2_GPIO20_EDGE_LOW_Msk (0x40000UL)        /*!< GPIO20_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS2_GPIO20_LEVEL_HIGH_Pos (17UL)           /*!< GPIO20_LEVEL_HIGH (Bit 17)                            */
#define IO_BANK0_PROC1_INTS2_GPIO20_LEVEL_HIGH_Msk (0x20000UL)      /*!< GPIO20_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTS2_GPIO20_LEVEL_LOW_Pos (16UL)            /*!< GPIO20_LEVEL_LOW (Bit 16)                             */
#define IO_BANK0_PROC1_INTS2_GPIO20_LEVEL_LOW_Msk (0x10000UL)       /*!< GPIO20_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS2_GPIO19_EDGE_HIGH_Pos (15UL)            /*!< GPIO19_EDGE_HIGH (Bit 15)                             */
#define IO_BANK0_PROC1_INTS2_GPIO19_EDGE_HIGH_Msk (0x8000UL)        /*!< GPIO19_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS2_GPIO19_EDGE_LOW_Pos (14UL)             /*!< GPIO19_EDGE_LOW (Bit 14)                              */
#define IO_BANK0_PROC1_INTS2_GPIO19_EDGE_LOW_Msk (0x4000UL)         /*!< GPIO19_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS2_GPIO19_LEVEL_HIGH_Pos (13UL)           /*!< GPIO19_LEVEL_HIGH (Bit 13)                            */
#define IO_BANK0_PROC1_INTS2_GPIO19_LEVEL_HIGH_Msk (0x2000UL)       /*!< GPIO19_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTS2_GPIO19_LEVEL_LOW_Pos (12UL)            /*!< GPIO19_LEVEL_LOW (Bit 12)                             */
#define IO_BANK0_PROC1_INTS2_GPIO19_LEVEL_LOW_Msk (0x1000UL)        /*!< GPIO19_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS2_GPIO18_EDGE_HIGH_Pos (11UL)            /*!< GPIO18_EDGE_HIGH (Bit 11)                             */
#define IO_BANK0_PROC1_INTS2_GPIO18_EDGE_HIGH_Msk (0x800UL)         /*!< GPIO18_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS2_GPIO18_EDGE_LOW_Pos (10UL)             /*!< GPIO18_EDGE_LOW (Bit 10)                              */
#define IO_BANK0_PROC1_INTS2_GPIO18_EDGE_LOW_Msk (0x400UL)          /*!< GPIO18_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS2_GPIO18_LEVEL_HIGH_Pos (9UL)            /*!< GPIO18_LEVEL_HIGH (Bit 9)                             */
#define IO_BANK0_PROC1_INTS2_GPIO18_LEVEL_HIGH_Msk (0x200UL)        /*!< GPIO18_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTS2_GPIO18_LEVEL_LOW_Pos (8UL)             /*!< GPIO18_LEVEL_LOW (Bit 8)                              */
#define IO_BANK0_PROC1_INTS2_GPIO18_LEVEL_LOW_Msk (0x100UL)         /*!< GPIO18_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS2_GPIO17_EDGE_HIGH_Pos (7UL)             /*!< GPIO17_EDGE_HIGH (Bit 7)                              */
#define IO_BANK0_PROC1_INTS2_GPIO17_EDGE_HIGH_Msk (0x80UL)          /*!< GPIO17_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS2_GPIO17_EDGE_LOW_Pos (6UL)              /*!< GPIO17_EDGE_LOW (Bit 6)                               */
#define IO_BANK0_PROC1_INTS2_GPIO17_EDGE_LOW_Msk (0x40UL)           /*!< GPIO17_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS2_GPIO17_LEVEL_HIGH_Pos (5UL)            /*!< GPIO17_LEVEL_HIGH (Bit 5)                             */
#define IO_BANK0_PROC1_INTS2_GPIO17_LEVEL_HIGH_Msk (0x20UL)         /*!< GPIO17_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTS2_GPIO17_LEVEL_LOW_Pos (4UL)             /*!< GPIO17_LEVEL_LOW (Bit 4)                              */
#define IO_BANK0_PROC1_INTS2_GPIO17_LEVEL_LOW_Msk (0x10UL)          /*!< GPIO17_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS2_GPIO16_EDGE_HIGH_Pos (3UL)             /*!< GPIO16_EDGE_HIGH (Bit 3)                              */
#define IO_BANK0_PROC1_INTS2_GPIO16_EDGE_HIGH_Msk (0x8UL)           /*!< GPIO16_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS2_GPIO16_EDGE_LOW_Pos (2UL)              /*!< GPIO16_EDGE_LOW (Bit 2)                               */
#define IO_BANK0_PROC1_INTS2_GPIO16_EDGE_LOW_Msk (0x4UL)            /*!< GPIO16_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS2_GPIO16_LEVEL_HIGH_Pos (1UL)            /*!< GPIO16_LEVEL_HIGH (Bit 1)                             */
#define IO_BANK0_PROC1_INTS2_GPIO16_LEVEL_HIGH_Msk (0x2UL)          /*!< GPIO16_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTS2_GPIO16_LEVEL_LOW_Pos (0UL)             /*!< GPIO16_LEVEL_LOW (Bit 0)                              */
#define IO_BANK0_PROC1_INTS2_GPIO16_LEVEL_LOW_Msk (0x1UL)           /*!< GPIO16_LEVEL_LOW (Bitfield-Mask: 0x01)                */
/* ======================================================  PROC1_INTS3  ====================================================== */
#define IO_BANK0_PROC1_INTS3_GPIO29_EDGE_HIGH_Pos (23UL)            /*!< GPIO29_EDGE_HIGH (Bit 23)                             */
#define IO_BANK0_PROC1_INTS3_GPIO29_EDGE_HIGH_Msk (0x800000UL)      /*!< GPIO29_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS3_GPIO29_EDGE_LOW_Pos (22UL)             /*!< GPIO29_EDGE_LOW (Bit 22)                              */
#define IO_BANK0_PROC1_INTS3_GPIO29_EDGE_LOW_Msk (0x400000UL)       /*!< GPIO29_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS3_GPIO29_LEVEL_HIGH_Pos (21UL)           /*!< GPIO29_LEVEL_HIGH (Bit 21)                            */
#define IO_BANK0_PROC1_INTS3_GPIO29_LEVEL_HIGH_Msk (0x200000UL)     /*!< GPIO29_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTS3_GPIO29_LEVEL_LOW_Pos (20UL)            /*!< GPIO29_LEVEL_LOW (Bit 20)                             */
#define IO_BANK0_PROC1_INTS3_GPIO29_LEVEL_LOW_Msk (0x100000UL)      /*!< GPIO29_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS3_GPIO28_EDGE_HIGH_Pos (19UL)            /*!< GPIO28_EDGE_HIGH (Bit 19)                             */
#define IO_BANK0_PROC1_INTS3_GPIO28_EDGE_HIGH_Msk (0x80000UL)       /*!< GPIO28_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS3_GPIO28_EDGE_LOW_Pos (18UL)             /*!< GPIO28_EDGE_LOW (Bit 18)                              */
#define IO_BANK0_PROC1_INTS3_GPIO28_EDGE_LOW_Msk (0x40000UL)        /*!< GPIO28_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS3_GPIO28_LEVEL_HIGH_Pos (17UL)           /*!< GPIO28_LEVEL_HIGH (Bit 17)                            */
#define IO_BANK0_PROC1_INTS3_GPIO28_LEVEL_HIGH_Msk (0x20000UL)      /*!< GPIO28_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTS3_GPIO28_LEVEL_LOW_Pos (16UL)            /*!< GPIO28_LEVEL_LOW (Bit 16)                             */
#define IO_BANK0_PROC1_INTS3_GPIO28_LEVEL_LOW_Msk (0x10000UL)       /*!< GPIO28_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS3_GPIO27_EDGE_HIGH_Pos (15UL)            /*!< GPIO27_EDGE_HIGH (Bit 15)                             */
#define IO_BANK0_PROC1_INTS3_GPIO27_EDGE_HIGH_Msk (0x8000UL)        /*!< GPIO27_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS3_GPIO27_EDGE_LOW_Pos (14UL)             /*!< GPIO27_EDGE_LOW (Bit 14)                              */
#define IO_BANK0_PROC1_INTS3_GPIO27_EDGE_LOW_Msk (0x4000UL)         /*!< GPIO27_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS3_GPIO27_LEVEL_HIGH_Pos (13UL)           /*!< GPIO27_LEVEL_HIGH (Bit 13)                            */
#define IO_BANK0_PROC1_INTS3_GPIO27_LEVEL_HIGH_Msk (0x2000UL)       /*!< GPIO27_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTS3_GPIO27_LEVEL_LOW_Pos (12UL)            /*!< GPIO27_LEVEL_LOW (Bit 12)                             */
#define IO_BANK0_PROC1_INTS3_GPIO27_LEVEL_LOW_Msk (0x1000UL)        /*!< GPIO27_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS3_GPIO26_EDGE_HIGH_Pos (11UL)            /*!< GPIO26_EDGE_HIGH (Bit 11)                             */
#define IO_BANK0_PROC1_INTS3_GPIO26_EDGE_HIGH_Msk (0x800UL)         /*!< GPIO26_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS3_GPIO26_EDGE_LOW_Pos (10UL)             /*!< GPIO26_EDGE_LOW (Bit 10)                              */
#define IO_BANK0_PROC1_INTS3_GPIO26_EDGE_LOW_Msk (0x400UL)          /*!< GPIO26_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS3_GPIO26_LEVEL_HIGH_Pos (9UL)            /*!< GPIO26_LEVEL_HIGH (Bit 9)                             */
#define IO_BANK0_PROC1_INTS3_GPIO26_LEVEL_HIGH_Msk (0x200UL)        /*!< GPIO26_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTS3_GPIO26_LEVEL_LOW_Pos (8UL)             /*!< GPIO26_LEVEL_LOW (Bit 8)                              */
#define IO_BANK0_PROC1_INTS3_GPIO26_LEVEL_LOW_Msk (0x100UL)         /*!< GPIO26_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS3_GPIO25_EDGE_HIGH_Pos (7UL)             /*!< GPIO25_EDGE_HIGH (Bit 7)                              */
#define IO_BANK0_PROC1_INTS3_GPIO25_EDGE_HIGH_Msk (0x80UL)          /*!< GPIO25_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS3_GPIO25_EDGE_LOW_Pos (6UL)              /*!< GPIO25_EDGE_LOW (Bit 6)                               */
#define IO_BANK0_PROC1_INTS3_GPIO25_EDGE_LOW_Msk (0x40UL)           /*!< GPIO25_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS3_GPIO25_LEVEL_HIGH_Pos (5UL)            /*!< GPIO25_LEVEL_HIGH (Bit 5)                             */
#define IO_BANK0_PROC1_INTS3_GPIO25_LEVEL_HIGH_Msk (0x20UL)         /*!< GPIO25_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTS3_GPIO25_LEVEL_LOW_Pos (4UL)             /*!< GPIO25_LEVEL_LOW (Bit 4)                              */
#define IO_BANK0_PROC1_INTS3_GPIO25_LEVEL_LOW_Msk (0x10UL)          /*!< GPIO25_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS3_GPIO24_EDGE_HIGH_Pos (3UL)             /*!< GPIO24_EDGE_HIGH (Bit 3)                              */
#define IO_BANK0_PROC1_INTS3_GPIO24_EDGE_HIGH_Msk (0x8UL)           /*!< GPIO24_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_PROC1_INTS3_GPIO24_EDGE_LOW_Pos (2UL)              /*!< GPIO24_EDGE_LOW (Bit 2)                               */
#define IO_BANK0_PROC1_INTS3_GPIO24_EDGE_LOW_Msk (0x4UL)            /*!< GPIO24_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_PROC1_INTS3_GPIO24_LEVEL_HIGH_Pos (1UL)            /*!< GPIO24_LEVEL_HIGH (Bit 1)                             */
#define IO_BANK0_PROC1_INTS3_GPIO24_LEVEL_HIGH_Msk (0x2UL)          /*!< GPIO24_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_PROC1_INTS3_GPIO24_LEVEL_LOW_Pos (0UL)             /*!< GPIO24_LEVEL_LOW (Bit 0)                              */
#define IO_BANK0_PROC1_INTS3_GPIO24_LEVEL_LOW_Msk (0x1UL)           /*!< GPIO24_LEVEL_LOW (Bitfield-Mask: 0x01)                */
/* ==================================================  DORMANT_WAKE_INTE0  =================================================== */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_EDGE_HIGH_Pos (31UL)      /*!< GPIO7_EDGE_HIGH (Bit 31)                              */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_EDGE_HIGH_Msk (0x80000000UL) /*!< GPIO7_EDGE_HIGH (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_EDGE_LOW_Pos (30UL)       /*!< GPIO7_EDGE_LOW (Bit 30)                               */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_EDGE_LOW_Msk (0x40000000UL) /*!< GPIO7_EDGE_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_LEVEL_HIGH_Pos (29UL)     /*!< GPIO7_LEVEL_HIGH (Bit 29)                             */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_LEVEL_HIGH_Msk (0x20000000UL) /*!< GPIO7_LEVEL_HIGH (Bitfield-Mask: 0x01)            */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_LEVEL_LOW_Pos (28UL)      /*!< GPIO7_LEVEL_LOW (Bit 28)                              */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO7_LEVEL_LOW_Msk (0x10000000UL) /*!< GPIO7_LEVEL_LOW (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_EDGE_HIGH_Pos (27UL)      /*!< GPIO6_EDGE_HIGH (Bit 27)                              */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_EDGE_HIGH_Msk (0x8000000UL) /*!< GPIO6_EDGE_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_EDGE_LOW_Pos (26UL)       /*!< GPIO6_EDGE_LOW (Bit 26)                               */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_EDGE_LOW_Msk (0x4000000UL) /*!< GPIO6_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_LEVEL_HIGH_Pos (25UL)     /*!< GPIO6_LEVEL_HIGH (Bit 25)                             */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_LEVEL_HIGH_Msk (0x2000000UL) /*!< GPIO6_LEVEL_HIGH (Bitfield-Mask: 0x01)             */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_LEVEL_LOW_Pos (24UL)      /*!< GPIO6_LEVEL_LOW (Bit 24)                              */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO6_LEVEL_LOW_Msk (0x1000000UL) /*!< GPIO6_LEVEL_LOW (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_EDGE_HIGH_Pos (23UL)      /*!< GPIO5_EDGE_HIGH (Bit 23)                              */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO5_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_EDGE_LOW_Pos (22UL)       /*!< GPIO5_EDGE_LOW (Bit 22)                               */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_EDGE_LOW_Msk (0x400000UL) /*!< GPIO5_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_LEVEL_HIGH_Pos (21UL)     /*!< GPIO5_LEVEL_HIGH (Bit 21)                             */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO5_LEVEL_HIGH (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_LEVEL_LOW_Pos (20UL)      /*!< GPIO5_LEVEL_LOW (Bit 20)                              */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO5_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO5_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_EDGE_HIGH_Pos (19UL)      /*!< GPIO4_EDGE_HIGH (Bit 19)                              */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_EDGE_HIGH_Msk (0x80000UL) /*!< GPIO4_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_EDGE_LOW_Pos (18UL)       /*!< GPIO4_EDGE_LOW (Bit 18)                               */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_EDGE_LOW_Msk (0x40000UL)  /*!< GPIO4_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_LEVEL_HIGH_Pos (17UL)     /*!< GPIO4_LEVEL_HIGH (Bit 17)                             */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO4_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_LEVEL_LOW_Pos (16UL)      /*!< GPIO4_LEVEL_LOW (Bit 16)                              */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO4_LEVEL_LOW_Msk (0x10000UL) /*!< GPIO4_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_EDGE_HIGH_Pos (15UL)      /*!< GPIO3_EDGE_HIGH (Bit 15)                              */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_EDGE_HIGH_Msk (0x8000UL)  /*!< GPIO3_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_EDGE_LOW_Pos (14UL)       /*!< GPIO3_EDGE_LOW (Bit 14)                               */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_EDGE_LOW_Msk (0x4000UL)   /*!< GPIO3_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_LEVEL_HIGH_Pos (13UL)     /*!< GPIO3_LEVEL_HIGH (Bit 13)                             */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_LEVEL_HIGH_Msk (0x2000UL) /*!< GPIO3_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_LEVEL_LOW_Pos (12UL)      /*!< GPIO3_LEVEL_LOW (Bit 12)                              */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO3_LEVEL_LOW_Msk (0x1000UL)  /*!< GPIO3_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_EDGE_HIGH_Pos (11UL)      /*!< GPIO2_EDGE_HIGH (Bit 11)                              */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_EDGE_HIGH_Msk (0x800UL)   /*!< GPIO2_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_EDGE_LOW_Pos (10UL)       /*!< GPIO2_EDGE_LOW (Bit 10)                               */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_EDGE_LOW_Msk (0x400UL)    /*!< GPIO2_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_LEVEL_HIGH_Pos (9UL)      /*!< GPIO2_LEVEL_HIGH (Bit 9)                              */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_LEVEL_HIGH_Msk (0x200UL)  /*!< GPIO2_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_LEVEL_LOW_Pos (8UL)       /*!< GPIO2_LEVEL_LOW (Bit 8)                               */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO2_LEVEL_LOW_Msk (0x100UL)   /*!< GPIO2_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_EDGE_HIGH_Pos (7UL)       /*!< GPIO1_EDGE_HIGH (Bit 7)                               */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_EDGE_HIGH_Msk (0x80UL)    /*!< GPIO1_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_EDGE_LOW_Pos (6UL)        /*!< GPIO1_EDGE_LOW (Bit 6)                                */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_EDGE_LOW_Msk (0x40UL)     /*!< GPIO1_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_LEVEL_HIGH_Pos (5UL)      /*!< GPIO1_LEVEL_HIGH (Bit 5)                              */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_LEVEL_HIGH_Msk (0x20UL)   /*!< GPIO1_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_LEVEL_LOW_Pos (4UL)       /*!< GPIO1_LEVEL_LOW (Bit 4)                               */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO1_LEVEL_LOW_Msk (0x10UL)    /*!< GPIO1_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_EDGE_HIGH_Pos (3UL)       /*!< GPIO0_EDGE_HIGH (Bit 3)                               */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_EDGE_HIGH_Msk (0x8UL)     /*!< GPIO0_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_EDGE_LOW_Pos (2UL)        /*!< GPIO0_EDGE_LOW (Bit 2)                                */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_EDGE_LOW_Msk (0x4UL)      /*!< GPIO0_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_LEVEL_HIGH_Pos (1UL)      /*!< GPIO0_LEVEL_HIGH (Bit 1)                              */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_LEVEL_HIGH_Msk (0x2UL)    /*!< GPIO0_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_LEVEL_LOW_Pos (0UL)       /*!< GPIO0_LEVEL_LOW (Bit 0)                               */
#define IO_BANK0_DORMANT_WAKE_INTE0_GPIO0_LEVEL_LOW_Msk (0x1UL)     /*!< GPIO0_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
/* ==================================================  DORMANT_WAKE_INTE1  =================================================== */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_EDGE_HIGH_Pos (31UL)     /*!< GPIO15_EDGE_HIGH (Bit 31)                             */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_EDGE_HIGH_Msk (0x80000000UL) /*!< GPIO15_EDGE_HIGH (Bitfield-Mask: 0x01)            */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_EDGE_LOW_Pos (30UL)      /*!< GPIO15_EDGE_LOW (Bit 30)                              */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_EDGE_LOW_Msk (0x40000000UL) /*!< GPIO15_EDGE_LOW (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_LEVEL_HIGH_Pos (29UL)    /*!< GPIO15_LEVEL_HIGH (Bit 29)                            */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_LEVEL_HIGH_Msk (0x20000000UL) /*!< GPIO15_LEVEL_HIGH (Bitfield-Mask: 0x01)          */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_LEVEL_LOW_Pos (28UL)     /*!< GPIO15_LEVEL_LOW (Bit 28)                             */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO15_LEVEL_LOW_Msk (0x10000000UL) /*!< GPIO15_LEVEL_LOW (Bitfield-Mask: 0x01)            */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_EDGE_HIGH_Pos (27UL)     /*!< GPIO14_EDGE_HIGH (Bit 27)                             */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_EDGE_HIGH_Msk (0x8000000UL) /*!< GPIO14_EDGE_HIGH (Bitfield-Mask: 0x01)             */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_EDGE_LOW_Pos (26UL)      /*!< GPIO14_EDGE_LOW (Bit 26)                              */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_EDGE_LOW_Msk (0x4000000UL) /*!< GPIO14_EDGE_LOW (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_LEVEL_HIGH_Pos (25UL)    /*!< GPIO14_LEVEL_HIGH (Bit 25)                            */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_LEVEL_HIGH_Msk (0x2000000UL) /*!< GPIO14_LEVEL_HIGH (Bitfield-Mask: 0x01)           */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_LEVEL_LOW_Pos (24UL)     /*!< GPIO14_LEVEL_LOW (Bit 24)                             */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO14_LEVEL_LOW_Msk (0x1000000UL) /*!< GPIO14_LEVEL_LOW (Bitfield-Mask: 0x01)             */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_EDGE_HIGH_Pos (23UL)     /*!< GPIO13_EDGE_HIGH (Bit 23)                             */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO13_EDGE_HIGH (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_EDGE_LOW_Pos (22UL)      /*!< GPIO13_EDGE_LOW (Bit 22)                              */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_EDGE_LOW_Msk (0x400000UL) /*!< GPIO13_EDGE_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_LEVEL_HIGH_Pos (21UL)    /*!< GPIO13_LEVEL_HIGH (Bit 21)                            */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO13_LEVEL_HIGH (Bitfield-Mask: 0x01)            */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_LEVEL_LOW_Pos (20UL)     /*!< GPIO13_LEVEL_LOW (Bit 20)                             */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO13_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO13_LEVEL_LOW (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_EDGE_HIGH_Pos (19UL)     /*!< GPIO12_EDGE_HIGH (Bit 19)                             */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_EDGE_HIGH_Msk (0x80000UL) /*!< GPIO12_EDGE_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_EDGE_LOW_Pos (18UL)      /*!< GPIO12_EDGE_LOW (Bit 18)                              */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_EDGE_LOW_Msk (0x40000UL) /*!< GPIO12_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_LEVEL_HIGH_Pos (17UL)    /*!< GPIO12_LEVEL_HIGH (Bit 17)                            */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO12_LEVEL_HIGH (Bitfield-Mask: 0x01)             */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_LEVEL_LOW_Pos (16UL)     /*!< GPIO12_LEVEL_LOW (Bit 16)                             */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO12_LEVEL_LOW_Msk (0x10000UL) /*!< GPIO12_LEVEL_LOW (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_EDGE_HIGH_Pos (15UL)     /*!< GPIO11_EDGE_HIGH (Bit 15)                             */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_EDGE_HIGH_Msk (0x8000UL) /*!< GPIO11_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_EDGE_LOW_Pos (14UL)      /*!< GPIO11_EDGE_LOW (Bit 14)                              */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_EDGE_LOW_Msk (0x4000UL)  /*!< GPIO11_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_LEVEL_HIGH_Pos (13UL)    /*!< GPIO11_LEVEL_HIGH (Bit 13)                            */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_LEVEL_HIGH_Msk (0x2000UL) /*!< GPIO11_LEVEL_HIGH (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_LEVEL_LOW_Pos (12UL)     /*!< GPIO11_LEVEL_LOW (Bit 12)                             */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO11_LEVEL_LOW_Msk (0x1000UL) /*!< GPIO11_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_EDGE_HIGH_Pos (11UL)     /*!< GPIO10_EDGE_HIGH (Bit 11)                             */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_EDGE_HIGH_Msk (0x800UL)  /*!< GPIO10_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_EDGE_LOW_Pos (10UL)      /*!< GPIO10_EDGE_LOW (Bit 10)                              */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_EDGE_LOW_Msk (0x400UL)   /*!< GPIO10_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_LEVEL_HIGH_Pos (9UL)     /*!< GPIO10_LEVEL_HIGH (Bit 9)                             */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_LEVEL_HIGH_Msk (0x200UL) /*!< GPIO10_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_LEVEL_LOW_Pos (8UL)      /*!< GPIO10_LEVEL_LOW (Bit 8)                              */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO10_LEVEL_LOW_Msk (0x100UL)  /*!< GPIO10_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_EDGE_HIGH_Pos (7UL)       /*!< GPIO9_EDGE_HIGH (Bit 7)                               */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_EDGE_HIGH_Msk (0x80UL)    /*!< GPIO9_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_EDGE_LOW_Pos (6UL)        /*!< GPIO9_EDGE_LOW (Bit 6)                                */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_EDGE_LOW_Msk (0x40UL)     /*!< GPIO9_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_LEVEL_HIGH_Pos (5UL)      /*!< GPIO9_LEVEL_HIGH (Bit 5)                              */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_LEVEL_HIGH_Msk (0x20UL)   /*!< GPIO9_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_LEVEL_LOW_Pos (4UL)       /*!< GPIO9_LEVEL_LOW (Bit 4)                               */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO9_LEVEL_LOW_Msk (0x10UL)    /*!< GPIO9_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_EDGE_HIGH_Pos (3UL)       /*!< GPIO8_EDGE_HIGH (Bit 3)                               */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_EDGE_HIGH_Msk (0x8UL)     /*!< GPIO8_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_EDGE_LOW_Pos (2UL)        /*!< GPIO8_EDGE_LOW (Bit 2)                                */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_EDGE_LOW_Msk (0x4UL)      /*!< GPIO8_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_LEVEL_HIGH_Pos (1UL)      /*!< GPIO8_LEVEL_HIGH (Bit 1)                              */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_LEVEL_HIGH_Msk (0x2UL)    /*!< GPIO8_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_LEVEL_LOW_Pos (0UL)       /*!< GPIO8_LEVEL_LOW (Bit 0)                               */
#define IO_BANK0_DORMANT_WAKE_INTE1_GPIO8_LEVEL_LOW_Msk (0x1UL)     /*!< GPIO8_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
/* ==================================================  DORMANT_WAKE_INTE2  =================================================== */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_EDGE_HIGH_Pos (31UL)     /*!< GPIO23_EDGE_HIGH (Bit 31)                             */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_EDGE_HIGH_Msk (0x80000000UL) /*!< GPIO23_EDGE_HIGH (Bitfield-Mask: 0x01)            */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_EDGE_LOW_Pos (30UL)      /*!< GPIO23_EDGE_LOW (Bit 30)                              */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_EDGE_LOW_Msk (0x40000000UL) /*!< GPIO23_EDGE_LOW (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_LEVEL_HIGH_Pos (29UL)    /*!< GPIO23_LEVEL_HIGH (Bit 29)                            */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_LEVEL_HIGH_Msk (0x20000000UL) /*!< GPIO23_LEVEL_HIGH (Bitfield-Mask: 0x01)          */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_LEVEL_LOW_Pos (28UL)     /*!< GPIO23_LEVEL_LOW (Bit 28)                             */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO23_LEVEL_LOW_Msk (0x10000000UL) /*!< GPIO23_LEVEL_LOW (Bitfield-Mask: 0x01)            */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_EDGE_HIGH_Pos (27UL)     /*!< GPIO22_EDGE_HIGH (Bit 27)                             */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_EDGE_HIGH_Msk (0x8000000UL) /*!< GPIO22_EDGE_HIGH (Bitfield-Mask: 0x01)             */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_EDGE_LOW_Pos (26UL)      /*!< GPIO22_EDGE_LOW (Bit 26)                              */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_EDGE_LOW_Msk (0x4000000UL) /*!< GPIO22_EDGE_LOW (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_LEVEL_HIGH_Pos (25UL)    /*!< GPIO22_LEVEL_HIGH (Bit 25)                            */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_LEVEL_HIGH_Msk (0x2000000UL) /*!< GPIO22_LEVEL_HIGH (Bitfield-Mask: 0x01)           */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_LEVEL_LOW_Pos (24UL)     /*!< GPIO22_LEVEL_LOW (Bit 24)                             */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO22_LEVEL_LOW_Msk (0x1000000UL) /*!< GPIO22_LEVEL_LOW (Bitfield-Mask: 0x01)             */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_EDGE_HIGH_Pos (23UL)     /*!< GPIO21_EDGE_HIGH (Bit 23)                             */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO21_EDGE_HIGH (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_EDGE_LOW_Pos (22UL)      /*!< GPIO21_EDGE_LOW (Bit 22)                              */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_EDGE_LOW_Msk (0x400000UL) /*!< GPIO21_EDGE_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_LEVEL_HIGH_Pos (21UL)    /*!< GPIO21_LEVEL_HIGH (Bit 21)                            */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO21_LEVEL_HIGH (Bitfield-Mask: 0x01)            */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_LEVEL_LOW_Pos (20UL)     /*!< GPIO21_LEVEL_LOW (Bit 20)                             */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO21_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO21_LEVEL_LOW (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_EDGE_HIGH_Pos (19UL)     /*!< GPIO20_EDGE_HIGH (Bit 19)                             */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_EDGE_HIGH_Msk (0x80000UL) /*!< GPIO20_EDGE_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_EDGE_LOW_Pos (18UL)      /*!< GPIO20_EDGE_LOW (Bit 18)                              */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_EDGE_LOW_Msk (0x40000UL) /*!< GPIO20_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_LEVEL_HIGH_Pos (17UL)    /*!< GPIO20_LEVEL_HIGH (Bit 17)                            */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO20_LEVEL_HIGH (Bitfield-Mask: 0x01)             */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_LEVEL_LOW_Pos (16UL)     /*!< GPIO20_LEVEL_LOW (Bit 16)                             */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO20_LEVEL_LOW_Msk (0x10000UL) /*!< GPIO20_LEVEL_LOW (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_EDGE_HIGH_Pos (15UL)     /*!< GPIO19_EDGE_HIGH (Bit 15)                             */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_EDGE_HIGH_Msk (0x8000UL) /*!< GPIO19_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_EDGE_LOW_Pos (14UL)      /*!< GPIO19_EDGE_LOW (Bit 14)                              */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_EDGE_LOW_Msk (0x4000UL)  /*!< GPIO19_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_LEVEL_HIGH_Pos (13UL)    /*!< GPIO19_LEVEL_HIGH (Bit 13)                            */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_LEVEL_HIGH_Msk (0x2000UL) /*!< GPIO19_LEVEL_HIGH (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_LEVEL_LOW_Pos (12UL)     /*!< GPIO19_LEVEL_LOW (Bit 12)                             */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO19_LEVEL_LOW_Msk (0x1000UL) /*!< GPIO19_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_EDGE_HIGH_Pos (11UL)     /*!< GPIO18_EDGE_HIGH (Bit 11)                             */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_EDGE_HIGH_Msk (0x800UL)  /*!< GPIO18_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_EDGE_LOW_Pos (10UL)      /*!< GPIO18_EDGE_LOW (Bit 10)                              */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_EDGE_LOW_Msk (0x400UL)   /*!< GPIO18_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_LEVEL_HIGH_Pos (9UL)     /*!< GPIO18_LEVEL_HIGH (Bit 9)                             */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_LEVEL_HIGH_Msk (0x200UL) /*!< GPIO18_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_LEVEL_LOW_Pos (8UL)      /*!< GPIO18_LEVEL_LOW (Bit 8)                              */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO18_LEVEL_LOW_Msk (0x100UL)  /*!< GPIO18_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_EDGE_HIGH_Pos (7UL)      /*!< GPIO17_EDGE_HIGH (Bit 7)                              */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_EDGE_HIGH_Msk (0x80UL)   /*!< GPIO17_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_EDGE_LOW_Pos (6UL)       /*!< GPIO17_EDGE_LOW (Bit 6)                               */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_EDGE_LOW_Msk (0x40UL)    /*!< GPIO17_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_LEVEL_HIGH_Pos (5UL)     /*!< GPIO17_LEVEL_HIGH (Bit 5)                             */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_LEVEL_HIGH_Msk (0x20UL)  /*!< GPIO17_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_LEVEL_LOW_Pos (4UL)      /*!< GPIO17_LEVEL_LOW (Bit 4)                              */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO17_LEVEL_LOW_Msk (0x10UL)   /*!< GPIO17_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_EDGE_HIGH_Pos (3UL)      /*!< GPIO16_EDGE_HIGH (Bit 3)                              */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_EDGE_HIGH_Msk (0x8UL)    /*!< GPIO16_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_EDGE_LOW_Pos (2UL)       /*!< GPIO16_EDGE_LOW (Bit 2)                               */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_EDGE_LOW_Msk (0x4UL)     /*!< GPIO16_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_LEVEL_HIGH_Pos (1UL)     /*!< GPIO16_LEVEL_HIGH (Bit 1)                             */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_LEVEL_HIGH_Msk (0x2UL)   /*!< GPIO16_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_LEVEL_LOW_Pos (0UL)      /*!< GPIO16_LEVEL_LOW (Bit 0)                              */
#define IO_BANK0_DORMANT_WAKE_INTE2_GPIO16_LEVEL_LOW_Msk (0x1UL)    /*!< GPIO16_LEVEL_LOW (Bitfield-Mask: 0x01)                */
/* ==================================================  DORMANT_WAKE_INTE3  =================================================== */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_EDGE_HIGH_Pos (23UL)     /*!< GPIO29_EDGE_HIGH (Bit 23)                             */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO29_EDGE_HIGH (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_EDGE_LOW_Pos (22UL)      /*!< GPIO29_EDGE_LOW (Bit 22)                              */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_EDGE_LOW_Msk (0x400000UL) /*!< GPIO29_EDGE_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_LEVEL_HIGH_Pos (21UL)    /*!< GPIO29_LEVEL_HIGH (Bit 21)                            */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO29_LEVEL_HIGH (Bitfield-Mask: 0x01)            */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_LEVEL_LOW_Pos (20UL)     /*!< GPIO29_LEVEL_LOW (Bit 20)                             */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO29_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO29_LEVEL_LOW (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_EDGE_HIGH_Pos (19UL)     /*!< GPIO28_EDGE_HIGH (Bit 19)                             */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_EDGE_HIGH_Msk (0x80000UL) /*!< GPIO28_EDGE_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_EDGE_LOW_Pos (18UL)      /*!< GPIO28_EDGE_LOW (Bit 18)                              */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_EDGE_LOW_Msk (0x40000UL) /*!< GPIO28_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_LEVEL_HIGH_Pos (17UL)    /*!< GPIO28_LEVEL_HIGH (Bit 17)                            */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO28_LEVEL_HIGH (Bitfield-Mask: 0x01)             */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_LEVEL_LOW_Pos (16UL)     /*!< GPIO28_LEVEL_LOW (Bit 16)                             */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO28_LEVEL_LOW_Msk (0x10000UL) /*!< GPIO28_LEVEL_LOW (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_EDGE_HIGH_Pos (15UL)     /*!< GPIO27_EDGE_HIGH (Bit 15)                             */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_EDGE_HIGH_Msk (0x8000UL) /*!< GPIO27_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_EDGE_LOW_Pos (14UL)      /*!< GPIO27_EDGE_LOW (Bit 14)                              */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_EDGE_LOW_Msk (0x4000UL)  /*!< GPIO27_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_LEVEL_HIGH_Pos (13UL)    /*!< GPIO27_LEVEL_HIGH (Bit 13)                            */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_LEVEL_HIGH_Msk (0x2000UL) /*!< GPIO27_LEVEL_HIGH (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_LEVEL_LOW_Pos (12UL)     /*!< GPIO27_LEVEL_LOW (Bit 12)                             */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO27_LEVEL_LOW_Msk (0x1000UL) /*!< GPIO27_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_EDGE_HIGH_Pos (11UL)     /*!< GPIO26_EDGE_HIGH (Bit 11)                             */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_EDGE_HIGH_Msk (0x800UL)  /*!< GPIO26_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_EDGE_LOW_Pos (10UL)      /*!< GPIO26_EDGE_LOW (Bit 10)                              */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_EDGE_LOW_Msk (0x400UL)   /*!< GPIO26_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_LEVEL_HIGH_Pos (9UL)     /*!< GPIO26_LEVEL_HIGH (Bit 9)                             */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_LEVEL_HIGH_Msk (0x200UL) /*!< GPIO26_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_LEVEL_LOW_Pos (8UL)      /*!< GPIO26_LEVEL_LOW (Bit 8)                              */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO26_LEVEL_LOW_Msk (0x100UL)  /*!< GPIO26_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_EDGE_HIGH_Pos (7UL)      /*!< GPIO25_EDGE_HIGH (Bit 7)                              */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_EDGE_HIGH_Msk (0x80UL)   /*!< GPIO25_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_EDGE_LOW_Pos (6UL)       /*!< GPIO25_EDGE_LOW (Bit 6)                               */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_EDGE_LOW_Msk (0x40UL)    /*!< GPIO25_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_LEVEL_HIGH_Pos (5UL)     /*!< GPIO25_LEVEL_HIGH (Bit 5)                             */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_LEVEL_HIGH_Msk (0x20UL)  /*!< GPIO25_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_LEVEL_LOW_Pos (4UL)      /*!< GPIO25_LEVEL_LOW (Bit 4)                              */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO25_LEVEL_LOW_Msk (0x10UL)   /*!< GPIO25_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_EDGE_HIGH_Pos (3UL)      /*!< GPIO24_EDGE_HIGH (Bit 3)                              */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_EDGE_HIGH_Msk (0x8UL)    /*!< GPIO24_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_EDGE_LOW_Pos (2UL)       /*!< GPIO24_EDGE_LOW (Bit 2)                               */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_EDGE_LOW_Msk (0x4UL)     /*!< GPIO24_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_LEVEL_HIGH_Pos (1UL)     /*!< GPIO24_LEVEL_HIGH (Bit 1)                             */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_LEVEL_HIGH_Msk (0x2UL)   /*!< GPIO24_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_LEVEL_LOW_Pos (0UL)      /*!< GPIO24_LEVEL_LOW (Bit 0)                              */
#define IO_BANK0_DORMANT_WAKE_INTE3_GPIO24_LEVEL_LOW_Msk (0x1UL)    /*!< GPIO24_LEVEL_LOW (Bitfield-Mask: 0x01)                */
/* ==================================================  DORMANT_WAKE_INTF0  =================================================== */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_EDGE_HIGH_Pos (31UL)      /*!< GPIO7_EDGE_HIGH (Bit 31)                              */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_EDGE_HIGH_Msk (0x80000000UL) /*!< GPIO7_EDGE_HIGH (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_EDGE_LOW_Pos (30UL)       /*!< GPIO7_EDGE_LOW (Bit 30)                               */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_EDGE_LOW_Msk (0x40000000UL) /*!< GPIO7_EDGE_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_LEVEL_HIGH_Pos (29UL)     /*!< GPIO7_LEVEL_HIGH (Bit 29)                             */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_LEVEL_HIGH_Msk (0x20000000UL) /*!< GPIO7_LEVEL_HIGH (Bitfield-Mask: 0x01)            */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_LEVEL_LOW_Pos (28UL)      /*!< GPIO7_LEVEL_LOW (Bit 28)                              */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO7_LEVEL_LOW_Msk (0x10000000UL) /*!< GPIO7_LEVEL_LOW (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_EDGE_HIGH_Pos (27UL)      /*!< GPIO6_EDGE_HIGH (Bit 27)                              */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_EDGE_HIGH_Msk (0x8000000UL) /*!< GPIO6_EDGE_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_EDGE_LOW_Pos (26UL)       /*!< GPIO6_EDGE_LOW (Bit 26)                               */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_EDGE_LOW_Msk (0x4000000UL) /*!< GPIO6_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_LEVEL_HIGH_Pos (25UL)     /*!< GPIO6_LEVEL_HIGH (Bit 25)                             */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_LEVEL_HIGH_Msk (0x2000000UL) /*!< GPIO6_LEVEL_HIGH (Bitfield-Mask: 0x01)             */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_LEVEL_LOW_Pos (24UL)      /*!< GPIO6_LEVEL_LOW (Bit 24)                              */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO6_LEVEL_LOW_Msk (0x1000000UL) /*!< GPIO6_LEVEL_LOW (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_EDGE_HIGH_Pos (23UL)      /*!< GPIO5_EDGE_HIGH (Bit 23)                              */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO5_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_EDGE_LOW_Pos (22UL)       /*!< GPIO5_EDGE_LOW (Bit 22)                               */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_EDGE_LOW_Msk (0x400000UL) /*!< GPIO5_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_LEVEL_HIGH_Pos (21UL)     /*!< GPIO5_LEVEL_HIGH (Bit 21)                             */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO5_LEVEL_HIGH (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_LEVEL_LOW_Pos (20UL)      /*!< GPIO5_LEVEL_LOW (Bit 20)                              */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO5_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO5_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_EDGE_HIGH_Pos (19UL)      /*!< GPIO4_EDGE_HIGH (Bit 19)                              */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_EDGE_HIGH_Msk (0x80000UL) /*!< GPIO4_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_EDGE_LOW_Pos (18UL)       /*!< GPIO4_EDGE_LOW (Bit 18)                               */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_EDGE_LOW_Msk (0x40000UL)  /*!< GPIO4_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_LEVEL_HIGH_Pos (17UL)     /*!< GPIO4_LEVEL_HIGH (Bit 17)                             */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO4_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_LEVEL_LOW_Pos (16UL)      /*!< GPIO4_LEVEL_LOW (Bit 16)                              */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO4_LEVEL_LOW_Msk (0x10000UL) /*!< GPIO4_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_EDGE_HIGH_Pos (15UL)      /*!< GPIO3_EDGE_HIGH (Bit 15)                              */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_EDGE_HIGH_Msk (0x8000UL)  /*!< GPIO3_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_EDGE_LOW_Pos (14UL)       /*!< GPIO3_EDGE_LOW (Bit 14)                               */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_EDGE_LOW_Msk (0x4000UL)   /*!< GPIO3_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_LEVEL_HIGH_Pos (13UL)     /*!< GPIO3_LEVEL_HIGH (Bit 13)                             */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_LEVEL_HIGH_Msk (0x2000UL) /*!< GPIO3_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_LEVEL_LOW_Pos (12UL)      /*!< GPIO3_LEVEL_LOW (Bit 12)                              */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO3_LEVEL_LOW_Msk (0x1000UL)  /*!< GPIO3_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_EDGE_HIGH_Pos (11UL)      /*!< GPIO2_EDGE_HIGH (Bit 11)                              */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_EDGE_HIGH_Msk (0x800UL)   /*!< GPIO2_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_EDGE_LOW_Pos (10UL)       /*!< GPIO2_EDGE_LOW (Bit 10)                               */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_EDGE_LOW_Msk (0x400UL)    /*!< GPIO2_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_LEVEL_HIGH_Pos (9UL)      /*!< GPIO2_LEVEL_HIGH (Bit 9)                              */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_LEVEL_HIGH_Msk (0x200UL)  /*!< GPIO2_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_LEVEL_LOW_Pos (8UL)       /*!< GPIO2_LEVEL_LOW (Bit 8)                               */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO2_LEVEL_LOW_Msk (0x100UL)   /*!< GPIO2_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_EDGE_HIGH_Pos (7UL)       /*!< GPIO1_EDGE_HIGH (Bit 7)                               */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_EDGE_HIGH_Msk (0x80UL)    /*!< GPIO1_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_EDGE_LOW_Pos (6UL)        /*!< GPIO1_EDGE_LOW (Bit 6)                                */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_EDGE_LOW_Msk (0x40UL)     /*!< GPIO1_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_LEVEL_HIGH_Pos (5UL)      /*!< GPIO1_LEVEL_HIGH (Bit 5)                              */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_LEVEL_HIGH_Msk (0x20UL)   /*!< GPIO1_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_LEVEL_LOW_Pos (4UL)       /*!< GPIO1_LEVEL_LOW (Bit 4)                               */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO1_LEVEL_LOW_Msk (0x10UL)    /*!< GPIO1_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_EDGE_HIGH_Pos (3UL)       /*!< GPIO0_EDGE_HIGH (Bit 3)                               */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_EDGE_HIGH_Msk (0x8UL)     /*!< GPIO0_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_EDGE_LOW_Pos (2UL)        /*!< GPIO0_EDGE_LOW (Bit 2)                                */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_EDGE_LOW_Msk (0x4UL)      /*!< GPIO0_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_LEVEL_HIGH_Pos (1UL)      /*!< GPIO0_LEVEL_HIGH (Bit 1)                              */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_LEVEL_HIGH_Msk (0x2UL)    /*!< GPIO0_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_LEVEL_LOW_Pos (0UL)       /*!< GPIO0_LEVEL_LOW (Bit 0)                               */
#define IO_BANK0_DORMANT_WAKE_INTF0_GPIO0_LEVEL_LOW_Msk (0x1UL)     /*!< GPIO0_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
/* ==================================================  DORMANT_WAKE_INTF1  =================================================== */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_EDGE_HIGH_Pos (31UL)     /*!< GPIO15_EDGE_HIGH (Bit 31)                             */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_EDGE_HIGH_Msk (0x80000000UL) /*!< GPIO15_EDGE_HIGH (Bitfield-Mask: 0x01)            */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_EDGE_LOW_Pos (30UL)      /*!< GPIO15_EDGE_LOW (Bit 30)                              */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_EDGE_LOW_Msk (0x40000000UL) /*!< GPIO15_EDGE_LOW (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_LEVEL_HIGH_Pos (29UL)    /*!< GPIO15_LEVEL_HIGH (Bit 29)                            */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_LEVEL_HIGH_Msk (0x20000000UL) /*!< GPIO15_LEVEL_HIGH (Bitfield-Mask: 0x01)          */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_LEVEL_LOW_Pos (28UL)     /*!< GPIO15_LEVEL_LOW (Bit 28)                             */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO15_LEVEL_LOW_Msk (0x10000000UL) /*!< GPIO15_LEVEL_LOW (Bitfield-Mask: 0x01)            */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_EDGE_HIGH_Pos (27UL)     /*!< GPIO14_EDGE_HIGH (Bit 27)                             */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_EDGE_HIGH_Msk (0x8000000UL) /*!< GPIO14_EDGE_HIGH (Bitfield-Mask: 0x01)             */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_EDGE_LOW_Pos (26UL)      /*!< GPIO14_EDGE_LOW (Bit 26)                              */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_EDGE_LOW_Msk (0x4000000UL) /*!< GPIO14_EDGE_LOW (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_LEVEL_HIGH_Pos (25UL)    /*!< GPIO14_LEVEL_HIGH (Bit 25)                            */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_LEVEL_HIGH_Msk (0x2000000UL) /*!< GPIO14_LEVEL_HIGH (Bitfield-Mask: 0x01)           */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_LEVEL_LOW_Pos (24UL)     /*!< GPIO14_LEVEL_LOW (Bit 24)                             */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO14_LEVEL_LOW_Msk (0x1000000UL) /*!< GPIO14_LEVEL_LOW (Bitfield-Mask: 0x01)             */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_EDGE_HIGH_Pos (23UL)     /*!< GPIO13_EDGE_HIGH (Bit 23)                             */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO13_EDGE_HIGH (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_EDGE_LOW_Pos (22UL)      /*!< GPIO13_EDGE_LOW (Bit 22)                              */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_EDGE_LOW_Msk (0x400000UL) /*!< GPIO13_EDGE_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_LEVEL_HIGH_Pos (21UL)    /*!< GPIO13_LEVEL_HIGH (Bit 21)                            */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO13_LEVEL_HIGH (Bitfield-Mask: 0x01)            */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_LEVEL_LOW_Pos (20UL)     /*!< GPIO13_LEVEL_LOW (Bit 20)                             */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO13_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO13_LEVEL_LOW (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_EDGE_HIGH_Pos (19UL)     /*!< GPIO12_EDGE_HIGH (Bit 19)                             */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_EDGE_HIGH_Msk (0x80000UL) /*!< GPIO12_EDGE_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_EDGE_LOW_Pos (18UL)      /*!< GPIO12_EDGE_LOW (Bit 18)                              */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_EDGE_LOW_Msk (0x40000UL) /*!< GPIO12_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_LEVEL_HIGH_Pos (17UL)    /*!< GPIO12_LEVEL_HIGH (Bit 17)                            */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO12_LEVEL_HIGH (Bitfield-Mask: 0x01)             */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_LEVEL_LOW_Pos (16UL)     /*!< GPIO12_LEVEL_LOW (Bit 16)                             */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO12_LEVEL_LOW_Msk (0x10000UL) /*!< GPIO12_LEVEL_LOW (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_EDGE_HIGH_Pos (15UL)     /*!< GPIO11_EDGE_HIGH (Bit 15)                             */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_EDGE_HIGH_Msk (0x8000UL) /*!< GPIO11_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_EDGE_LOW_Pos (14UL)      /*!< GPIO11_EDGE_LOW (Bit 14)                              */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_EDGE_LOW_Msk (0x4000UL)  /*!< GPIO11_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_LEVEL_HIGH_Pos (13UL)    /*!< GPIO11_LEVEL_HIGH (Bit 13)                            */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_LEVEL_HIGH_Msk (0x2000UL) /*!< GPIO11_LEVEL_HIGH (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_LEVEL_LOW_Pos (12UL)     /*!< GPIO11_LEVEL_LOW (Bit 12)                             */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO11_LEVEL_LOW_Msk (0x1000UL) /*!< GPIO11_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_EDGE_HIGH_Pos (11UL)     /*!< GPIO10_EDGE_HIGH (Bit 11)                             */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_EDGE_HIGH_Msk (0x800UL)  /*!< GPIO10_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_EDGE_LOW_Pos (10UL)      /*!< GPIO10_EDGE_LOW (Bit 10)                              */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_EDGE_LOW_Msk (0x400UL)   /*!< GPIO10_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_LEVEL_HIGH_Pos (9UL)     /*!< GPIO10_LEVEL_HIGH (Bit 9)                             */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_LEVEL_HIGH_Msk (0x200UL) /*!< GPIO10_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_LEVEL_LOW_Pos (8UL)      /*!< GPIO10_LEVEL_LOW (Bit 8)                              */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO10_LEVEL_LOW_Msk (0x100UL)  /*!< GPIO10_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_EDGE_HIGH_Pos (7UL)       /*!< GPIO9_EDGE_HIGH (Bit 7)                               */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_EDGE_HIGH_Msk (0x80UL)    /*!< GPIO9_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_EDGE_LOW_Pos (6UL)        /*!< GPIO9_EDGE_LOW (Bit 6)                                */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_EDGE_LOW_Msk (0x40UL)     /*!< GPIO9_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_LEVEL_HIGH_Pos (5UL)      /*!< GPIO9_LEVEL_HIGH (Bit 5)                              */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_LEVEL_HIGH_Msk (0x20UL)   /*!< GPIO9_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_LEVEL_LOW_Pos (4UL)       /*!< GPIO9_LEVEL_LOW (Bit 4)                               */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO9_LEVEL_LOW_Msk (0x10UL)    /*!< GPIO9_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_EDGE_HIGH_Pos (3UL)       /*!< GPIO8_EDGE_HIGH (Bit 3)                               */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_EDGE_HIGH_Msk (0x8UL)     /*!< GPIO8_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_EDGE_LOW_Pos (2UL)        /*!< GPIO8_EDGE_LOW (Bit 2)                                */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_EDGE_LOW_Msk (0x4UL)      /*!< GPIO8_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_LEVEL_HIGH_Pos (1UL)      /*!< GPIO8_LEVEL_HIGH (Bit 1)                              */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_LEVEL_HIGH_Msk (0x2UL)    /*!< GPIO8_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_LEVEL_LOW_Pos (0UL)       /*!< GPIO8_LEVEL_LOW (Bit 0)                               */
#define IO_BANK0_DORMANT_WAKE_INTF1_GPIO8_LEVEL_LOW_Msk (0x1UL)     /*!< GPIO8_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
/* ==================================================  DORMANT_WAKE_INTF2  =================================================== */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_EDGE_HIGH_Pos (31UL)     /*!< GPIO23_EDGE_HIGH (Bit 31)                             */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_EDGE_HIGH_Msk (0x80000000UL) /*!< GPIO23_EDGE_HIGH (Bitfield-Mask: 0x01)            */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_EDGE_LOW_Pos (30UL)      /*!< GPIO23_EDGE_LOW (Bit 30)                              */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_EDGE_LOW_Msk (0x40000000UL) /*!< GPIO23_EDGE_LOW (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_LEVEL_HIGH_Pos (29UL)    /*!< GPIO23_LEVEL_HIGH (Bit 29)                            */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_LEVEL_HIGH_Msk (0x20000000UL) /*!< GPIO23_LEVEL_HIGH (Bitfield-Mask: 0x01)          */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_LEVEL_LOW_Pos (28UL)     /*!< GPIO23_LEVEL_LOW (Bit 28)                             */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO23_LEVEL_LOW_Msk (0x10000000UL) /*!< GPIO23_LEVEL_LOW (Bitfield-Mask: 0x01)            */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_EDGE_HIGH_Pos (27UL)     /*!< GPIO22_EDGE_HIGH (Bit 27)                             */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_EDGE_HIGH_Msk (0x8000000UL) /*!< GPIO22_EDGE_HIGH (Bitfield-Mask: 0x01)             */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_EDGE_LOW_Pos (26UL)      /*!< GPIO22_EDGE_LOW (Bit 26)                              */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_EDGE_LOW_Msk (0x4000000UL) /*!< GPIO22_EDGE_LOW (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_LEVEL_HIGH_Pos (25UL)    /*!< GPIO22_LEVEL_HIGH (Bit 25)                            */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_LEVEL_HIGH_Msk (0x2000000UL) /*!< GPIO22_LEVEL_HIGH (Bitfield-Mask: 0x01)           */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_LEVEL_LOW_Pos (24UL)     /*!< GPIO22_LEVEL_LOW (Bit 24)                             */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO22_LEVEL_LOW_Msk (0x1000000UL) /*!< GPIO22_LEVEL_LOW (Bitfield-Mask: 0x01)             */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_EDGE_HIGH_Pos (23UL)     /*!< GPIO21_EDGE_HIGH (Bit 23)                             */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO21_EDGE_HIGH (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_EDGE_LOW_Pos (22UL)      /*!< GPIO21_EDGE_LOW (Bit 22)                              */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_EDGE_LOW_Msk (0x400000UL) /*!< GPIO21_EDGE_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_LEVEL_HIGH_Pos (21UL)    /*!< GPIO21_LEVEL_HIGH (Bit 21)                            */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO21_LEVEL_HIGH (Bitfield-Mask: 0x01)            */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_LEVEL_LOW_Pos (20UL)     /*!< GPIO21_LEVEL_LOW (Bit 20)                             */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO21_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO21_LEVEL_LOW (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_EDGE_HIGH_Pos (19UL)     /*!< GPIO20_EDGE_HIGH (Bit 19)                             */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_EDGE_HIGH_Msk (0x80000UL) /*!< GPIO20_EDGE_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_EDGE_LOW_Pos (18UL)      /*!< GPIO20_EDGE_LOW (Bit 18)                              */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_EDGE_LOW_Msk (0x40000UL) /*!< GPIO20_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_LEVEL_HIGH_Pos (17UL)    /*!< GPIO20_LEVEL_HIGH (Bit 17)                            */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO20_LEVEL_HIGH (Bitfield-Mask: 0x01)             */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_LEVEL_LOW_Pos (16UL)     /*!< GPIO20_LEVEL_LOW (Bit 16)                             */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO20_LEVEL_LOW_Msk (0x10000UL) /*!< GPIO20_LEVEL_LOW (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_EDGE_HIGH_Pos (15UL)     /*!< GPIO19_EDGE_HIGH (Bit 15)                             */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_EDGE_HIGH_Msk (0x8000UL) /*!< GPIO19_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_EDGE_LOW_Pos (14UL)      /*!< GPIO19_EDGE_LOW (Bit 14)                              */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_EDGE_LOW_Msk (0x4000UL)  /*!< GPIO19_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_LEVEL_HIGH_Pos (13UL)    /*!< GPIO19_LEVEL_HIGH (Bit 13)                            */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_LEVEL_HIGH_Msk (0x2000UL) /*!< GPIO19_LEVEL_HIGH (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_LEVEL_LOW_Pos (12UL)     /*!< GPIO19_LEVEL_LOW (Bit 12)                             */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO19_LEVEL_LOW_Msk (0x1000UL) /*!< GPIO19_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_EDGE_HIGH_Pos (11UL)     /*!< GPIO18_EDGE_HIGH (Bit 11)                             */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_EDGE_HIGH_Msk (0x800UL)  /*!< GPIO18_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_EDGE_LOW_Pos (10UL)      /*!< GPIO18_EDGE_LOW (Bit 10)                              */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_EDGE_LOW_Msk (0x400UL)   /*!< GPIO18_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_LEVEL_HIGH_Pos (9UL)     /*!< GPIO18_LEVEL_HIGH (Bit 9)                             */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_LEVEL_HIGH_Msk (0x200UL) /*!< GPIO18_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_LEVEL_LOW_Pos (8UL)      /*!< GPIO18_LEVEL_LOW (Bit 8)                              */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO18_LEVEL_LOW_Msk (0x100UL)  /*!< GPIO18_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_EDGE_HIGH_Pos (7UL)      /*!< GPIO17_EDGE_HIGH (Bit 7)                              */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_EDGE_HIGH_Msk (0x80UL)   /*!< GPIO17_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_EDGE_LOW_Pos (6UL)       /*!< GPIO17_EDGE_LOW (Bit 6)                               */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_EDGE_LOW_Msk (0x40UL)    /*!< GPIO17_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_LEVEL_HIGH_Pos (5UL)     /*!< GPIO17_LEVEL_HIGH (Bit 5)                             */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_LEVEL_HIGH_Msk (0x20UL)  /*!< GPIO17_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_LEVEL_LOW_Pos (4UL)      /*!< GPIO17_LEVEL_LOW (Bit 4)                              */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO17_LEVEL_LOW_Msk (0x10UL)   /*!< GPIO17_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_EDGE_HIGH_Pos (3UL)      /*!< GPIO16_EDGE_HIGH (Bit 3)                              */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_EDGE_HIGH_Msk (0x8UL)    /*!< GPIO16_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_EDGE_LOW_Pos (2UL)       /*!< GPIO16_EDGE_LOW (Bit 2)                               */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_EDGE_LOW_Msk (0x4UL)     /*!< GPIO16_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_LEVEL_HIGH_Pos (1UL)     /*!< GPIO16_LEVEL_HIGH (Bit 1)                             */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_LEVEL_HIGH_Msk (0x2UL)   /*!< GPIO16_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_LEVEL_LOW_Pos (0UL)      /*!< GPIO16_LEVEL_LOW (Bit 0)                              */
#define IO_BANK0_DORMANT_WAKE_INTF2_GPIO16_LEVEL_LOW_Msk (0x1UL)    /*!< GPIO16_LEVEL_LOW (Bitfield-Mask: 0x01)                */
/* ==================================================  DORMANT_WAKE_INTF3  =================================================== */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_EDGE_HIGH_Pos (23UL)     /*!< GPIO29_EDGE_HIGH (Bit 23)                             */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO29_EDGE_HIGH (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_EDGE_LOW_Pos (22UL)      /*!< GPIO29_EDGE_LOW (Bit 22)                              */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_EDGE_LOW_Msk (0x400000UL) /*!< GPIO29_EDGE_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_LEVEL_HIGH_Pos (21UL)    /*!< GPIO29_LEVEL_HIGH (Bit 21)                            */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO29_LEVEL_HIGH (Bitfield-Mask: 0x01)            */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_LEVEL_LOW_Pos (20UL)     /*!< GPIO29_LEVEL_LOW (Bit 20)                             */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO29_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO29_LEVEL_LOW (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_EDGE_HIGH_Pos (19UL)     /*!< GPIO28_EDGE_HIGH (Bit 19)                             */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_EDGE_HIGH_Msk (0x80000UL) /*!< GPIO28_EDGE_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_EDGE_LOW_Pos (18UL)      /*!< GPIO28_EDGE_LOW (Bit 18)                              */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_EDGE_LOW_Msk (0x40000UL) /*!< GPIO28_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_LEVEL_HIGH_Pos (17UL)    /*!< GPIO28_LEVEL_HIGH (Bit 17)                            */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO28_LEVEL_HIGH (Bitfield-Mask: 0x01)             */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_LEVEL_LOW_Pos (16UL)     /*!< GPIO28_LEVEL_LOW (Bit 16)                             */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO28_LEVEL_LOW_Msk (0x10000UL) /*!< GPIO28_LEVEL_LOW (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_EDGE_HIGH_Pos (15UL)     /*!< GPIO27_EDGE_HIGH (Bit 15)                             */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_EDGE_HIGH_Msk (0x8000UL) /*!< GPIO27_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_EDGE_LOW_Pos (14UL)      /*!< GPIO27_EDGE_LOW (Bit 14)                              */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_EDGE_LOW_Msk (0x4000UL)  /*!< GPIO27_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_LEVEL_HIGH_Pos (13UL)    /*!< GPIO27_LEVEL_HIGH (Bit 13)                            */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_LEVEL_HIGH_Msk (0x2000UL) /*!< GPIO27_LEVEL_HIGH (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_LEVEL_LOW_Pos (12UL)     /*!< GPIO27_LEVEL_LOW (Bit 12)                             */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO27_LEVEL_LOW_Msk (0x1000UL) /*!< GPIO27_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_EDGE_HIGH_Pos (11UL)     /*!< GPIO26_EDGE_HIGH (Bit 11)                             */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_EDGE_HIGH_Msk (0x800UL)  /*!< GPIO26_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_EDGE_LOW_Pos (10UL)      /*!< GPIO26_EDGE_LOW (Bit 10)                              */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_EDGE_LOW_Msk (0x400UL)   /*!< GPIO26_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_LEVEL_HIGH_Pos (9UL)     /*!< GPIO26_LEVEL_HIGH (Bit 9)                             */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_LEVEL_HIGH_Msk (0x200UL) /*!< GPIO26_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_LEVEL_LOW_Pos (8UL)      /*!< GPIO26_LEVEL_LOW (Bit 8)                              */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO26_LEVEL_LOW_Msk (0x100UL)  /*!< GPIO26_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_EDGE_HIGH_Pos (7UL)      /*!< GPIO25_EDGE_HIGH (Bit 7)                              */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_EDGE_HIGH_Msk (0x80UL)   /*!< GPIO25_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_EDGE_LOW_Pos (6UL)       /*!< GPIO25_EDGE_LOW (Bit 6)                               */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_EDGE_LOW_Msk (0x40UL)    /*!< GPIO25_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_LEVEL_HIGH_Pos (5UL)     /*!< GPIO25_LEVEL_HIGH (Bit 5)                             */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_LEVEL_HIGH_Msk (0x20UL)  /*!< GPIO25_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_LEVEL_LOW_Pos (4UL)      /*!< GPIO25_LEVEL_LOW (Bit 4)                              */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO25_LEVEL_LOW_Msk (0x10UL)   /*!< GPIO25_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_EDGE_HIGH_Pos (3UL)      /*!< GPIO24_EDGE_HIGH (Bit 3)                              */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_EDGE_HIGH_Msk (0x8UL)    /*!< GPIO24_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_EDGE_LOW_Pos (2UL)       /*!< GPIO24_EDGE_LOW (Bit 2)                               */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_EDGE_LOW_Msk (0x4UL)     /*!< GPIO24_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_LEVEL_HIGH_Pos (1UL)     /*!< GPIO24_LEVEL_HIGH (Bit 1)                             */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_LEVEL_HIGH_Msk (0x2UL)   /*!< GPIO24_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_LEVEL_LOW_Pos (0UL)      /*!< GPIO24_LEVEL_LOW (Bit 0)                              */
#define IO_BANK0_DORMANT_WAKE_INTF3_GPIO24_LEVEL_LOW_Msk (0x1UL)    /*!< GPIO24_LEVEL_LOW (Bitfield-Mask: 0x01)                */
/* ==================================================  DORMANT_WAKE_INTS0  =================================================== */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_EDGE_HIGH_Pos (31UL)      /*!< GPIO7_EDGE_HIGH (Bit 31)                              */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_EDGE_HIGH_Msk (0x80000000UL) /*!< GPIO7_EDGE_HIGH (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_EDGE_LOW_Pos (30UL)       /*!< GPIO7_EDGE_LOW (Bit 30)                               */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_EDGE_LOW_Msk (0x40000000UL) /*!< GPIO7_EDGE_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_LEVEL_HIGH_Pos (29UL)     /*!< GPIO7_LEVEL_HIGH (Bit 29)                             */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_LEVEL_HIGH_Msk (0x20000000UL) /*!< GPIO7_LEVEL_HIGH (Bitfield-Mask: 0x01)            */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_LEVEL_LOW_Pos (28UL)      /*!< GPIO7_LEVEL_LOW (Bit 28)                              */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO7_LEVEL_LOW_Msk (0x10000000UL) /*!< GPIO7_LEVEL_LOW (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_EDGE_HIGH_Pos (27UL)      /*!< GPIO6_EDGE_HIGH (Bit 27)                              */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_EDGE_HIGH_Msk (0x8000000UL) /*!< GPIO6_EDGE_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_EDGE_LOW_Pos (26UL)       /*!< GPIO6_EDGE_LOW (Bit 26)                               */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_EDGE_LOW_Msk (0x4000000UL) /*!< GPIO6_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_LEVEL_HIGH_Pos (25UL)     /*!< GPIO6_LEVEL_HIGH (Bit 25)                             */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_LEVEL_HIGH_Msk (0x2000000UL) /*!< GPIO6_LEVEL_HIGH (Bitfield-Mask: 0x01)             */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_LEVEL_LOW_Pos (24UL)      /*!< GPIO6_LEVEL_LOW (Bit 24)                              */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO6_LEVEL_LOW_Msk (0x1000000UL) /*!< GPIO6_LEVEL_LOW (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_EDGE_HIGH_Pos (23UL)      /*!< GPIO5_EDGE_HIGH (Bit 23)                              */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO5_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_EDGE_LOW_Pos (22UL)       /*!< GPIO5_EDGE_LOW (Bit 22)                               */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_EDGE_LOW_Msk (0x400000UL) /*!< GPIO5_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_LEVEL_HIGH_Pos (21UL)     /*!< GPIO5_LEVEL_HIGH (Bit 21)                             */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO5_LEVEL_HIGH (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_LEVEL_LOW_Pos (20UL)      /*!< GPIO5_LEVEL_LOW (Bit 20)                              */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO5_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO5_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_EDGE_HIGH_Pos (19UL)      /*!< GPIO4_EDGE_HIGH (Bit 19)                              */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_EDGE_HIGH_Msk (0x80000UL) /*!< GPIO4_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_EDGE_LOW_Pos (18UL)       /*!< GPIO4_EDGE_LOW (Bit 18)                               */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_EDGE_LOW_Msk (0x40000UL)  /*!< GPIO4_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_LEVEL_HIGH_Pos (17UL)     /*!< GPIO4_LEVEL_HIGH (Bit 17)                             */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO4_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_LEVEL_LOW_Pos (16UL)      /*!< GPIO4_LEVEL_LOW (Bit 16)                              */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO4_LEVEL_LOW_Msk (0x10000UL) /*!< GPIO4_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_EDGE_HIGH_Pos (15UL)      /*!< GPIO3_EDGE_HIGH (Bit 15)                              */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_EDGE_HIGH_Msk (0x8000UL)  /*!< GPIO3_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_EDGE_LOW_Pos (14UL)       /*!< GPIO3_EDGE_LOW (Bit 14)                               */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_EDGE_LOW_Msk (0x4000UL)   /*!< GPIO3_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_LEVEL_HIGH_Pos (13UL)     /*!< GPIO3_LEVEL_HIGH (Bit 13)                             */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_LEVEL_HIGH_Msk (0x2000UL) /*!< GPIO3_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_LEVEL_LOW_Pos (12UL)      /*!< GPIO3_LEVEL_LOW (Bit 12)                              */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO3_LEVEL_LOW_Msk (0x1000UL)  /*!< GPIO3_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_EDGE_HIGH_Pos (11UL)      /*!< GPIO2_EDGE_HIGH (Bit 11)                              */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_EDGE_HIGH_Msk (0x800UL)   /*!< GPIO2_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_EDGE_LOW_Pos (10UL)       /*!< GPIO2_EDGE_LOW (Bit 10)                               */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_EDGE_LOW_Msk (0x400UL)    /*!< GPIO2_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_LEVEL_HIGH_Pos (9UL)      /*!< GPIO2_LEVEL_HIGH (Bit 9)                              */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_LEVEL_HIGH_Msk (0x200UL)  /*!< GPIO2_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_LEVEL_LOW_Pos (8UL)       /*!< GPIO2_LEVEL_LOW (Bit 8)                               */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO2_LEVEL_LOW_Msk (0x100UL)   /*!< GPIO2_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_EDGE_HIGH_Pos (7UL)       /*!< GPIO1_EDGE_HIGH (Bit 7)                               */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_EDGE_HIGH_Msk (0x80UL)    /*!< GPIO1_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_EDGE_LOW_Pos (6UL)        /*!< GPIO1_EDGE_LOW (Bit 6)                                */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_EDGE_LOW_Msk (0x40UL)     /*!< GPIO1_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_LEVEL_HIGH_Pos (5UL)      /*!< GPIO1_LEVEL_HIGH (Bit 5)                              */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_LEVEL_HIGH_Msk (0x20UL)   /*!< GPIO1_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_LEVEL_LOW_Pos (4UL)       /*!< GPIO1_LEVEL_LOW (Bit 4)                               */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO1_LEVEL_LOW_Msk (0x10UL)    /*!< GPIO1_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_EDGE_HIGH_Pos (3UL)       /*!< GPIO0_EDGE_HIGH (Bit 3)                               */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_EDGE_HIGH_Msk (0x8UL)     /*!< GPIO0_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_EDGE_LOW_Pos (2UL)        /*!< GPIO0_EDGE_LOW (Bit 2)                                */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_EDGE_LOW_Msk (0x4UL)      /*!< GPIO0_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_LEVEL_HIGH_Pos (1UL)      /*!< GPIO0_LEVEL_HIGH (Bit 1)                              */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_LEVEL_HIGH_Msk (0x2UL)    /*!< GPIO0_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_LEVEL_LOW_Pos (0UL)       /*!< GPIO0_LEVEL_LOW (Bit 0)                               */
#define IO_BANK0_DORMANT_WAKE_INTS0_GPIO0_LEVEL_LOW_Msk (0x1UL)     /*!< GPIO0_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
/* ==================================================  DORMANT_WAKE_INTS1  =================================================== */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_EDGE_HIGH_Pos (31UL)     /*!< GPIO15_EDGE_HIGH (Bit 31)                             */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_EDGE_HIGH_Msk (0x80000000UL) /*!< GPIO15_EDGE_HIGH (Bitfield-Mask: 0x01)            */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_EDGE_LOW_Pos (30UL)      /*!< GPIO15_EDGE_LOW (Bit 30)                              */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_EDGE_LOW_Msk (0x40000000UL) /*!< GPIO15_EDGE_LOW (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_LEVEL_HIGH_Pos (29UL)    /*!< GPIO15_LEVEL_HIGH (Bit 29)                            */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_LEVEL_HIGH_Msk (0x20000000UL) /*!< GPIO15_LEVEL_HIGH (Bitfield-Mask: 0x01)          */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_LEVEL_LOW_Pos (28UL)     /*!< GPIO15_LEVEL_LOW (Bit 28)                             */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO15_LEVEL_LOW_Msk (0x10000000UL) /*!< GPIO15_LEVEL_LOW (Bitfield-Mask: 0x01)            */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_EDGE_HIGH_Pos (27UL)     /*!< GPIO14_EDGE_HIGH (Bit 27)                             */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_EDGE_HIGH_Msk (0x8000000UL) /*!< GPIO14_EDGE_HIGH (Bitfield-Mask: 0x01)             */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_EDGE_LOW_Pos (26UL)      /*!< GPIO14_EDGE_LOW (Bit 26)                              */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_EDGE_LOW_Msk (0x4000000UL) /*!< GPIO14_EDGE_LOW (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_LEVEL_HIGH_Pos (25UL)    /*!< GPIO14_LEVEL_HIGH (Bit 25)                            */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_LEVEL_HIGH_Msk (0x2000000UL) /*!< GPIO14_LEVEL_HIGH (Bitfield-Mask: 0x01)           */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_LEVEL_LOW_Pos (24UL)     /*!< GPIO14_LEVEL_LOW (Bit 24)                             */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO14_LEVEL_LOW_Msk (0x1000000UL) /*!< GPIO14_LEVEL_LOW (Bitfield-Mask: 0x01)             */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_EDGE_HIGH_Pos (23UL)     /*!< GPIO13_EDGE_HIGH (Bit 23)                             */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO13_EDGE_HIGH (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_EDGE_LOW_Pos (22UL)      /*!< GPIO13_EDGE_LOW (Bit 22)                              */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_EDGE_LOW_Msk (0x400000UL) /*!< GPIO13_EDGE_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_LEVEL_HIGH_Pos (21UL)    /*!< GPIO13_LEVEL_HIGH (Bit 21)                            */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO13_LEVEL_HIGH (Bitfield-Mask: 0x01)            */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_LEVEL_LOW_Pos (20UL)     /*!< GPIO13_LEVEL_LOW (Bit 20)                             */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO13_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO13_LEVEL_LOW (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_EDGE_HIGH_Pos (19UL)     /*!< GPIO12_EDGE_HIGH (Bit 19)                             */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_EDGE_HIGH_Msk (0x80000UL) /*!< GPIO12_EDGE_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_EDGE_LOW_Pos (18UL)      /*!< GPIO12_EDGE_LOW (Bit 18)                              */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_EDGE_LOW_Msk (0x40000UL) /*!< GPIO12_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_LEVEL_HIGH_Pos (17UL)    /*!< GPIO12_LEVEL_HIGH (Bit 17)                            */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO12_LEVEL_HIGH (Bitfield-Mask: 0x01)             */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_LEVEL_LOW_Pos (16UL)     /*!< GPIO12_LEVEL_LOW (Bit 16)                             */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO12_LEVEL_LOW_Msk (0x10000UL) /*!< GPIO12_LEVEL_LOW (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_EDGE_HIGH_Pos (15UL)     /*!< GPIO11_EDGE_HIGH (Bit 15)                             */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_EDGE_HIGH_Msk (0x8000UL) /*!< GPIO11_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_EDGE_LOW_Pos (14UL)      /*!< GPIO11_EDGE_LOW (Bit 14)                              */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_EDGE_LOW_Msk (0x4000UL)  /*!< GPIO11_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_LEVEL_HIGH_Pos (13UL)    /*!< GPIO11_LEVEL_HIGH (Bit 13)                            */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_LEVEL_HIGH_Msk (0x2000UL) /*!< GPIO11_LEVEL_HIGH (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_LEVEL_LOW_Pos (12UL)     /*!< GPIO11_LEVEL_LOW (Bit 12)                             */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO11_LEVEL_LOW_Msk (0x1000UL) /*!< GPIO11_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_EDGE_HIGH_Pos (11UL)     /*!< GPIO10_EDGE_HIGH (Bit 11)                             */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_EDGE_HIGH_Msk (0x800UL)  /*!< GPIO10_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_EDGE_LOW_Pos (10UL)      /*!< GPIO10_EDGE_LOW (Bit 10)                              */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_EDGE_LOW_Msk (0x400UL)   /*!< GPIO10_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_LEVEL_HIGH_Pos (9UL)     /*!< GPIO10_LEVEL_HIGH (Bit 9)                             */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_LEVEL_HIGH_Msk (0x200UL) /*!< GPIO10_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_LEVEL_LOW_Pos (8UL)      /*!< GPIO10_LEVEL_LOW (Bit 8)                              */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO10_LEVEL_LOW_Msk (0x100UL)  /*!< GPIO10_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_EDGE_HIGH_Pos (7UL)       /*!< GPIO9_EDGE_HIGH (Bit 7)                               */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_EDGE_HIGH_Msk (0x80UL)    /*!< GPIO9_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_EDGE_LOW_Pos (6UL)        /*!< GPIO9_EDGE_LOW (Bit 6)                                */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_EDGE_LOW_Msk (0x40UL)     /*!< GPIO9_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_LEVEL_HIGH_Pos (5UL)      /*!< GPIO9_LEVEL_HIGH (Bit 5)                              */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_LEVEL_HIGH_Msk (0x20UL)   /*!< GPIO9_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_LEVEL_LOW_Pos (4UL)       /*!< GPIO9_LEVEL_LOW (Bit 4)                               */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO9_LEVEL_LOW_Msk (0x10UL)    /*!< GPIO9_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_EDGE_HIGH_Pos (3UL)       /*!< GPIO8_EDGE_HIGH (Bit 3)                               */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_EDGE_HIGH_Msk (0x8UL)     /*!< GPIO8_EDGE_HIGH (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_EDGE_LOW_Pos (2UL)        /*!< GPIO8_EDGE_LOW (Bit 2)                                */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_EDGE_LOW_Msk (0x4UL)      /*!< GPIO8_EDGE_LOW (Bitfield-Mask: 0x01)                  */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_LEVEL_HIGH_Pos (1UL)      /*!< GPIO8_LEVEL_HIGH (Bit 1)                              */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_LEVEL_HIGH_Msk (0x2UL)    /*!< GPIO8_LEVEL_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_LEVEL_LOW_Pos (0UL)       /*!< GPIO8_LEVEL_LOW (Bit 0)                               */
#define IO_BANK0_DORMANT_WAKE_INTS1_GPIO8_LEVEL_LOW_Msk (0x1UL)     /*!< GPIO8_LEVEL_LOW (Bitfield-Mask: 0x01)                 */
/* ==================================================  DORMANT_WAKE_INTS2  =================================================== */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_EDGE_HIGH_Pos (31UL)     /*!< GPIO23_EDGE_HIGH (Bit 31)                             */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_EDGE_HIGH_Msk (0x80000000UL) /*!< GPIO23_EDGE_HIGH (Bitfield-Mask: 0x01)            */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_EDGE_LOW_Pos (30UL)      /*!< GPIO23_EDGE_LOW (Bit 30)                              */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_EDGE_LOW_Msk (0x40000000UL) /*!< GPIO23_EDGE_LOW (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_LEVEL_HIGH_Pos (29UL)    /*!< GPIO23_LEVEL_HIGH (Bit 29)                            */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_LEVEL_HIGH_Msk (0x20000000UL) /*!< GPIO23_LEVEL_HIGH (Bitfield-Mask: 0x01)          */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_LEVEL_LOW_Pos (28UL)     /*!< GPIO23_LEVEL_LOW (Bit 28)                             */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO23_LEVEL_LOW_Msk (0x10000000UL) /*!< GPIO23_LEVEL_LOW (Bitfield-Mask: 0x01)            */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_EDGE_HIGH_Pos (27UL)     /*!< GPIO22_EDGE_HIGH (Bit 27)                             */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_EDGE_HIGH_Msk (0x8000000UL) /*!< GPIO22_EDGE_HIGH (Bitfield-Mask: 0x01)             */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_EDGE_LOW_Pos (26UL)      /*!< GPIO22_EDGE_LOW (Bit 26)                              */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_EDGE_LOW_Msk (0x4000000UL) /*!< GPIO22_EDGE_LOW (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_LEVEL_HIGH_Pos (25UL)    /*!< GPIO22_LEVEL_HIGH (Bit 25)                            */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_LEVEL_HIGH_Msk (0x2000000UL) /*!< GPIO22_LEVEL_HIGH (Bitfield-Mask: 0x01)           */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_LEVEL_LOW_Pos (24UL)     /*!< GPIO22_LEVEL_LOW (Bit 24)                             */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO22_LEVEL_LOW_Msk (0x1000000UL) /*!< GPIO22_LEVEL_LOW (Bitfield-Mask: 0x01)             */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_EDGE_HIGH_Pos (23UL)     /*!< GPIO21_EDGE_HIGH (Bit 23)                             */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO21_EDGE_HIGH (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_EDGE_LOW_Pos (22UL)      /*!< GPIO21_EDGE_LOW (Bit 22)                              */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_EDGE_LOW_Msk (0x400000UL) /*!< GPIO21_EDGE_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_LEVEL_HIGH_Pos (21UL)    /*!< GPIO21_LEVEL_HIGH (Bit 21)                            */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO21_LEVEL_HIGH (Bitfield-Mask: 0x01)            */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_LEVEL_LOW_Pos (20UL)     /*!< GPIO21_LEVEL_LOW (Bit 20)                             */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO21_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO21_LEVEL_LOW (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_EDGE_HIGH_Pos (19UL)     /*!< GPIO20_EDGE_HIGH (Bit 19)                             */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_EDGE_HIGH_Msk (0x80000UL) /*!< GPIO20_EDGE_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_EDGE_LOW_Pos (18UL)      /*!< GPIO20_EDGE_LOW (Bit 18)                              */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_EDGE_LOW_Msk (0x40000UL) /*!< GPIO20_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_LEVEL_HIGH_Pos (17UL)    /*!< GPIO20_LEVEL_HIGH (Bit 17)                            */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO20_LEVEL_HIGH (Bitfield-Mask: 0x01)             */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_LEVEL_LOW_Pos (16UL)     /*!< GPIO20_LEVEL_LOW (Bit 16)                             */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO20_LEVEL_LOW_Msk (0x10000UL) /*!< GPIO20_LEVEL_LOW (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_EDGE_HIGH_Pos (15UL)     /*!< GPIO19_EDGE_HIGH (Bit 15)                             */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_EDGE_HIGH_Msk (0x8000UL) /*!< GPIO19_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_EDGE_LOW_Pos (14UL)      /*!< GPIO19_EDGE_LOW (Bit 14)                              */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_EDGE_LOW_Msk (0x4000UL)  /*!< GPIO19_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_LEVEL_HIGH_Pos (13UL)    /*!< GPIO19_LEVEL_HIGH (Bit 13)                            */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_LEVEL_HIGH_Msk (0x2000UL) /*!< GPIO19_LEVEL_HIGH (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_LEVEL_LOW_Pos (12UL)     /*!< GPIO19_LEVEL_LOW (Bit 12)                             */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO19_LEVEL_LOW_Msk (0x1000UL) /*!< GPIO19_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_EDGE_HIGH_Pos (11UL)     /*!< GPIO18_EDGE_HIGH (Bit 11)                             */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_EDGE_HIGH_Msk (0x800UL)  /*!< GPIO18_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_EDGE_LOW_Pos (10UL)      /*!< GPIO18_EDGE_LOW (Bit 10)                              */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_EDGE_LOW_Msk (0x400UL)   /*!< GPIO18_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_LEVEL_HIGH_Pos (9UL)     /*!< GPIO18_LEVEL_HIGH (Bit 9)                             */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_LEVEL_HIGH_Msk (0x200UL) /*!< GPIO18_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_LEVEL_LOW_Pos (8UL)      /*!< GPIO18_LEVEL_LOW (Bit 8)                              */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO18_LEVEL_LOW_Msk (0x100UL)  /*!< GPIO18_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_EDGE_HIGH_Pos (7UL)      /*!< GPIO17_EDGE_HIGH (Bit 7)                              */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_EDGE_HIGH_Msk (0x80UL)   /*!< GPIO17_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_EDGE_LOW_Pos (6UL)       /*!< GPIO17_EDGE_LOW (Bit 6)                               */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_EDGE_LOW_Msk (0x40UL)    /*!< GPIO17_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_LEVEL_HIGH_Pos (5UL)     /*!< GPIO17_LEVEL_HIGH (Bit 5)                             */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_LEVEL_HIGH_Msk (0x20UL)  /*!< GPIO17_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_LEVEL_LOW_Pos (4UL)      /*!< GPIO17_LEVEL_LOW (Bit 4)                              */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO17_LEVEL_LOW_Msk (0x10UL)   /*!< GPIO17_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_EDGE_HIGH_Pos (3UL)      /*!< GPIO16_EDGE_HIGH (Bit 3)                              */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_EDGE_HIGH_Msk (0x8UL)    /*!< GPIO16_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_EDGE_LOW_Pos (2UL)       /*!< GPIO16_EDGE_LOW (Bit 2)                               */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_EDGE_LOW_Msk (0x4UL)     /*!< GPIO16_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_LEVEL_HIGH_Pos (1UL)     /*!< GPIO16_LEVEL_HIGH (Bit 1)                             */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_LEVEL_HIGH_Msk (0x2UL)   /*!< GPIO16_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_LEVEL_LOW_Pos (0UL)      /*!< GPIO16_LEVEL_LOW (Bit 0)                              */
#define IO_BANK0_DORMANT_WAKE_INTS2_GPIO16_LEVEL_LOW_Msk (0x1UL)    /*!< GPIO16_LEVEL_LOW (Bitfield-Mask: 0x01)                */
/* ==================================================  DORMANT_WAKE_INTS3  =================================================== */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_EDGE_HIGH_Pos (23UL)     /*!< GPIO29_EDGE_HIGH (Bit 23)                             */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO29_EDGE_HIGH (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_EDGE_LOW_Pos (22UL)      /*!< GPIO29_EDGE_LOW (Bit 22)                              */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_EDGE_LOW_Msk (0x400000UL) /*!< GPIO29_EDGE_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_LEVEL_HIGH_Pos (21UL)    /*!< GPIO29_LEVEL_HIGH (Bit 21)                            */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO29_LEVEL_HIGH (Bitfield-Mask: 0x01)            */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_LEVEL_LOW_Pos (20UL)     /*!< GPIO29_LEVEL_LOW (Bit 20)                             */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO29_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO29_LEVEL_LOW (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_EDGE_HIGH_Pos (19UL)     /*!< GPIO28_EDGE_HIGH (Bit 19)                             */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_EDGE_HIGH_Msk (0x80000UL) /*!< GPIO28_EDGE_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_EDGE_LOW_Pos (18UL)      /*!< GPIO28_EDGE_LOW (Bit 18)                              */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_EDGE_LOW_Msk (0x40000UL) /*!< GPIO28_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_LEVEL_HIGH_Pos (17UL)    /*!< GPIO28_LEVEL_HIGH (Bit 17)                            */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO28_LEVEL_HIGH (Bitfield-Mask: 0x01)             */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_LEVEL_LOW_Pos (16UL)     /*!< GPIO28_LEVEL_LOW (Bit 16)                             */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO28_LEVEL_LOW_Msk (0x10000UL) /*!< GPIO28_LEVEL_LOW (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_EDGE_HIGH_Pos (15UL)     /*!< GPIO27_EDGE_HIGH (Bit 15)                             */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_EDGE_HIGH_Msk (0x8000UL) /*!< GPIO27_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_EDGE_LOW_Pos (14UL)      /*!< GPIO27_EDGE_LOW (Bit 14)                              */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_EDGE_LOW_Msk (0x4000UL)  /*!< GPIO27_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_LEVEL_HIGH_Pos (13UL)    /*!< GPIO27_LEVEL_HIGH (Bit 13)                            */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_LEVEL_HIGH_Msk (0x2000UL) /*!< GPIO27_LEVEL_HIGH (Bitfield-Mask: 0x01)              */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_LEVEL_LOW_Pos (12UL)     /*!< GPIO27_LEVEL_LOW (Bit 12)                             */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO27_LEVEL_LOW_Msk (0x1000UL) /*!< GPIO27_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_EDGE_HIGH_Pos (11UL)     /*!< GPIO26_EDGE_HIGH (Bit 11)                             */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_EDGE_HIGH_Msk (0x800UL)  /*!< GPIO26_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_EDGE_LOW_Pos (10UL)      /*!< GPIO26_EDGE_LOW (Bit 10)                              */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_EDGE_LOW_Msk (0x400UL)   /*!< GPIO26_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_LEVEL_HIGH_Pos (9UL)     /*!< GPIO26_LEVEL_HIGH (Bit 9)                             */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_LEVEL_HIGH_Msk (0x200UL) /*!< GPIO26_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_LEVEL_LOW_Pos (8UL)      /*!< GPIO26_LEVEL_LOW (Bit 8)                              */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO26_LEVEL_LOW_Msk (0x100UL)  /*!< GPIO26_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_EDGE_HIGH_Pos (7UL)      /*!< GPIO25_EDGE_HIGH (Bit 7)                              */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_EDGE_HIGH_Msk (0x80UL)   /*!< GPIO25_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_EDGE_LOW_Pos (6UL)       /*!< GPIO25_EDGE_LOW (Bit 6)                               */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_EDGE_LOW_Msk (0x40UL)    /*!< GPIO25_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_LEVEL_HIGH_Pos (5UL)     /*!< GPIO25_LEVEL_HIGH (Bit 5)                             */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_LEVEL_HIGH_Msk (0x20UL)  /*!< GPIO25_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_LEVEL_LOW_Pos (4UL)      /*!< GPIO25_LEVEL_LOW (Bit 4)                              */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO25_LEVEL_LOW_Msk (0x10UL)   /*!< GPIO25_LEVEL_LOW (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_EDGE_HIGH_Pos (3UL)      /*!< GPIO24_EDGE_HIGH (Bit 3)                              */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_EDGE_HIGH_Msk (0x8UL)    /*!< GPIO24_EDGE_HIGH (Bitfield-Mask: 0x01)                */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_EDGE_LOW_Pos (2UL)       /*!< GPIO24_EDGE_LOW (Bit 2)                               */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_EDGE_LOW_Msk (0x4UL)     /*!< GPIO24_EDGE_LOW (Bitfield-Mask: 0x01)                 */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_LEVEL_HIGH_Pos (1UL)     /*!< GPIO24_LEVEL_HIGH (Bit 1)                             */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_LEVEL_HIGH_Msk (0x2UL)   /*!< GPIO24_LEVEL_HIGH (Bitfield-Mask: 0x01)               */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_LEVEL_LOW_Pos (0UL)      /*!< GPIO24_LEVEL_LOW (Bit 0)                              */
#define IO_BANK0_DORMANT_WAKE_INTS3_GPIO24_LEVEL_LOW_Msk (0x1UL)    /*!< GPIO24_LEVEL_LOW (Bitfield-Mask: 0x01)                */


/* =========================================================================================================================== */
/* ================                                          IO_QSPI                                          ================ */
/* =========================================================================================================================== */

/* =================================================  GPIO_QSPI_SCLK_STATUS  ================================================= */
#define IO_QSPI_GPIO_QSPI_SCLK_STATUS_IRQTOPROC_Pos (26UL)          /*!< IRQTOPROC (Bit 26)                                    */
#define IO_QSPI_GPIO_QSPI_SCLK_STATUS_IRQTOPROC_Msk (0x4000000UL)   /*!< IRQTOPROC (Bitfield-Mask: 0x01)                       */
#define IO_QSPI_GPIO_QSPI_SCLK_STATUS_IRQFROMPAD_Pos (24UL)         /*!< IRQFROMPAD (Bit 24)                                   */
#define IO_QSPI_GPIO_QSPI_SCLK_STATUS_IRQFROMPAD_Msk (0x1000000UL)  /*!< IRQFROMPAD (Bitfield-Mask: 0x01)                      */
#define IO_QSPI_GPIO_QSPI_SCLK_STATUS_INTOPERI_Pos (19UL)           /*!< INTOPERI (Bit 19)                                     */
#define IO_QSPI_GPIO_QSPI_SCLK_STATUS_INTOPERI_Msk (0x80000UL)      /*!< INTOPERI (Bitfield-Mask: 0x01)                        */
#define IO_QSPI_GPIO_QSPI_SCLK_STATUS_INFROMPAD_Pos (17UL)          /*!< INFROMPAD (Bit 17)                                    */
#define IO_QSPI_GPIO_QSPI_SCLK_STATUS_INFROMPAD_Msk (0x20000UL)     /*!< INFROMPAD (Bitfield-Mask: 0x01)                       */
#define IO_QSPI_GPIO_QSPI_SCLK_STATUS_OETOPAD_Pos (13UL)            /*!< OETOPAD (Bit 13)                                      */
#define IO_QSPI_GPIO_QSPI_SCLK_STATUS_OETOPAD_Msk (0x2000UL)        /*!< OETOPAD (Bitfield-Mask: 0x01)                         */
#define IO_QSPI_GPIO_QSPI_SCLK_STATUS_OEFROMPERI_Pos (12UL)         /*!< OEFROMPERI (Bit 12)                                   */
#define IO_QSPI_GPIO_QSPI_SCLK_STATUS_OEFROMPERI_Msk (0x1000UL)     /*!< OEFROMPERI (Bitfield-Mask: 0x01)                      */
#define IO_QSPI_GPIO_QSPI_SCLK_STATUS_OUTTOPAD_Pos (9UL)            /*!< OUTTOPAD (Bit 9)                                      */
#define IO_QSPI_GPIO_QSPI_SCLK_STATUS_OUTTOPAD_Msk (0x200UL)        /*!< OUTTOPAD (Bitfield-Mask: 0x01)                        */
#define IO_QSPI_GPIO_QSPI_SCLK_STATUS_OUTFROMPERI_Pos (8UL)         /*!< OUTFROMPERI (Bit 8)                                   */
#define IO_QSPI_GPIO_QSPI_SCLK_STATUS_OUTFROMPERI_Msk (0x100UL)     /*!< OUTFROMPERI (Bitfield-Mask: 0x01)                     */
/* ==================================================  GPIO_QSPI_SCLK_CTRL  ================================================== */
#define IO_QSPI_GPIO_QSPI_SCLK_CTRL_IRQOVER_Pos (28UL)              /*!< IRQOVER (Bit 28)                                      */
#define IO_QSPI_GPIO_QSPI_SCLK_CTRL_IRQOVER_Msk (0x30000000UL)      /*!< IRQOVER (Bitfield-Mask: 0x03)                         */
#define IO_QSPI_GPIO_QSPI_SCLK_CTRL_INOVER_Pos (16UL)               /*!< INOVER (Bit 16)                                       */
#define IO_QSPI_GPIO_QSPI_SCLK_CTRL_INOVER_Msk (0x30000UL)          /*!< INOVER (Bitfield-Mask: 0x03)                          */
#define IO_QSPI_GPIO_QSPI_SCLK_CTRL_OEOVER_Pos (12UL)               /*!< OEOVER (Bit 12)                                       */
#define IO_QSPI_GPIO_QSPI_SCLK_CTRL_OEOVER_Msk (0x3000UL)           /*!< OEOVER (Bitfield-Mask: 0x03)                          */
#define IO_QSPI_GPIO_QSPI_SCLK_CTRL_OUTOVER_Pos (8UL)               /*!< OUTOVER (Bit 8)                                       */
#define IO_QSPI_GPIO_QSPI_SCLK_CTRL_OUTOVER_Msk (0x300UL)           /*!< OUTOVER (Bitfield-Mask: 0x03)                         */
#define IO_QSPI_GPIO_QSPI_SCLK_CTRL_FUNCSEL_Pos (0UL)               /*!< FUNCSEL (Bit 0)                                       */
#define IO_QSPI_GPIO_QSPI_SCLK_CTRL_FUNCSEL_Msk (0x1fUL)            /*!< FUNCSEL (Bitfield-Mask: 0x1f)                         */
/* ==================================================  GPIO_QSPI_SS_STATUS  ================================================== */
#define IO_QSPI_GPIO_QSPI_SS_STATUS_IRQTOPROC_Pos (26UL)            /*!< IRQTOPROC (Bit 26)                                    */
#define IO_QSPI_GPIO_QSPI_SS_STATUS_IRQTOPROC_Msk (0x4000000UL)     /*!< IRQTOPROC (Bitfield-Mask: 0x01)                       */
#define IO_QSPI_GPIO_QSPI_SS_STATUS_IRQFROMPAD_Pos (24UL)           /*!< IRQFROMPAD (Bit 24)                                   */
#define IO_QSPI_GPIO_QSPI_SS_STATUS_IRQFROMPAD_Msk (0x1000000UL)    /*!< IRQFROMPAD (Bitfield-Mask: 0x01)                      */
#define IO_QSPI_GPIO_QSPI_SS_STATUS_INTOPERI_Pos (19UL)             /*!< INTOPERI (Bit 19)                                     */
#define IO_QSPI_GPIO_QSPI_SS_STATUS_INTOPERI_Msk (0x80000UL)        /*!< INTOPERI (Bitfield-Mask: 0x01)                        */
#define IO_QSPI_GPIO_QSPI_SS_STATUS_INFROMPAD_Pos (17UL)            /*!< INFROMPAD (Bit 17)                                    */
#define IO_QSPI_GPIO_QSPI_SS_STATUS_INFROMPAD_Msk (0x20000UL)       /*!< INFROMPAD (Bitfield-Mask: 0x01)                       */
#define IO_QSPI_GPIO_QSPI_SS_STATUS_OETOPAD_Pos (13UL)              /*!< OETOPAD (Bit 13)                                      */
#define IO_QSPI_GPIO_QSPI_SS_STATUS_OETOPAD_Msk (0x2000UL)          /*!< OETOPAD (Bitfield-Mask: 0x01)                         */
#define IO_QSPI_GPIO_QSPI_SS_STATUS_OEFROMPERI_Pos (12UL)           /*!< OEFROMPERI (Bit 12)                                   */
#define IO_QSPI_GPIO_QSPI_SS_STATUS_OEFROMPERI_Msk (0x1000UL)       /*!< OEFROMPERI (Bitfield-Mask: 0x01)                      */
#define IO_QSPI_GPIO_QSPI_SS_STATUS_OUTTOPAD_Pos (9UL)              /*!< OUTTOPAD (Bit 9)                                      */
#define IO_QSPI_GPIO_QSPI_SS_STATUS_OUTTOPAD_Msk (0x200UL)          /*!< OUTTOPAD (Bitfield-Mask: 0x01)                        */
#define IO_QSPI_GPIO_QSPI_SS_STATUS_OUTFROMPERI_Pos (8UL)           /*!< OUTFROMPERI (Bit 8)                                   */
#define IO_QSPI_GPIO_QSPI_SS_STATUS_OUTFROMPERI_Msk (0x100UL)       /*!< OUTFROMPERI (Bitfield-Mask: 0x01)                     */
/* ===================================================  GPIO_QSPI_SS_CTRL  =================================================== */
#define IO_QSPI_GPIO_QSPI_SS_CTRL_IRQOVER_Pos (28UL)                /*!< IRQOVER (Bit 28)                                      */
#define IO_QSPI_GPIO_QSPI_SS_CTRL_IRQOVER_Msk (0x30000000UL)        /*!< IRQOVER (Bitfield-Mask: 0x03)                         */
#define IO_QSPI_GPIO_QSPI_SS_CTRL_INOVER_Pos (16UL)                 /*!< INOVER (Bit 16)                                       */
#define IO_QSPI_GPIO_QSPI_SS_CTRL_INOVER_Msk (0x30000UL)            /*!< INOVER (Bitfield-Mask: 0x03)                          */
#define IO_QSPI_GPIO_QSPI_SS_CTRL_OEOVER_Pos (12UL)                 /*!< OEOVER (Bit 12)                                       */
#define IO_QSPI_GPIO_QSPI_SS_CTRL_OEOVER_Msk (0x3000UL)             /*!< OEOVER (Bitfield-Mask: 0x03)                          */
#define IO_QSPI_GPIO_QSPI_SS_CTRL_OUTOVER_Pos (8UL)                 /*!< OUTOVER (Bit 8)                                       */
#define IO_QSPI_GPIO_QSPI_SS_CTRL_OUTOVER_Msk (0x300UL)             /*!< OUTOVER (Bitfield-Mask: 0x03)                         */
#define IO_QSPI_GPIO_QSPI_SS_CTRL_FUNCSEL_Pos (0UL)                 /*!< FUNCSEL (Bit 0)                                       */
#define IO_QSPI_GPIO_QSPI_SS_CTRL_FUNCSEL_Msk (0x1fUL)              /*!< FUNCSEL (Bitfield-Mask: 0x1f)                         */
/* =================================================  GPIO_QSPI_SD0_STATUS  ================================================== */
#define IO_QSPI_GPIO_QSPI_SD0_STATUS_IRQTOPROC_Pos (26UL)           /*!< IRQTOPROC (Bit 26)                                    */
#define IO_QSPI_GPIO_QSPI_SD0_STATUS_IRQTOPROC_Msk (0x4000000UL)    /*!< IRQTOPROC (Bitfield-Mask: 0x01)                       */
#define IO_QSPI_GPIO_QSPI_SD0_STATUS_IRQFROMPAD_Pos (24UL)          /*!< IRQFROMPAD (Bit 24)                                   */
#define IO_QSPI_GPIO_QSPI_SD0_STATUS_IRQFROMPAD_Msk (0x1000000UL)   /*!< IRQFROMPAD (Bitfield-Mask: 0x01)                      */
#define IO_QSPI_GPIO_QSPI_SD0_STATUS_INTOPERI_Pos (19UL)            /*!< INTOPERI (Bit 19)                                     */
#define IO_QSPI_GPIO_QSPI_SD0_STATUS_INTOPERI_Msk (0x80000UL)       /*!< INTOPERI (Bitfield-Mask: 0x01)                        */
#define IO_QSPI_GPIO_QSPI_SD0_STATUS_INFROMPAD_Pos (17UL)           /*!< INFROMPAD (Bit 17)                                    */
#define IO_QSPI_GPIO_QSPI_SD0_STATUS_INFROMPAD_Msk (0x20000UL)      /*!< INFROMPAD (Bitfield-Mask: 0x01)                       */
#define IO_QSPI_GPIO_QSPI_SD0_STATUS_OETOPAD_Pos (13UL)             /*!< OETOPAD (Bit 13)                                      */
#define IO_QSPI_GPIO_QSPI_SD0_STATUS_OETOPAD_Msk (0x2000UL)         /*!< OETOPAD (Bitfield-Mask: 0x01)                         */
#define IO_QSPI_GPIO_QSPI_SD0_STATUS_OEFROMPERI_Pos (12UL)          /*!< OEFROMPERI (Bit 12)                                   */
#define IO_QSPI_GPIO_QSPI_SD0_STATUS_OEFROMPERI_Msk (0x1000UL)      /*!< OEFROMPERI (Bitfield-Mask: 0x01)                      */
#define IO_QSPI_GPIO_QSPI_SD0_STATUS_OUTTOPAD_Pos (9UL)             /*!< OUTTOPAD (Bit 9)                                      */
#define IO_QSPI_GPIO_QSPI_SD0_STATUS_OUTTOPAD_Msk (0x200UL)         /*!< OUTTOPAD (Bitfield-Mask: 0x01)                        */
#define IO_QSPI_GPIO_QSPI_SD0_STATUS_OUTFROMPERI_Pos (8UL)          /*!< OUTFROMPERI (Bit 8)                                   */
#define IO_QSPI_GPIO_QSPI_SD0_STATUS_OUTFROMPERI_Msk (0x100UL)      /*!< OUTFROMPERI (Bitfield-Mask: 0x01)                     */
/* ==================================================  GPIO_QSPI_SD0_CTRL  =================================================== */
#define IO_QSPI_GPIO_QSPI_SD0_CTRL_IRQOVER_Pos (28UL)               /*!< IRQOVER (Bit 28)                                      */
#define IO_QSPI_GPIO_QSPI_SD0_CTRL_IRQOVER_Msk (0x30000000UL)       /*!< IRQOVER (Bitfield-Mask: 0x03)                         */
#define IO_QSPI_GPIO_QSPI_SD0_CTRL_INOVER_Pos (16UL)                /*!< INOVER (Bit 16)                                       */
#define IO_QSPI_GPIO_QSPI_SD0_CTRL_INOVER_Msk (0x30000UL)           /*!< INOVER (Bitfield-Mask: 0x03)                          */
#define IO_QSPI_GPIO_QSPI_SD0_CTRL_OEOVER_Pos (12UL)                /*!< OEOVER (Bit 12)                                       */
#define IO_QSPI_GPIO_QSPI_SD0_CTRL_OEOVER_Msk (0x3000UL)            /*!< OEOVER (Bitfield-Mask: 0x03)                          */
#define IO_QSPI_GPIO_QSPI_SD0_CTRL_OUTOVER_Pos (8UL)                /*!< OUTOVER (Bit 8)                                       */
#define IO_QSPI_GPIO_QSPI_SD0_CTRL_OUTOVER_Msk (0x300UL)            /*!< OUTOVER (Bitfield-Mask: 0x03)                         */
#define IO_QSPI_GPIO_QSPI_SD0_CTRL_FUNCSEL_Pos (0UL)                /*!< FUNCSEL (Bit 0)                                       */
#define IO_QSPI_GPIO_QSPI_SD0_CTRL_FUNCSEL_Msk (0x1fUL)             /*!< FUNCSEL (Bitfield-Mask: 0x1f)                         */
/* =================================================  GPIO_QSPI_SD1_STATUS  ================================================== */
#define IO_QSPI_GPIO_QSPI_SD1_STATUS_IRQTOPROC_Pos (26UL)           /*!< IRQTOPROC (Bit 26)                                    */
#define IO_QSPI_GPIO_QSPI_SD1_STATUS_IRQTOPROC_Msk (0x4000000UL)    /*!< IRQTOPROC (Bitfield-Mask: 0x01)                       */
#define IO_QSPI_GPIO_QSPI_SD1_STATUS_IRQFROMPAD_Pos (24UL)          /*!< IRQFROMPAD (Bit 24)                                   */
#define IO_QSPI_GPIO_QSPI_SD1_STATUS_IRQFROMPAD_Msk (0x1000000UL)   /*!< IRQFROMPAD (Bitfield-Mask: 0x01)                      */
#define IO_QSPI_GPIO_QSPI_SD1_STATUS_INTOPERI_Pos (19UL)            /*!< INTOPERI (Bit 19)                                     */
#define IO_QSPI_GPIO_QSPI_SD1_STATUS_INTOPERI_Msk (0x80000UL)       /*!< INTOPERI (Bitfield-Mask: 0x01)                        */
#define IO_QSPI_GPIO_QSPI_SD1_STATUS_INFROMPAD_Pos (17UL)           /*!< INFROMPAD (Bit 17)                                    */
#define IO_QSPI_GPIO_QSPI_SD1_STATUS_INFROMPAD_Msk (0x20000UL)      /*!< INFROMPAD (Bitfield-Mask: 0x01)                       */
#define IO_QSPI_GPIO_QSPI_SD1_STATUS_OETOPAD_Pos (13UL)             /*!< OETOPAD (Bit 13)                                      */
#define IO_QSPI_GPIO_QSPI_SD1_STATUS_OETOPAD_Msk (0x2000UL)         /*!< OETOPAD (Bitfield-Mask: 0x01)                         */
#define IO_QSPI_GPIO_QSPI_SD1_STATUS_OEFROMPERI_Pos (12UL)          /*!< OEFROMPERI (Bit 12)                                   */
#define IO_QSPI_GPIO_QSPI_SD1_STATUS_OEFROMPERI_Msk (0x1000UL)      /*!< OEFROMPERI (Bitfield-Mask: 0x01)                      */
#define IO_QSPI_GPIO_QSPI_SD1_STATUS_OUTTOPAD_Pos (9UL)             /*!< OUTTOPAD (Bit 9)                                      */
#define IO_QSPI_GPIO_QSPI_SD1_STATUS_OUTTOPAD_Msk (0x200UL)         /*!< OUTTOPAD (Bitfield-Mask: 0x01)                        */
#define IO_QSPI_GPIO_QSPI_SD1_STATUS_OUTFROMPERI_Pos (8UL)          /*!< OUTFROMPERI (Bit 8)                                   */
#define IO_QSPI_GPIO_QSPI_SD1_STATUS_OUTFROMPERI_Msk (0x100UL)      /*!< OUTFROMPERI (Bitfield-Mask: 0x01)                     */
/* ==================================================  GPIO_QSPI_SD1_CTRL  =================================================== */
#define IO_QSPI_GPIO_QSPI_SD1_CTRL_IRQOVER_Pos (28UL)               /*!< IRQOVER (Bit 28)                                      */
#define IO_QSPI_GPIO_QSPI_SD1_CTRL_IRQOVER_Msk (0x30000000UL)       /*!< IRQOVER (Bitfield-Mask: 0x03)                         */
#define IO_QSPI_GPIO_QSPI_SD1_CTRL_INOVER_Pos (16UL)                /*!< INOVER (Bit 16)                                       */
#define IO_QSPI_GPIO_QSPI_SD1_CTRL_INOVER_Msk (0x30000UL)           /*!< INOVER (Bitfield-Mask: 0x03)                          */
#define IO_QSPI_GPIO_QSPI_SD1_CTRL_OEOVER_Pos (12UL)                /*!< OEOVER (Bit 12)                                       */
#define IO_QSPI_GPIO_QSPI_SD1_CTRL_OEOVER_Msk (0x3000UL)            /*!< OEOVER (Bitfield-Mask: 0x03)                          */
#define IO_QSPI_GPIO_QSPI_SD1_CTRL_OUTOVER_Pos (8UL)                /*!< OUTOVER (Bit 8)                                       */
#define IO_QSPI_GPIO_QSPI_SD1_CTRL_OUTOVER_Msk (0x300UL)            /*!< OUTOVER (Bitfield-Mask: 0x03)                         */
#define IO_QSPI_GPIO_QSPI_SD1_CTRL_FUNCSEL_Pos (0UL)                /*!< FUNCSEL (Bit 0)                                       */
#define IO_QSPI_GPIO_QSPI_SD1_CTRL_FUNCSEL_Msk (0x1fUL)             /*!< FUNCSEL (Bitfield-Mask: 0x1f)                         */
/* =================================================  GPIO_QSPI_SD2_STATUS  ================================================== */
#define IO_QSPI_GPIO_QSPI_SD2_STATUS_IRQTOPROC_Pos (26UL)           /*!< IRQTOPROC (Bit 26)                                    */
#define IO_QSPI_GPIO_QSPI_SD2_STATUS_IRQTOPROC_Msk (0x4000000UL)    /*!< IRQTOPROC (Bitfield-Mask: 0x01)                       */
#define IO_QSPI_GPIO_QSPI_SD2_STATUS_IRQFROMPAD_Pos (24UL)          /*!< IRQFROMPAD (Bit 24)                                   */
#define IO_QSPI_GPIO_QSPI_SD2_STATUS_IRQFROMPAD_Msk (0x1000000UL)   /*!< IRQFROMPAD (Bitfield-Mask: 0x01)                      */
#define IO_QSPI_GPIO_QSPI_SD2_STATUS_INTOPERI_Pos (19UL)            /*!< INTOPERI (Bit 19)                                     */
#define IO_QSPI_GPIO_QSPI_SD2_STATUS_INTOPERI_Msk (0x80000UL)       /*!< INTOPERI (Bitfield-Mask: 0x01)                        */
#define IO_QSPI_GPIO_QSPI_SD2_STATUS_INFROMPAD_Pos (17UL)           /*!< INFROMPAD (Bit 17)                                    */
#define IO_QSPI_GPIO_QSPI_SD2_STATUS_INFROMPAD_Msk (0x20000UL)      /*!< INFROMPAD (Bitfield-Mask: 0x01)                       */
#define IO_QSPI_GPIO_QSPI_SD2_STATUS_OETOPAD_Pos (13UL)             /*!< OETOPAD (Bit 13)                                      */
#define IO_QSPI_GPIO_QSPI_SD2_STATUS_OETOPAD_Msk (0x2000UL)         /*!< OETOPAD (Bitfield-Mask: 0x01)                         */
#define IO_QSPI_GPIO_QSPI_SD2_STATUS_OEFROMPERI_Pos (12UL)          /*!< OEFROMPERI (Bit 12)                                   */
#define IO_QSPI_GPIO_QSPI_SD2_STATUS_OEFROMPERI_Msk (0x1000UL)      /*!< OEFROMPERI (Bitfield-Mask: 0x01)                      */
#define IO_QSPI_GPIO_QSPI_SD2_STATUS_OUTTOPAD_Pos (9UL)             /*!< OUTTOPAD (Bit 9)                                      */
#define IO_QSPI_GPIO_QSPI_SD2_STATUS_OUTTOPAD_Msk (0x200UL)         /*!< OUTTOPAD (Bitfield-Mask: 0x01)                        */
#define IO_QSPI_GPIO_QSPI_SD2_STATUS_OUTFROMPERI_Pos (8UL)          /*!< OUTFROMPERI (Bit 8)                                   */
#define IO_QSPI_GPIO_QSPI_SD2_STATUS_OUTFROMPERI_Msk (0x100UL)      /*!< OUTFROMPERI (Bitfield-Mask: 0x01)                     */
/* ==================================================  GPIO_QSPI_SD2_CTRL  =================================================== */
#define IO_QSPI_GPIO_QSPI_SD2_CTRL_IRQOVER_Pos (28UL)               /*!< IRQOVER (Bit 28)                                      */
#define IO_QSPI_GPIO_QSPI_SD2_CTRL_IRQOVER_Msk (0x30000000UL)       /*!< IRQOVER (Bitfield-Mask: 0x03)                         */
#define IO_QSPI_GPIO_QSPI_SD2_CTRL_INOVER_Pos (16UL)                /*!< INOVER (Bit 16)                                       */
#define IO_QSPI_GPIO_QSPI_SD2_CTRL_INOVER_Msk (0x30000UL)           /*!< INOVER (Bitfield-Mask: 0x03)                          */
#define IO_QSPI_GPIO_QSPI_SD2_CTRL_OEOVER_Pos (12UL)                /*!< OEOVER (Bit 12)                                       */
#define IO_QSPI_GPIO_QSPI_SD2_CTRL_OEOVER_Msk (0x3000UL)            /*!< OEOVER (Bitfield-Mask: 0x03)                          */
#define IO_QSPI_GPIO_QSPI_SD2_CTRL_OUTOVER_Pos (8UL)                /*!< OUTOVER (Bit 8)                                       */
#define IO_QSPI_GPIO_QSPI_SD2_CTRL_OUTOVER_Msk (0x300UL)            /*!< OUTOVER (Bitfield-Mask: 0x03)                         */
#define IO_QSPI_GPIO_QSPI_SD2_CTRL_FUNCSEL_Pos (0UL)                /*!< FUNCSEL (Bit 0)                                       */
#define IO_QSPI_GPIO_QSPI_SD2_CTRL_FUNCSEL_Msk (0x1fUL)             /*!< FUNCSEL (Bitfield-Mask: 0x1f)                         */
/* =================================================  GPIO_QSPI_SD3_STATUS  ================================================== */
#define IO_QSPI_GPIO_QSPI_SD3_STATUS_IRQTOPROC_Pos (26UL)           /*!< IRQTOPROC (Bit 26)                                    */
#define IO_QSPI_GPIO_QSPI_SD3_STATUS_IRQTOPROC_Msk (0x4000000UL)    /*!< IRQTOPROC (Bitfield-Mask: 0x01)                       */
#define IO_QSPI_GPIO_QSPI_SD3_STATUS_IRQFROMPAD_Pos (24UL)          /*!< IRQFROMPAD (Bit 24)                                   */
#define IO_QSPI_GPIO_QSPI_SD3_STATUS_IRQFROMPAD_Msk (0x1000000UL)   /*!< IRQFROMPAD (Bitfield-Mask: 0x01)                      */
#define IO_QSPI_GPIO_QSPI_SD3_STATUS_INTOPERI_Pos (19UL)            /*!< INTOPERI (Bit 19)                                     */
#define IO_QSPI_GPIO_QSPI_SD3_STATUS_INTOPERI_Msk (0x80000UL)       /*!< INTOPERI (Bitfield-Mask: 0x01)                        */
#define IO_QSPI_GPIO_QSPI_SD3_STATUS_INFROMPAD_Pos (17UL)           /*!< INFROMPAD (Bit 17)                                    */
#define IO_QSPI_GPIO_QSPI_SD3_STATUS_INFROMPAD_Msk (0x20000UL)      /*!< INFROMPAD (Bitfield-Mask: 0x01)                       */
#define IO_QSPI_GPIO_QSPI_SD3_STATUS_OETOPAD_Pos (13UL)             /*!< OETOPAD (Bit 13)                                      */
#define IO_QSPI_GPIO_QSPI_SD3_STATUS_OETOPAD_Msk (0x2000UL)         /*!< OETOPAD (Bitfield-Mask: 0x01)                         */
#define IO_QSPI_GPIO_QSPI_SD3_STATUS_OEFROMPERI_Pos (12UL)          /*!< OEFROMPERI (Bit 12)                                   */
#define IO_QSPI_GPIO_QSPI_SD3_STATUS_OEFROMPERI_Msk (0x1000UL)      /*!< OEFROMPERI (Bitfield-Mask: 0x01)                      */
#define IO_QSPI_GPIO_QSPI_SD3_STATUS_OUTTOPAD_Pos (9UL)             /*!< OUTTOPAD (Bit 9)                                      */
#define IO_QSPI_GPIO_QSPI_SD3_STATUS_OUTTOPAD_Msk (0x200UL)         /*!< OUTTOPAD (Bitfield-Mask: 0x01)                        */
#define IO_QSPI_GPIO_QSPI_SD3_STATUS_OUTFROMPERI_Pos (8UL)          /*!< OUTFROMPERI (Bit 8)                                   */
#define IO_QSPI_GPIO_QSPI_SD3_STATUS_OUTFROMPERI_Msk (0x100UL)      /*!< OUTFROMPERI (Bitfield-Mask: 0x01)                     */
/* ==================================================  GPIO_QSPI_SD3_CTRL  =================================================== */
#define IO_QSPI_GPIO_QSPI_SD3_CTRL_IRQOVER_Pos (28UL)               /*!< IRQOVER (Bit 28)                                      */
#define IO_QSPI_GPIO_QSPI_SD3_CTRL_IRQOVER_Msk (0x30000000UL)       /*!< IRQOVER (Bitfield-Mask: 0x03)                         */
#define IO_QSPI_GPIO_QSPI_SD3_CTRL_INOVER_Pos (16UL)                /*!< INOVER (Bit 16)                                       */
#define IO_QSPI_GPIO_QSPI_SD3_CTRL_INOVER_Msk (0x30000UL)           /*!< INOVER (Bitfield-Mask: 0x03)                          */
#define IO_QSPI_GPIO_QSPI_SD3_CTRL_OEOVER_Pos (12UL)                /*!< OEOVER (Bit 12)                                       */
#define IO_QSPI_GPIO_QSPI_SD3_CTRL_OEOVER_Msk (0x3000UL)            /*!< OEOVER (Bitfield-Mask: 0x03)                          */
#define IO_QSPI_GPIO_QSPI_SD3_CTRL_OUTOVER_Pos (8UL)                /*!< OUTOVER (Bit 8)                                       */
#define IO_QSPI_GPIO_QSPI_SD3_CTRL_OUTOVER_Msk (0x300UL)            /*!< OUTOVER (Bitfield-Mask: 0x03)                         */
#define IO_QSPI_GPIO_QSPI_SD3_CTRL_FUNCSEL_Pos (0UL)                /*!< FUNCSEL (Bit 0)                                       */
#define IO_QSPI_GPIO_QSPI_SD3_CTRL_FUNCSEL_Msk (0x1fUL)             /*!< FUNCSEL (Bitfield-Mask: 0x1f)                         */
/* =========================================================  INTR  ========================================================== */
#define IO_QSPI_INTR_GPIO_QSPI_SD3_EDGE_HIGH_Pos (23UL)             /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bit 23)                      */
#define IO_QSPI_INTR_GPIO_QSPI_SD3_EDGE_HIGH_Msk (0x800000UL)       /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bitfield-Mask: 0x01)         */
#define IO_QSPI_INTR_GPIO_QSPI_SD3_EDGE_LOW_Pos (22UL)              /*!< GPIO_QSPI_SD3_EDGE_LOW (Bit 22)                       */
#define IO_QSPI_INTR_GPIO_QSPI_SD3_EDGE_LOW_Msk (0x400000UL)        /*!< GPIO_QSPI_SD3_EDGE_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_INTR_GPIO_QSPI_SD3_LEVEL_HIGH_Pos (21UL)            /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bit 21)                     */
#define IO_QSPI_INTR_GPIO_QSPI_SD3_LEVEL_HIGH_Msk (0x200000UL)      /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bitfield-Mask: 0x01)        */
#define IO_QSPI_INTR_GPIO_QSPI_SD3_LEVEL_LOW_Pos (20UL)             /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bit 20)                      */
#define IO_QSPI_INTR_GPIO_QSPI_SD3_LEVEL_LOW_Msk (0x100000UL)       /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bitfield-Mask: 0x01)         */
#define IO_QSPI_INTR_GPIO_QSPI_SD2_EDGE_HIGH_Pos (19UL)             /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bit 19)                      */
#define IO_QSPI_INTR_GPIO_QSPI_SD2_EDGE_HIGH_Msk (0x80000UL)        /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bitfield-Mask: 0x01)         */
#define IO_QSPI_INTR_GPIO_QSPI_SD2_EDGE_LOW_Pos (18UL)              /*!< GPIO_QSPI_SD2_EDGE_LOW (Bit 18)                       */
#define IO_QSPI_INTR_GPIO_QSPI_SD2_EDGE_LOW_Msk (0x40000UL)         /*!< GPIO_QSPI_SD2_EDGE_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_INTR_GPIO_QSPI_SD2_LEVEL_HIGH_Pos (17UL)            /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bit 17)                     */
#define IO_QSPI_INTR_GPIO_QSPI_SD2_LEVEL_HIGH_Msk (0x20000UL)       /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bitfield-Mask: 0x01)        */
#define IO_QSPI_INTR_GPIO_QSPI_SD2_LEVEL_LOW_Pos (16UL)             /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bit 16)                      */
#define IO_QSPI_INTR_GPIO_QSPI_SD2_LEVEL_LOW_Msk (0x10000UL)        /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bitfield-Mask: 0x01)         */
#define IO_QSPI_INTR_GPIO_QSPI_SD1_EDGE_HIGH_Pos (15UL)             /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bit 15)                      */
#define IO_QSPI_INTR_GPIO_QSPI_SD1_EDGE_HIGH_Msk (0x8000UL)         /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bitfield-Mask: 0x01)         */
#define IO_QSPI_INTR_GPIO_QSPI_SD1_EDGE_LOW_Pos (14UL)              /*!< GPIO_QSPI_SD1_EDGE_LOW (Bit 14)                       */
#define IO_QSPI_INTR_GPIO_QSPI_SD1_EDGE_LOW_Msk (0x4000UL)          /*!< GPIO_QSPI_SD1_EDGE_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_INTR_GPIO_QSPI_SD1_LEVEL_HIGH_Pos (13UL)            /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bit 13)                     */
#define IO_QSPI_INTR_GPIO_QSPI_SD1_LEVEL_HIGH_Msk (0x2000UL)        /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bitfield-Mask: 0x01)        */
#define IO_QSPI_INTR_GPIO_QSPI_SD1_LEVEL_LOW_Pos (12UL)             /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bit 12)                      */
#define IO_QSPI_INTR_GPIO_QSPI_SD1_LEVEL_LOW_Msk (0x1000UL)         /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bitfield-Mask: 0x01)         */
#define IO_QSPI_INTR_GPIO_QSPI_SD0_EDGE_HIGH_Pos (11UL)             /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bit 11)                      */
#define IO_QSPI_INTR_GPIO_QSPI_SD0_EDGE_HIGH_Msk (0x800UL)          /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bitfield-Mask: 0x01)         */
#define IO_QSPI_INTR_GPIO_QSPI_SD0_EDGE_LOW_Pos (10UL)              /*!< GPIO_QSPI_SD0_EDGE_LOW (Bit 10)                       */
#define IO_QSPI_INTR_GPIO_QSPI_SD0_EDGE_LOW_Msk (0x400UL)           /*!< GPIO_QSPI_SD0_EDGE_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_INTR_GPIO_QSPI_SD0_LEVEL_HIGH_Pos (9UL)             /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bit 9)                      */
#define IO_QSPI_INTR_GPIO_QSPI_SD0_LEVEL_HIGH_Msk (0x200UL)         /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bitfield-Mask: 0x01)        */
#define IO_QSPI_INTR_GPIO_QSPI_SD0_LEVEL_LOW_Pos (8UL)              /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bit 8)                       */
#define IO_QSPI_INTR_GPIO_QSPI_SD0_LEVEL_LOW_Msk (0x100UL)          /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bitfield-Mask: 0x01)         */
#define IO_QSPI_INTR_GPIO_QSPI_SS_EDGE_HIGH_Pos (7UL)               /*!< GPIO_QSPI_SS_EDGE_HIGH (Bit 7)                        */
#define IO_QSPI_INTR_GPIO_QSPI_SS_EDGE_HIGH_Msk (0x80UL)            /*!< GPIO_QSPI_SS_EDGE_HIGH (Bitfield-Mask: 0x01)          */
#define IO_QSPI_INTR_GPIO_QSPI_SS_EDGE_LOW_Pos (6UL)                /*!< GPIO_QSPI_SS_EDGE_LOW (Bit 6)                         */
#define IO_QSPI_INTR_GPIO_QSPI_SS_EDGE_LOW_Msk (0x40UL)             /*!< GPIO_QSPI_SS_EDGE_LOW (Bitfield-Mask: 0x01)           */
#define IO_QSPI_INTR_GPIO_QSPI_SS_LEVEL_HIGH_Pos (5UL)              /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bit 5)                       */
#define IO_QSPI_INTR_GPIO_QSPI_SS_LEVEL_HIGH_Msk (0x20UL)           /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bitfield-Mask: 0x01)         */
#define IO_QSPI_INTR_GPIO_QSPI_SS_LEVEL_LOW_Pos (4UL)               /*!< GPIO_QSPI_SS_LEVEL_LOW (Bit 4)                        */
#define IO_QSPI_INTR_GPIO_QSPI_SS_LEVEL_LOW_Msk (0x10UL)            /*!< GPIO_QSPI_SS_LEVEL_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_INTR_GPIO_QSPI_SCLK_EDGE_HIGH_Pos (3UL)             /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bit 3)                      */
#define IO_QSPI_INTR_GPIO_QSPI_SCLK_EDGE_HIGH_Msk (0x8UL)           /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bitfield-Mask: 0x01)        */
#define IO_QSPI_INTR_GPIO_QSPI_SCLK_EDGE_LOW_Pos (2UL)              /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bit 2)                       */
#define IO_QSPI_INTR_GPIO_QSPI_SCLK_EDGE_LOW_Msk (0x4UL)            /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bitfield-Mask: 0x01)         */
#define IO_QSPI_INTR_GPIO_QSPI_SCLK_LEVEL_HIGH_Pos (1UL)            /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bit 1)                     */
#define IO_QSPI_INTR_GPIO_QSPI_SCLK_LEVEL_HIGH_Msk (0x2UL)          /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bitfield-Mask: 0x01)       */
#define IO_QSPI_INTR_GPIO_QSPI_SCLK_LEVEL_LOW_Pos (0UL)             /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bit 0)                      */
#define IO_QSPI_INTR_GPIO_QSPI_SCLK_LEVEL_LOW_Msk (0x1UL)           /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bitfield-Mask: 0x01)        */
/* ======================================================  PROC0_INTE  ======================================================= */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD3_EDGE_HIGH_Pos (23UL)       /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bit 23)                      */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD3_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD3_EDGE_LOW_Pos (22UL)        /*!< GPIO_QSPI_SD3_EDGE_LOW (Bit 22)                       */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD3_EDGE_LOW_Msk (0x400000UL)  /*!< GPIO_QSPI_SD3_EDGE_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD3_LEVEL_HIGH_Pos (21UL)      /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bit 21)                     */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD3_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bitfield-Mask: 0x01)       */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD3_LEVEL_LOW_Pos (20UL)       /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bit 20)                      */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD3_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD2_EDGE_HIGH_Pos (19UL)       /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bit 19)                      */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD2_EDGE_HIGH_Msk (0x80000UL)  /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD2_EDGE_LOW_Pos (18UL)        /*!< GPIO_QSPI_SD2_EDGE_LOW (Bit 18)                       */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD2_EDGE_LOW_Msk (0x40000UL)   /*!< GPIO_QSPI_SD2_EDGE_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD2_LEVEL_HIGH_Pos (17UL)      /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bit 17)                     */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD2_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bitfield-Mask: 0x01)        */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD2_LEVEL_LOW_Pos (16UL)       /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bit 16)                      */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD2_LEVEL_LOW_Msk (0x10000UL)  /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD1_EDGE_HIGH_Pos (15UL)       /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bit 15)                      */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD1_EDGE_HIGH_Msk (0x8000UL)   /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD1_EDGE_LOW_Pos (14UL)        /*!< GPIO_QSPI_SD1_EDGE_LOW (Bit 14)                       */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD1_EDGE_LOW_Msk (0x4000UL)    /*!< GPIO_QSPI_SD1_EDGE_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD1_LEVEL_HIGH_Pos (13UL)      /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bit 13)                     */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD1_LEVEL_HIGH_Msk (0x2000UL)  /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bitfield-Mask: 0x01)        */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD1_LEVEL_LOW_Pos (12UL)       /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bit 12)                      */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD1_LEVEL_LOW_Msk (0x1000UL)   /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD0_EDGE_HIGH_Pos (11UL)       /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bit 11)                      */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD0_EDGE_HIGH_Msk (0x800UL)    /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD0_EDGE_LOW_Pos (10UL)        /*!< GPIO_QSPI_SD0_EDGE_LOW (Bit 10)                       */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD0_EDGE_LOW_Msk (0x400UL)     /*!< GPIO_QSPI_SD0_EDGE_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD0_LEVEL_HIGH_Pos (9UL)       /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bit 9)                      */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD0_LEVEL_HIGH_Msk (0x200UL)   /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bitfield-Mask: 0x01)        */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD0_LEVEL_LOW_Pos (8UL)        /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bit 8)                       */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SD0_LEVEL_LOW_Msk (0x100UL)    /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SS_EDGE_HIGH_Pos (7UL)         /*!< GPIO_QSPI_SS_EDGE_HIGH (Bit 7)                        */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SS_EDGE_HIGH_Msk (0x80UL)      /*!< GPIO_QSPI_SS_EDGE_HIGH (Bitfield-Mask: 0x01)          */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SS_EDGE_LOW_Pos (6UL)          /*!< GPIO_QSPI_SS_EDGE_LOW (Bit 6)                         */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SS_EDGE_LOW_Msk (0x40UL)       /*!< GPIO_QSPI_SS_EDGE_LOW (Bitfield-Mask: 0x01)           */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SS_LEVEL_HIGH_Pos (5UL)        /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bit 5)                       */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SS_LEVEL_HIGH_Msk (0x20UL)     /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SS_LEVEL_LOW_Pos (4UL)         /*!< GPIO_QSPI_SS_LEVEL_LOW (Bit 4)                        */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SS_LEVEL_LOW_Msk (0x10UL)      /*!< GPIO_QSPI_SS_LEVEL_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SCLK_EDGE_HIGH_Pos (3UL)       /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bit 3)                      */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SCLK_EDGE_HIGH_Msk (0x8UL)     /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bitfield-Mask: 0x01)        */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SCLK_EDGE_LOW_Pos (2UL)        /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bit 2)                       */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SCLK_EDGE_LOW_Msk (0x4UL)      /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SCLK_LEVEL_HIGH_Pos (1UL)      /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bit 1)                     */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SCLK_LEVEL_HIGH_Msk (0x2UL)    /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bitfield-Mask: 0x01)       */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SCLK_LEVEL_LOW_Pos (0UL)       /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bit 0)                      */
#define IO_QSPI_PROC0_INTE_GPIO_QSPI_SCLK_LEVEL_LOW_Msk (0x1UL)     /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bitfield-Mask: 0x01)        */
/* ======================================================  PROC0_INTF  ======================================================= */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD3_EDGE_HIGH_Pos (23UL)       /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bit 23)                      */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD3_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD3_EDGE_LOW_Pos (22UL)        /*!< GPIO_QSPI_SD3_EDGE_LOW (Bit 22)                       */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD3_EDGE_LOW_Msk (0x400000UL)  /*!< GPIO_QSPI_SD3_EDGE_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD3_LEVEL_HIGH_Pos (21UL)      /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bit 21)                     */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD3_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bitfield-Mask: 0x01)       */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD3_LEVEL_LOW_Pos (20UL)       /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bit 20)                      */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD3_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD2_EDGE_HIGH_Pos (19UL)       /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bit 19)                      */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD2_EDGE_HIGH_Msk (0x80000UL)  /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD2_EDGE_LOW_Pos (18UL)        /*!< GPIO_QSPI_SD2_EDGE_LOW (Bit 18)                       */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD2_EDGE_LOW_Msk (0x40000UL)   /*!< GPIO_QSPI_SD2_EDGE_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD2_LEVEL_HIGH_Pos (17UL)      /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bit 17)                     */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD2_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bitfield-Mask: 0x01)        */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD2_LEVEL_LOW_Pos (16UL)       /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bit 16)                      */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD2_LEVEL_LOW_Msk (0x10000UL)  /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD1_EDGE_HIGH_Pos (15UL)       /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bit 15)                      */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD1_EDGE_HIGH_Msk (0x8000UL)   /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD1_EDGE_LOW_Pos (14UL)        /*!< GPIO_QSPI_SD1_EDGE_LOW (Bit 14)                       */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD1_EDGE_LOW_Msk (0x4000UL)    /*!< GPIO_QSPI_SD1_EDGE_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD1_LEVEL_HIGH_Pos (13UL)      /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bit 13)                     */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD1_LEVEL_HIGH_Msk (0x2000UL)  /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bitfield-Mask: 0x01)        */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD1_LEVEL_LOW_Pos (12UL)       /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bit 12)                      */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD1_LEVEL_LOW_Msk (0x1000UL)   /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD0_EDGE_HIGH_Pos (11UL)       /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bit 11)                      */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD0_EDGE_HIGH_Msk (0x800UL)    /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD0_EDGE_LOW_Pos (10UL)        /*!< GPIO_QSPI_SD0_EDGE_LOW (Bit 10)                       */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD0_EDGE_LOW_Msk (0x400UL)     /*!< GPIO_QSPI_SD0_EDGE_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD0_LEVEL_HIGH_Pos (9UL)       /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bit 9)                      */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD0_LEVEL_HIGH_Msk (0x200UL)   /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bitfield-Mask: 0x01)        */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD0_LEVEL_LOW_Pos (8UL)        /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bit 8)                       */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SD0_LEVEL_LOW_Msk (0x100UL)    /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SS_EDGE_HIGH_Pos (7UL)         /*!< GPIO_QSPI_SS_EDGE_HIGH (Bit 7)                        */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SS_EDGE_HIGH_Msk (0x80UL)      /*!< GPIO_QSPI_SS_EDGE_HIGH (Bitfield-Mask: 0x01)          */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SS_EDGE_LOW_Pos (6UL)          /*!< GPIO_QSPI_SS_EDGE_LOW (Bit 6)                         */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SS_EDGE_LOW_Msk (0x40UL)       /*!< GPIO_QSPI_SS_EDGE_LOW (Bitfield-Mask: 0x01)           */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SS_LEVEL_HIGH_Pos (5UL)        /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bit 5)                       */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SS_LEVEL_HIGH_Msk (0x20UL)     /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SS_LEVEL_LOW_Pos (4UL)         /*!< GPIO_QSPI_SS_LEVEL_LOW (Bit 4)                        */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SS_LEVEL_LOW_Msk (0x10UL)      /*!< GPIO_QSPI_SS_LEVEL_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SCLK_EDGE_HIGH_Pos (3UL)       /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bit 3)                      */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SCLK_EDGE_HIGH_Msk (0x8UL)     /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bitfield-Mask: 0x01)        */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SCLK_EDGE_LOW_Pos (2UL)        /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bit 2)                       */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SCLK_EDGE_LOW_Msk (0x4UL)      /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SCLK_LEVEL_HIGH_Pos (1UL)      /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bit 1)                     */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SCLK_LEVEL_HIGH_Msk (0x2UL)    /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bitfield-Mask: 0x01)       */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SCLK_LEVEL_LOW_Pos (0UL)       /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bit 0)                      */
#define IO_QSPI_PROC0_INTF_GPIO_QSPI_SCLK_LEVEL_LOW_Msk (0x1UL)     /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bitfield-Mask: 0x01)        */
/* ======================================================  PROC0_INTS  ======================================================= */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD3_EDGE_HIGH_Pos (23UL)       /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bit 23)                      */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD3_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD3_EDGE_LOW_Pos (22UL)        /*!< GPIO_QSPI_SD3_EDGE_LOW (Bit 22)                       */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD3_EDGE_LOW_Msk (0x400000UL)  /*!< GPIO_QSPI_SD3_EDGE_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD3_LEVEL_HIGH_Pos (21UL)      /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bit 21)                     */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD3_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bitfield-Mask: 0x01)       */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD3_LEVEL_LOW_Pos (20UL)       /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bit 20)                      */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD3_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD2_EDGE_HIGH_Pos (19UL)       /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bit 19)                      */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD2_EDGE_HIGH_Msk (0x80000UL)  /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD2_EDGE_LOW_Pos (18UL)        /*!< GPIO_QSPI_SD2_EDGE_LOW (Bit 18)                       */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD2_EDGE_LOW_Msk (0x40000UL)   /*!< GPIO_QSPI_SD2_EDGE_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD2_LEVEL_HIGH_Pos (17UL)      /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bit 17)                     */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD2_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bitfield-Mask: 0x01)        */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD2_LEVEL_LOW_Pos (16UL)       /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bit 16)                      */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD2_LEVEL_LOW_Msk (0x10000UL)  /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD1_EDGE_HIGH_Pos (15UL)       /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bit 15)                      */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD1_EDGE_HIGH_Msk (0x8000UL)   /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD1_EDGE_LOW_Pos (14UL)        /*!< GPIO_QSPI_SD1_EDGE_LOW (Bit 14)                       */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD1_EDGE_LOW_Msk (0x4000UL)    /*!< GPIO_QSPI_SD1_EDGE_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD1_LEVEL_HIGH_Pos (13UL)      /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bit 13)                     */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD1_LEVEL_HIGH_Msk (0x2000UL)  /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bitfield-Mask: 0x01)        */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD1_LEVEL_LOW_Pos (12UL)       /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bit 12)                      */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD1_LEVEL_LOW_Msk (0x1000UL)   /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD0_EDGE_HIGH_Pos (11UL)       /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bit 11)                      */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD0_EDGE_HIGH_Msk (0x800UL)    /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD0_EDGE_LOW_Pos (10UL)        /*!< GPIO_QSPI_SD0_EDGE_LOW (Bit 10)                       */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD0_EDGE_LOW_Msk (0x400UL)     /*!< GPIO_QSPI_SD0_EDGE_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD0_LEVEL_HIGH_Pos (9UL)       /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bit 9)                      */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD0_LEVEL_HIGH_Msk (0x200UL)   /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bitfield-Mask: 0x01)        */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD0_LEVEL_LOW_Pos (8UL)        /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bit 8)                       */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SD0_LEVEL_LOW_Msk (0x100UL)    /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SS_EDGE_HIGH_Pos (7UL)         /*!< GPIO_QSPI_SS_EDGE_HIGH (Bit 7)                        */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SS_EDGE_HIGH_Msk (0x80UL)      /*!< GPIO_QSPI_SS_EDGE_HIGH (Bitfield-Mask: 0x01)          */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SS_EDGE_LOW_Pos (6UL)          /*!< GPIO_QSPI_SS_EDGE_LOW (Bit 6)                         */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SS_EDGE_LOW_Msk (0x40UL)       /*!< GPIO_QSPI_SS_EDGE_LOW (Bitfield-Mask: 0x01)           */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SS_LEVEL_HIGH_Pos (5UL)        /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bit 5)                       */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SS_LEVEL_HIGH_Msk (0x20UL)     /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SS_LEVEL_LOW_Pos (4UL)         /*!< GPIO_QSPI_SS_LEVEL_LOW (Bit 4)                        */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SS_LEVEL_LOW_Msk (0x10UL)      /*!< GPIO_QSPI_SS_LEVEL_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SCLK_EDGE_HIGH_Pos (3UL)       /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bit 3)                      */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SCLK_EDGE_HIGH_Msk (0x8UL)     /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bitfield-Mask: 0x01)        */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SCLK_EDGE_LOW_Pos (2UL)        /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bit 2)                       */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SCLK_EDGE_LOW_Msk (0x4UL)      /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SCLK_LEVEL_HIGH_Pos (1UL)      /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bit 1)                     */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SCLK_LEVEL_HIGH_Msk (0x2UL)    /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bitfield-Mask: 0x01)       */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SCLK_LEVEL_LOW_Pos (0UL)       /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bit 0)                      */
#define IO_QSPI_PROC0_INTS_GPIO_QSPI_SCLK_LEVEL_LOW_Msk (0x1UL)     /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bitfield-Mask: 0x01)        */
/* ======================================================  PROC1_INTE  ======================================================= */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD3_EDGE_HIGH_Pos (23UL)       /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bit 23)                      */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD3_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD3_EDGE_LOW_Pos (22UL)        /*!< GPIO_QSPI_SD3_EDGE_LOW (Bit 22)                       */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD3_EDGE_LOW_Msk (0x400000UL)  /*!< GPIO_QSPI_SD3_EDGE_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD3_LEVEL_HIGH_Pos (21UL)      /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bit 21)                     */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD3_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bitfield-Mask: 0x01)       */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD3_LEVEL_LOW_Pos (20UL)       /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bit 20)                      */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD3_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD2_EDGE_HIGH_Pos (19UL)       /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bit 19)                      */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD2_EDGE_HIGH_Msk (0x80000UL)  /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD2_EDGE_LOW_Pos (18UL)        /*!< GPIO_QSPI_SD2_EDGE_LOW (Bit 18)                       */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD2_EDGE_LOW_Msk (0x40000UL)   /*!< GPIO_QSPI_SD2_EDGE_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD2_LEVEL_HIGH_Pos (17UL)      /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bit 17)                     */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD2_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bitfield-Mask: 0x01)        */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD2_LEVEL_LOW_Pos (16UL)       /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bit 16)                      */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD2_LEVEL_LOW_Msk (0x10000UL)  /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD1_EDGE_HIGH_Pos (15UL)       /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bit 15)                      */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD1_EDGE_HIGH_Msk (0x8000UL)   /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD1_EDGE_LOW_Pos (14UL)        /*!< GPIO_QSPI_SD1_EDGE_LOW (Bit 14)                       */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD1_EDGE_LOW_Msk (0x4000UL)    /*!< GPIO_QSPI_SD1_EDGE_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD1_LEVEL_HIGH_Pos (13UL)      /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bit 13)                     */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD1_LEVEL_HIGH_Msk (0x2000UL)  /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bitfield-Mask: 0x01)        */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD1_LEVEL_LOW_Pos (12UL)       /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bit 12)                      */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD1_LEVEL_LOW_Msk (0x1000UL)   /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD0_EDGE_HIGH_Pos (11UL)       /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bit 11)                      */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD0_EDGE_HIGH_Msk (0x800UL)    /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD0_EDGE_LOW_Pos (10UL)        /*!< GPIO_QSPI_SD0_EDGE_LOW (Bit 10)                       */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD0_EDGE_LOW_Msk (0x400UL)     /*!< GPIO_QSPI_SD0_EDGE_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD0_LEVEL_HIGH_Pos (9UL)       /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bit 9)                      */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD0_LEVEL_HIGH_Msk (0x200UL)   /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bitfield-Mask: 0x01)        */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD0_LEVEL_LOW_Pos (8UL)        /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bit 8)                       */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SD0_LEVEL_LOW_Msk (0x100UL)    /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SS_EDGE_HIGH_Pos (7UL)         /*!< GPIO_QSPI_SS_EDGE_HIGH (Bit 7)                        */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SS_EDGE_HIGH_Msk (0x80UL)      /*!< GPIO_QSPI_SS_EDGE_HIGH (Bitfield-Mask: 0x01)          */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SS_EDGE_LOW_Pos (6UL)          /*!< GPIO_QSPI_SS_EDGE_LOW (Bit 6)                         */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SS_EDGE_LOW_Msk (0x40UL)       /*!< GPIO_QSPI_SS_EDGE_LOW (Bitfield-Mask: 0x01)           */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SS_LEVEL_HIGH_Pos (5UL)        /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bit 5)                       */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SS_LEVEL_HIGH_Msk (0x20UL)     /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SS_LEVEL_LOW_Pos (4UL)         /*!< GPIO_QSPI_SS_LEVEL_LOW (Bit 4)                        */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SS_LEVEL_LOW_Msk (0x10UL)      /*!< GPIO_QSPI_SS_LEVEL_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SCLK_EDGE_HIGH_Pos (3UL)       /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bit 3)                      */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SCLK_EDGE_HIGH_Msk (0x8UL)     /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bitfield-Mask: 0x01)        */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SCLK_EDGE_LOW_Pos (2UL)        /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bit 2)                       */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SCLK_EDGE_LOW_Msk (0x4UL)      /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SCLK_LEVEL_HIGH_Pos (1UL)      /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bit 1)                     */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SCLK_LEVEL_HIGH_Msk (0x2UL)    /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bitfield-Mask: 0x01)       */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SCLK_LEVEL_LOW_Pos (0UL)       /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bit 0)                      */
#define IO_QSPI_PROC1_INTE_GPIO_QSPI_SCLK_LEVEL_LOW_Msk (0x1UL)     /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bitfield-Mask: 0x01)        */
/* ======================================================  PROC1_INTF  ======================================================= */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD3_EDGE_HIGH_Pos (23UL)       /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bit 23)                      */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD3_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD3_EDGE_LOW_Pos (22UL)        /*!< GPIO_QSPI_SD3_EDGE_LOW (Bit 22)                       */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD3_EDGE_LOW_Msk (0x400000UL)  /*!< GPIO_QSPI_SD3_EDGE_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD3_LEVEL_HIGH_Pos (21UL)      /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bit 21)                     */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD3_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bitfield-Mask: 0x01)       */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD3_LEVEL_LOW_Pos (20UL)       /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bit 20)                      */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD3_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD2_EDGE_HIGH_Pos (19UL)       /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bit 19)                      */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD2_EDGE_HIGH_Msk (0x80000UL)  /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD2_EDGE_LOW_Pos (18UL)        /*!< GPIO_QSPI_SD2_EDGE_LOW (Bit 18)                       */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD2_EDGE_LOW_Msk (0x40000UL)   /*!< GPIO_QSPI_SD2_EDGE_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD2_LEVEL_HIGH_Pos (17UL)      /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bit 17)                     */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD2_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bitfield-Mask: 0x01)        */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD2_LEVEL_LOW_Pos (16UL)       /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bit 16)                      */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD2_LEVEL_LOW_Msk (0x10000UL)  /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD1_EDGE_HIGH_Pos (15UL)       /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bit 15)                      */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD1_EDGE_HIGH_Msk (0x8000UL)   /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD1_EDGE_LOW_Pos (14UL)        /*!< GPIO_QSPI_SD1_EDGE_LOW (Bit 14)                       */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD1_EDGE_LOW_Msk (0x4000UL)    /*!< GPIO_QSPI_SD1_EDGE_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD1_LEVEL_HIGH_Pos (13UL)      /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bit 13)                     */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD1_LEVEL_HIGH_Msk (0x2000UL)  /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bitfield-Mask: 0x01)        */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD1_LEVEL_LOW_Pos (12UL)       /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bit 12)                      */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD1_LEVEL_LOW_Msk (0x1000UL)   /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD0_EDGE_HIGH_Pos (11UL)       /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bit 11)                      */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD0_EDGE_HIGH_Msk (0x800UL)    /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD0_EDGE_LOW_Pos (10UL)        /*!< GPIO_QSPI_SD0_EDGE_LOW (Bit 10)                       */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD0_EDGE_LOW_Msk (0x400UL)     /*!< GPIO_QSPI_SD0_EDGE_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD0_LEVEL_HIGH_Pos (9UL)       /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bit 9)                      */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD0_LEVEL_HIGH_Msk (0x200UL)   /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bitfield-Mask: 0x01)        */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD0_LEVEL_LOW_Pos (8UL)        /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bit 8)                       */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SD0_LEVEL_LOW_Msk (0x100UL)    /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SS_EDGE_HIGH_Pos (7UL)         /*!< GPIO_QSPI_SS_EDGE_HIGH (Bit 7)                        */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SS_EDGE_HIGH_Msk (0x80UL)      /*!< GPIO_QSPI_SS_EDGE_HIGH (Bitfield-Mask: 0x01)          */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SS_EDGE_LOW_Pos (6UL)          /*!< GPIO_QSPI_SS_EDGE_LOW (Bit 6)                         */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SS_EDGE_LOW_Msk (0x40UL)       /*!< GPIO_QSPI_SS_EDGE_LOW (Bitfield-Mask: 0x01)           */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SS_LEVEL_HIGH_Pos (5UL)        /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bit 5)                       */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SS_LEVEL_HIGH_Msk (0x20UL)     /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SS_LEVEL_LOW_Pos (4UL)         /*!< GPIO_QSPI_SS_LEVEL_LOW (Bit 4)                        */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SS_LEVEL_LOW_Msk (0x10UL)      /*!< GPIO_QSPI_SS_LEVEL_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SCLK_EDGE_HIGH_Pos (3UL)       /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bit 3)                      */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SCLK_EDGE_HIGH_Msk (0x8UL)     /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bitfield-Mask: 0x01)        */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SCLK_EDGE_LOW_Pos (2UL)        /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bit 2)                       */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SCLK_EDGE_LOW_Msk (0x4UL)      /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SCLK_LEVEL_HIGH_Pos (1UL)      /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bit 1)                     */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SCLK_LEVEL_HIGH_Msk (0x2UL)    /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bitfield-Mask: 0x01)       */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SCLK_LEVEL_LOW_Pos (0UL)       /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bit 0)                      */
#define IO_QSPI_PROC1_INTF_GPIO_QSPI_SCLK_LEVEL_LOW_Msk (0x1UL)     /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bitfield-Mask: 0x01)        */
/* ======================================================  PROC1_INTS  ======================================================= */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD3_EDGE_HIGH_Pos (23UL)       /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bit 23)                      */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD3_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD3_EDGE_LOW_Pos (22UL)        /*!< GPIO_QSPI_SD3_EDGE_LOW (Bit 22)                       */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD3_EDGE_LOW_Msk (0x400000UL)  /*!< GPIO_QSPI_SD3_EDGE_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD3_LEVEL_HIGH_Pos (21UL)      /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bit 21)                     */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD3_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bitfield-Mask: 0x01)       */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD3_LEVEL_LOW_Pos (20UL)       /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bit 20)                      */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD3_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD2_EDGE_HIGH_Pos (19UL)       /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bit 19)                      */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD2_EDGE_HIGH_Msk (0x80000UL)  /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD2_EDGE_LOW_Pos (18UL)        /*!< GPIO_QSPI_SD2_EDGE_LOW (Bit 18)                       */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD2_EDGE_LOW_Msk (0x40000UL)   /*!< GPIO_QSPI_SD2_EDGE_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD2_LEVEL_HIGH_Pos (17UL)      /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bit 17)                     */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD2_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bitfield-Mask: 0x01)        */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD2_LEVEL_LOW_Pos (16UL)       /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bit 16)                      */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD2_LEVEL_LOW_Msk (0x10000UL)  /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD1_EDGE_HIGH_Pos (15UL)       /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bit 15)                      */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD1_EDGE_HIGH_Msk (0x8000UL)   /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD1_EDGE_LOW_Pos (14UL)        /*!< GPIO_QSPI_SD1_EDGE_LOW (Bit 14)                       */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD1_EDGE_LOW_Msk (0x4000UL)    /*!< GPIO_QSPI_SD1_EDGE_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD1_LEVEL_HIGH_Pos (13UL)      /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bit 13)                     */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD1_LEVEL_HIGH_Msk (0x2000UL)  /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bitfield-Mask: 0x01)        */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD1_LEVEL_LOW_Pos (12UL)       /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bit 12)                      */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD1_LEVEL_LOW_Msk (0x1000UL)   /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD0_EDGE_HIGH_Pos (11UL)       /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bit 11)                      */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD0_EDGE_HIGH_Msk (0x800UL)    /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD0_EDGE_LOW_Pos (10UL)        /*!< GPIO_QSPI_SD0_EDGE_LOW (Bit 10)                       */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD0_EDGE_LOW_Msk (0x400UL)     /*!< GPIO_QSPI_SD0_EDGE_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD0_LEVEL_HIGH_Pos (9UL)       /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bit 9)                      */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD0_LEVEL_HIGH_Msk (0x200UL)   /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bitfield-Mask: 0x01)        */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD0_LEVEL_LOW_Pos (8UL)        /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bit 8)                       */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SD0_LEVEL_LOW_Msk (0x100UL)    /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SS_EDGE_HIGH_Pos (7UL)         /*!< GPIO_QSPI_SS_EDGE_HIGH (Bit 7)                        */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SS_EDGE_HIGH_Msk (0x80UL)      /*!< GPIO_QSPI_SS_EDGE_HIGH (Bitfield-Mask: 0x01)          */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SS_EDGE_LOW_Pos (6UL)          /*!< GPIO_QSPI_SS_EDGE_LOW (Bit 6)                         */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SS_EDGE_LOW_Msk (0x40UL)       /*!< GPIO_QSPI_SS_EDGE_LOW (Bitfield-Mask: 0x01)           */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SS_LEVEL_HIGH_Pos (5UL)        /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bit 5)                       */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SS_LEVEL_HIGH_Msk (0x20UL)     /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SS_LEVEL_LOW_Pos (4UL)         /*!< GPIO_QSPI_SS_LEVEL_LOW (Bit 4)                        */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SS_LEVEL_LOW_Msk (0x10UL)      /*!< GPIO_QSPI_SS_LEVEL_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SCLK_EDGE_HIGH_Pos (3UL)       /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bit 3)                      */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SCLK_EDGE_HIGH_Msk (0x8UL)     /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bitfield-Mask: 0x01)        */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SCLK_EDGE_LOW_Pos (2UL)        /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bit 2)                       */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SCLK_EDGE_LOW_Msk (0x4UL)      /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bitfield-Mask: 0x01)         */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SCLK_LEVEL_HIGH_Pos (1UL)      /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bit 1)                     */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SCLK_LEVEL_HIGH_Msk (0x2UL)    /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bitfield-Mask: 0x01)       */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SCLK_LEVEL_LOW_Pos (0UL)       /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bit 0)                      */
#define IO_QSPI_PROC1_INTS_GPIO_QSPI_SCLK_LEVEL_LOW_Msk (0x1UL)     /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bitfield-Mask: 0x01)        */
/* ===================================================  DORMANT_WAKE_INTE  =================================================== */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD3_EDGE_HIGH_Pos (23UL) /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bit 23)                     */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD3_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bitfield-Mask: 0x01)  */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD3_EDGE_LOW_Pos (22UL) /*!< GPIO_QSPI_SD3_EDGE_LOW (Bit 22)                       */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD3_EDGE_LOW_Msk (0x400000UL) /*!< GPIO_QSPI_SD3_EDGE_LOW (Bitfield-Mask: 0x01)    */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD3_LEVEL_HIGH_Pos (21UL) /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bit 21)                   */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD3_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD3_LEVEL_LOW_Pos (20UL) /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bit 20)                     */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD3_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bitfield-Mask: 0x01)  */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD2_EDGE_HIGH_Pos (19UL) /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bit 19)                     */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD2_EDGE_HIGH_Msk (0x80000UL) /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bitfield-Mask: 0x01)   */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD2_EDGE_LOW_Pos (18UL) /*!< GPIO_QSPI_SD2_EDGE_LOW (Bit 18)                       */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD2_EDGE_LOW_Msk (0x40000UL) /*!< GPIO_QSPI_SD2_EDGE_LOW (Bitfield-Mask: 0x01)     */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD2_LEVEL_HIGH_Pos (17UL) /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bit 17)                   */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD2_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD2_LEVEL_LOW_Pos (16UL) /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bit 16)                     */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD2_LEVEL_LOW_Msk (0x10000UL) /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bitfield-Mask: 0x01)   */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD1_EDGE_HIGH_Pos (15UL) /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bit 15)                     */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD1_EDGE_HIGH_Msk (0x8000UL) /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bitfield-Mask: 0x01)    */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD1_EDGE_LOW_Pos (14UL) /*!< GPIO_QSPI_SD1_EDGE_LOW (Bit 14)                       */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD1_EDGE_LOW_Msk (0x4000UL) /*!< GPIO_QSPI_SD1_EDGE_LOW (Bitfield-Mask: 0x01)      */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD1_LEVEL_HIGH_Pos (13UL) /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bit 13)                   */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD1_LEVEL_HIGH_Msk (0x2000UL) /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bitfield-Mask: 0x01)  */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD1_LEVEL_LOW_Pos (12UL) /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bit 12)                     */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD1_LEVEL_LOW_Msk (0x1000UL) /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bitfield-Mask: 0x01)    */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD0_EDGE_HIGH_Pos (11UL) /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bit 11)                     */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD0_EDGE_HIGH_Msk (0x800UL) /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bitfield-Mask: 0x01)     */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD0_EDGE_LOW_Pos (10UL) /*!< GPIO_QSPI_SD0_EDGE_LOW (Bit 10)                       */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD0_EDGE_LOW_Msk (0x400UL) /*!< GPIO_QSPI_SD0_EDGE_LOW (Bitfield-Mask: 0x01)       */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD0_LEVEL_HIGH_Pos (9UL) /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bit 9)                     */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD0_LEVEL_HIGH_Msk (0x200UL) /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bitfield-Mask: 0x01)   */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD0_LEVEL_LOW_Pos (8UL) /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bit 8)                       */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SD0_LEVEL_LOW_Msk (0x100UL) /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bitfield-Mask: 0x01)     */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SS_EDGE_HIGH_Pos (7UL)  /*!< GPIO_QSPI_SS_EDGE_HIGH (Bit 7)                        */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SS_EDGE_HIGH_Msk (0x80UL) /*!< GPIO_QSPI_SS_EDGE_HIGH (Bitfield-Mask: 0x01)        */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SS_EDGE_LOW_Pos (6UL)   /*!< GPIO_QSPI_SS_EDGE_LOW (Bit 6)                         */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SS_EDGE_LOW_Msk (0x40UL) /*!< GPIO_QSPI_SS_EDGE_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SS_LEVEL_HIGH_Pos (5UL) /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bit 5)                       */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SS_LEVEL_HIGH_Msk (0x20UL) /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bitfield-Mask: 0x01)      */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SS_LEVEL_LOW_Pos (4UL)  /*!< GPIO_QSPI_SS_LEVEL_LOW (Bit 4)                        */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SS_LEVEL_LOW_Msk (0x10UL) /*!< GPIO_QSPI_SS_LEVEL_LOW (Bitfield-Mask: 0x01)        */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SCLK_EDGE_HIGH_Pos (3UL) /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bit 3)                     */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SCLK_EDGE_HIGH_Msk (0x8UL) /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bitfield-Mask: 0x01)     */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SCLK_EDGE_LOW_Pos (2UL) /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bit 2)                       */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SCLK_EDGE_LOW_Msk (0x4UL) /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bitfield-Mask: 0x01)       */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SCLK_LEVEL_HIGH_Pos (1UL) /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bit 1)                   */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SCLK_LEVEL_HIGH_Msk (0x2UL) /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bitfield-Mask: 0x01)   */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SCLK_LEVEL_LOW_Pos (0UL) /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bit 0)                     */
#define IO_QSPI_DORMANT_WAKE_INTE_GPIO_QSPI_SCLK_LEVEL_LOW_Msk (0x1UL) /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bitfield-Mask: 0x01)     */
/* ===================================================  DORMANT_WAKE_INTF  =================================================== */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD3_EDGE_HIGH_Pos (23UL) /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bit 23)                     */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD3_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bitfield-Mask: 0x01)  */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD3_EDGE_LOW_Pos (22UL) /*!< GPIO_QSPI_SD3_EDGE_LOW (Bit 22)                       */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD3_EDGE_LOW_Msk (0x400000UL) /*!< GPIO_QSPI_SD3_EDGE_LOW (Bitfield-Mask: 0x01)    */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD3_LEVEL_HIGH_Pos (21UL) /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bit 21)                   */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD3_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD3_LEVEL_LOW_Pos (20UL) /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bit 20)                     */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD3_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bitfield-Mask: 0x01)  */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD2_EDGE_HIGH_Pos (19UL) /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bit 19)                     */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD2_EDGE_HIGH_Msk (0x80000UL) /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bitfield-Mask: 0x01)   */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD2_EDGE_LOW_Pos (18UL) /*!< GPIO_QSPI_SD2_EDGE_LOW (Bit 18)                       */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD2_EDGE_LOW_Msk (0x40000UL) /*!< GPIO_QSPI_SD2_EDGE_LOW (Bitfield-Mask: 0x01)     */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD2_LEVEL_HIGH_Pos (17UL) /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bit 17)                   */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD2_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD2_LEVEL_LOW_Pos (16UL) /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bit 16)                     */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD2_LEVEL_LOW_Msk (0x10000UL) /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bitfield-Mask: 0x01)   */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD1_EDGE_HIGH_Pos (15UL) /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bit 15)                     */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD1_EDGE_HIGH_Msk (0x8000UL) /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bitfield-Mask: 0x01)    */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD1_EDGE_LOW_Pos (14UL) /*!< GPIO_QSPI_SD1_EDGE_LOW (Bit 14)                       */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD1_EDGE_LOW_Msk (0x4000UL) /*!< GPIO_QSPI_SD1_EDGE_LOW (Bitfield-Mask: 0x01)      */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD1_LEVEL_HIGH_Pos (13UL) /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bit 13)                   */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD1_LEVEL_HIGH_Msk (0x2000UL) /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bitfield-Mask: 0x01)  */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD1_LEVEL_LOW_Pos (12UL) /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bit 12)                     */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD1_LEVEL_LOW_Msk (0x1000UL) /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bitfield-Mask: 0x01)    */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD0_EDGE_HIGH_Pos (11UL) /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bit 11)                     */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD0_EDGE_HIGH_Msk (0x800UL) /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bitfield-Mask: 0x01)     */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD0_EDGE_LOW_Pos (10UL) /*!< GPIO_QSPI_SD0_EDGE_LOW (Bit 10)                       */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD0_EDGE_LOW_Msk (0x400UL) /*!< GPIO_QSPI_SD0_EDGE_LOW (Bitfield-Mask: 0x01)       */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD0_LEVEL_HIGH_Pos (9UL) /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bit 9)                     */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD0_LEVEL_HIGH_Msk (0x200UL) /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bitfield-Mask: 0x01)   */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD0_LEVEL_LOW_Pos (8UL) /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bit 8)                       */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SD0_LEVEL_LOW_Msk (0x100UL) /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bitfield-Mask: 0x01)     */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SS_EDGE_HIGH_Pos (7UL)  /*!< GPIO_QSPI_SS_EDGE_HIGH (Bit 7)                        */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SS_EDGE_HIGH_Msk (0x80UL) /*!< GPIO_QSPI_SS_EDGE_HIGH (Bitfield-Mask: 0x01)        */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SS_EDGE_LOW_Pos (6UL)   /*!< GPIO_QSPI_SS_EDGE_LOW (Bit 6)                         */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SS_EDGE_LOW_Msk (0x40UL) /*!< GPIO_QSPI_SS_EDGE_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SS_LEVEL_HIGH_Pos (5UL) /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bit 5)                       */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SS_LEVEL_HIGH_Msk (0x20UL) /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bitfield-Mask: 0x01)      */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SS_LEVEL_LOW_Pos (4UL)  /*!< GPIO_QSPI_SS_LEVEL_LOW (Bit 4)                        */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SS_LEVEL_LOW_Msk (0x10UL) /*!< GPIO_QSPI_SS_LEVEL_LOW (Bitfield-Mask: 0x01)        */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SCLK_EDGE_HIGH_Pos (3UL) /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bit 3)                     */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SCLK_EDGE_HIGH_Msk (0x8UL) /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bitfield-Mask: 0x01)     */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SCLK_EDGE_LOW_Pos (2UL) /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bit 2)                       */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SCLK_EDGE_LOW_Msk (0x4UL) /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bitfield-Mask: 0x01)       */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SCLK_LEVEL_HIGH_Pos (1UL) /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bit 1)                   */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SCLK_LEVEL_HIGH_Msk (0x2UL) /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bitfield-Mask: 0x01)   */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SCLK_LEVEL_LOW_Pos (0UL) /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bit 0)                     */
#define IO_QSPI_DORMANT_WAKE_INTF_GPIO_QSPI_SCLK_LEVEL_LOW_Msk (0x1UL) /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bitfield-Mask: 0x01)     */
/* ===================================================  DORMANT_WAKE_INTS  =================================================== */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD3_EDGE_HIGH_Pos (23UL) /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bit 23)                     */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD3_EDGE_HIGH_Msk (0x800000UL) /*!< GPIO_QSPI_SD3_EDGE_HIGH (Bitfield-Mask: 0x01)  */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD3_EDGE_LOW_Pos (22UL) /*!< GPIO_QSPI_SD3_EDGE_LOW (Bit 22)                       */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD3_EDGE_LOW_Msk (0x400000UL) /*!< GPIO_QSPI_SD3_EDGE_LOW (Bitfield-Mask: 0x01)    */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD3_LEVEL_HIGH_Pos (21UL) /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bit 21)                   */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD3_LEVEL_HIGH_Msk (0x200000UL) /*!< GPIO_QSPI_SD3_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD3_LEVEL_LOW_Pos (20UL) /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bit 20)                     */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD3_LEVEL_LOW_Msk (0x100000UL) /*!< GPIO_QSPI_SD3_LEVEL_LOW (Bitfield-Mask: 0x01)  */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD2_EDGE_HIGH_Pos (19UL) /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bit 19)                     */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD2_EDGE_HIGH_Msk (0x80000UL) /*!< GPIO_QSPI_SD2_EDGE_HIGH (Bitfield-Mask: 0x01)   */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD2_EDGE_LOW_Pos (18UL) /*!< GPIO_QSPI_SD2_EDGE_LOW (Bit 18)                       */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD2_EDGE_LOW_Msk (0x40000UL) /*!< GPIO_QSPI_SD2_EDGE_LOW (Bitfield-Mask: 0x01)     */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD2_LEVEL_HIGH_Pos (17UL) /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bit 17)                   */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD2_LEVEL_HIGH_Msk (0x20000UL) /*!< GPIO_QSPI_SD2_LEVEL_HIGH (Bitfield-Mask: 0x01) */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD2_LEVEL_LOW_Pos (16UL) /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bit 16)                     */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD2_LEVEL_LOW_Msk (0x10000UL) /*!< GPIO_QSPI_SD2_LEVEL_LOW (Bitfield-Mask: 0x01)   */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD1_EDGE_HIGH_Pos (15UL) /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bit 15)                     */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD1_EDGE_HIGH_Msk (0x8000UL) /*!< GPIO_QSPI_SD1_EDGE_HIGH (Bitfield-Mask: 0x01)    */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD1_EDGE_LOW_Pos (14UL) /*!< GPIO_QSPI_SD1_EDGE_LOW (Bit 14)                       */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD1_EDGE_LOW_Msk (0x4000UL) /*!< GPIO_QSPI_SD1_EDGE_LOW (Bitfield-Mask: 0x01)      */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD1_LEVEL_HIGH_Pos (13UL) /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bit 13)                   */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD1_LEVEL_HIGH_Msk (0x2000UL) /*!< GPIO_QSPI_SD1_LEVEL_HIGH (Bitfield-Mask: 0x01)  */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD1_LEVEL_LOW_Pos (12UL) /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bit 12)                     */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD1_LEVEL_LOW_Msk (0x1000UL) /*!< GPIO_QSPI_SD1_LEVEL_LOW (Bitfield-Mask: 0x01)    */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD0_EDGE_HIGH_Pos (11UL) /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bit 11)                     */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD0_EDGE_HIGH_Msk (0x800UL) /*!< GPIO_QSPI_SD0_EDGE_HIGH (Bitfield-Mask: 0x01)     */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD0_EDGE_LOW_Pos (10UL) /*!< GPIO_QSPI_SD0_EDGE_LOW (Bit 10)                       */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD0_EDGE_LOW_Msk (0x400UL) /*!< GPIO_QSPI_SD0_EDGE_LOW (Bitfield-Mask: 0x01)       */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD0_LEVEL_HIGH_Pos (9UL) /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bit 9)                     */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD0_LEVEL_HIGH_Msk (0x200UL) /*!< GPIO_QSPI_SD0_LEVEL_HIGH (Bitfield-Mask: 0x01)   */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD0_LEVEL_LOW_Pos (8UL) /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bit 8)                       */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SD0_LEVEL_LOW_Msk (0x100UL) /*!< GPIO_QSPI_SD0_LEVEL_LOW (Bitfield-Mask: 0x01)     */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SS_EDGE_HIGH_Pos (7UL)  /*!< GPIO_QSPI_SS_EDGE_HIGH (Bit 7)                        */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SS_EDGE_HIGH_Msk (0x80UL) /*!< GPIO_QSPI_SS_EDGE_HIGH (Bitfield-Mask: 0x01)        */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SS_EDGE_LOW_Pos (6UL)   /*!< GPIO_QSPI_SS_EDGE_LOW (Bit 6)                         */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SS_EDGE_LOW_Msk (0x40UL) /*!< GPIO_QSPI_SS_EDGE_LOW (Bitfield-Mask: 0x01)          */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SS_LEVEL_HIGH_Pos (5UL) /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bit 5)                       */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SS_LEVEL_HIGH_Msk (0x20UL) /*!< GPIO_QSPI_SS_LEVEL_HIGH (Bitfield-Mask: 0x01)      */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SS_LEVEL_LOW_Pos (4UL)  /*!< GPIO_QSPI_SS_LEVEL_LOW (Bit 4)                        */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SS_LEVEL_LOW_Msk (0x10UL) /*!< GPIO_QSPI_SS_LEVEL_LOW (Bitfield-Mask: 0x01)        */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SCLK_EDGE_HIGH_Pos (3UL) /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bit 3)                     */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SCLK_EDGE_HIGH_Msk (0x8UL) /*!< GPIO_QSPI_SCLK_EDGE_HIGH (Bitfield-Mask: 0x01)     */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SCLK_EDGE_LOW_Pos (2UL) /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bit 2)                       */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SCLK_EDGE_LOW_Msk (0x4UL) /*!< GPIO_QSPI_SCLK_EDGE_LOW (Bitfield-Mask: 0x01)       */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SCLK_LEVEL_HIGH_Pos (1UL) /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bit 1)                   */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SCLK_LEVEL_HIGH_Msk (0x2UL) /*!< GPIO_QSPI_SCLK_LEVEL_HIGH (Bitfield-Mask: 0x01)   */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SCLK_LEVEL_LOW_Pos (0UL) /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bit 0)                     */
#define IO_QSPI_DORMANT_WAKE_INTS_GPIO_QSPI_SCLK_LEVEL_LOW_Msk (0x1UL) /*!< GPIO_QSPI_SCLK_LEVEL_LOW (Bitfield-Mask: 0x01)     */


/* =========================================================================================================================== */
/* ================                                        PADS_BANK0                                         ================ */
/* =========================================================================================================================== */

/* ====================================================  VOLTAGE_SELECT  ===================================================== */
#define PADS_BANK0_VOLTAGE_SELECT_VOLTAGE_SELECT_Pos (0UL)          /*!< VOLTAGE_SELECT (Bit 0)                                */
#define PADS_BANK0_VOLTAGE_SELECT_VOLTAGE_SELECT_Msk (0x1UL)        /*!< VOLTAGE_SELECT (Bitfield-Mask: 0x01)                  */
/* =========================================================  GPIO0  ========================================================= */
#define PADS_BANK0_GPIO0_OD_Pos           (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_BANK0_GPIO0_OD_Msk           (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO0_IE_Pos           (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_BANK0_GPIO0_IE_Msk           (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO0_DRIVE_Pos        (4UL)                     /*!< DRIVE (Bit 4)                                         */
#define PADS_BANK0_GPIO0_DRIVE_Msk        (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_BANK0_GPIO0_PUE_Pos          (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_BANK0_GPIO0_PUE_Msk          (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO0_PDE_Pos          (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_BANK0_GPIO0_PDE_Msk          (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO0_SCHMITT_Pos      (1UL)                     /*!< SCHMITT (Bit 1)                                       */
#define PADS_BANK0_GPIO0_SCHMITT_Msk      (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_BANK0_GPIO0_SLEWFAST_Pos     (0UL)                     /*!< SLEWFAST (Bit 0)                                      */
#define PADS_BANK0_GPIO0_SLEWFAST_Msk     (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */
/* =========================================================  GPIO1  ========================================================= */
#define PADS_BANK0_GPIO1_OD_Pos           (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_BANK0_GPIO1_OD_Msk           (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO1_IE_Pos           (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_BANK0_GPIO1_IE_Msk           (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO1_DRIVE_Pos        (4UL)                     /*!< DRIVE (Bit 4)                                         */
#define PADS_BANK0_GPIO1_DRIVE_Msk        (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_BANK0_GPIO1_PUE_Pos          (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_BANK0_GPIO1_PUE_Msk          (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO1_PDE_Pos          (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_BANK0_GPIO1_PDE_Msk          (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO1_SCHMITT_Pos      (1UL)                     /*!< SCHMITT (Bit 1)                                       */
#define PADS_BANK0_GPIO1_SCHMITT_Msk      (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_BANK0_GPIO1_SLEWFAST_Pos     (0UL)                     /*!< SLEWFAST (Bit 0)                                      */
#define PADS_BANK0_GPIO1_SLEWFAST_Msk     (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */
/* =========================================================  GPIO2  ========================================================= */
#define PADS_BANK0_GPIO2_OD_Pos           (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_BANK0_GPIO2_OD_Msk           (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO2_IE_Pos           (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_BANK0_GPIO2_IE_Msk           (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO2_DRIVE_Pos        (4UL)                     /*!< DRIVE (Bit 4)                                         */
#define PADS_BANK0_GPIO2_DRIVE_Msk        (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_BANK0_GPIO2_PUE_Pos          (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_BANK0_GPIO2_PUE_Msk          (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO2_PDE_Pos          (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_BANK0_GPIO2_PDE_Msk          (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO2_SCHMITT_Pos      (1UL)                     /*!< SCHMITT (Bit 1)                                       */
#define PADS_BANK0_GPIO2_SCHMITT_Msk      (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_BANK0_GPIO2_SLEWFAST_Pos     (0UL)                     /*!< SLEWFAST (Bit 0)                                      */
#define PADS_BANK0_GPIO2_SLEWFAST_Msk     (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */
/* =========================================================  GPIO3  ========================================================= */
#define PADS_BANK0_GPIO3_OD_Pos           (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_BANK0_GPIO3_OD_Msk           (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO3_IE_Pos           (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_BANK0_GPIO3_IE_Msk           (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO3_DRIVE_Pos        (4UL)                     /*!< DRIVE (Bit 4)                                         */
#define PADS_BANK0_GPIO3_DRIVE_Msk        (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_BANK0_GPIO3_PUE_Pos          (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_BANK0_GPIO3_PUE_Msk          (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO3_PDE_Pos          (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_BANK0_GPIO3_PDE_Msk          (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO3_SCHMITT_Pos      (1UL)                     /*!< SCHMITT (Bit 1)                                       */
#define PADS_BANK0_GPIO3_SCHMITT_Msk      (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_BANK0_GPIO3_SLEWFAST_Pos     (0UL)                     /*!< SLEWFAST (Bit 0)                                      */
#define PADS_BANK0_GPIO3_SLEWFAST_Msk     (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */
/* =========================================================  GPIO4  ========================================================= */
#define PADS_BANK0_GPIO4_OD_Pos           (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_BANK0_GPIO4_OD_Msk           (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO4_IE_Pos           (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_BANK0_GPIO4_IE_Msk           (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO4_DRIVE_Pos        (4UL)                     /*!< DRIVE (Bit 4)                                         */
#define PADS_BANK0_GPIO4_DRIVE_Msk        (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_BANK0_GPIO4_PUE_Pos          (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_BANK0_GPIO4_PUE_Msk          (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO4_PDE_Pos          (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_BANK0_GPIO4_PDE_Msk          (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO4_SCHMITT_Pos      (1UL)                     /*!< SCHMITT (Bit 1)                                       */
#define PADS_BANK0_GPIO4_SCHMITT_Msk      (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_BANK0_GPIO4_SLEWFAST_Pos     (0UL)                     /*!< SLEWFAST (Bit 0)                                      */
#define PADS_BANK0_GPIO4_SLEWFAST_Msk     (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */
/* =========================================================  GPIO5  ========================================================= */
#define PADS_BANK0_GPIO5_OD_Pos           (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_BANK0_GPIO5_OD_Msk           (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO5_IE_Pos           (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_BANK0_GPIO5_IE_Msk           (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO5_DRIVE_Pos        (4UL)                     /*!< DRIVE (Bit 4)                                         */
#define PADS_BANK0_GPIO5_DRIVE_Msk        (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_BANK0_GPIO5_PUE_Pos          (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_BANK0_GPIO5_PUE_Msk          (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO5_PDE_Pos          (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_BANK0_GPIO5_PDE_Msk          (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO5_SCHMITT_Pos      (1UL)                     /*!< SCHMITT (Bit 1)                                       */
#define PADS_BANK0_GPIO5_SCHMITT_Msk      (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_BANK0_GPIO5_SLEWFAST_Pos     (0UL)                     /*!< SLEWFAST (Bit 0)                                      */
#define PADS_BANK0_GPIO5_SLEWFAST_Msk     (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */
/* =========================================================  GPIO6  ========================================================= */
#define PADS_BANK0_GPIO6_OD_Pos           (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_BANK0_GPIO6_OD_Msk           (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO6_IE_Pos           (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_BANK0_GPIO6_IE_Msk           (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO6_DRIVE_Pos        (4UL)                     /*!< DRIVE (Bit 4)                                         */
#define PADS_BANK0_GPIO6_DRIVE_Msk        (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_BANK0_GPIO6_PUE_Pos          (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_BANK0_GPIO6_PUE_Msk          (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO6_PDE_Pos          (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_BANK0_GPIO6_PDE_Msk          (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO6_SCHMITT_Pos      (1UL)                     /*!< SCHMITT (Bit 1)                                       */
#define PADS_BANK0_GPIO6_SCHMITT_Msk      (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_BANK0_GPIO6_SLEWFAST_Pos     (0UL)                     /*!< SLEWFAST (Bit 0)                                      */
#define PADS_BANK0_GPIO6_SLEWFAST_Msk     (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */
/* =========================================================  GPIO7  ========================================================= */
#define PADS_BANK0_GPIO7_OD_Pos           (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_BANK0_GPIO7_OD_Msk           (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO7_IE_Pos           (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_BANK0_GPIO7_IE_Msk           (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO7_DRIVE_Pos        (4UL)                     /*!< DRIVE (Bit 4)                                         */
#define PADS_BANK0_GPIO7_DRIVE_Msk        (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_BANK0_GPIO7_PUE_Pos          (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_BANK0_GPIO7_PUE_Msk          (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO7_PDE_Pos          (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_BANK0_GPIO7_PDE_Msk          (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO7_SCHMITT_Pos      (1UL)                     /*!< SCHMITT (Bit 1)                                       */
#define PADS_BANK0_GPIO7_SCHMITT_Msk      (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_BANK0_GPIO7_SLEWFAST_Pos     (0UL)                     /*!< SLEWFAST (Bit 0)                                      */
#define PADS_BANK0_GPIO7_SLEWFAST_Msk     (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */
/* =========================================================  GPIO8  ========================================================= */
#define PADS_BANK0_GPIO8_OD_Pos           (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_BANK0_GPIO8_OD_Msk           (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO8_IE_Pos           (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_BANK0_GPIO8_IE_Msk           (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO8_DRIVE_Pos        (4UL)                     /*!< DRIVE (Bit 4)                                         */
#define PADS_BANK0_GPIO8_DRIVE_Msk        (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_BANK0_GPIO8_PUE_Pos          (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_BANK0_GPIO8_PUE_Msk          (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO8_PDE_Pos          (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_BANK0_GPIO8_PDE_Msk          (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO8_SCHMITT_Pos      (1UL)                     /*!< SCHMITT (Bit 1)                                       */
#define PADS_BANK0_GPIO8_SCHMITT_Msk      (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_BANK0_GPIO8_SLEWFAST_Pos     (0UL)                     /*!< SLEWFAST (Bit 0)                                      */
#define PADS_BANK0_GPIO8_SLEWFAST_Msk     (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */
/* =========================================================  GPIO9  ========================================================= */
#define PADS_BANK0_GPIO9_OD_Pos           (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_BANK0_GPIO9_OD_Msk           (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO9_IE_Pos           (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_BANK0_GPIO9_IE_Msk           (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO9_DRIVE_Pos        (4UL)                     /*!< DRIVE (Bit 4)                                         */
#define PADS_BANK0_GPIO9_DRIVE_Msk        (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_BANK0_GPIO9_PUE_Pos          (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_BANK0_GPIO9_PUE_Msk          (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO9_PDE_Pos          (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_BANK0_GPIO9_PDE_Msk          (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO9_SCHMITT_Pos      (1UL)                     /*!< SCHMITT (Bit 1)                                       */
#define PADS_BANK0_GPIO9_SCHMITT_Msk      (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_BANK0_GPIO9_SLEWFAST_Pos     (0UL)                     /*!< SLEWFAST (Bit 0)                                      */
#define PADS_BANK0_GPIO9_SLEWFAST_Msk     (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */
/* ========================================================  GPIO10  ========================================================= */
#define PADS_BANK0_GPIO10_OD_Pos          (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_BANK0_GPIO10_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO10_IE_Pos          (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_BANK0_GPIO10_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO10_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4)                                         */
#define PADS_BANK0_GPIO10_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_BANK0_GPIO10_PUE_Pos         (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_BANK0_GPIO10_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO10_PDE_Pos         (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_BANK0_GPIO10_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO10_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1)                                       */
#define PADS_BANK0_GPIO10_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_BANK0_GPIO10_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0)                                      */
#define PADS_BANK0_GPIO10_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */
/* ========================================================  GPIO11  ========================================================= */
#define PADS_BANK0_GPIO11_OD_Pos          (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_BANK0_GPIO11_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO11_IE_Pos          (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_BANK0_GPIO11_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO11_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4)                                         */
#define PADS_BANK0_GPIO11_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_BANK0_GPIO11_PUE_Pos         (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_BANK0_GPIO11_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO11_PDE_Pos         (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_BANK0_GPIO11_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO11_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1)                                       */
#define PADS_BANK0_GPIO11_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_BANK0_GPIO11_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0)                                      */
#define PADS_BANK0_GPIO11_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */
/* ========================================================  GPIO12  ========================================================= */
#define PADS_BANK0_GPIO12_OD_Pos          (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_BANK0_GPIO12_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO12_IE_Pos          (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_BANK0_GPIO12_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO12_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4)                                         */
#define PADS_BANK0_GPIO12_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_BANK0_GPIO12_PUE_Pos         (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_BANK0_GPIO12_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO12_PDE_Pos         (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_BANK0_GPIO12_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO12_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1)                                       */
#define PADS_BANK0_GPIO12_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_BANK0_GPIO12_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0)                                      */
#define PADS_BANK0_GPIO12_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */
/* ========================================================  GPIO13  ========================================================= */
#define PADS_BANK0_GPIO13_OD_Pos          (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_BANK0_GPIO13_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO13_IE_Pos          (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_BANK0_GPIO13_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO13_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4)                                         */
#define PADS_BANK0_GPIO13_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_BANK0_GPIO13_PUE_Pos         (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_BANK0_GPIO13_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO13_PDE_Pos         (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_BANK0_GPIO13_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO13_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1)                                       */
#define PADS_BANK0_GPIO13_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_BANK0_GPIO13_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0)                                      */
#define PADS_BANK0_GPIO13_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */
/* ========================================================  GPIO14  ========================================================= */
#define PADS_BANK0_GPIO14_OD_Pos          (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_BANK0_GPIO14_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO14_IE_Pos          (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_BANK0_GPIO14_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO14_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4)                                         */
#define PADS_BANK0_GPIO14_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_BANK0_GPIO14_PUE_Pos         (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_BANK0_GPIO14_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO14_PDE_Pos         (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_BANK0_GPIO14_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO14_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1)                                       */
#define PADS_BANK0_GPIO14_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_BANK0_GPIO14_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0)                                      */
#define PADS_BANK0_GPIO14_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */
/* ========================================================  GPIO15  ========================================================= */
#define PADS_BANK0_GPIO15_OD_Pos          (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_BANK0_GPIO15_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO15_IE_Pos          (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_BANK0_GPIO15_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO15_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4)                                         */
#define PADS_BANK0_GPIO15_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_BANK0_GPIO15_PUE_Pos         (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_BANK0_GPIO15_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO15_PDE_Pos         (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_BANK0_GPIO15_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO15_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1)                                       */
#define PADS_BANK0_GPIO15_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_BANK0_GPIO15_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0)                                      */
#define PADS_BANK0_GPIO15_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */
/* ========================================================  GPIO16  ========================================================= */
#define PADS_BANK0_GPIO16_OD_Pos          (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_BANK0_GPIO16_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO16_IE_Pos          (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_BANK0_GPIO16_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO16_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4)                                         */
#define PADS_BANK0_GPIO16_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_BANK0_GPIO16_PUE_Pos         (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_BANK0_GPIO16_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO16_PDE_Pos         (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_BANK0_GPIO16_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO16_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1)                                       */
#define PADS_BANK0_GPIO16_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_BANK0_GPIO16_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0)                                      */
#define PADS_BANK0_GPIO16_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */
/* ========================================================  GPIO17  ========================================================= */
#define PADS_BANK0_GPIO17_OD_Pos          (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_BANK0_GPIO17_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO17_IE_Pos          (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_BANK0_GPIO17_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO17_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4)                                         */
#define PADS_BANK0_GPIO17_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_BANK0_GPIO17_PUE_Pos         (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_BANK0_GPIO17_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO17_PDE_Pos         (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_BANK0_GPIO17_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO17_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1)                                       */
#define PADS_BANK0_GPIO17_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_BANK0_GPIO17_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0)                                      */
#define PADS_BANK0_GPIO17_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */
/* ========================================================  GPIO18  ========================================================= */
#define PADS_BANK0_GPIO18_OD_Pos          (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_BANK0_GPIO18_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO18_IE_Pos          (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_BANK0_GPIO18_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO18_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4)                                         */
#define PADS_BANK0_GPIO18_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_BANK0_GPIO18_PUE_Pos         (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_BANK0_GPIO18_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO18_PDE_Pos         (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_BANK0_GPIO18_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO18_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1)                                       */
#define PADS_BANK0_GPIO18_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_BANK0_GPIO18_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0)                                      */
#define PADS_BANK0_GPIO18_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */
/* ========================================================  GPIO19  ========================================================= */
#define PADS_BANK0_GPIO19_OD_Pos          (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_BANK0_GPIO19_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO19_IE_Pos          (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_BANK0_GPIO19_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO19_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4)                                         */
#define PADS_BANK0_GPIO19_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_BANK0_GPIO19_PUE_Pos         (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_BANK0_GPIO19_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO19_PDE_Pos         (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_BANK0_GPIO19_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO19_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1)                                       */
#define PADS_BANK0_GPIO19_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_BANK0_GPIO19_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0)                                      */
#define PADS_BANK0_GPIO19_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */
/* ========================================================  GPIO20  ========================================================= */
#define PADS_BANK0_GPIO20_OD_Pos          (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_BANK0_GPIO20_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO20_IE_Pos          (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_BANK0_GPIO20_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO20_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4)                                         */
#define PADS_BANK0_GPIO20_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_BANK0_GPIO20_PUE_Pos         (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_BANK0_GPIO20_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO20_PDE_Pos         (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_BANK0_GPIO20_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO20_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1)                                       */
#define PADS_BANK0_GPIO20_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_BANK0_GPIO20_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0)                                      */
#define PADS_BANK0_GPIO20_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */
/* ========================================================  GPIO21  ========================================================= */
#define PADS_BANK0_GPIO21_OD_Pos          (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_BANK0_GPIO21_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO21_IE_Pos          (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_BANK0_GPIO21_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO21_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4)                                         */
#define PADS_BANK0_GPIO21_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_BANK0_GPIO21_PUE_Pos         (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_BANK0_GPIO21_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO21_PDE_Pos         (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_BANK0_GPIO21_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO21_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1)                                       */
#define PADS_BANK0_GPIO21_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_BANK0_GPIO21_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0)                                      */
#define PADS_BANK0_GPIO21_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */
/* ========================================================  GPIO22  ========================================================= */
#define PADS_BANK0_GPIO22_OD_Pos          (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_BANK0_GPIO22_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO22_IE_Pos          (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_BANK0_GPIO22_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO22_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4)                                         */
#define PADS_BANK0_GPIO22_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_BANK0_GPIO22_PUE_Pos         (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_BANK0_GPIO22_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO22_PDE_Pos         (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_BANK0_GPIO22_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO22_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1)                                       */
#define PADS_BANK0_GPIO22_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_BANK0_GPIO22_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0)                                      */
#define PADS_BANK0_GPIO22_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */
/* ========================================================  GPIO23  ========================================================= */
#define PADS_BANK0_GPIO23_OD_Pos          (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_BANK0_GPIO23_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO23_IE_Pos          (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_BANK0_GPIO23_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO23_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4)                                         */
#define PADS_BANK0_GPIO23_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_BANK0_GPIO23_PUE_Pos         (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_BANK0_GPIO23_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO23_PDE_Pos         (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_BANK0_GPIO23_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO23_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1)                                       */
#define PADS_BANK0_GPIO23_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_BANK0_GPIO23_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0)                                      */
#define PADS_BANK0_GPIO23_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */
/* ========================================================  GPIO24  ========================================================= */
#define PADS_BANK0_GPIO24_OD_Pos          (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_BANK0_GPIO24_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO24_IE_Pos          (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_BANK0_GPIO24_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO24_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4)                                         */
#define PADS_BANK0_GPIO24_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_BANK0_GPIO24_PUE_Pos         (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_BANK0_GPIO24_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO24_PDE_Pos         (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_BANK0_GPIO24_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO24_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1)                                       */
#define PADS_BANK0_GPIO24_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_BANK0_GPIO24_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0)                                      */
#define PADS_BANK0_GPIO24_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */
/* ========================================================  GPIO25  ========================================================= */
#define PADS_BANK0_GPIO25_OD_Pos          (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_BANK0_GPIO25_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO25_IE_Pos          (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_BANK0_GPIO25_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO25_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4)                                         */
#define PADS_BANK0_GPIO25_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_BANK0_GPIO25_PUE_Pos         (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_BANK0_GPIO25_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO25_PDE_Pos         (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_BANK0_GPIO25_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO25_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1)                                       */
#define PADS_BANK0_GPIO25_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_BANK0_GPIO25_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0)                                      */
#define PADS_BANK0_GPIO25_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */
/* ========================================================  GPIO26  ========================================================= */
#define PADS_BANK0_GPIO26_OD_Pos          (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_BANK0_GPIO26_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO26_IE_Pos          (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_BANK0_GPIO26_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO26_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4)                                         */
#define PADS_BANK0_GPIO26_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_BANK0_GPIO26_PUE_Pos         (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_BANK0_GPIO26_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO26_PDE_Pos         (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_BANK0_GPIO26_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO26_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1)                                       */
#define PADS_BANK0_GPIO26_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_BANK0_GPIO26_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0)                                      */
#define PADS_BANK0_GPIO26_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */
/* ========================================================  GPIO27  ========================================================= */
#define PADS_BANK0_GPIO27_OD_Pos          (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_BANK0_GPIO27_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO27_IE_Pos          (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_BANK0_GPIO27_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO27_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4)                                         */
#define PADS_BANK0_GPIO27_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_BANK0_GPIO27_PUE_Pos         (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_BANK0_GPIO27_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO27_PDE_Pos         (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_BANK0_GPIO27_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO27_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1)                                       */
#define PADS_BANK0_GPIO27_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_BANK0_GPIO27_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0)                                      */
#define PADS_BANK0_GPIO27_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */
/* ========================================================  GPIO28  ========================================================= */
#define PADS_BANK0_GPIO28_OD_Pos          (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_BANK0_GPIO28_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO28_IE_Pos          (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_BANK0_GPIO28_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO28_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4)                                         */
#define PADS_BANK0_GPIO28_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_BANK0_GPIO28_PUE_Pos         (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_BANK0_GPIO28_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO28_PDE_Pos         (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_BANK0_GPIO28_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO28_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1)                                       */
#define PADS_BANK0_GPIO28_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_BANK0_GPIO28_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0)                                      */
#define PADS_BANK0_GPIO28_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */
/* ========================================================  GPIO29  ========================================================= */
#define PADS_BANK0_GPIO29_OD_Pos          (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_BANK0_GPIO29_OD_Msk          (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO29_IE_Pos          (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_BANK0_GPIO29_IE_Msk          (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_GPIO29_DRIVE_Pos       (4UL)                     /*!< DRIVE (Bit 4)                                         */
#define PADS_BANK0_GPIO29_DRIVE_Msk       (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_BANK0_GPIO29_PUE_Pos         (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_BANK0_GPIO29_PUE_Msk         (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO29_PDE_Pos         (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_BANK0_GPIO29_PDE_Msk         (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_GPIO29_SCHMITT_Pos     (1UL)                     /*!< SCHMITT (Bit 1)                                       */
#define PADS_BANK0_GPIO29_SCHMITT_Msk     (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_BANK0_GPIO29_SLEWFAST_Pos    (0UL)                     /*!< SLEWFAST (Bit 0)                                      */
#define PADS_BANK0_GPIO29_SLEWFAST_Msk    (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */
/* =========================================================  SWCLK  ========================================================= */
#define PADS_BANK0_SWCLK_OD_Pos           (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_BANK0_SWCLK_OD_Msk           (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_SWCLK_IE_Pos           (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_BANK0_SWCLK_IE_Msk           (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_SWCLK_DRIVE_Pos        (4UL)                     /*!< DRIVE (Bit 4)                                         */
#define PADS_BANK0_SWCLK_DRIVE_Msk        (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_BANK0_SWCLK_PUE_Pos          (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_BANK0_SWCLK_PUE_Msk          (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_SWCLK_PDE_Pos          (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_BANK0_SWCLK_PDE_Msk          (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_SWCLK_SCHMITT_Pos      (1UL)                     /*!< SCHMITT (Bit 1)                                       */
#define PADS_BANK0_SWCLK_SCHMITT_Msk      (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_BANK0_SWCLK_SLEWFAST_Pos     (0UL)                     /*!< SLEWFAST (Bit 0)                                      */
#define PADS_BANK0_SWCLK_SLEWFAST_Msk     (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */
/* ==========================================================  SWD  ========================================================== */
#define PADS_BANK0_SWD_OD_Pos             (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_BANK0_SWD_OD_Msk             (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_SWD_IE_Pos             (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_BANK0_SWD_IE_Msk             (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_BANK0_SWD_DRIVE_Pos          (4UL)                     /*!< DRIVE (Bit 4)                                         */
#define PADS_BANK0_SWD_DRIVE_Msk          (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_BANK0_SWD_PUE_Pos            (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_BANK0_SWD_PUE_Msk            (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_SWD_PDE_Pos            (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_BANK0_SWD_PDE_Msk            (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_BANK0_SWD_SCHMITT_Pos        (1UL)                     /*!< SCHMITT (Bit 1)                                       */
#define PADS_BANK0_SWD_SCHMITT_Msk        (0x2UL)                   /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_BANK0_SWD_SLEWFAST_Pos       (0UL)                     /*!< SLEWFAST (Bit 0)                                      */
#define PADS_BANK0_SWD_SLEWFAST_Msk       (0x1UL)                   /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */


/* =========================================================================================================================== */
/* ================                                         PADS_QSPI                                         ================ */
/* =========================================================================================================================== */

/* ====================================================  VOLTAGE_SELECT  ===================================================== */
#define PADS_QSPI_VOLTAGE_SELECT_VOLTAGE_SELECT_Pos (0UL)           /*!< VOLTAGE_SELECT (Bit 0)                                */
#define PADS_QSPI_VOLTAGE_SELECT_VOLTAGE_SELECT_Msk (0x1UL)         /*!< VOLTAGE_SELECT (Bitfield-Mask: 0x01)                  */
/* ====================================================  GPIO_QSPI_SCLK  ===================================================== */
#define PADS_QSPI_GPIO_QSPI_SCLK_OD_Pos   (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_QSPI_GPIO_QSPI_SCLK_OD_Msk   (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_QSPI_GPIO_QSPI_SCLK_IE_Pos   (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_QSPI_GPIO_QSPI_SCLK_IE_Msk   (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_QSPI_GPIO_QSPI_SCLK_DRIVE_Pos (4UL)                    /*!< DRIVE (Bit 4)                                         */
#define PADS_QSPI_GPIO_QSPI_SCLK_DRIVE_Msk (0x30UL)                 /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_QSPI_GPIO_QSPI_SCLK_PUE_Pos  (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_QSPI_GPIO_QSPI_SCLK_PUE_Msk  (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_QSPI_GPIO_QSPI_SCLK_PDE_Pos  (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_QSPI_GPIO_QSPI_SCLK_PDE_Msk  (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_QSPI_GPIO_QSPI_SCLK_SCHMITT_Pos (1UL)                  /*!< SCHMITT (Bit 1)                                       */
#define PADS_QSPI_GPIO_QSPI_SCLK_SCHMITT_Msk (0x2UL)                /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_QSPI_GPIO_QSPI_SCLK_SLEWFAST_Pos (0UL)                 /*!< SLEWFAST (Bit 0)                                      */
#define PADS_QSPI_GPIO_QSPI_SCLK_SLEWFAST_Msk (0x1UL)               /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */
/* =====================================================  GPIO_QSPI_SD0  ===================================================== */
#define PADS_QSPI_GPIO_QSPI_SD0_OD_Pos    (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_QSPI_GPIO_QSPI_SD0_OD_Msk    (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_QSPI_GPIO_QSPI_SD0_IE_Pos    (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_QSPI_GPIO_QSPI_SD0_IE_Msk    (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_QSPI_GPIO_QSPI_SD0_DRIVE_Pos (4UL)                     /*!< DRIVE (Bit 4)                                         */
#define PADS_QSPI_GPIO_QSPI_SD0_DRIVE_Msk (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_QSPI_GPIO_QSPI_SD0_PUE_Pos   (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_QSPI_GPIO_QSPI_SD0_PUE_Msk   (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_QSPI_GPIO_QSPI_SD0_PDE_Pos   (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_QSPI_GPIO_QSPI_SD0_PDE_Msk   (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_QSPI_GPIO_QSPI_SD0_SCHMITT_Pos (1UL)                   /*!< SCHMITT (Bit 1)                                       */
#define PADS_QSPI_GPIO_QSPI_SD0_SCHMITT_Msk (0x2UL)                 /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_QSPI_GPIO_QSPI_SD0_SLEWFAST_Pos (0UL)                  /*!< SLEWFAST (Bit 0)                                      */
#define PADS_QSPI_GPIO_QSPI_SD0_SLEWFAST_Msk (0x1UL)                /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */
/* =====================================================  GPIO_QSPI_SD1  ===================================================== */
#define PADS_QSPI_GPIO_QSPI_SD1_OD_Pos    (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_QSPI_GPIO_QSPI_SD1_OD_Msk    (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_QSPI_GPIO_QSPI_SD1_IE_Pos    (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_QSPI_GPIO_QSPI_SD1_IE_Msk    (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_QSPI_GPIO_QSPI_SD1_DRIVE_Pos (4UL)                     /*!< DRIVE (Bit 4)                                         */
#define PADS_QSPI_GPIO_QSPI_SD1_DRIVE_Msk (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_QSPI_GPIO_QSPI_SD1_PUE_Pos   (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_QSPI_GPIO_QSPI_SD1_PUE_Msk   (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_QSPI_GPIO_QSPI_SD1_PDE_Pos   (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_QSPI_GPIO_QSPI_SD1_PDE_Msk   (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_QSPI_GPIO_QSPI_SD1_SCHMITT_Pos (1UL)                   /*!< SCHMITT (Bit 1)                                       */
#define PADS_QSPI_GPIO_QSPI_SD1_SCHMITT_Msk (0x2UL)                 /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_QSPI_GPIO_QSPI_SD1_SLEWFAST_Pos (0UL)                  /*!< SLEWFAST (Bit 0)                                      */
#define PADS_QSPI_GPIO_QSPI_SD1_SLEWFAST_Msk (0x1UL)                /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */
/* =====================================================  GPIO_QSPI_SD2  ===================================================== */
#define PADS_QSPI_GPIO_QSPI_SD2_OD_Pos    (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_QSPI_GPIO_QSPI_SD2_OD_Msk    (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_QSPI_GPIO_QSPI_SD2_IE_Pos    (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_QSPI_GPIO_QSPI_SD2_IE_Msk    (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_QSPI_GPIO_QSPI_SD2_DRIVE_Pos (4UL)                     /*!< DRIVE (Bit 4)                                         */
#define PADS_QSPI_GPIO_QSPI_SD2_DRIVE_Msk (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_QSPI_GPIO_QSPI_SD2_PUE_Pos   (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_QSPI_GPIO_QSPI_SD2_PUE_Msk   (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_QSPI_GPIO_QSPI_SD2_PDE_Pos   (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_QSPI_GPIO_QSPI_SD2_PDE_Msk   (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_QSPI_GPIO_QSPI_SD2_SCHMITT_Pos (1UL)                   /*!< SCHMITT (Bit 1)                                       */
#define PADS_QSPI_GPIO_QSPI_SD2_SCHMITT_Msk (0x2UL)                 /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_QSPI_GPIO_QSPI_SD2_SLEWFAST_Pos (0UL)                  /*!< SLEWFAST (Bit 0)                                      */
#define PADS_QSPI_GPIO_QSPI_SD2_SLEWFAST_Msk (0x1UL)                /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */
/* =====================================================  GPIO_QSPI_SD3  ===================================================== */
#define PADS_QSPI_GPIO_QSPI_SD3_OD_Pos    (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_QSPI_GPIO_QSPI_SD3_OD_Msk    (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_QSPI_GPIO_QSPI_SD3_IE_Pos    (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_QSPI_GPIO_QSPI_SD3_IE_Msk    (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_QSPI_GPIO_QSPI_SD3_DRIVE_Pos (4UL)                     /*!< DRIVE (Bit 4)                                         */
#define PADS_QSPI_GPIO_QSPI_SD3_DRIVE_Msk (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_QSPI_GPIO_QSPI_SD3_PUE_Pos   (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_QSPI_GPIO_QSPI_SD3_PUE_Msk   (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_QSPI_GPIO_QSPI_SD3_PDE_Pos   (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_QSPI_GPIO_QSPI_SD3_PDE_Msk   (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_QSPI_GPIO_QSPI_SD3_SCHMITT_Pos (1UL)                   /*!< SCHMITT (Bit 1)                                       */
#define PADS_QSPI_GPIO_QSPI_SD3_SCHMITT_Msk (0x2UL)                 /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_QSPI_GPIO_QSPI_SD3_SLEWFAST_Pos (0UL)                  /*!< SLEWFAST (Bit 0)                                      */
#define PADS_QSPI_GPIO_QSPI_SD3_SLEWFAST_Msk (0x1UL)                /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */
/* =====================================================  GPIO_QSPI_SS  ====================================================== */
#define PADS_QSPI_GPIO_QSPI_SS_OD_Pos     (7UL)                     /*!< OD (Bit 7)                                            */
#define PADS_QSPI_GPIO_QSPI_SS_OD_Msk     (0x80UL)                  /*!< OD (Bitfield-Mask: 0x01)                              */
#define PADS_QSPI_GPIO_QSPI_SS_IE_Pos     (6UL)                     /*!< IE (Bit 6)                                            */
#define PADS_QSPI_GPIO_QSPI_SS_IE_Msk     (0x40UL)                  /*!< IE (Bitfield-Mask: 0x01)                              */
#define PADS_QSPI_GPIO_QSPI_SS_DRIVE_Pos  (4UL)                     /*!< DRIVE (Bit 4)                                         */
#define PADS_QSPI_GPIO_QSPI_SS_DRIVE_Msk  (0x30UL)                  /*!< DRIVE (Bitfield-Mask: 0x03)                           */
#define PADS_QSPI_GPIO_QSPI_SS_PUE_Pos    (3UL)                     /*!< PUE (Bit 3)                                           */
#define PADS_QSPI_GPIO_QSPI_SS_PUE_Msk    (0x8UL)                   /*!< PUE (Bitfield-Mask: 0x01)                             */
#define PADS_QSPI_GPIO_QSPI_SS_PDE_Pos    (2UL)                     /*!< PDE (Bit 2)                                           */
#define PADS_QSPI_GPIO_QSPI_SS_PDE_Msk    (0x4UL)                   /*!< PDE (Bitfield-Mask: 0x01)                             */
#define PADS_QSPI_GPIO_QSPI_SS_SCHMITT_Pos (1UL)                    /*!< SCHMITT (Bit 1)                                       */
#define PADS_QSPI_GPIO_QSPI_SS_SCHMITT_Msk (0x2UL)                  /*!< SCHMITT (Bitfield-Mask: 0x01)                         */
#define PADS_QSPI_GPIO_QSPI_SS_SLEWFAST_Pos (0UL)                   /*!< SLEWFAST (Bit 0)                                      */
#define PADS_QSPI_GPIO_QSPI_SS_SLEWFAST_Msk (0x1UL)                 /*!< SLEWFAST (Bitfield-Mask: 0x01)                        */


/* =========================================================================================================================== */
/* ================                                           XOSC                                            ================ */
/* =========================================================================================================================== */

/* =========================================================  CTRL  ========================================================== */
#define XOSC_CTRL_ENABLE_Pos              (12UL)                    /*!< ENABLE (Bit 12)                                       */
#define XOSC_CTRL_ENABLE_Msk              (0xfff000UL)              /*!< ENABLE (Bitfield-Mask: 0xfff)                         */
#define XOSC_CTRL_FREQ_RANGE_Pos          (0UL)                     /*!< FREQ_RANGE (Bit 0)                                    */
#define XOSC_CTRL_FREQ_RANGE_Msk          (0xfffUL)                 /*!< FREQ_RANGE (Bitfield-Mask: 0xfff)                     */
/* ========================================================  STATUS  ========================================================= */
#define XOSC_STATUS_STABLE_Pos            (31UL)                    /*!< STABLE (Bit 31)                                       */
#define XOSC_STATUS_STABLE_Msk            (0x80000000UL)            /*!< STABLE (Bitfield-Mask: 0x01)                          */
#define XOSC_STATUS_BADWRITE_Pos          (24UL)                    /*!< BADWRITE (Bit 24)                                     */
#define XOSC_STATUS_BADWRITE_Msk          (0x1000000UL)             /*!< BADWRITE (Bitfield-Mask: 0x01)                        */
#define XOSC_STATUS_ENABLED_Pos           (12UL)                    /*!< ENABLED (Bit 12)                                      */
#define XOSC_STATUS_ENABLED_Msk           (0x1000UL)                /*!< ENABLED (Bitfield-Mask: 0x01)                         */
#define XOSC_STATUS_FREQ_RANGE_Pos        (0UL)                     /*!< FREQ_RANGE (Bit 0)                                    */
#define XOSC_STATUS_FREQ_RANGE_Msk        (0x3UL)                   /*!< FREQ_RANGE (Bitfield-Mask: 0x03)                      */
/* ========================================================  DORMANT  ======================================================== */
/* ========================================================  STARTUP  ======================================================== */
#define XOSC_STARTUP_X4_Pos               (20UL)                    /*!< X4 (Bit 20)                                           */
#define XOSC_STARTUP_X4_Msk               (0x100000UL)              /*!< X4 (Bitfield-Mask: 0x01)                              */
#define XOSC_STARTUP_DELAY_Pos            (0UL)                     /*!< DELAY (Bit 0)                                         */
#define XOSC_STARTUP_DELAY_Msk            (0x3fffUL)                /*!< DELAY (Bitfield-Mask: 0x3fff)                         */
/* =========================================================  COUNT  ========================================================= */
#define XOSC_COUNT_COUNT_Pos              (0UL)                     /*!< COUNT (Bit 0)                                         */
#define XOSC_COUNT_COUNT_Msk              (0xffUL)                  /*!< COUNT (Bitfield-Mask: 0xff)                           */


/* =========================================================================================================================== */
/* ================                                          PLL_SYS                                          ================ */
/* =========================================================================================================================== */

/* ==========================================================  CS  =========================================================== */
#define PLL_SYS_CS_LOCK_Pos               (31UL)                    /*!< LOCK (Bit 31)                                         */
#define PLL_SYS_CS_LOCK_Msk               (0x80000000UL)            /*!< LOCK (Bitfield-Mask: 0x01)                            */
#define PLL_SYS_CS_BYPASS_Pos             (8UL)                     /*!< BYPASS (Bit 8)                                        */
#define PLL_SYS_CS_BYPASS_Msk             (0x100UL)                 /*!< BYPASS (Bitfield-Mask: 0x01)                          */
#define PLL_SYS_CS_REFDIV_Pos             (0UL)                     /*!< REFDIV (Bit 0)                                        */
#define PLL_SYS_CS_REFDIV_Msk             (0x3fUL)                  /*!< REFDIV (Bitfield-Mask: 0x3f)                          */
/* ==========================================================  PWR  ========================================================== */
#define PLL_SYS_PWR_VCOPD_Pos             (5UL)                     /*!< VCOPD (Bit 5)                                         */
#define PLL_SYS_PWR_VCOPD_Msk             (0x20UL)                  /*!< VCOPD (Bitfield-Mask: 0x01)                           */
#define PLL_SYS_PWR_POSTDIVPD_Pos         (3UL)                     /*!< POSTDIVPD (Bit 3)                                     */
#define PLL_SYS_PWR_POSTDIVPD_Msk         (0x8UL)                   /*!< POSTDIVPD (Bitfield-Mask: 0x01)                       */
#define PLL_SYS_PWR_DSMPD_Pos             (2UL)                     /*!< DSMPD (Bit 2)                                         */
#define PLL_SYS_PWR_DSMPD_Msk             (0x4UL)                   /*!< DSMPD (Bitfield-Mask: 0x01)                           */
#define PLL_SYS_PWR_PD_Pos                (0UL)                     /*!< PD (Bit 0)                                            */
#define PLL_SYS_PWR_PD_Msk                (0x1UL)                   /*!< PD (Bitfield-Mask: 0x01)                              */
/* =======================================================  FBDIV_INT  ======================================================= */
#define PLL_SYS_FBDIV_INT_FBDIV_INT_Pos   (0UL)                     /*!< FBDIV_INT (Bit 0)                                     */
#define PLL_SYS_FBDIV_INT_FBDIV_INT_Msk   (0xfffUL)                 /*!< FBDIV_INT (Bitfield-Mask: 0xfff)                      */
/* =========================================================  PRIM  ========================================================== */
#define PLL_SYS_PRIM_POSTDIV1_Pos         (16UL)                    /*!< POSTDIV1 (Bit 16)                                     */
#define PLL_SYS_PRIM_POSTDIV1_Msk         (0x70000UL)               /*!< POSTDIV1 (Bitfield-Mask: 0x07)                        */
#define PLL_SYS_PRIM_POSTDIV2_Pos         (12UL)                    /*!< POSTDIV2 (Bit 12)                                     */
#define PLL_SYS_PRIM_POSTDIV2_Msk         (0x7000UL)                /*!< POSTDIV2 (Bitfield-Mask: 0x07)                        */


/* =========================================================================================================================== */
/* ================                                          BUSCTRL                                          ================ */
/* =========================================================================================================================== */

/* =====================================================  BUS_PRIORITY  ====================================================== */
#define BUSCTRL_BUS_PRIORITY_DMA_W_Pos    (12UL)                    /*!< DMA_W (Bit 12)                                        */
#define BUSCTRL_BUS_PRIORITY_DMA_W_Msk    (0x1000UL)                /*!< DMA_W (Bitfield-Mask: 0x01)                           */
#define BUSCTRL_BUS_PRIORITY_DMA_R_Pos    (8UL)                     /*!< DMA_R (Bit 8)                                         */
#define BUSCTRL_BUS_PRIORITY_DMA_R_Msk    (0x100UL)                 /*!< DMA_R (Bitfield-Mask: 0x01)                           */
#define BUSCTRL_BUS_PRIORITY_PROC1_Pos    (4UL)                     /*!< PROC1 (Bit 4)                                         */
#define BUSCTRL_BUS_PRIORITY_PROC1_Msk    (0x10UL)                  /*!< PROC1 (Bitfield-Mask: 0x01)                           */
#define BUSCTRL_BUS_PRIORITY_PROC0_Pos    (0UL)                     /*!< PROC0 (Bit 0)                                         */
#define BUSCTRL_BUS_PRIORITY_PROC0_Msk    (0x1UL)                   /*!< PROC0 (Bitfield-Mask: 0x01)                           */
/* ===================================================  BUS_PRIORITY_ACK  ==================================================== */
#define BUSCTRL_BUS_PRIORITY_ACK_BUS_PRIORITY_ACK_Pos (0UL)         /*!< BUS_PRIORITY_ACK (Bit 0)                              */
#define BUSCTRL_BUS_PRIORITY_ACK_BUS_PRIORITY_ACK_Msk (0x1UL)       /*!< BUS_PRIORITY_ACK (Bitfield-Mask: 0x01)                */
/* =======================================================  PERFCTR0  ======================================================== */
#define BUSCTRL_PERFCTR0_PERFCTR0_Pos     (0UL)                     /*!< PERFCTR0 (Bit 0)                                      */
#define BUSCTRL_PERFCTR0_PERFCTR0_Msk     (0xffffffUL)              /*!< PERFCTR0 (Bitfield-Mask: 0xffffff)                    */
/* =======================================================  PERFSEL0  ======================================================== */
#define BUSCTRL_PERFSEL0_PERFSEL0_Pos     (0UL)                     /*!< PERFSEL0 (Bit 0)                                      */
#define BUSCTRL_PERFSEL0_PERFSEL0_Msk     (0x1fUL)                  /*!< PERFSEL0 (Bitfield-Mask: 0x1f)                        */
/* =======================================================  PERFCTR1  ======================================================== */
#define BUSCTRL_PERFCTR1_PERFCTR1_Pos     (0UL)                     /*!< PERFCTR1 (Bit 0)                                      */
#define BUSCTRL_PERFCTR1_PERFCTR1_Msk     (0xffffffUL)              /*!< PERFCTR1 (Bitfield-Mask: 0xffffff)                    */
/* =======================================================  PERFSEL1  ======================================================== */
#define BUSCTRL_PERFSEL1_PERFSEL1_Pos     (0UL)                     /*!< PERFSEL1 (Bit 0)                                      */
#define BUSCTRL_PERFSEL1_PERFSEL1_Msk     (0x1fUL)                  /*!< PERFSEL1 (Bitfield-Mask: 0x1f)                        */
/* =======================================================  PERFCTR2  ======================================================== */
#define BUSCTRL_PERFCTR2_PERFCTR2_Pos     (0UL)                     /*!< PERFCTR2 (Bit 0)                                      */
#define BUSCTRL_PERFCTR2_PERFCTR2_Msk     (0xffffffUL)              /*!< PERFCTR2 (Bitfield-Mask: 0xffffff)                    */
/* =======================================================  PERFSEL2  ======================================================== */
#define BUSCTRL_PERFSEL2_PERFSEL2_Pos     (0UL)                     /*!< PERFSEL2 (Bit 0)                                      */
#define BUSCTRL_PERFSEL2_PERFSEL2_Msk     (0x1fUL)                  /*!< PERFSEL2 (Bitfield-Mask: 0x1f)                        */
/* =======================================================  PERFCTR3  ======================================================== */
#define BUSCTRL_PERFCTR3_PERFCTR3_Pos     (0UL)                     /*!< PERFCTR3 (Bit 0)                                      */
#define BUSCTRL_PERFCTR3_PERFCTR3_Msk     (0xffffffUL)              /*!< PERFCTR3 (Bitfield-Mask: 0xffffff)                    */
/* =======================================================  PERFSEL3  ======================================================== */
#define BUSCTRL_PERFSEL3_PERFSEL3_Pos     (0UL)                     /*!< PERFSEL3 (Bit 0)                                      */
#define BUSCTRL_PERFSEL3_PERFSEL3_Msk     (0x1fUL)                  /*!< PERFSEL3 (Bitfield-Mask: 0x1f)                        */


/* =========================================================================================================================== */
/* ================                                           UART0                                           ================ */
/* =========================================================================================================================== */

/* ========================================================  UARTDR  ========================================================= */
#define UART0_UARTDR_OE_Pos               (11UL)                    /*!< OE (Bit 11)                                           */
#define UART0_UARTDR_OE_Msk               (0x800UL)                 /*!< OE (Bitfield-Mask: 0x01)                              */
#define UART0_UARTDR_BE_Pos               (10UL)                    /*!< BE (Bit 10)                                           */
#define UART0_UARTDR_BE_Msk               (0x400UL)                 /*!< BE (Bitfield-Mask: 0x01)                              */
#define UART0_UARTDR_PE_Pos               (9UL)                     /*!< PE (Bit 9)                                            */
#define UART0_UARTDR_PE_Msk               (0x200UL)                 /*!< PE (Bitfield-Mask: 0x01)                              */
#define UART0_UARTDR_FE_Pos               (8UL)                     /*!< FE (Bit 8)                                            */
#define UART0_UARTDR_FE_Msk               (0x100UL)                 /*!< FE (Bitfield-Mask: 0x01)                              */
#define UART0_UARTDR_DATA_Pos             (0UL)                     /*!< DATA (Bit 0)                                          */
#define UART0_UARTDR_DATA_Msk             (0xffUL)                  /*!< DATA (Bitfield-Mask: 0xff)                            */
/* ========================================================  UARTRSR  ======================================================== */
#define UART0_UARTRSR_OE_Pos              (3UL)                     /*!< OE (Bit 3)                                            */
#define UART0_UARTRSR_OE_Msk              (0x8UL)                   /*!< OE (Bitfield-Mask: 0x01)                              */
#define UART0_UARTRSR_BE_Pos              (2UL)                     /*!< BE (Bit 2)                                            */
#define UART0_UARTRSR_BE_Msk              (0x4UL)                   /*!< BE (Bitfield-Mask: 0x01)                              */
#define UART0_UARTRSR_PE_Pos              (1UL)                     /*!< PE (Bit 1)                                            */
#define UART0_UARTRSR_PE_Msk              (0x2UL)                   /*!< PE (Bitfield-Mask: 0x01)                              */
#define UART0_UARTRSR_FE_Pos              (0UL)                     /*!< FE (Bit 0)                                            */
#define UART0_UARTRSR_FE_Msk              (0x1UL)                   /*!< FE (Bitfield-Mask: 0x01)                              */
/* ========================================================  UARTFR  ========================================================= */
#define UART0_UARTFR_RI_Pos               (8UL)                     /*!< RI (Bit 8)                                            */
#define UART0_UARTFR_RI_Msk               (0x100UL)                 /*!< RI (Bitfield-Mask: 0x01)                              */
#define UART0_UARTFR_TXFE_Pos             (7UL)                     /*!< TXFE (Bit 7)                                          */
#define UART0_UARTFR_TXFE_Msk             (0x80UL)                  /*!< TXFE (Bitfield-Mask: 0x01)                            */
#define UART0_UARTFR_RXFF_Pos             (6UL)                     /*!< RXFF (Bit 6)                                          */
#define UART0_UARTFR_RXFF_Msk             (0x40UL)                  /*!< RXFF (Bitfield-Mask: 0x01)                            */
#define UART0_UARTFR_TXFF_Pos             (5UL)                     /*!< TXFF (Bit 5)                                          */
#define UART0_UARTFR_TXFF_Msk             (0x20UL)                  /*!< TXFF (Bitfield-Mask: 0x01)                            */
#define UART0_UARTFR_RXFE_Pos             (4UL)                     /*!< RXFE (Bit 4)                                          */
#define UART0_UARTFR_RXFE_Msk             (0x10UL)                  /*!< RXFE (Bitfield-Mask: 0x01)                            */
#define UART0_UARTFR_BUSY_Pos             (3UL)                     /*!< BUSY (Bit 3)                                          */
#define UART0_UARTFR_BUSY_Msk             (0x8UL)                   /*!< BUSY (Bitfield-Mask: 0x01)                            */
#define UART0_UARTFR_DCD_Pos              (2UL)                     /*!< DCD (Bit 2)                                           */
#define UART0_UARTFR_DCD_Msk              (0x4UL)                   /*!< DCD (Bitfield-Mask: 0x01)                             */
#define UART0_UARTFR_DSR_Pos              (1UL)                     /*!< DSR (Bit 1)                                           */
#define UART0_UARTFR_DSR_Msk              (0x2UL)                   /*!< DSR (Bitfield-Mask: 0x01)                             */
#define UART0_UARTFR_CTS_Pos              (0UL)                     /*!< CTS (Bit 0)                                           */
#define UART0_UARTFR_CTS_Msk              (0x1UL)                   /*!< CTS (Bitfield-Mask: 0x01)                             */
/* =======================================================  UARTILPR  ======================================================== */
#define UART0_UARTILPR_ILPDVSR_Pos        (0UL)                     /*!< ILPDVSR (Bit 0)                                       */
#define UART0_UARTILPR_ILPDVSR_Msk        (0xffUL)                  /*!< ILPDVSR (Bitfield-Mask: 0xff)                         */
/* =======================================================  UARTIBRD  ======================================================== */
#define UART0_UARTIBRD_BAUD_DIVINT_Pos    (0UL)                     /*!< BAUD_DIVINT (Bit 0)                                   */
#define UART0_UARTIBRD_BAUD_DIVINT_Msk    (0xffffUL)                /*!< BAUD_DIVINT (Bitfield-Mask: 0xffff)                   */
/* =======================================================  UARTFBRD  ======================================================== */
#define UART0_UARTFBRD_BAUD_DIVFRAC_Pos   (0UL)                     /*!< BAUD_DIVFRAC (Bit 0)                                  */
#define UART0_UARTFBRD_BAUD_DIVFRAC_Msk   (0x3fUL)                  /*!< BAUD_DIVFRAC (Bitfield-Mask: 0x3f)                    */
/* =======================================================  UARTLCR_H  ======================================================= */
#define UART0_UARTLCR_H_SPS_Pos           (7UL)                     /*!< SPS (Bit 7)                                           */
#define UART0_UARTLCR_H_SPS_Msk           (0x80UL)                  /*!< SPS (Bitfield-Mask: 0x01)                             */
#define UART0_UARTLCR_H_WLEN_Pos          (5UL)                     /*!< WLEN (Bit 5)                                          */
#define UART0_UARTLCR_H_WLEN_Msk          (0x60UL)                  /*!< WLEN (Bitfield-Mask: 0x03)                            */
#define UART0_UARTLCR_H_FEN_Pos           (4UL)                     /*!< FEN (Bit 4)                                           */
#define UART0_UARTLCR_H_FEN_Msk           (0x10UL)                  /*!< FEN (Bitfield-Mask: 0x01)                             */
#define UART0_UARTLCR_H_STP2_Pos          (3UL)                     /*!< STP2 (Bit 3)                                          */
#define UART0_UARTLCR_H_STP2_Msk          (0x8UL)                   /*!< STP2 (Bitfield-Mask: 0x01)                            */
#define UART0_UARTLCR_H_EPS_Pos           (2UL)                     /*!< EPS (Bit 2)                                           */
#define UART0_UARTLCR_H_EPS_Msk           (0x4UL)                   /*!< EPS (Bitfield-Mask: 0x01)                             */
#define UART0_UARTLCR_H_PEN_Pos           (1UL)                     /*!< PEN (Bit 1)                                           */
#define UART0_UARTLCR_H_PEN_Msk           (0x2UL)                   /*!< PEN (Bitfield-Mask: 0x01)                             */
#define UART0_UARTLCR_H_BRK_Pos           (0UL)                     /*!< BRK (Bit 0)                                           */
#define UART0_UARTLCR_H_BRK_Msk           (0x1UL)                   /*!< BRK (Bitfield-Mask: 0x01)                             */
/* ========================================================  UARTCR  ========================================================= */
#define UART0_UARTCR_CTSEN_Pos            (15UL)                    /*!< CTSEN (Bit 15)                                        */
#define UART0_UARTCR_CTSEN_Msk            (0x8000UL)                /*!< CTSEN (Bitfield-Mask: 0x01)                           */
#define UART0_UARTCR_RTSEN_Pos            (14UL)                    /*!< RTSEN (Bit 14)                                        */
#define UART0_UARTCR_RTSEN_Msk            (0x4000UL)                /*!< RTSEN (Bitfield-Mask: 0x01)                           */
#define UART0_UARTCR_OUT2_Pos             (13UL)                    /*!< OUT2 (Bit 13)                                         */
#define UART0_UARTCR_OUT2_Msk             (0x2000UL)                /*!< OUT2 (Bitfield-Mask: 0x01)                            */
#define UART0_UARTCR_OUT1_Pos             (12UL)                    /*!< OUT1 (Bit 12)                                         */
#define UART0_UARTCR_OUT1_Msk             (0x1000UL)                /*!< OUT1 (Bitfield-Mask: 0x01)                            */
#define UART0_UARTCR_RTS_Pos              (11UL)                    /*!< RTS (Bit 11)                                          */
#define UART0_UARTCR_RTS_Msk              (0x800UL)                 /*!< RTS (Bitfield-Mask: 0x01)                             */
#define UART0_UARTCR_DTR_Pos              (10UL)                    /*!< DTR (Bit 10)                                          */
#define UART0_UARTCR_DTR_Msk              (0x400UL)                 /*!< DTR (Bitfield-Mask: 0x01)                             */
#define UART0_UARTCR_RXE_Pos              (9UL)                     /*!< RXE (Bit 9)                                           */
#define UART0_UARTCR_RXE_Msk              (0x200UL)                 /*!< RXE (Bitfield-Mask: 0x01)                             */
#define UART0_UARTCR_TXE_Pos              (8UL)                     /*!< TXE (Bit 8)                                           */
#define UART0_UARTCR_TXE_Msk              (0x100UL)                 /*!< TXE (Bitfield-Mask: 0x01)                             */
#define UART0_UARTCR_LBE_Pos              (7UL)                     /*!< LBE (Bit 7)                                           */
#define UART0_UARTCR_LBE_Msk              (0x80UL)                  /*!< LBE (Bitfield-Mask: 0x01)                             */
#define UART0_UARTCR_SIRLP_Pos            (2UL)                     /*!< SIRLP (Bit 2)                                         */
#define UART0_UARTCR_SIRLP_Msk            (0x4UL)                   /*!< SIRLP (Bitfield-Mask: 0x01)                           */
#define UART0_UARTCR_SIREN_Pos            (1UL)                     /*!< SIREN (Bit 1)                                         */
#define UART0_UARTCR_SIREN_Msk            (0x2UL)                   /*!< SIREN (Bitfield-Mask: 0x01)                           */
#define UART0_UARTCR_UARTEN_Pos           (0UL)                     /*!< UARTEN (Bit 0)                                        */
#define UART0_UARTCR_UARTEN_Msk           (0x1UL)                   /*!< UARTEN (Bitfield-Mask: 0x01)                          */
/* =======================================================  UARTIFLS  ======================================================== */
#define UART0_UARTIFLS_RXIFLSEL_Pos       (3UL)                     /*!< RXIFLSEL (Bit 3)                                      */
#define UART0_UARTIFLS_RXIFLSEL_Msk       (0x38UL)                  /*!< RXIFLSEL (Bitfield-Mask: 0x07)                        */
#define UART0_UARTIFLS_TXIFLSEL_Pos       (0UL)                     /*!< TXIFLSEL (Bit 0)                                      */
#define UART0_UARTIFLS_TXIFLSEL_Msk       (0x7UL)                   /*!< TXIFLSEL (Bitfield-Mask: 0x07)                        */
/* =======================================================  UARTIMSC  ======================================================== */
#define UART0_UARTIMSC_OEIM_Pos           (10UL)                    /*!< OEIM (Bit 10)                                         */
#define UART0_UARTIMSC_OEIM_Msk           (0x400UL)                 /*!< OEIM (Bitfield-Mask: 0x01)                            */
#define UART0_UARTIMSC_BEIM_Pos           (9UL)                     /*!< BEIM (Bit 9)                                          */
#define UART0_UARTIMSC_BEIM_Msk           (0x200UL)                 /*!< BEIM (Bitfield-Mask: 0x01)                            */
#define UART0_UARTIMSC_PEIM_Pos           (8UL)                     /*!< PEIM (Bit 8)                                          */
#define UART0_UARTIMSC_PEIM_Msk           (0x100UL)                 /*!< PEIM (Bitfield-Mask: 0x01)                            */
#define UART0_UARTIMSC_FEIM_Pos           (7UL)                     /*!< FEIM (Bit 7)                                          */
#define UART0_UARTIMSC_FEIM_Msk           (0x80UL)                  /*!< FEIM (Bitfield-Mask: 0x01)                            */
#define UART0_UARTIMSC_RTIM_Pos           (6UL)                     /*!< RTIM (Bit 6)                                          */
#define UART0_UARTIMSC_RTIM_Msk           (0x40UL)                  /*!< RTIM (Bitfield-Mask: 0x01)                            */
#define UART0_UARTIMSC_TXIM_Pos           (5UL)                     /*!< TXIM (Bit 5)                                          */
#define UART0_UARTIMSC_TXIM_Msk           (0x20UL)                  /*!< TXIM (Bitfield-Mask: 0x01)                            */
#define UART0_UARTIMSC_RXIM_Pos           (4UL)                     /*!< RXIM (Bit 4)                                          */
#define UART0_UARTIMSC_RXIM_Msk           (0x10UL)                  /*!< RXIM (Bitfield-Mask: 0x01)                            */
#define UART0_UARTIMSC_DSRMIM_Pos         (3UL)                     /*!< DSRMIM (Bit 3)                                        */
#define UART0_UARTIMSC_DSRMIM_Msk         (0x8UL)                   /*!< DSRMIM (Bitfield-Mask: 0x01)                          */
#define UART0_UARTIMSC_DCDMIM_Pos         (2UL)                     /*!< DCDMIM (Bit 2)                                        */
#define UART0_UARTIMSC_DCDMIM_Msk         (0x4UL)                   /*!< DCDMIM (Bitfield-Mask: 0x01)                          */
#define UART0_UARTIMSC_CTSMIM_Pos         (1UL)                     /*!< CTSMIM (Bit 1)                                        */
#define UART0_UARTIMSC_CTSMIM_Msk         (0x2UL)                   /*!< CTSMIM (Bitfield-Mask: 0x01)                          */
#define UART0_UARTIMSC_RIMIM_Pos          (0UL)                     /*!< RIMIM (Bit 0)                                         */
#define UART0_UARTIMSC_RIMIM_Msk          (0x1UL)                   /*!< RIMIM (Bitfield-Mask: 0x01)                           */
/* ========================================================  UARTRIS  ======================================================== */
#define UART0_UARTRIS_OERIS_Pos           (10UL)                    /*!< OERIS (Bit 10)                                        */
#define UART0_UARTRIS_OERIS_Msk           (0x400UL)                 /*!< OERIS (Bitfield-Mask: 0x01)                           */
#define UART0_UARTRIS_BERIS_Pos           (9UL)                     /*!< BERIS (Bit 9)                                         */
#define UART0_UARTRIS_BERIS_Msk           (0x200UL)                 /*!< BERIS (Bitfield-Mask: 0x01)                           */
#define UART0_UARTRIS_PERIS_Pos           (8UL)                     /*!< PERIS (Bit 8)                                         */
#define UART0_UARTRIS_PERIS_Msk           (0x100UL)                 /*!< PERIS (Bitfield-Mask: 0x01)                           */
#define UART0_UARTRIS_FERIS_Pos           (7UL)                     /*!< FERIS (Bit 7)                                         */
#define UART0_UARTRIS_FERIS_Msk           (0x80UL)                  /*!< FERIS (Bitfield-Mask: 0x01)                           */
#define UART0_UARTRIS_RTRIS_Pos           (6UL)                     /*!< RTRIS (Bit 6)                                         */
#define UART0_UARTRIS_RTRIS_Msk           (0x40UL)                  /*!< RTRIS (Bitfield-Mask: 0x01)                           */
#define UART0_UARTRIS_TXRIS_Pos           (5UL)                     /*!< TXRIS (Bit 5)                                         */
#define UART0_UARTRIS_TXRIS_Msk           (0x20UL)                  /*!< TXRIS (Bitfield-Mask: 0x01)                           */
#define UART0_UARTRIS_RXRIS_Pos           (4UL)                     /*!< RXRIS (Bit 4)                                         */
#define UART0_UARTRIS_RXRIS_Msk           (0x10UL)                  /*!< RXRIS (Bitfield-Mask: 0x01)                           */
#define UART0_UARTRIS_DSRRMIS_Pos         (3UL)                     /*!< DSRRMIS (Bit 3)                                       */
#define UART0_UARTRIS_DSRRMIS_Msk         (0x8UL)                   /*!< DSRRMIS (Bitfield-Mask: 0x01)                         */
#define UART0_UARTRIS_DCDRMIS_Pos         (2UL)                     /*!< DCDRMIS (Bit 2)                                       */
#define UART0_UARTRIS_DCDRMIS_Msk         (0x4UL)                   /*!< DCDRMIS (Bitfield-Mask: 0x01)                         */
#define UART0_UARTRIS_CTSRMIS_Pos         (1UL)                     /*!< CTSRMIS (Bit 1)                                       */
#define UART0_UARTRIS_CTSRMIS_Msk         (0x2UL)                   /*!< CTSRMIS (Bitfield-Mask: 0x01)                         */
#define UART0_UARTRIS_RIRMIS_Pos          (0UL)                     /*!< RIRMIS (Bit 0)                                        */
#define UART0_UARTRIS_RIRMIS_Msk          (0x1UL)                   /*!< RIRMIS (Bitfield-Mask: 0x01)                          */
/* ========================================================  UARTMIS  ======================================================== */
#define UART0_UARTMIS_OEMIS_Pos           (10UL)                    /*!< OEMIS (Bit 10)                                        */
#define UART0_UARTMIS_OEMIS_Msk           (0x400UL)                 /*!< OEMIS (Bitfield-Mask: 0x01)                           */
#define UART0_UARTMIS_BEMIS_Pos           (9UL)                     /*!< BEMIS (Bit 9)                                         */
#define UART0_UARTMIS_BEMIS_Msk           (0x200UL)                 /*!< BEMIS (Bitfield-Mask: 0x01)                           */
#define UART0_UARTMIS_PEMIS_Pos           (8UL)                     /*!< PEMIS (Bit 8)                                         */
#define UART0_UARTMIS_PEMIS_Msk           (0x100UL)                 /*!< PEMIS (Bitfield-Mask: 0x01)                           */
#define UART0_UARTMIS_FEMIS_Pos           (7UL)                     /*!< FEMIS (Bit 7)                                         */
#define UART0_UARTMIS_FEMIS_Msk           (0x80UL)                  /*!< FEMIS (Bitfield-Mask: 0x01)                           */
#define UART0_UARTMIS_RTMIS_Pos           (6UL)                     /*!< RTMIS (Bit 6)                                         */
#define UART0_UARTMIS_RTMIS_Msk           (0x40UL)                  /*!< RTMIS (Bitfield-Mask: 0x01)                           */
#define UART0_UARTMIS_TXMIS_Pos           (5UL)                     /*!< TXMIS (Bit 5)                                         */
#define UART0_UARTMIS_TXMIS_Msk           (0x20UL)                  /*!< TXMIS (Bitfield-Mask: 0x01)                           */
#define UART0_UARTMIS_RXMIS_Pos           (4UL)                     /*!< RXMIS (Bit 4)                                         */
#define UART0_UARTMIS_RXMIS_Msk           (0x10UL)                  /*!< RXMIS (Bitfield-Mask: 0x01)                           */
#define UART0_UARTMIS_DSRMMIS_Pos         (3UL)                     /*!< DSRMMIS (Bit 3)                                       */
#define UART0_UARTMIS_DSRMMIS_Msk         (0x8UL)                   /*!< DSRMMIS (Bitfield-Mask: 0x01)                         */
#define UART0_UARTMIS_DCDMMIS_Pos         (2UL)                     /*!< DCDMMIS (Bit 2)                                       */
#define UART0_UARTMIS_DCDMMIS_Msk         (0x4UL)                   /*!< DCDMMIS (Bitfield-Mask: 0x01)                         */
#define UART0_UARTMIS_CTSMMIS_Pos         (1UL)                     /*!< CTSMMIS (Bit 1)                                       */
#define UART0_UARTMIS_CTSMMIS_Msk         (0x2UL)                   /*!< CTSMMIS (Bitfield-Mask: 0x01)                         */
#define UART0_UARTMIS_RIMMIS_Pos          (0UL)                     /*!< RIMMIS (Bit 0)                                        */
#define UART0_UARTMIS_RIMMIS_Msk          (0x1UL)                   /*!< RIMMIS (Bitfield-Mask: 0x01)                          */
/* ========================================================  UARTICR  ======================================================== */
#define UART0_UARTICR_OEIC_Pos            (10UL)                    /*!< OEIC (Bit 10)                                         */
#define UART0_UARTICR_OEIC_Msk            (0x400UL)                 /*!< OEIC (Bitfield-Mask: 0x01)                            */
#define UART0_UARTICR_BEIC_Pos            (9UL)                     /*!< BEIC (Bit 9)                                          */
#define UART0_UARTICR_BEIC_Msk            (0x200UL)                 /*!< BEIC (Bitfield-Mask: 0x01)                            */
#define UART0_UARTICR_PEIC_Pos            (8UL)                     /*!< PEIC (Bit 8)                                          */
#define UART0_UARTICR_PEIC_Msk            (0x100UL)                 /*!< PEIC (Bitfield-Mask: 0x01)                            */
#define UART0_UARTICR_FEIC_Pos            (7UL)                     /*!< FEIC (Bit 7)                                          */
#define UART0_UARTICR_FEIC_Msk            (0x80UL)                  /*!< FEIC (Bitfield-Mask: 0x01)                            */
#define UART0_UARTICR_RTIC_Pos            (6UL)                     /*!< RTIC (Bit 6)                                          */
#define UART0_UARTICR_RTIC_Msk            (0x40UL)                  /*!< RTIC (Bitfield-Mask: 0x01)                            */
#define UART0_UARTICR_TXIC_Pos            (5UL)                     /*!< TXIC (Bit 5)                                          */
#define UART0_UARTICR_TXIC_Msk            (0x20UL)                  /*!< TXIC (Bitfield-Mask: 0x01)                            */
#define UART0_UARTICR_RXIC_Pos            (4UL)                     /*!< RXIC (Bit 4)                                          */
#define UART0_UARTICR_RXIC_Msk            (0x10UL)                  /*!< RXIC (Bitfield-Mask: 0x01)                            */
#define UART0_UARTICR_DSRMIC_Pos          (3UL)                     /*!< DSRMIC (Bit 3)                                        */
#define UART0_UARTICR_DSRMIC_Msk          (0x8UL)                   /*!< DSRMIC (Bitfield-Mask: 0x01)                          */
#define UART0_UARTICR_DCDMIC_Pos          (2UL)                     /*!< DCDMIC (Bit 2)                                        */
#define UART0_UARTICR_DCDMIC_Msk          (0x4UL)                   /*!< DCDMIC (Bitfield-Mask: 0x01)                          */
#define UART0_UARTICR_CTSMIC_Pos          (1UL)                     /*!< CTSMIC (Bit 1)                                        */
#define UART0_UARTICR_CTSMIC_Msk          (0x2UL)                   /*!< CTSMIC (Bitfield-Mask: 0x01)                          */
#define UART0_UARTICR_RIMIC_Pos           (0UL)                     /*!< RIMIC (Bit 0)                                         */
#define UART0_UARTICR_RIMIC_Msk           (0x1UL)                   /*!< RIMIC (Bitfield-Mask: 0x01)                           */
/* =======================================================  UARTDMACR  ======================================================= */
#define UART0_UARTDMACR_DMAONERR_Pos      (2UL)                     /*!< DMAONERR (Bit 2)                                      */
#define UART0_UARTDMACR_DMAONERR_Msk      (0x4UL)                   /*!< DMAONERR (Bitfield-Mask: 0x01)                        */
#define UART0_UARTDMACR_TXDMAE_Pos        (1UL)                     /*!< TXDMAE (Bit 1)                                        */
#define UART0_UARTDMACR_TXDMAE_Msk        (0x2UL)                   /*!< TXDMAE (Bitfield-Mask: 0x01)                          */
#define UART0_UARTDMACR_RXDMAE_Pos        (0UL)                     /*!< RXDMAE (Bit 0)                                        */
#define UART0_UARTDMACR_RXDMAE_Msk        (0x1UL)                   /*!< RXDMAE (Bitfield-Mask: 0x01)                          */
/* =====================================================  UARTPERIPHID0  ===================================================== */
#define UART0_UARTPERIPHID0_PARTNUMBER0_Pos (0UL)                   /*!< PARTNUMBER0 (Bit 0)                                   */
#define UART0_UARTPERIPHID0_PARTNUMBER0_Msk (0xffUL)                /*!< PARTNUMBER0 (Bitfield-Mask: 0xff)                     */
/* =====================================================  UARTPERIPHID1  ===================================================== */
#define UART0_UARTPERIPHID1_DESIGNER0_Pos (4UL)                     /*!< DESIGNER0 (Bit 4)                                     */
#define UART0_UARTPERIPHID1_DESIGNER0_Msk (0xf0UL)                  /*!< DESIGNER0 (Bitfield-Mask: 0x0f)                       */
#define UART0_UARTPERIPHID1_PARTNUMBER1_Pos (0UL)                   /*!< PARTNUMBER1 (Bit 0)                                   */
#define UART0_UARTPERIPHID1_PARTNUMBER1_Msk (0xfUL)                 /*!< PARTNUMBER1 (Bitfield-Mask: 0x0f)                     */
/* =====================================================  UARTPERIPHID2  ===================================================== */
#define UART0_UARTPERIPHID2_REVISION_Pos  (4UL)                     /*!< REVISION (Bit 4)                                      */
#define UART0_UARTPERIPHID2_REVISION_Msk  (0xf0UL)                  /*!< REVISION (Bitfield-Mask: 0x0f)                        */
#define UART0_UARTPERIPHID2_DESIGNER1_Pos (0UL)                     /*!< DESIGNER1 (Bit 0)                                     */
#define UART0_UARTPERIPHID2_DESIGNER1_Msk (0xfUL)                   /*!< DESIGNER1 (Bitfield-Mask: 0x0f)                       */
/* =====================================================  UARTPERIPHID3  ===================================================== */
#define UART0_UARTPERIPHID3_CONFIGURATION_Pos (0UL)                 /*!< CONFIGURATION (Bit 0)                                 */
#define UART0_UARTPERIPHID3_CONFIGURATION_Msk (0xffUL)              /*!< CONFIGURATION (Bitfield-Mask: 0xff)                   */
/* =====================================================  UARTPCELLID0  ====================================================== */
#define UART0_UARTPCELLID0_UARTPCELLID0_Pos (0UL)                   /*!< UARTPCELLID0 (Bit 0)                                  */
#define UART0_UARTPCELLID0_UARTPCELLID0_Msk (0xffUL)                /*!< UARTPCELLID0 (Bitfield-Mask: 0xff)                    */
/* =====================================================  UARTPCELLID1  ====================================================== */
#define UART0_UARTPCELLID1_UARTPCELLID1_Pos (0UL)                   /*!< UARTPCELLID1 (Bit 0)                                  */
#define UART0_UARTPCELLID1_UARTPCELLID1_Msk (0xffUL)                /*!< UARTPCELLID1 (Bitfield-Mask: 0xff)                    */
/* =====================================================  UARTPCELLID2  ====================================================== */
#define UART0_UARTPCELLID2_UARTPCELLID2_Pos (0UL)                   /*!< UARTPCELLID2 (Bit 0)                                  */
#define UART0_UARTPCELLID2_UARTPCELLID2_Msk (0xffUL)                /*!< UARTPCELLID2 (Bitfield-Mask: 0xff)                    */
/* =====================================================  UARTPCELLID3  ====================================================== */
#define UART0_UARTPCELLID3_UARTPCELLID3_Pos (0UL)                   /*!< UARTPCELLID3 (Bit 0)                                  */
#define UART0_UARTPCELLID3_UARTPCELLID3_Msk (0xffUL)                /*!< UARTPCELLID3 (Bitfield-Mask: 0xff)                    */


/* =========================================================================================================================== */
/* ================                                           SPI0                                            ================ */
/* =========================================================================================================================== */

/* ========================================================  SSPCR0  ========================================================= */
#define SPI0_SSPCR0_SCR_Pos               (8UL)                     /*!< SCR (Bit 8)                                           */
#define SPI0_SSPCR0_SCR_Msk               (0xff00UL)                /*!< SCR (Bitfield-Mask: 0xff)                             */
#define SPI0_SSPCR0_SPH_Pos               (7UL)                     /*!< SPH (Bit 7)                                           */
#define SPI0_SSPCR0_SPH_Msk               (0x80UL)                  /*!< SPH (Bitfield-Mask: 0x01)                             */
#define SPI0_SSPCR0_SPO_Pos               (6UL)                     /*!< SPO (Bit 6)                                           */
#define SPI0_SSPCR0_SPO_Msk               (0x40UL)                  /*!< SPO (Bitfield-Mask: 0x01)                             */
#define SPI0_SSPCR0_FRF_Pos               (4UL)                     /*!< FRF (Bit 4)                                           */
#define SPI0_SSPCR0_FRF_Msk               (0x30UL)                  /*!< FRF (Bitfield-Mask: 0x03)                             */
#define SPI0_SSPCR0_DSS_Pos               (0UL)                     /*!< DSS (Bit 0)                                           */
#define SPI0_SSPCR0_DSS_Msk               (0xfUL)                   /*!< DSS (Bitfield-Mask: 0x0f)                             */
/* ========================================================  SSPCR1  ========================================================= */
#define SPI0_SSPCR1_SOD_Pos               (3UL)                     /*!< SOD (Bit 3)                                           */
#define SPI0_SSPCR1_SOD_Msk               (0x8UL)                   /*!< SOD (Bitfield-Mask: 0x01)                             */
#define SPI0_SSPCR1_MS_Pos                (2UL)                     /*!< MS (Bit 2)                                            */
#define SPI0_SSPCR1_MS_Msk                (0x4UL)                   /*!< MS (Bitfield-Mask: 0x01)                              */
#define SPI0_SSPCR1_SSE_Pos               (1UL)                     /*!< SSE (Bit 1)                                           */
#define SPI0_SSPCR1_SSE_Msk               (0x2UL)                   /*!< SSE (Bitfield-Mask: 0x01)                             */
#define SPI0_SSPCR1_LBM_Pos               (0UL)                     /*!< LBM (Bit 0)                                           */
#define SPI0_SSPCR1_LBM_Msk               (0x1UL)                   /*!< LBM (Bitfield-Mask: 0x01)                             */
/* =========================================================  SSPDR  ========================================================= */
#define SPI0_SSPDR_DATA_Pos               (0UL)                     /*!< DATA (Bit 0)                                          */
#define SPI0_SSPDR_DATA_Msk               (0xffffUL)                /*!< DATA (Bitfield-Mask: 0xffff)                          */
/* =========================================================  SSPSR  ========================================================= */
#define SPI0_SSPSR_BSY_Pos                (4UL)                     /*!< BSY (Bit 4)                                           */
#define SPI0_SSPSR_BSY_Msk                (0x10UL)                  /*!< BSY (Bitfield-Mask: 0x01)                             */
#define SPI0_SSPSR_RFF_Pos                (3UL)                     /*!< RFF (Bit 3)                                           */
#define SPI0_SSPSR_RFF_Msk                (0x8UL)                   /*!< RFF (Bitfield-Mask: 0x01)                             */
#define SPI0_SSPSR_RNE_Pos                (2UL)                     /*!< RNE (Bit 2)                                           */
#define SPI0_SSPSR_RNE_Msk                (0x4UL)                   /*!< RNE (Bitfield-Mask: 0x01)                             */
#define SPI0_SSPSR_TNF_Pos                (1UL)                     /*!< TNF (Bit 1)                                           */
#define SPI0_SSPSR_TNF_Msk                (0x2UL)                   /*!< TNF (Bitfield-Mask: 0x01)                             */
#define SPI0_SSPSR_TFE_Pos                (0UL)                     /*!< TFE (Bit 0)                                           */
#define SPI0_SSPSR_TFE_Msk                (0x1UL)                   /*!< TFE (Bitfield-Mask: 0x01)                             */
/* ========================================================  SSPCPSR  ======================================================== */
#define SPI0_SSPCPSR_CPSDVSR_Pos          (0UL)                     /*!< CPSDVSR (Bit 0)                                       */
#define SPI0_SSPCPSR_CPSDVSR_Msk          (0xffUL)                  /*!< CPSDVSR (Bitfield-Mask: 0xff)                         */
/* ========================================================  SSPIMSC  ======================================================== */
#define SPI0_SSPIMSC_TXIM_Pos             (3UL)                     /*!< TXIM (Bit 3)                                          */
#define SPI0_SSPIMSC_TXIM_Msk             (0x8UL)                   /*!< TXIM (Bitfield-Mask: 0x01)                            */
#define SPI0_SSPIMSC_RXIM_Pos             (2UL)                     /*!< RXIM (Bit 2)                                          */
#define SPI0_SSPIMSC_RXIM_Msk             (0x4UL)                   /*!< RXIM (Bitfield-Mask: 0x01)                            */
#define SPI0_SSPIMSC_RTIM_Pos             (1UL)                     /*!< RTIM (Bit 1)                                          */
#define SPI0_SSPIMSC_RTIM_Msk             (0x2UL)                   /*!< RTIM (Bitfield-Mask: 0x01)                            */
#define SPI0_SSPIMSC_RORIM_Pos            (0UL)                     /*!< RORIM (Bit 0)                                         */
#define SPI0_SSPIMSC_RORIM_Msk            (0x1UL)                   /*!< RORIM (Bitfield-Mask: 0x01)                           */
/* ========================================================  SSPRIS  ========================================================= */
#define SPI0_SSPRIS_TXRIS_Pos             (3UL)                     /*!< TXRIS (Bit 3)                                         */
#define SPI0_SSPRIS_TXRIS_Msk             (0x8UL)                   /*!< TXRIS (Bitfield-Mask: 0x01)                           */
#define SPI0_SSPRIS_RXRIS_Pos             (2UL)                     /*!< RXRIS (Bit 2)                                         */
#define SPI0_SSPRIS_RXRIS_Msk             (0x4UL)                   /*!< RXRIS (Bitfield-Mask: 0x01)                           */
#define SPI0_SSPRIS_RTRIS_Pos             (1UL)                     /*!< RTRIS (Bit 1)                                         */
#define SPI0_SSPRIS_RTRIS_Msk             (0x2UL)                   /*!< RTRIS (Bitfield-Mask: 0x01)                           */
#define SPI0_SSPRIS_RORRIS_Pos            (0UL)                     /*!< RORRIS (Bit 0)                                        */
#define SPI0_SSPRIS_RORRIS_Msk            (0x1UL)                   /*!< RORRIS (Bitfield-Mask: 0x01)                          */
/* ========================================================  SSPMIS  ========================================================= */
#define SPI0_SSPMIS_TXMIS_Pos             (3UL)                     /*!< TXMIS (Bit 3)                                         */
#define SPI0_SSPMIS_TXMIS_Msk             (0x8UL)                   /*!< TXMIS (Bitfield-Mask: 0x01)                           */
#define SPI0_SSPMIS_RXMIS_Pos             (2UL)                     /*!< RXMIS (Bit 2)                                         */
#define SPI0_SSPMIS_RXMIS_Msk             (0x4UL)                   /*!< RXMIS (Bitfield-Mask: 0x01)                           */
#define SPI0_SSPMIS_RTMIS_Pos             (1UL)                     /*!< RTMIS (Bit 1)                                         */
#define SPI0_SSPMIS_RTMIS_Msk             (0x2UL)                   /*!< RTMIS (Bitfield-Mask: 0x01)                           */
#define SPI0_SSPMIS_RORMIS_Pos            (0UL)                     /*!< RORMIS (Bit 0)                                        */
#define SPI0_SSPMIS_RORMIS_Msk            (0x1UL)                   /*!< RORMIS (Bitfield-Mask: 0x01)                          */
/* ========================================================  SSPICR  ========================================================= */
#define SPI0_SSPICR_RTIC_Pos              (1UL)                     /*!< RTIC (Bit 1)                                          */
#define SPI0_SSPICR_RTIC_Msk              (0x2UL)                   /*!< RTIC (Bitfield-Mask: 0x01)                            */
#define SPI0_SSPICR_RORIC_Pos             (0UL)                     /*!< RORIC (Bit 0)                                         */
#define SPI0_SSPICR_RORIC_Msk             (0x1UL)                   /*!< RORIC (Bitfield-Mask: 0x01)                           */
/* =======================================================  SSPDMACR  ======================================================== */
#define SPI0_SSPDMACR_TXDMAE_Pos          (1UL)                     /*!< TXDMAE (Bit 1)                                        */
#define SPI0_SSPDMACR_TXDMAE_Msk          (0x2UL)                   /*!< TXDMAE (Bitfield-Mask: 0x01)                          */
#define SPI0_SSPDMACR_RXDMAE_Pos          (0UL)                     /*!< RXDMAE (Bit 0)                                        */
#define SPI0_SSPDMACR_RXDMAE_Msk          (0x1UL)                   /*!< RXDMAE (Bitfield-Mask: 0x01)                          */
/* =====================================================  SSPPERIPHID0  ====================================================== */
#define SPI0_SSPPERIPHID0_PARTNUMBER0_Pos (0UL)                     /*!< PARTNUMBER0 (Bit 0)                                   */
#define SPI0_SSPPERIPHID0_PARTNUMBER0_Msk (0xffUL)                  /*!< PARTNUMBER0 (Bitfield-Mask: 0xff)                     */
/* =====================================================  SSPPERIPHID1  ====================================================== */
#define SPI0_SSPPERIPHID1_DESIGNER0_Pos   (4UL)                     /*!< DESIGNER0 (Bit 4)                                     */
#define SPI0_SSPPERIPHID1_DESIGNER0_Msk   (0xf0UL)                  /*!< DESIGNER0 (Bitfield-Mask: 0x0f)                       */
#define SPI0_SSPPERIPHID1_PARTNUMBER1_Pos (0UL)                     /*!< PARTNUMBER1 (Bit 0)                                   */
#define SPI0_SSPPERIPHID1_PARTNUMBER1_Msk (0xfUL)                   /*!< PARTNUMBER1 (Bitfield-Mask: 0x0f)                     */
/* =====================================================  SSPPERIPHID2  ====================================================== */
#define SPI0_SSPPERIPHID2_REVISION_Pos    (4UL)                     /*!< REVISION (Bit 4)                                      */
#define SPI0_SSPPERIPHID2_REVISION_Msk    (0xf0UL)                  /*!< REVISION (Bitfield-Mask: 0x0f)                        */
#define SPI0_SSPPERIPHID2_DESIGNER1_Pos   (0UL)                     /*!< DESIGNER1 (Bit 0)                                     */
#define SPI0_SSPPERIPHID2_DESIGNER1_Msk   (0xfUL)                   /*!< DESIGNER1 (Bitfield-Mask: 0x0f)                       */
/* =====================================================  SSPPERIPHID3  ====================================================== */
#define SPI0_SSPPERIPHID3_CONFIGURATION_Pos (0UL)                   /*!< CONFIGURATION (Bit 0)                                 */
#define SPI0_SSPPERIPHID3_CONFIGURATION_Msk (0xffUL)                /*!< CONFIGURATION (Bitfield-Mask: 0xff)                   */
/* ======================================================  SSPPCELLID0  ====================================================== */
#define SPI0_SSPPCELLID0_SSPPCELLID0_Pos  (0UL)                     /*!< SSPPCELLID0 (Bit 0)                                   */
#define SPI0_SSPPCELLID0_SSPPCELLID0_Msk  (0xffUL)                  /*!< SSPPCELLID0 (Bitfield-Mask: 0xff)                     */
/* ======================================================  SSPPCELLID1  ====================================================== */
#define SPI0_SSPPCELLID1_SSPPCELLID1_Pos  (0UL)                     /*!< SSPPCELLID1 (Bit 0)                                   */
#define SPI0_SSPPCELLID1_SSPPCELLID1_Msk  (0xffUL)                  /*!< SSPPCELLID1 (Bitfield-Mask: 0xff)                     */
/* ======================================================  SSPPCELLID2  ====================================================== */
#define SPI0_SSPPCELLID2_SSPPCELLID2_Pos  (0UL)                     /*!< SSPPCELLID2 (Bit 0)                                   */
#define SPI0_SSPPCELLID2_SSPPCELLID2_Msk  (0xffUL)                  /*!< SSPPCELLID2 (Bitfield-Mask: 0xff)                     */
/* ======================================================  SSPPCELLID3  ====================================================== */
#define SPI0_SSPPCELLID3_SSPPCELLID3_Pos  (0UL)                     /*!< SSPPCELLID3 (Bit 0)                                   */
#define SPI0_SSPPCELLID3_SSPPCELLID3_Msk  (0xffUL)                  /*!< SSPPCELLID3 (Bitfield-Mask: 0xff)                     */


/* =========================================================================================================================== */
/* ================                                           I2C0                                            ================ */
/* =========================================================================================================================== */

/* ========================================================  IC_CON  ========================================================= */
#define I2C0_IC_CON_STOP_DET_IF_MASTER_ACTIVE_Pos (10UL)            /*!< STOP_DET_IF_MASTER_ACTIVE (Bit 10)                    */
#define I2C0_IC_CON_STOP_DET_IF_MASTER_ACTIVE_Msk (0x400UL)         /*!< STOP_DET_IF_MASTER_ACTIVE (Bitfield-Mask: 0x01)       */
#define I2C0_IC_CON_RX_FIFO_FULL_HLD_CTRL_Pos (9UL)                 /*!< RX_FIFO_FULL_HLD_CTRL (Bit 9)                         */
#define I2C0_IC_CON_RX_FIFO_FULL_HLD_CTRL_Msk (0x200UL)             /*!< RX_FIFO_FULL_HLD_CTRL (Bitfield-Mask: 0x01)           */
#define I2C0_IC_CON_TX_EMPTY_CTRL_Pos     (8UL)                     /*!< TX_EMPTY_CTRL (Bit 8)                                 */
#define I2C0_IC_CON_TX_EMPTY_CTRL_Msk     (0x100UL)                 /*!< TX_EMPTY_CTRL (Bitfield-Mask: 0x01)                   */
#define I2C0_IC_CON_STOP_DET_IFADDRESSED_Pos (7UL)                  /*!< STOP_DET_IFADDRESSED (Bit 7)                          */
#define I2C0_IC_CON_STOP_DET_IFADDRESSED_Msk (0x80UL)               /*!< STOP_DET_IFADDRESSED (Bitfield-Mask: 0x01)            */
#define I2C0_IC_CON_IC_SLAVE_DISABLE_Pos  (6UL)                     /*!< IC_SLAVE_DISABLE (Bit 6)                              */
#define I2C0_IC_CON_IC_SLAVE_DISABLE_Msk  (0x40UL)                  /*!< IC_SLAVE_DISABLE (Bitfield-Mask: 0x01)                */
#define I2C0_IC_CON_IC_RESTART_EN_Pos     (5UL)                     /*!< IC_RESTART_EN (Bit 5)                                 */
#define I2C0_IC_CON_IC_RESTART_EN_Msk     (0x20UL)                  /*!< IC_RESTART_EN (Bitfield-Mask: 0x01)                   */
#define I2C0_IC_CON_IC_10BITADDR_MASTER_Pos (4UL)                   /*!< IC_10BITADDR_MASTER (Bit 4)                           */
#define I2C0_IC_CON_IC_10BITADDR_MASTER_Msk (0x10UL)                /*!< IC_10BITADDR_MASTER (Bitfield-Mask: 0x01)             */
#define I2C0_IC_CON_IC_10BITADDR_SLAVE_Pos (3UL)                    /*!< IC_10BITADDR_SLAVE (Bit 3)                            */
#define I2C0_IC_CON_IC_10BITADDR_SLAVE_Msk (0x8UL)                  /*!< IC_10BITADDR_SLAVE (Bitfield-Mask: 0x01)              */
#define I2C0_IC_CON_SPEED_Pos             (1UL)                     /*!< SPEED (Bit 1)                                         */
#define I2C0_IC_CON_SPEED_Msk             (0x6UL)                   /*!< SPEED (Bitfield-Mask: 0x03)                           */
#define I2C0_IC_CON_MASTER_MODE_Pos       (0UL)                     /*!< MASTER_MODE (Bit 0)                                   */
#define I2C0_IC_CON_MASTER_MODE_Msk       (0x1UL)                   /*!< MASTER_MODE (Bitfield-Mask: 0x01)                     */
/* ========================================================  IC_TAR  ========================================================= */
#define I2C0_IC_TAR_SPECIAL_Pos           (11UL)                    /*!< SPECIAL (Bit 11)                                      */
#define I2C0_IC_TAR_SPECIAL_Msk           (0x800UL)                 /*!< SPECIAL (Bitfield-Mask: 0x01)                         */
#define I2C0_IC_TAR_GC_OR_START_Pos       (10UL)                    /*!< GC_OR_START (Bit 10)                                  */
#define I2C0_IC_TAR_GC_OR_START_Msk       (0x400UL)                 /*!< GC_OR_START (Bitfield-Mask: 0x01)                     */
#define I2C0_IC_TAR_IC_TAR_Pos            (0UL)                     /*!< IC_TAR (Bit 0)                                        */
#define I2C0_IC_TAR_IC_TAR_Msk            (0x3ffUL)                 /*!< IC_TAR (Bitfield-Mask: 0x3ff)                         */
/* ========================================================  IC_SAR  ========================================================= */
#define I2C0_IC_SAR_IC_SAR_Pos            (0UL)                     /*!< IC_SAR (Bit 0)                                        */
#define I2C0_IC_SAR_IC_SAR_Msk            (0x3ffUL)                 /*!< IC_SAR (Bitfield-Mask: 0x3ff)                         */
/* ======================================================  IC_DATA_CMD  ====================================================== */
#define I2C0_IC_DATA_CMD_FIRST_DATA_BYTE_Pos (11UL)                 /*!< FIRST_DATA_BYTE (Bit 11)                              */
#define I2C0_IC_DATA_CMD_FIRST_DATA_BYTE_Msk (0x800UL)              /*!< FIRST_DATA_BYTE (Bitfield-Mask: 0x01)                 */
#define I2C0_IC_DATA_CMD_RESTART_Pos      (10UL)                    /*!< RESTART (Bit 10)                                      */
#define I2C0_IC_DATA_CMD_RESTART_Msk      (0x400UL)                 /*!< RESTART (Bitfield-Mask: 0x01)                         */
#define I2C0_IC_DATA_CMD_STOP_Pos         (9UL)                     /*!< STOP (Bit 9)                                          */
#define I2C0_IC_DATA_CMD_STOP_Msk         (0x200UL)                 /*!< STOP (Bitfield-Mask: 0x01)                            */
#define I2C0_IC_DATA_CMD_CMD_Pos          (8UL)                     /*!< CMD (Bit 8)                                           */
#define I2C0_IC_DATA_CMD_CMD_Msk          (0x100UL)                 /*!< CMD (Bitfield-Mask: 0x01)                             */
#define I2C0_IC_DATA_CMD_DAT_Pos          (0UL)                     /*!< DAT (Bit 0)                                           */
#define I2C0_IC_DATA_CMD_DAT_Msk          (0xffUL)                  /*!< DAT (Bitfield-Mask: 0xff)                             */
/* ====================================================  IC_SS_SCL_HCNT  ===================================================== */
#define I2C0_IC_SS_SCL_HCNT_IC_SS_SCL_HCNT_Pos (0UL)                /*!< IC_SS_SCL_HCNT (Bit 0)                                */
#define I2C0_IC_SS_SCL_HCNT_IC_SS_SCL_HCNT_Msk (0xffffUL)           /*!< IC_SS_SCL_HCNT (Bitfield-Mask: 0xffff)                */
/* ====================================================  IC_SS_SCL_LCNT  ===================================================== */
#define I2C0_IC_SS_SCL_LCNT_IC_SS_SCL_LCNT_Pos (0UL)                /*!< IC_SS_SCL_LCNT (Bit 0)                                */
#define I2C0_IC_SS_SCL_LCNT_IC_SS_SCL_LCNT_Msk (0xffffUL)           /*!< IC_SS_SCL_LCNT (Bitfield-Mask: 0xffff)                */
/* ====================================================  IC_FS_SCL_HCNT  ===================================================== */
#define I2C0_IC_FS_SCL_HCNT_IC_FS_SCL_HCNT_Pos (0UL)                /*!< IC_FS_SCL_HCNT (Bit 0)                                */
#define I2C0_IC_FS_SCL_HCNT_IC_FS_SCL_HCNT_Msk (0xffffUL)           /*!< IC_FS_SCL_HCNT (Bitfield-Mask: 0xffff)                */
/* ====================================================  IC_FS_SCL_LCNT  ===================================================== */
#define I2C0_IC_FS_SCL_LCNT_IC_FS_SCL_LCNT_Pos (0UL)                /*!< IC_FS_SCL_LCNT (Bit 0)                                */
#define I2C0_IC_FS_SCL_LCNT_IC_FS_SCL_LCNT_Msk (0xffffUL)           /*!< IC_FS_SCL_LCNT (Bitfield-Mask: 0xffff)                */
/* =====================================================  IC_INTR_STAT  ====================================================== */
#define I2C0_IC_INTR_STAT_R_MASTER_ON_HOLD_Pos (13UL)               /*!< R_MASTER_ON_HOLD (Bit 13)                             */
#define I2C0_IC_INTR_STAT_R_MASTER_ON_HOLD_Msk (0x2000UL)           /*!< R_MASTER_ON_HOLD (Bitfield-Mask: 0x01)                */
#define I2C0_IC_INTR_STAT_R_RESTART_DET_Pos (12UL)                  /*!< R_RESTART_DET (Bit 12)                                */
#define I2C0_IC_INTR_STAT_R_RESTART_DET_Msk (0x1000UL)              /*!< R_RESTART_DET (Bitfield-Mask: 0x01)                   */
#define I2C0_IC_INTR_STAT_R_GEN_CALL_Pos  (11UL)                    /*!< R_GEN_CALL (Bit 11)                                   */
#define I2C0_IC_INTR_STAT_R_GEN_CALL_Msk  (0x800UL)                 /*!< R_GEN_CALL (Bitfield-Mask: 0x01)                      */
#define I2C0_IC_INTR_STAT_R_START_DET_Pos (10UL)                    /*!< R_START_DET (Bit 10)                                  */
#define I2C0_IC_INTR_STAT_R_START_DET_Msk (0x400UL)                 /*!< R_START_DET (Bitfield-Mask: 0x01)                     */
#define I2C0_IC_INTR_STAT_R_STOP_DET_Pos  (9UL)                     /*!< R_STOP_DET (Bit 9)                                    */
#define I2C0_IC_INTR_STAT_R_STOP_DET_Msk  (0x200UL)                 /*!< R_STOP_DET (Bitfield-Mask: 0x01)                      */
#define I2C0_IC_INTR_STAT_R_ACTIVITY_Pos  (8UL)                     /*!< R_ACTIVITY (Bit 8)                                    */
#define I2C0_IC_INTR_STAT_R_ACTIVITY_Msk  (0x100UL)                 /*!< R_ACTIVITY (Bitfield-Mask: 0x01)                      */
#define I2C0_IC_INTR_STAT_R_RX_DONE_Pos   (7UL)                     /*!< R_RX_DONE (Bit 7)                                     */
#define I2C0_IC_INTR_STAT_R_RX_DONE_Msk   (0x80UL)                  /*!< R_RX_DONE (Bitfield-Mask: 0x01)                       */
#define I2C0_IC_INTR_STAT_R_TX_ABRT_Pos   (6UL)                     /*!< R_TX_ABRT (Bit 6)                                     */
#define I2C0_IC_INTR_STAT_R_TX_ABRT_Msk   (0x40UL)                  /*!< R_TX_ABRT (Bitfield-Mask: 0x01)                       */
#define I2C0_IC_INTR_STAT_R_RD_REQ_Pos    (5UL)                     /*!< R_RD_REQ (Bit 5)                                      */
#define I2C0_IC_INTR_STAT_R_RD_REQ_Msk    (0x20UL)                  /*!< R_RD_REQ (Bitfield-Mask: 0x01)                        */
#define I2C0_IC_INTR_STAT_R_TX_EMPTY_Pos  (4UL)                     /*!< R_TX_EMPTY (Bit 4)                                    */
#define I2C0_IC_INTR_STAT_R_TX_EMPTY_Msk  (0x10UL)                  /*!< R_TX_EMPTY (Bitfield-Mask: 0x01)                      */
#define I2C0_IC_INTR_STAT_R_TX_OVER_Pos   (3UL)                     /*!< R_TX_OVER (Bit 3)                                     */
#define I2C0_IC_INTR_STAT_R_TX_OVER_Msk   (0x8UL)                   /*!< R_TX_OVER (Bitfield-Mask: 0x01)                       */
#define I2C0_IC_INTR_STAT_R_RX_FULL_Pos   (2UL)                     /*!< R_RX_FULL (Bit 2)                                     */
#define I2C0_IC_INTR_STAT_R_RX_FULL_Msk   (0x4UL)                   /*!< R_RX_FULL (Bitfield-Mask: 0x01)                       */
#define I2C0_IC_INTR_STAT_R_RX_OVER_Pos   (1UL)                     /*!< R_RX_OVER (Bit 1)                                     */
#define I2C0_IC_INTR_STAT_R_RX_OVER_Msk   (0x2UL)                   /*!< R_RX_OVER (Bitfield-Mask: 0x01)                       */
#define I2C0_IC_INTR_STAT_R_RX_UNDER_Pos  (0UL)                     /*!< R_RX_UNDER (Bit 0)                                    */
#define I2C0_IC_INTR_STAT_R_RX_UNDER_Msk  (0x1UL)                   /*!< R_RX_UNDER (Bitfield-Mask: 0x01)                      */
/* =====================================================  IC_INTR_MASK  ====================================================== */
#define I2C0_IC_INTR_MASK_M_MASTER_ON_HOLD_READ_ONLY_Pos (13UL)     /*!< M_MASTER_ON_HOLD_READ_ONLY (Bit 13)                   */
#define I2C0_IC_INTR_MASK_M_MASTER_ON_HOLD_READ_ONLY_Msk (0x2000UL) /*!< M_MASTER_ON_HOLD_READ_ONLY (Bitfield-Mask: 0x01)      */
#define I2C0_IC_INTR_MASK_M_RESTART_DET_Pos (12UL)                  /*!< M_RESTART_DET (Bit 12)                                */
#define I2C0_IC_INTR_MASK_M_RESTART_DET_Msk (0x1000UL)              /*!< M_RESTART_DET (Bitfield-Mask: 0x01)                   */
#define I2C0_IC_INTR_MASK_M_GEN_CALL_Pos  (11UL)                    /*!< M_GEN_CALL (Bit 11)                                   */
#define I2C0_IC_INTR_MASK_M_GEN_CALL_Msk  (0x800UL)                 /*!< M_GEN_CALL (Bitfield-Mask: 0x01)                      */
#define I2C0_IC_INTR_MASK_M_START_DET_Pos (10UL)                    /*!< M_START_DET (Bit 10)                                  */
#define I2C0_IC_INTR_MASK_M_START_DET_Msk (0x400UL)                 /*!< M_START_DET (Bitfield-Mask: 0x01)                     */
#define I2C0_IC_INTR_MASK_M_STOP_DET_Pos  (9UL)                     /*!< M_STOP_DET (Bit 9)                                    */
#define I2C0_IC_INTR_MASK_M_STOP_DET_Msk  (0x200UL)                 /*!< M_STOP_DET (Bitfield-Mask: 0x01)                      */
#define I2C0_IC_INTR_MASK_M_ACTIVITY_Pos  (8UL)                     /*!< M_ACTIVITY (Bit 8)                                    */
#define I2C0_IC_INTR_MASK_M_ACTIVITY_Msk  (0x100UL)                 /*!< M_ACTIVITY (Bitfield-Mask: 0x01)                      */
#define I2C0_IC_INTR_MASK_M_RX_DONE_Pos   (7UL)                     /*!< M_RX_DONE (Bit 7)                                     */
#define I2C0_IC_INTR_MASK_M_RX_DONE_Msk   (0x80UL)                  /*!< M_RX_DONE (Bitfield-Mask: 0x01)                       */
#define I2C0_IC_INTR_MASK_M_TX_ABRT_Pos   (6UL)                     /*!< M_TX_ABRT (Bit 6)                                     */
#define I2C0_IC_INTR_MASK_M_TX_ABRT_Msk   (0x40UL)                  /*!< M_TX_ABRT (Bitfield-Mask: 0x01)                       */
#define I2C0_IC_INTR_MASK_M_RD_REQ_Pos    (5UL)                     /*!< M_RD_REQ (Bit 5)                                      */
#define I2C0_IC_INTR_MASK_M_RD_REQ_Msk    (0x20UL)                  /*!< M_RD_REQ (Bitfield-Mask: 0x01)                        */
#define I2C0_IC_INTR_MASK_M_TX_EMPTY_Pos  (4UL)                     /*!< M_TX_EMPTY (Bit 4)                                    */
#define I2C0_IC_INTR_MASK_M_TX_EMPTY_Msk  (0x10UL)                  /*!< M_TX_EMPTY (Bitfield-Mask: 0x01)                      */
#define I2C0_IC_INTR_MASK_M_TX_OVER_Pos   (3UL)                     /*!< M_TX_OVER (Bit 3)                                     */
#define I2C0_IC_INTR_MASK_M_TX_OVER_Msk   (0x8UL)                   /*!< M_TX_OVER (Bitfield-Mask: 0x01)                       */
#define I2C0_IC_INTR_MASK_M_RX_FULL_Pos   (2UL)                     /*!< M_RX_FULL (Bit 2)                                     */
#define I2C0_IC_INTR_MASK_M_RX_FULL_Msk   (0x4UL)                   /*!< M_RX_FULL (Bitfield-Mask: 0x01)                       */
#define I2C0_IC_INTR_MASK_M_RX_OVER_Pos   (1UL)                     /*!< M_RX_OVER (Bit 1)                                     */
#define I2C0_IC_INTR_MASK_M_RX_OVER_Msk   (0x2UL)                   /*!< M_RX_OVER (Bitfield-Mask: 0x01)                       */
#define I2C0_IC_INTR_MASK_M_RX_UNDER_Pos  (0UL)                     /*!< M_RX_UNDER (Bit 0)                                    */
#define I2C0_IC_INTR_MASK_M_RX_UNDER_Msk  (0x1UL)                   /*!< M_RX_UNDER (Bitfield-Mask: 0x01)                      */
/* ===================================================  IC_RAW_INTR_STAT  ==================================================== */
#define I2C0_IC_RAW_INTR_STAT_MASTER_ON_HOLD_Pos (13UL)             /*!< MASTER_ON_HOLD (Bit 13)                               */
#define I2C0_IC_RAW_INTR_STAT_MASTER_ON_HOLD_Msk (0x2000UL)         /*!< MASTER_ON_HOLD (Bitfield-Mask: 0x01)                  */
#define I2C0_IC_RAW_INTR_STAT_RESTART_DET_Pos (12UL)                /*!< RESTART_DET (Bit 12)                                  */
#define I2C0_IC_RAW_INTR_STAT_RESTART_DET_Msk (0x1000UL)            /*!< RESTART_DET (Bitfield-Mask: 0x01)                     */
#define I2C0_IC_RAW_INTR_STAT_GEN_CALL_Pos (11UL)                   /*!< GEN_CALL (Bit 11)                                     */
#define I2C0_IC_RAW_INTR_STAT_GEN_CALL_Msk (0x800UL)                /*!< GEN_CALL (Bitfield-Mask: 0x01)                        */
#define I2C0_IC_RAW_INTR_STAT_START_DET_Pos (10UL)                  /*!< START_DET (Bit 10)                                    */
#define I2C0_IC_RAW_INTR_STAT_START_DET_Msk (0x400UL)               /*!< START_DET (Bitfield-Mask: 0x01)                       */
#define I2C0_IC_RAW_INTR_STAT_STOP_DET_Pos (9UL)                    /*!< STOP_DET (Bit 9)                                      */
#define I2C0_IC_RAW_INTR_STAT_STOP_DET_Msk (0x200UL)                /*!< STOP_DET (Bitfield-Mask: 0x01)                        */
#define I2C0_IC_RAW_INTR_STAT_ACTIVITY_Pos (8UL)                    /*!< ACTIVITY (Bit 8)                                      */
#define I2C0_IC_RAW_INTR_STAT_ACTIVITY_Msk (0x100UL)                /*!< ACTIVITY (Bitfield-Mask: 0x01)                        */
#define I2C0_IC_RAW_INTR_STAT_RX_DONE_Pos (7UL)                     /*!< RX_DONE (Bit 7)                                       */
#define I2C0_IC_RAW_INTR_STAT_RX_DONE_Msk (0x80UL)                  /*!< RX_DONE (Bitfield-Mask: 0x01)                         */
#define I2C0_IC_RAW_INTR_STAT_TX_ABRT_Pos (6UL)                     /*!< TX_ABRT (Bit 6)                                       */
#define I2C0_IC_RAW_INTR_STAT_TX_ABRT_Msk (0x40UL)                  /*!< TX_ABRT (Bitfield-Mask: 0x01)                         */
#define I2C0_IC_RAW_INTR_STAT_RD_REQ_Pos  (5UL)                     /*!< RD_REQ (Bit 5)                                        */
#define I2C0_IC_RAW_INTR_STAT_RD_REQ_Msk  (0x20UL)                  /*!< RD_REQ (Bitfield-Mask: 0x01)                          */
#define I2C0_IC_RAW_INTR_STAT_TX_EMPTY_Pos (4UL)                    /*!< TX_EMPTY (Bit 4)                                      */
#define I2C0_IC_RAW_INTR_STAT_TX_EMPTY_Msk (0x10UL)                 /*!< TX_EMPTY (Bitfield-Mask: 0x01)                        */
#define I2C0_IC_RAW_INTR_STAT_TX_OVER_Pos (3UL)                     /*!< TX_OVER (Bit 3)                                       */
#define I2C0_IC_RAW_INTR_STAT_TX_OVER_Msk (0x8UL)                   /*!< TX_OVER (Bitfield-Mask: 0x01)                         */
#define I2C0_IC_RAW_INTR_STAT_RX_FULL_Pos (2UL)                     /*!< RX_FULL (Bit 2)                                       */
#define I2C0_IC_RAW_INTR_STAT_RX_FULL_Msk (0x4UL)                   /*!< RX_FULL (Bitfield-Mask: 0x01)                         */
#define I2C0_IC_RAW_INTR_STAT_RX_OVER_Pos (1UL)                     /*!< RX_OVER (Bit 1)                                       */
#define I2C0_IC_RAW_INTR_STAT_RX_OVER_Msk (0x2UL)                   /*!< RX_OVER (Bitfield-Mask: 0x01)                         */
#define I2C0_IC_RAW_INTR_STAT_RX_UNDER_Pos (0UL)                    /*!< RX_UNDER (Bit 0)                                      */
#define I2C0_IC_RAW_INTR_STAT_RX_UNDER_Msk (0x1UL)                  /*!< RX_UNDER (Bitfield-Mask: 0x01)                        */
/* =======================================================  IC_RX_TL  ======================================================== */
#define I2C0_IC_RX_TL_RX_TL_Pos           (0UL)                     /*!< RX_TL (Bit 0)                                         */
#define I2C0_IC_RX_TL_RX_TL_Msk           (0xffUL)                  /*!< RX_TL (Bitfield-Mask: 0xff)                           */
/* =======================================================  IC_TX_TL  ======================================================== */
#define I2C0_IC_TX_TL_TX_TL_Pos           (0UL)                     /*!< TX_TL (Bit 0)                                         */
#define I2C0_IC_TX_TL_TX_TL_Msk           (0xffUL)                  /*!< TX_TL (Bitfield-Mask: 0xff)                           */
/* ======================================================  IC_CLR_INTR  ====================================================== */
#define I2C0_IC_CLR_INTR_CLR_INTR_Pos     (0UL)                     /*!< CLR_INTR (Bit 0)                                      */
#define I2C0_IC_CLR_INTR_CLR_INTR_Msk     (0x1UL)                   /*!< CLR_INTR (Bitfield-Mask: 0x01)                        */
/* ====================================================  IC_CLR_RX_UNDER  ==================================================== */
#define I2C0_IC_CLR_RX_UNDER_CLR_RX_UNDER_Pos (0UL)                 /*!< CLR_RX_UNDER (Bit 0)                                  */
#define I2C0_IC_CLR_RX_UNDER_CLR_RX_UNDER_Msk (0x1UL)               /*!< CLR_RX_UNDER (Bitfield-Mask: 0x01)                    */
/* ====================================================  IC_CLR_RX_OVER  ===================================================== */
#define I2C0_IC_CLR_RX_OVER_CLR_RX_OVER_Pos (0UL)                   /*!< CLR_RX_OVER (Bit 0)                                   */
#define I2C0_IC_CLR_RX_OVER_CLR_RX_OVER_Msk (0x1UL)                 /*!< CLR_RX_OVER (Bitfield-Mask: 0x01)                     */
/* ====================================================  IC_CLR_TX_OVER  ===================================================== */
#define I2C0_IC_CLR_TX_OVER_CLR_TX_OVER_Pos (0UL)                   /*!< CLR_TX_OVER (Bit 0)                                   */
#define I2C0_IC_CLR_TX_OVER_CLR_TX_OVER_Msk (0x1UL)                 /*!< CLR_TX_OVER (Bitfield-Mask: 0x01)                     */
/* =====================================================  IC_CLR_RD_REQ  ===================================================== */
#define I2C0_IC_CLR_RD_REQ_CLR_RD_REQ_Pos (0UL)                     /*!< CLR_RD_REQ (Bit 0)                                    */
#define I2C0_IC_CLR_RD_REQ_CLR_RD_REQ_Msk (0x1UL)                   /*!< CLR_RD_REQ (Bitfield-Mask: 0x01)                      */
/* ====================================================  IC_CLR_TX_ABRT  ===================================================== */
#define I2C0_IC_CLR_TX_ABRT_CLR_TX_ABRT_Pos (0UL)                   /*!< CLR_TX_ABRT (Bit 0)                                   */
#define I2C0_IC_CLR_TX_ABRT_CLR_TX_ABRT_Msk (0x1UL)                 /*!< CLR_TX_ABRT (Bitfield-Mask: 0x01)                     */
/* ====================================================  IC_CLR_RX_DONE  ===================================================== */
#define I2C0_IC_CLR_RX_DONE_CLR_RX_DONE_Pos (0UL)                   /*!< CLR_RX_DONE (Bit 0)                                   */
#define I2C0_IC_CLR_RX_DONE_CLR_RX_DONE_Msk (0x1UL)                 /*!< CLR_RX_DONE (Bitfield-Mask: 0x01)                     */
/* ====================================================  IC_CLR_ACTIVITY  ==================================================== */
#define I2C0_IC_CLR_ACTIVITY_CLR_ACTIVITY_Pos (0UL)                 /*!< CLR_ACTIVITY (Bit 0)                                  */
#define I2C0_IC_CLR_ACTIVITY_CLR_ACTIVITY_Msk (0x1UL)               /*!< CLR_ACTIVITY (Bitfield-Mask: 0x01)                    */
/* ====================================================  IC_CLR_STOP_DET  ==================================================== */
#define I2C0_IC_CLR_STOP_DET_CLR_STOP_DET_Pos (0UL)                 /*!< CLR_STOP_DET (Bit 0)                                  */
#define I2C0_IC_CLR_STOP_DET_CLR_STOP_DET_Msk (0x1UL)               /*!< CLR_STOP_DET (Bitfield-Mask: 0x01)                    */
/* ===================================================  IC_CLR_START_DET  ==================================================== */
#define I2C0_IC_CLR_START_DET_CLR_START_DET_Pos (0UL)               /*!< CLR_START_DET (Bit 0)                                 */
#define I2C0_IC_CLR_START_DET_CLR_START_DET_Msk (0x1UL)             /*!< CLR_START_DET (Bitfield-Mask: 0x01)                   */
/* ====================================================  IC_CLR_GEN_CALL  ==================================================== */
#define I2C0_IC_CLR_GEN_CALL_CLR_GEN_CALL_Pos (0UL)                 /*!< CLR_GEN_CALL (Bit 0)                                  */
#define I2C0_IC_CLR_GEN_CALL_CLR_GEN_CALL_Msk (0x1UL)               /*!< CLR_GEN_CALL (Bitfield-Mask: 0x01)                    */
/* =======================================================  IC_ENABLE  ======================================================= */
#define I2C0_IC_ENABLE_TX_CMD_BLOCK_Pos   (2UL)                     /*!< TX_CMD_BLOCK (Bit 2)                                  */
#define I2C0_IC_ENABLE_TX_CMD_BLOCK_Msk   (0x4UL)                   /*!< TX_CMD_BLOCK (Bitfield-Mask: 0x01)                    */
#define I2C0_IC_ENABLE_ABORT_Pos          (1UL)                     /*!< ABORT (Bit 1)                                         */
#define I2C0_IC_ENABLE_ABORT_Msk          (0x2UL)                   /*!< ABORT (Bitfield-Mask: 0x01)                           */
#define I2C0_IC_ENABLE_ENABLE_Pos         (0UL)                     /*!< ENABLE (Bit 0)                                        */
#define I2C0_IC_ENABLE_ENABLE_Msk         (0x1UL)                   /*!< ENABLE (Bitfield-Mask: 0x01)                          */
/* =======================================================  IC_STATUS  ======================================================= */
#define I2C0_IC_STATUS_SLV_ACTIVITY_Pos   (6UL)                     /*!< SLV_ACTIVITY (Bit 6)                                  */
#define I2C0_IC_STATUS_SLV_ACTIVITY_Msk   (0x40UL)                  /*!< SLV_ACTIVITY (Bitfield-Mask: 0x01)                    */
#define I2C0_IC_STATUS_MST_ACTIVITY_Pos   (5UL)                     /*!< MST_ACTIVITY (Bit 5)                                  */
#define I2C0_IC_STATUS_MST_ACTIVITY_Msk   (0x20UL)                  /*!< MST_ACTIVITY (Bitfield-Mask: 0x01)                    */
#define I2C0_IC_STATUS_RFF_Pos            (4UL)                     /*!< RFF (Bit 4)                                           */
#define I2C0_IC_STATUS_RFF_Msk            (0x10UL)                  /*!< RFF (Bitfield-Mask: 0x01)                             */
#define I2C0_IC_STATUS_RFNE_Pos           (3UL)                     /*!< RFNE (Bit 3)                                          */
#define I2C0_IC_STATUS_RFNE_Msk           (0x8UL)                   /*!< RFNE (Bitfield-Mask: 0x01)                            */
#define I2C0_IC_STATUS_TFE_Pos            (2UL)                     /*!< TFE (Bit 2)                                           */
#define I2C0_IC_STATUS_TFE_Msk            (0x4UL)                   /*!< TFE (Bitfield-Mask: 0x01)                             */
#define I2C0_IC_STATUS_TFNF_Pos           (1UL)                     /*!< TFNF (Bit 1)                                          */
#define I2C0_IC_STATUS_TFNF_Msk           (0x2UL)                   /*!< TFNF (Bitfield-Mask: 0x01)                            */
#define I2C0_IC_STATUS_ACTIVITY_Pos       (0UL)                     /*!< ACTIVITY (Bit 0)                                      */
#define I2C0_IC_STATUS_ACTIVITY_Msk       (0x1UL)                   /*!< ACTIVITY (Bitfield-Mask: 0x01)                        */
/* =======================================================  IC_TXFLR  ======================================================== */
#define I2C0_IC_TXFLR_TXFLR_Pos           (0UL)                     /*!< TXFLR (Bit 0)                                         */
#define I2C0_IC_TXFLR_TXFLR_Msk           (0x1fUL)                  /*!< TXFLR (Bitfield-Mask: 0x1f)                           */
/* =======================================================  IC_RXFLR  ======================================================== */
#define I2C0_IC_RXFLR_RXFLR_Pos           (0UL)                     /*!< RXFLR (Bit 0)                                         */
#define I2C0_IC_RXFLR_RXFLR_Msk           (0x1fUL)                  /*!< RXFLR (Bitfield-Mask: 0x1f)                           */
/* ======================================================  IC_SDA_HOLD  ====================================================== */
#define I2C0_IC_SDA_HOLD_IC_SDA_RX_HOLD_Pos (16UL)                  /*!< IC_SDA_RX_HOLD (Bit 16)                               */
#define I2C0_IC_SDA_HOLD_IC_SDA_RX_HOLD_Msk (0xff0000UL)            /*!< IC_SDA_RX_HOLD (Bitfield-Mask: 0xff)                  */
#define I2C0_IC_SDA_HOLD_IC_SDA_TX_HOLD_Pos (0UL)                   /*!< IC_SDA_TX_HOLD (Bit 0)                                */
#define I2C0_IC_SDA_HOLD_IC_SDA_TX_HOLD_Msk (0xffffUL)              /*!< IC_SDA_TX_HOLD (Bitfield-Mask: 0xffff)                */
/* ===================================================  IC_TX_ABRT_SOURCE  =================================================== */
#define I2C0_IC_TX_ABRT_SOURCE_TX_FLUSH_CNT_Pos (23UL)              /*!< TX_FLUSH_CNT (Bit 23)                                 */
#define I2C0_IC_TX_ABRT_SOURCE_TX_FLUSH_CNT_Msk (0xff800000UL)      /*!< TX_FLUSH_CNT (Bitfield-Mask: 0x1ff)                   */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT_Pos (16UL)            /*!< ABRT_USER_ABRT (Bit 16)                               */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT_Msk (0x10000UL)       /*!< ABRT_USER_ABRT (Bitfield-Mask: 0x01)                  */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX_Pos (15UL)           /*!< ABRT_SLVRD_INTX (Bit 15)                              */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX_Msk (0x8000UL)       /*!< ABRT_SLVRD_INTX (Bitfield-Mask: 0x01)                 */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST_Pos (14UL)          /*!< ABRT_SLV_ARBLOST (Bit 14)                             */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST_Msk (0x4000UL)      /*!< ABRT_SLV_ARBLOST (Bitfield-Mask: 0x01)                */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO_Pos (13UL)      /*!< ABRT_SLVFLUSH_TXFIFO (Bit 13)                         */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO_Msk (0x2000UL)  /*!< ABRT_SLVFLUSH_TXFIFO (Bitfield-Mask: 0x01)            */
#define I2C0_IC_TX_ABRT_SOURCE_ARB_LOST_Pos (12UL)                  /*!< ARB_LOST (Bit 12)                                     */
#define I2C0_IC_TX_ABRT_SOURCE_ARB_LOST_Msk (0x1000UL)              /*!< ARB_LOST (Bitfield-Mask: 0x01)                        */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS_Pos (11UL)           /*!< ABRT_MASTER_DIS (Bit 11)                              */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS_Msk (0x800UL)        /*!< ABRT_MASTER_DIS (Bitfield-Mask: 0x01)                 */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT_Pos (10UL)       /*!< ABRT_10B_RD_NORSTRT (Bit 10)                          */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT_Msk (0x400UL)    /*!< ABRT_10B_RD_NORSTRT (Bitfield-Mask: 0x01)             */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT_Pos (9UL)         /*!< ABRT_SBYTE_NORSTRT (Bit 9)                            */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT_Msk (0x200UL)     /*!< ABRT_SBYTE_NORSTRT (Bitfield-Mask: 0x01)              */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT_Pos (8UL)            /*!< ABRT_HS_NORSTRT (Bit 8)                               */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT_Msk (0x100UL)        /*!< ABRT_HS_NORSTRT (Bitfield-Mask: 0x01)                 */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET_Pos (7UL)          /*!< ABRT_SBYTE_ACKDET (Bit 7)                             */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET_Msk (0x80UL)       /*!< ABRT_SBYTE_ACKDET (Bitfield-Mask: 0x01)               */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET_Pos (6UL)             /*!< ABRT_HS_ACKDET (Bit 6)                                */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET_Msk (0x40UL)          /*!< ABRT_HS_ACKDET (Bitfield-Mask: 0x01)                  */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ_Pos (5UL)            /*!< ABRT_GCALL_READ (Bit 5)                               */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ_Msk (0x20UL)         /*!< ABRT_GCALL_READ (Bitfield-Mask: 0x01)                 */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK_Pos (4UL)           /*!< ABRT_GCALL_NOACK (Bit 4)                              */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK_Msk (0x10UL)        /*!< ABRT_GCALL_NOACK (Bitfield-Mask: 0x01)                */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK_Pos (3UL)          /*!< ABRT_TXDATA_NOACK (Bit 3)                             */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK_Msk (0x8UL)        /*!< ABRT_TXDATA_NOACK (Bitfield-Mask: 0x01)               */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK_Pos (2UL)         /*!< ABRT_10ADDR2_NOACK (Bit 2)                            */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK_Msk (0x4UL)       /*!< ABRT_10ADDR2_NOACK (Bitfield-Mask: 0x01)              */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK_Pos (1UL)         /*!< ABRT_10ADDR1_NOACK (Bit 1)                            */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK_Msk (0x2UL)       /*!< ABRT_10ADDR1_NOACK (Bitfield-Mask: 0x01)              */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK_Pos (0UL)         /*!< ABRT_7B_ADDR_NOACK (Bit 0)                            */
#define I2C0_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK_Msk (0x1UL)       /*!< ABRT_7B_ADDR_NOACK (Bitfield-Mask: 0x01)              */
/* =================================================  IC_SLV_DATA_NACK_ONLY  ================================================= */
#define I2C0_IC_SLV_DATA_NACK_ONLY_NACK_Pos (0UL)                   /*!< NACK (Bit 0)                                          */
#define I2C0_IC_SLV_DATA_NACK_ONLY_NACK_Msk (0x1UL)                 /*!< NACK (Bitfield-Mask: 0x01)                            */
/* =======================================================  IC_DMA_CR  ======================================================= */
#define I2C0_IC_DMA_CR_TDMAE_Pos          (1UL)                     /*!< TDMAE (Bit 1)                                         */
#define I2C0_IC_DMA_CR_TDMAE_Msk          (0x2UL)                   /*!< TDMAE (Bitfield-Mask: 0x01)                           */
#define I2C0_IC_DMA_CR_RDMAE_Pos          (0UL)                     /*!< RDMAE (Bit 0)                                         */
#define I2C0_IC_DMA_CR_RDMAE_Msk          (0x1UL)                   /*!< RDMAE (Bitfield-Mask: 0x01)                           */
/* ======================================================  IC_DMA_TDLR  ====================================================== */
#define I2C0_IC_DMA_TDLR_DMATDL_Pos       (0UL)                     /*!< DMATDL (Bit 0)                                        */
#define I2C0_IC_DMA_TDLR_DMATDL_Msk       (0xfUL)                   /*!< DMATDL (Bitfield-Mask: 0x0f)                          */
/* ======================================================  IC_DMA_RDLR  ====================================================== */
#define I2C0_IC_DMA_RDLR_DMARDL_Pos       (0UL)                     /*!< DMARDL (Bit 0)                                        */
#define I2C0_IC_DMA_RDLR_DMARDL_Msk       (0xfUL)                   /*!< DMARDL (Bitfield-Mask: 0x0f)                          */
/* =====================================================  IC_SDA_SETUP  ====================================================== */
#define I2C0_IC_SDA_SETUP_SDA_SETUP_Pos   (0UL)                     /*!< SDA_SETUP (Bit 0)                                     */
#define I2C0_IC_SDA_SETUP_SDA_SETUP_Msk   (0xffUL)                  /*!< SDA_SETUP (Bitfield-Mask: 0xff)                       */
/* ==================================================  IC_ACK_GENERAL_CALL  ================================================== */
#define I2C0_IC_ACK_GENERAL_CALL_ACK_GEN_CALL_Pos (0UL)             /*!< ACK_GEN_CALL (Bit 0)                                  */
#define I2C0_IC_ACK_GENERAL_CALL_ACK_GEN_CALL_Msk (0x1UL)           /*!< ACK_GEN_CALL (Bitfield-Mask: 0x01)                    */
/* ===================================================  IC_ENABLE_STATUS  ==================================================== */
#define I2C0_IC_ENABLE_STATUS_SLV_RX_DATA_LOST_Pos (2UL)            /*!< SLV_RX_DATA_LOST (Bit 2)                              */
#define I2C0_IC_ENABLE_STATUS_SLV_RX_DATA_LOST_Msk (0x4UL)          /*!< SLV_RX_DATA_LOST (Bitfield-Mask: 0x01)                */
#define I2C0_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY_Pos (1UL)     /*!< SLV_DISABLED_WHILE_BUSY (Bit 1)                       */
#define I2C0_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY_Msk (0x2UL)   /*!< SLV_DISABLED_WHILE_BUSY (Bitfield-Mask: 0x01)         */
#define I2C0_IC_ENABLE_STATUS_IC_EN_Pos   (0UL)                     /*!< IC_EN (Bit 0)                                         */
#define I2C0_IC_ENABLE_STATUS_IC_EN_Msk   (0x1UL)                   /*!< IC_EN (Bitfield-Mask: 0x01)                           */
/* =====================================================  IC_FS_SPKLEN  ====================================================== */
#define I2C0_IC_FS_SPKLEN_IC_FS_SPKLEN_Pos (0UL)                    /*!< IC_FS_SPKLEN (Bit 0)                                  */
#define I2C0_IC_FS_SPKLEN_IC_FS_SPKLEN_Msk (0xffUL)                 /*!< IC_FS_SPKLEN (Bitfield-Mask: 0xff)                    */
/* ==================================================  IC_CLR_RESTART_DET  =================================================== */
#define I2C0_IC_CLR_RESTART_DET_CLR_RESTART_DET_Pos (0UL)           /*!< CLR_RESTART_DET (Bit 0)                               */
#define I2C0_IC_CLR_RESTART_DET_CLR_RESTART_DET_Msk (0x1UL)         /*!< CLR_RESTART_DET (Bitfield-Mask: 0x01)                 */
/* ====================================================  IC_COMP_PARAM_1  ==================================================== */
#define I2C0_IC_COMP_PARAM_1_TX_BUFFER_DEPTH_Pos (16UL)             /*!< TX_BUFFER_DEPTH (Bit 16)                              */
#define I2C0_IC_COMP_PARAM_1_TX_BUFFER_DEPTH_Msk (0xff0000UL)       /*!< TX_BUFFER_DEPTH (Bitfield-Mask: 0xff)                 */
#define I2C0_IC_COMP_PARAM_1_RX_BUFFER_DEPTH_Pos (8UL)              /*!< RX_BUFFER_DEPTH (Bit 8)                               */
#define I2C0_IC_COMP_PARAM_1_RX_BUFFER_DEPTH_Msk (0xff00UL)         /*!< RX_BUFFER_DEPTH (Bitfield-Mask: 0xff)                 */
#define I2C0_IC_COMP_PARAM_1_ADD_ENCODED_PARAMS_Pos (7UL)           /*!< ADD_ENCODED_PARAMS (Bit 7)                            */
#define I2C0_IC_COMP_PARAM_1_ADD_ENCODED_PARAMS_Msk (0x80UL)        /*!< ADD_ENCODED_PARAMS (Bitfield-Mask: 0x01)              */
#define I2C0_IC_COMP_PARAM_1_HAS_DMA_Pos  (6UL)                     /*!< HAS_DMA (Bit 6)                                       */
#define I2C0_IC_COMP_PARAM_1_HAS_DMA_Msk  (0x40UL)                  /*!< HAS_DMA (Bitfield-Mask: 0x01)                         */
#define I2C0_IC_COMP_PARAM_1_INTR_IO_Pos  (5UL)                     /*!< INTR_IO (Bit 5)                                       */
#define I2C0_IC_COMP_PARAM_1_INTR_IO_Msk  (0x20UL)                  /*!< INTR_IO (Bitfield-Mask: 0x01)                         */
#define I2C0_IC_COMP_PARAM_1_HC_COUNT_VALUES_Pos (4UL)              /*!< HC_COUNT_VALUES (Bit 4)                               */
#define I2C0_IC_COMP_PARAM_1_HC_COUNT_VALUES_Msk (0x10UL)           /*!< HC_COUNT_VALUES (Bitfield-Mask: 0x01)                 */
#define I2C0_IC_COMP_PARAM_1_MAX_SPEED_MODE_Pos (2UL)               /*!< MAX_SPEED_MODE (Bit 2)                                */
#define I2C0_IC_COMP_PARAM_1_MAX_SPEED_MODE_Msk (0xcUL)             /*!< MAX_SPEED_MODE (Bitfield-Mask: 0x03)                  */
#define I2C0_IC_COMP_PARAM_1_APB_DATA_WIDTH_Pos (0UL)               /*!< APB_DATA_WIDTH (Bit 0)                                */
#define I2C0_IC_COMP_PARAM_1_APB_DATA_WIDTH_Msk (0x3UL)             /*!< APB_DATA_WIDTH (Bitfield-Mask: 0x03)                  */
/* ====================================================  IC_COMP_VERSION  ==================================================== */
#define I2C0_IC_COMP_VERSION_IC_COMP_VERSION_Pos (0UL)              /*!< IC_COMP_VERSION (Bit 0)                               */
#define I2C0_IC_COMP_VERSION_IC_COMP_VERSION_Msk (0xffffffffUL)     /*!< IC_COMP_VERSION (Bitfield-Mask: 0xffffffff)           */
/* =====================================================  IC_COMP_TYPE  ====================================================== */
#define I2C0_IC_COMP_TYPE_IC_COMP_TYPE_Pos (0UL)                    /*!< IC_COMP_TYPE (Bit 0)                                  */
#define I2C0_IC_COMP_TYPE_IC_COMP_TYPE_Msk (0xffffffffUL)           /*!< IC_COMP_TYPE (Bitfield-Mask: 0xffffffff)              */


/* =========================================================================================================================== */
/* ================                                            ADC                                            ================ */
/* =========================================================================================================================== */

/* ==========================================================  CS  =========================================================== */
#define ADC_CS_RROBIN_Pos                 (16UL)                    /*!< RROBIN (Bit 16)                                       */
#define ADC_CS_RROBIN_Msk                 (0x1f0000UL)              /*!< RROBIN (Bitfield-Mask: 0x1f)                          */
#define ADC_CS_AINSEL_Pos                 (12UL)                    /*!< AINSEL (Bit 12)                                       */
#define ADC_CS_AINSEL_Msk                 (0x7000UL)                /*!< AINSEL (Bitfield-Mask: 0x07)                          */
#define ADC_CS_ERR_STICKY_Pos             (10UL)                    /*!< ERR_STICKY (Bit 10)                                   */
#define ADC_CS_ERR_STICKY_Msk             (0x400UL)                 /*!< ERR_STICKY (Bitfield-Mask: 0x01)                      */
#define ADC_CS_ERR_Pos                    (9UL)                     /*!< ERR (Bit 9)                                           */
#define ADC_CS_ERR_Msk                    (0x200UL)                 /*!< ERR (Bitfield-Mask: 0x01)                             */
#define ADC_CS_READY_Pos                  (8UL)                     /*!< READY (Bit 8)                                         */
#define ADC_CS_READY_Msk                  (0x100UL)                 /*!< READY (Bitfield-Mask: 0x01)                           */
#define ADC_CS_START_MANY_Pos             (3UL)                     /*!< START_MANY (Bit 3)                                    */
#define ADC_CS_START_MANY_Msk             (0x8UL)                   /*!< START_MANY (Bitfield-Mask: 0x01)                      */
#define ADC_CS_START_ONCE_Pos             (2UL)                     /*!< START_ONCE (Bit 2)                                    */
#define ADC_CS_START_ONCE_Msk             (0x4UL)                   /*!< START_ONCE (Bitfield-Mask: 0x01)                      */
#define ADC_CS_TS_EN_Pos                  (1UL)                     /*!< TS_EN (Bit 1)                                         */
#define ADC_CS_TS_EN_Msk                  (0x2UL)                   /*!< TS_EN (Bitfield-Mask: 0x01)                           */
#define ADC_CS_EN_Pos                     (0UL)                     /*!< EN (Bit 0)                                            */
#define ADC_CS_EN_Msk                     (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01)                              */
/* ========================================================  RESULT  ========================================================= */
#define ADC_RESULT_RESULT_Pos             (0UL)                     /*!< RESULT (Bit 0)                                        */
#define ADC_RESULT_RESULT_Msk             (0xfffUL)                 /*!< RESULT (Bitfield-Mask: 0xfff)                         */
/* ==========================================================  FCS  ========================================================== */
#define ADC_FCS_THRESH_Pos                (24UL)                    /*!< THRESH (Bit 24)                                       */
#define ADC_FCS_THRESH_Msk                (0xf000000UL)             /*!< THRESH (Bitfield-Mask: 0x0f)                          */
#define ADC_FCS_LEVEL_Pos                 (16UL)                    /*!< LEVEL (Bit 16)                                        */
#define ADC_FCS_LEVEL_Msk                 (0xf0000UL)               /*!< LEVEL (Bitfield-Mask: 0x0f)                           */
#define ADC_FCS_OVER_Pos                  (11UL)                    /*!< OVER (Bit 11)                                         */
#define ADC_FCS_OVER_Msk                  (0x800UL)                 /*!< OVER (Bitfield-Mask: 0x01)                            */
#define ADC_FCS_UNDER_Pos                 (10UL)                    /*!< UNDER (Bit 10)                                        */
#define ADC_FCS_UNDER_Msk                 (0x400UL)                 /*!< UNDER (Bitfield-Mask: 0x01)                           */
#define ADC_FCS_FULL_Pos                  (9UL)                     /*!< FULL (Bit 9)                                          */
#define ADC_FCS_FULL_Msk                  (0x200UL)                 /*!< FULL (Bitfield-Mask: 0x01)                            */
#define ADC_FCS_EMPTY_Pos                 (8UL)                     /*!< EMPTY (Bit 8)                                         */
#define ADC_FCS_EMPTY_Msk                 (0x100UL)                 /*!< EMPTY (Bitfield-Mask: 0x01)                           */
#define ADC_FCS_DREQ_EN_Pos               (3UL)                     /*!< DREQ_EN (Bit 3)                                       */
#define ADC_FCS_DREQ_EN_Msk               (0x8UL)                   /*!< DREQ_EN (Bitfield-Mask: 0x01)                         */
#define ADC_FCS_ERR_Pos                   (2UL)                     /*!< ERR (Bit 2)                                           */
#define ADC_FCS_ERR_Msk                   (0x4UL)                   /*!< ERR (Bitfield-Mask: 0x01)                             */
#define ADC_FCS_SHIFT_Pos                 (1UL)                     /*!< SHIFT (Bit 1)                                         */
#define ADC_FCS_SHIFT_Msk                 (0x2UL)                   /*!< SHIFT (Bitfield-Mask: 0x01)                           */
#define ADC_FCS_EN_Pos                    (0UL)                     /*!< EN (Bit 0)                                            */
#define ADC_FCS_EN_Msk                    (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01)                              */
/* =========================================================  FIFO  ========================================================== */
#define ADC_FIFO_ERR_Pos                  (15UL)                    /*!< ERR (Bit 15)                                          */
#define ADC_FIFO_ERR_Msk                  (0x8000UL)                /*!< ERR (Bitfield-Mask: 0x01)                             */
#define ADC_FIFO_VAL_Pos                  (0UL)                     /*!< VAL (Bit 0)                                           */
#define ADC_FIFO_VAL_Msk                  (0xfffUL)                 /*!< VAL (Bitfield-Mask: 0xfff)                            */
/* ==========================================================  DIV  ========================================================== */
#define ADC_DIV_INT_Pos                   (8UL)                     /*!< INT (Bit 8)                                           */
#define ADC_DIV_INT_Msk                   (0xffff00UL)              /*!< INT (Bitfield-Mask: 0xffff)                           */
#define ADC_DIV_FRAC_Pos                  (0UL)                     /*!< FRAC (Bit 0)                                          */
#define ADC_DIV_FRAC_Msk                  (0xffUL)                  /*!< FRAC (Bitfield-Mask: 0xff)                            */
/* =========================================================  INTR  ========================================================== */
#define ADC_INTR_FIFO_Pos                 (0UL)                     /*!< FIFO (Bit 0)                                          */
#define ADC_INTR_FIFO_Msk                 (0x1UL)                   /*!< FIFO (Bitfield-Mask: 0x01)                            */
/* =========================================================  INTE  ========================================================== */
#define ADC_INTE_FIFO_Pos                 (0UL)                     /*!< FIFO (Bit 0)                                          */
#define ADC_INTE_FIFO_Msk                 (0x1UL)                   /*!< FIFO (Bitfield-Mask: 0x01)                            */
/* =========================================================  INTF  ========================================================== */
#define ADC_INTF_FIFO_Pos                 (0UL)                     /*!< FIFO (Bit 0)                                          */
#define ADC_INTF_FIFO_Msk                 (0x1UL)                   /*!< FIFO (Bitfield-Mask: 0x01)                            */
/* =========================================================  INTS  ========================================================== */
#define ADC_INTS_FIFO_Pos                 (0UL)                     /*!< FIFO (Bit 0)                                          */
#define ADC_INTS_FIFO_Msk                 (0x1UL)                   /*!< FIFO (Bitfield-Mask: 0x01)                            */


/* =========================================================================================================================== */
/* ================                                            PWM                                            ================ */
/* =========================================================================================================================== */

/* ========================================================  CH0_CSR  ======================================================== */
#define PWM_CH0_CSR_PH_ADV_Pos            (7UL)                     /*!< PH_ADV (Bit 7)                                        */
#define PWM_CH0_CSR_PH_ADV_Msk            (0x80UL)                  /*!< PH_ADV (Bitfield-Mask: 0x01)                          */
#define PWM_CH0_CSR_PH_RET_Pos            (6UL)                     /*!< PH_RET (Bit 6)                                        */
#define PWM_CH0_CSR_PH_RET_Msk            (0x40UL)                  /*!< PH_RET (Bitfield-Mask: 0x01)                          */
#define PWM_CH0_CSR_DIVMODE_Pos           (4UL)                     /*!< DIVMODE (Bit 4)                                       */
#define PWM_CH0_CSR_DIVMODE_Msk           (0x30UL)                  /*!< DIVMODE (Bitfield-Mask: 0x03)                         */
#define PWM_CH0_CSR_B_INV_Pos             (3UL)                     /*!< B_INV (Bit 3)                                         */
#define PWM_CH0_CSR_B_INV_Msk             (0x8UL)                   /*!< B_INV (Bitfield-Mask: 0x01)                           */
#define PWM_CH0_CSR_A_INV_Pos             (2UL)                     /*!< A_INV (Bit 2)                                         */
#define PWM_CH0_CSR_A_INV_Msk             (0x4UL)                   /*!< A_INV (Bitfield-Mask: 0x01)                           */
#define PWM_CH0_CSR_PH_CORRECT_Pos        (1UL)                     /*!< PH_CORRECT (Bit 1)                                    */
#define PWM_CH0_CSR_PH_CORRECT_Msk        (0x2UL)                   /*!< PH_CORRECT (Bitfield-Mask: 0x01)                      */
#define PWM_CH0_CSR_EN_Pos                (0UL)                     /*!< EN (Bit 0)                                            */
#define PWM_CH0_CSR_EN_Msk                (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01)                              */
/* ========================================================  CH0_DIV  ======================================================== */
#define PWM_CH0_DIV_INT_Pos               (4UL)                     /*!< INT (Bit 4)                                           */
#define PWM_CH0_DIV_INT_Msk               (0xff0UL)                 /*!< INT (Bitfield-Mask: 0xff)                             */
#define PWM_CH0_DIV_FRAC_Pos              (0UL)                     /*!< FRAC (Bit 0)                                          */
#define PWM_CH0_DIV_FRAC_Msk              (0xfUL)                   /*!< FRAC (Bitfield-Mask: 0x0f)                            */
/* ========================================================  CH0_CTR  ======================================================== */
#define PWM_CH0_CTR_CH0_CTR_Pos           (0UL)                     /*!< CH0_CTR (Bit 0)                                       */
#define PWM_CH0_CTR_CH0_CTR_Msk           (0xffffUL)                /*!< CH0_CTR (Bitfield-Mask: 0xffff)                       */
/* ========================================================  CH0_CC  ========================================================= */
#define PWM_CH0_CC_B_Pos                  (16UL)                    /*!< B (Bit 16)                                            */
#define PWM_CH0_CC_B_Msk                  (0xffff0000UL)            /*!< B (Bitfield-Mask: 0xffff)                             */
#define PWM_CH0_CC_A_Pos                  (0UL)                     /*!< A (Bit 0)                                             */
#define PWM_CH0_CC_A_Msk                  (0xffffUL)                /*!< A (Bitfield-Mask: 0xffff)                             */
/* ========================================================  CH0_TOP  ======================================================== */
#define PWM_CH0_TOP_CH0_TOP_Pos           (0UL)                     /*!< CH0_TOP (Bit 0)                                       */
#define PWM_CH0_TOP_CH0_TOP_Msk           (0xffffUL)                /*!< CH0_TOP (Bitfield-Mask: 0xffff)                       */
/* ========================================================  CH1_CSR  ======================================================== */
#define PWM_CH1_CSR_PH_ADV_Pos            (7UL)                     /*!< PH_ADV (Bit 7)                                        */
#define PWM_CH1_CSR_PH_ADV_Msk            (0x80UL)                  /*!< PH_ADV (Bitfield-Mask: 0x01)                          */
#define PWM_CH1_CSR_PH_RET_Pos            (6UL)                     /*!< PH_RET (Bit 6)                                        */
#define PWM_CH1_CSR_PH_RET_Msk            (0x40UL)                  /*!< PH_RET (Bitfield-Mask: 0x01)                          */
#define PWM_CH1_CSR_DIVMODE_Pos           (4UL)                     /*!< DIVMODE (Bit 4)                                       */
#define PWM_CH1_CSR_DIVMODE_Msk           (0x30UL)                  /*!< DIVMODE (Bitfield-Mask: 0x03)                         */
#define PWM_CH1_CSR_B_INV_Pos             (3UL)                     /*!< B_INV (Bit 3)                                         */
#define PWM_CH1_CSR_B_INV_Msk             (0x8UL)                   /*!< B_INV (Bitfield-Mask: 0x01)                           */
#define PWM_CH1_CSR_A_INV_Pos             (2UL)                     /*!< A_INV (Bit 2)                                         */
#define PWM_CH1_CSR_A_INV_Msk             (0x4UL)                   /*!< A_INV (Bitfield-Mask: 0x01)                           */
#define PWM_CH1_CSR_PH_CORRECT_Pos        (1UL)                     /*!< PH_CORRECT (Bit 1)                                    */
#define PWM_CH1_CSR_PH_CORRECT_Msk        (0x2UL)                   /*!< PH_CORRECT (Bitfield-Mask: 0x01)                      */
#define PWM_CH1_CSR_EN_Pos                (0UL)                     /*!< EN (Bit 0)                                            */
#define PWM_CH1_CSR_EN_Msk                (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01)                              */
/* ========================================================  CH1_DIV  ======================================================== */
#define PWM_CH1_DIV_INT_Pos               (4UL)                     /*!< INT (Bit 4)                                           */
#define PWM_CH1_DIV_INT_Msk               (0xff0UL)                 /*!< INT (Bitfield-Mask: 0xff)                             */
#define PWM_CH1_DIV_FRAC_Pos              (0UL)                     /*!< FRAC (Bit 0)                                          */
#define PWM_CH1_DIV_FRAC_Msk              (0xfUL)                   /*!< FRAC (Bitfield-Mask: 0x0f)                            */
/* ========================================================  CH1_CTR  ======================================================== */
#define PWM_CH1_CTR_CH1_CTR_Pos           (0UL)                     /*!< CH1_CTR (Bit 0)                                       */
#define PWM_CH1_CTR_CH1_CTR_Msk           (0xffffUL)                /*!< CH1_CTR (Bitfield-Mask: 0xffff)                       */
/* ========================================================  CH1_CC  ========================================================= */
#define PWM_CH1_CC_B_Pos                  (16UL)                    /*!< B (Bit 16)                                            */
#define PWM_CH1_CC_B_Msk                  (0xffff0000UL)            /*!< B (Bitfield-Mask: 0xffff)                             */
#define PWM_CH1_CC_A_Pos                  (0UL)                     /*!< A (Bit 0)                                             */
#define PWM_CH1_CC_A_Msk                  (0xffffUL)                /*!< A (Bitfield-Mask: 0xffff)                             */
/* ========================================================  CH1_TOP  ======================================================== */
#define PWM_CH1_TOP_CH1_TOP_Pos           (0UL)                     /*!< CH1_TOP (Bit 0)                                       */
#define PWM_CH1_TOP_CH1_TOP_Msk           (0xffffUL)                /*!< CH1_TOP (Bitfield-Mask: 0xffff)                       */
/* ========================================================  CH2_CSR  ======================================================== */
#define PWM_CH2_CSR_PH_ADV_Pos            (7UL)                     /*!< PH_ADV (Bit 7)                                        */
#define PWM_CH2_CSR_PH_ADV_Msk            (0x80UL)                  /*!< PH_ADV (Bitfield-Mask: 0x01)                          */
#define PWM_CH2_CSR_PH_RET_Pos            (6UL)                     /*!< PH_RET (Bit 6)                                        */
#define PWM_CH2_CSR_PH_RET_Msk            (0x40UL)                  /*!< PH_RET (Bitfield-Mask: 0x01)                          */
#define PWM_CH2_CSR_DIVMODE_Pos           (4UL)                     /*!< DIVMODE (Bit 4)                                       */
#define PWM_CH2_CSR_DIVMODE_Msk           (0x30UL)                  /*!< DIVMODE (Bitfield-Mask: 0x03)                         */
#define PWM_CH2_CSR_B_INV_Pos             (3UL)                     /*!< B_INV (Bit 3)                                         */
#define PWM_CH2_CSR_B_INV_Msk             (0x8UL)                   /*!< B_INV (Bitfield-Mask: 0x01)                           */
#define PWM_CH2_CSR_A_INV_Pos             (2UL)                     /*!< A_INV (Bit 2)                                         */
#define PWM_CH2_CSR_A_INV_Msk             (0x4UL)                   /*!< A_INV (Bitfield-Mask: 0x01)                           */
#define PWM_CH2_CSR_PH_CORRECT_Pos        (1UL)                     /*!< PH_CORRECT (Bit 1)                                    */
#define PWM_CH2_CSR_PH_CORRECT_Msk        (0x2UL)                   /*!< PH_CORRECT (Bitfield-Mask: 0x01)                      */
#define PWM_CH2_CSR_EN_Pos                (0UL)                     /*!< EN (Bit 0)                                            */
#define PWM_CH2_CSR_EN_Msk                (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01)                              */
/* ========================================================  CH2_DIV  ======================================================== */
#define PWM_CH2_DIV_INT_Pos               (4UL)                     /*!< INT (Bit 4)                                           */
#define PWM_CH2_DIV_INT_Msk               (0xff0UL)                 /*!< INT (Bitfield-Mask: 0xff)                             */
#define PWM_CH2_DIV_FRAC_Pos              (0UL)                     /*!< FRAC (Bit 0)                                          */
#define PWM_CH2_DIV_FRAC_Msk              (0xfUL)                   /*!< FRAC (Bitfield-Mask: 0x0f)                            */
/* ========================================================  CH2_CTR  ======================================================== */
#define PWM_CH2_CTR_CH2_CTR_Pos           (0UL)                     /*!< CH2_CTR (Bit 0)                                       */
#define PWM_CH2_CTR_CH2_CTR_Msk           (0xffffUL)                /*!< CH2_CTR (Bitfield-Mask: 0xffff)                       */
/* ========================================================  CH2_CC  ========================================================= */
#define PWM_CH2_CC_B_Pos                  (16UL)                    /*!< B (Bit 16)                                            */
#define PWM_CH2_CC_B_Msk                  (0xffff0000UL)            /*!< B (Bitfield-Mask: 0xffff)                             */
#define PWM_CH2_CC_A_Pos                  (0UL)                     /*!< A (Bit 0)                                             */
#define PWM_CH2_CC_A_Msk                  (0xffffUL)                /*!< A (Bitfield-Mask: 0xffff)                             */
/* ========================================================  CH2_TOP  ======================================================== */
#define PWM_CH2_TOP_CH2_TOP_Pos           (0UL)                     /*!< CH2_TOP (Bit 0)                                       */
#define PWM_CH2_TOP_CH2_TOP_Msk           (0xffffUL)                /*!< CH2_TOP (Bitfield-Mask: 0xffff)                       */
/* ========================================================  CH3_CSR  ======================================================== */
#define PWM_CH3_CSR_PH_ADV_Pos            (7UL)                     /*!< PH_ADV (Bit 7)                                        */
#define PWM_CH3_CSR_PH_ADV_Msk            (0x80UL)                  /*!< PH_ADV (Bitfield-Mask: 0x01)                          */
#define PWM_CH3_CSR_PH_RET_Pos            (6UL)                     /*!< PH_RET (Bit 6)                                        */
#define PWM_CH3_CSR_PH_RET_Msk            (0x40UL)                  /*!< PH_RET (Bitfield-Mask: 0x01)                          */
#define PWM_CH3_CSR_DIVMODE_Pos           (4UL)                     /*!< DIVMODE (Bit 4)                                       */
#define PWM_CH3_CSR_DIVMODE_Msk           (0x30UL)                  /*!< DIVMODE (Bitfield-Mask: 0x03)                         */
#define PWM_CH3_CSR_B_INV_Pos             (3UL)                     /*!< B_INV (Bit 3)                                         */
#define PWM_CH3_CSR_B_INV_Msk             (0x8UL)                   /*!< B_INV (Bitfield-Mask: 0x01)                           */
#define PWM_CH3_CSR_A_INV_Pos             (2UL)                     /*!< A_INV (Bit 2)                                         */
#define PWM_CH3_CSR_A_INV_Msk             (0x4UL)                   /*!< A_INV (Bitfield-Mask: 0x01)                           */
#define PWM_CH3_CSR_PH_CORRECT_Pos        (1UL)                     /*!< PH_CORRECT (Bit 1)                                    */
#define PWM_CH3_CSR_PH_CORRECT_Msk        (0x2UL)                   /*!< PH_CORRECT (Bitfield-Mask: 0x01)                      */
#define PWM_CH3_CSR_EN_Pos                (0UL)                     /*!< EN (Bit 0)                                            */
#define PWM_CH3_CSR_EN_Msk                (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01)                              */
/* ========================================================  CH3_DIV  ======================================================== */
#define PWM_CH3_DIV_INT_Pos               (4UL)                     /*!< INT (Bit 4)                                           */
#define PWM_CH3_DIV_INT_Msk               (0xff0UL)                 /*!< INT (Bitfield-Mask: 0xff)                             */
#define PWM_CH3_DIV_FRAC_Pos              (0UL)                     /*!< FRAC (Bit 0)                                          */
#define PWM_CH3_DIV_FRAC_Msk              (0xfUL)                   /*!< FRAC (Bitfield-Mask: 0x0f)                            */
/* ========================================================  CH3_CTR  ======================================================== */
#define PWM_CH3_CTR_CH3_CTR_Pos           (0UL)                     /*!< CH3_CTR (Bit 0)                                       */
#define PWM_CH3_CTR_CH3_CTR_Msk           (0xffffUL)                /*!< CH3_CTR (Bitfield-Mask: 0xffff)                       */
/* ========================================================  CH3_CC  ========================================================= */
#define PWM_CH3_CC_B_Pos                  (16UL)                    /*!< B (Bit 16)                                            */
#define PWM_CH3_CC_B_Msk                  (0xffff0000UL)            /*!< B (Bitfield-Mask: 0xffff)                             */
#define PWM_CH3_CC_A_Pos                  (0UL)                     /*!< A (Bit 0)                                             */
#define PWM_CH3_CC_A_Msk                  (0xffffUL)                /*!< A (Bitfield-Mask: 0xffff)                             */
/* ========================================================  CH3_TOP  ======================================================== */
#define PWM_CH3_TOP_CH3_TOP_Pos           (0UL)                     /*!< CH3_TOP (Bit 0)                                       */
#define PWM_CH3_TOP_CH3_TOP_Msk           (0xffffUL)                /*!< CH3_TOP (Bitfield-Mask: 0xffff)                       */
/* ========================================================  CH4_CSR  ======================================================== */
#define PWM_CH4_CSR_PH_ADV_Pos            (7UL)                     /*!< PH_ADV (Bit 7)                                        */
#define PWM_CH4_CSR_PH_ADV_Msk            (0x80UL)                  /*!< PH_ADV (Bitfield-Mask: 0x01)                          */
#define PWM_CH4_CSR_PH_RET_Pos            (6UL)                     /*!< PH_RET (Bit 6)                                        */
#define PWM_CH4_CSR_PH_RET_Msk            (0x40UL)                  /*!< PH_RET (Bitfield-Mask: 0x01)                          */
#define PWM_CH4_CSR_DIVMODE_Pos           (4UL)                     /*!< DIVMODE (Bit 4)                                       */
#define PWM_CH4_CSR_DIVMODE_Msk           (0x30UL)                  /*!< DIVMODE (Bitfield-Mask: 0x03)                         */
#define PWM_CH4_CSR_B_INV_Pos             (3UL)                     /*!< B_INV (Bit 3)                                         */
#define PWM_CH4_CSR_B_INV_Msk             (0x8UL)                   /*!< B_INV (Bitfield-Mask: 0x01)                           */
#define PWM_CH4_CSR_A_INV_Pos             (2UL)                     /*!< A_INV (Bit 2)                                         */
#define PWM_CH4_CSR_A_INV_Msk             (0x4UL)                   /*!< A_INV (Bitfield-Mask: 0x01)                           */
#define PWM_CH4_CSR_PH_CORRECT_Pos        (1UL)                     /*!< PH_CORRECT (Bit 1)                                    */
#define PWM_CH4_CSR_PH_CORRECT_Msk        (0x2UL)                   /*!< PH_CORRECT (Bitfield-Mask: 0x01)                      */
#define PWM_CH4_CSR_EN_Pos                (0UL)                     /*!< EN (Bit 0)                                            */
#define PWM_CH4_CSR_EN_Msk                (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01)                              */
/* ========================================================  CH4_DIV  ======================================================== */
#define PWM_CH4_DIV_INT_Pos               (4UL)                     /*!< INT (Bit 4)                                           */
#define PWM_CH4_DIV_INT_Msk               (0xff0UL)                 /*!< INT (Bitfield-Mask: 0xff)                             */
#define PWM_CH4_DIV_FRAC_Pos              (0UL)                     /*!< FRAC (Bit 0)                                          */
#define PWM_CH4_DIV_FRAC_Msk              (0xfUL)                   /*!< FRAC (Bitfield-Mask: 0x0f)                            */
/* ========================================================  CH4_CTR  ======================================================== */
#define PWM_CH4_CTR_CH4_CTR_Pos           (0UL)                     /*!< CH4_CTR (Bit 0)                                       */
#define PWM_CH4_CTR_CH4_CTR_Msk           (0xffffUL)                /*!< CH4_CTR (Bitfield-Mask: 0xffff)                       */
/* ========================================================  CH4_CC  ========================================================= */
#define PWM_CH4_CC_B_Pos                  (16UL)                    /*!< B (Bit 16)                                            */
#define PWM_CH4_CC_B_Msk                  (0xffff0000UL)            /*!< B (Bitfield-Mask: 0xffff)                             */
#define PWM_CH4_CC_A_Pos                  (0UL)                     /*!< A (Bit 0)                                             */
#define PWM_CH4_CC_A_Msk                  (0xffffUL)                /*!< A (Bitfield-Mask: 0xffff)                             */
/* ========================================================  CH4_TOP  ======================================================== */
#define PWM_CH4_TOP_CH4_TOP_Pos           (0UL)                     /*!< CH4_TOP (Bit 0)                                       */
#define PWM_CH4_TOP_CH4_TOP_Msk           (0xffffUL)                /*!< CH4_TOP (Bitfield-Mask: 0xffff)                       */
/* ========================================================  CH5_CSR  ======================================================== */
#define PWM_CH5_CSR_PH_ADV_Pos            (7UL)                     /*!< PH_ADV (Bit 7)                                        */
#define PWM_CH5_CSR_PH_ADV_Msk            (0x80UL)                  /*!< PH_ADV (Bitfield-Mask: 0x01)                          */
#define PWM_CH5_CSR_PH_RET_Pos            (6UL)                     /*!< PH_RET (Bit 6)                                        */
#define PWM_CH5_CSR_PH_RET_Msk            (0x40UL)                  /*!< PH_RET (Bitfield-Mask: 0x01)                          */
#define PWM_CH5_CSR_DIVMODE_Pos           (4UL)                     /*!< DIVMODE (Bit 4)                                       */
#define PWM_CH5_CSR_DIVMODE_Msk           (0x30UL)                  /*!< DIVMODE (Bitfield-Mask: 0x03)                         */
#define PWM_CH5_CSR_B_INV_Pos             (3UL)                     /*!< B_INV (Bit 3)                                         */
#define PWM_CH5_CSR_B_INV_Msk             (0x8UL)                   /*!< B_INV (Bitfield-Mask: 0x01)                           */
#define PWM_CH5_CSR_A_INV_Pos             (2UL)                     /*!< A_INV (Bit 2)                                         */
#define PWM_CH5_CSR_A_INV_Msk             (0x4UL)                   /*!< A_INV (Bitfield-Mask: 0x01)                           */
#define PWM_CH5_CSR_PH_CORRECT_Pos        (1UL)                     /*!< PH_CORRECT (Bit 1)                                    */
#define PWM_CH5_CSR_PH_CORRECT_Msk        (0x2UL)                   /*!< PH_CORRECT (Bitfield-Mask: 0x01)                      */
#define PWM_CH5_CSR_EN_Pos                (0UL)                     /*!< EN (Bit 0)                                            */
#define PWM_CH5_CSR_EN_Msk                (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01)                              */
/* ========================================================  CH5_DIV  ======================================================== */
#define PWM_CH5_DIV_INT_Pos               (4UL)                     /*!< INT (Bit 4)                                           */
#define PWM_CH5_DIV_INT_Msk               (0xff0UL)                 /*!< INT (Bitfield-Mask: 0xff)                             */
#define PWM_CH5_DIV_FRAC_Pos              (0UL)                     /*!< FRAC (Bit 0)                                          */
#define PWM_CH5_DIV_FRAC_Msk              (0xfUL)                   /*!< FRAC (Bitfield-Mask: 0x0f)                            */
/* ========================================================  CH5_CTR  ======================================================== */
#define PWM_CH5_CTR_CH5_CTR_Pos           (0UL)                     /*!< CH5_CTR (Bit 0)                                       */
#define PWM_CH5_CTR_CH5_CTR_Msk           (0xffffUL)                /*!< CH5_CTR (Bitfield-Mask: 0xffff)                       */
/* ========================================================  CH5_CC  ========================================================= */
#define PWM_CH5_CC_B_Pos                  (16UL)                    /*!< B (Bit 16)                                            */
#define PWM_CH5_CC_B_Msk                  (0xffff0000UL)            /*!< B (Bitfield-Mask: 0xffff)                             */
#define PWM_CH5_CC_A_Pos                  (0UL)                     /*!< A (Bit 0)                                             */
#define PWM_CH5_CC_A_Msk                  (0xffffUL)                /*!< A (Bitfield-Mask: 0xffff)                             */
/* ========================================================  CH5_TOP  ======================================================== */
#define PWM_CH5_TOP_CH5_TOP_Pos           (0UL)                     /*!< CH5_TOP (Bit 0)                                       */
#define PWM_CH5_TOP_CH5_TOP_Msk           (0xffffUL)                /*!< CH5_TOP (Bitfield-Mask: 0xffff)                       */
/* ========================================================  CH6_CSR  ======================================================== */
#define PWM_CH6_CSR_PH_ADV_Pos            (7UL)                     /*!< PH_ADV (Bit 7)                                        */
#define PWM_CH6_CSR_PH_ADV_Msk            (0x80UL)                  /*!< PH_ADV (Bitfield-Mask: 0x01)                          */
#define PWM_CH6_CSR_PH_RET_Pos            (6UL)                     /*!< PH_RET (Bit 6)                                        */
#define PWM_CH6_CSR_PH_RET_Msk            (0x40UL)                  /*!< PH_RET (Bitfield-Mask: 0x01)                          */
#define PWM_CH6_CSR_DIVMODE_Pos           (4UL)                     /*!< DIVMODE (Bit 4)                                       */
#define PWM_CH6_CSR_DIVMODE_Msk           (0x30UL)                  /*!< DIVMODE (Bitfield-Mask: 0x03)                         */
#define PWM_CH6_CSR_B_INV_Pos             (3UL)                     /*!< B_INV (Bit 3)                                         */
#define PWM_CH6_CSR_B_INV_Msk             (0x8UL)                   /*!< B_INV (Bitfield-Mask: 0x01)                           */
#define PWM_CH6_CSR_A_INV_Pos             (2UL)                     /*!< A_INV (Bit 2)                                         */
#define PWM_CH6_CSR_A_INV_Msk             (0x4UL)                   /*!< A_INV (Bitfield-Mask: 0x01)                           */
#define PWM_CH6_CSR_PH_CORRECT_Pos        (1UL)                     /*!< PH_CORRECT (Bit 1)                                    */
#define PWM_CH6_CSR_PH_CORRECT_Msk        (0x2UL)                   /*!< PH_CORRECT (Bitfield-Mask: 0x01)                      */
#define PWM_CH6_CSR_EN_Pos                (0UL)                     /*!< EN (Bit 0)                                            */
#define PWM_CH6_CSR_EN_Msk                (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01)                              */
/* ========================================================  CH6_DIV  ======================================================== */
#define PWM_CH6_DIV_INT_Pos               (4UL)                     /*!< INT (Bit 4)                                           */
#define PWM_CH6_DIV_INT_Msk               (0xff0UL)                 /*!< INT (Bitfield-Mask: 0xff)                             */
#define PWM_CH6_DIV_FRAC_Pos              (0UL)                     /*!< FRAC (Bit 0)                                          */
#define PWM_CH6_DIV_FRAC_Msk              (0xfUL)                   /*!< FRAC (Bitfield-Mask: 0x0f)                            */
/* ========================================================  CH6_CTR  ======================================================== */
#define PWM_CH6_CTR_CH6_CTR_Pos           (0UL)                     /*!< CH6_CTR (Bit 0)                                       */
#define PWM_CH6_CTR_CH6_CTR_Msk           (0xffffUL)                /*!< CH6_CTR (Bitfield-Mask: 0xffff)                       */
/* ========================================================  CH6_CC  ========================================================= */
#define PWM_CH6_CC_B_Pos                  (16UL)                    /*!< B (Bit 16)                                            */
#define PWM_CH6_CC_B_Msk                  (0xffff0000UL)            /*!< B (Bitfield-Mask: 0xffff)                             */
#define PWM_CH6_CC_A_Pos                  (0UL)                     /*!< A (Bit 0)                                             */
#define PWM_CH6_CC_A_Msk                  (0xffffUL)                /*!< A (Bitfield-Mask: 0xffff)                             */
/* ========================================================  CH6_TOP  ======================================================== */
#define PWM_CH6_TOP_CH6_TOP_Pos           (0UL)                     /*!< CH6_TOP (Bit 0)                                       */
#define PWM_CH6_TOP_CH6_TOP_Msk           (0xffffUL)                /*!< CH6_TOP (Bitfield-Mask: 0xffff)                       */
/* ========================================================  CH7_CSR  ======================================================== */
#define PWM_CH7_CSR_PH_ADV_Pos            (7UL)                     /*!< PH_ADV (Bit 7)                                        */
#define PWM_CH7_CSR_PH_ADV_Msk            (0x80UL)                  /*!< PH_ADV (Bitfield-Mask: 0x01)                          */
#define PWM_CH7_CSR_PH_RET_Pos            (6UL)                     /*!< PH_RET (Bit 6)                                        */
#define PWM_CH7_CSR_PH_RET_Msk            (0x40UL)                  /*!< PH_RET (Bitfield-Mask: 0x01)                          */
#define PWM_CH7_CSR_DIVMODE_Pos           (4UL)                     /*!< DIVMODE (Bit 4)                                       */
#define PWM_CH7_CSR_DIVMODE_Msk           (0x30UL)                  /*!< DIVMODE (Bitfield-Mask: 0x03)                         */
#define PWM_CH7_CSR_B_INV_Pos             (3UL)                     /*!< B_INV (Bit 3)                                         */
#define PWM_CH7_CSR_B_INV_Msk             (0x8UL)                   /*!< B_INV (Bitfield-Mask: 0x01)                           */
#define PWM_CH7_CSR_A_INV_Pos             (2UL)                     /*!< A_INV (Bit 2)                                         */
#define PWM_CH7_CSR_A_INV_Msk             (0x4UL)                   /*!< A_INV (Bitfield-Mask: 0x01)                           */
#define PWM_CH7_CSR_PH_CORRECT_Pos        (1UL)                     /*!< PH_CORRECT (Bit 1)                                    */
#define PWM_CH7_CSR_PH_CORRECT_Msk        (0x2UL)                   /*!< PH_CORRECT (Bitfield-Mask: 0x01)                      */
#define PWM_CH7_CSR_EN_Pos                (0UL)                     /*!< EN (Bit 0)                                            */
#define PWM_CH7_CSR_EN_Msk                (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01)                              */
/* ========================================================  CH7_DIV  ======================================================== */
#define PWM_CH7_DIV_INT_Pos               (4UL)                     /*!< INT (Bit 4)                                           */
#define PWM_CH7_DIV_INT_Msk               (0xff0UL)                 /*!< INT (Bitfield-Mask: 0xff)                             */
#define PWM_CH7_DIV_FRAC_Pos              (0UL)                     /*!< FRAC (Bit 0)                                          */
#define PWM_CH7_DIV_FRAC_Msk              (0xfUL)                   /*!< FRAC (Bitfield-Mask: 0x0f)                            */
/* ========================================================  CH7_CTR  ======================================================== */
#define PWM_CH7_CTR_CH7_CTR_Pos           (0UL)                     /*!< CH7_CTR (Bit 0)                                       */
#define PWM_CH7_CTR_CH7_CTR_Msk           (0xffffUL)                /*!< CH7_CTR (Bitfield-Mask: 0xffff)                       */
/* ========================================================  CH7_CC  ========================================================= */
#define PWM_CH7_CC_B_Pos                  (16UL)                    /*!< B (Bit 16)                                            */
#define PWM_CH7_CC_B_Msk                  (0xffff0000UL)            /*!< B (Bitfield-Mask: 0xffff)                             */
#define PWM_CH7_CC_A_Pos                  (0UL)                     /*!< A (Bit 0)                                             */
#define PWM_CH7_CC_A_Msk                  (0xffffUL)                /*!< A (Bitfield-Mask: 0xffff)                             */
/* ========================================================  CH7_TOP  ======================================================== */
#define PWM_CH7_TOP_CH7_TOP_Pos           (0UL)                     /*!< CH7_TOP (Bit 0)                                       */
#define PWM_CH7_TOP_CH7_TOP_Msk           (0xffffUL)                /*!< CH7_TOP (Bitfield-Mask: 0xffff)                       */
/* ==========================================================  EN  =========================================================== */
#define PWM_EN_CH7_Pos                    (7UL)                     /*!< CH7 (Bit 7)                                           */
#define PWM_EN_CH7_Msk                    (0x80UL)                  /*!< CH7 (Bitfield-Mask: 0x01)                             */
#define PWM_EN_CH6_Pos                    (6UL)                     /*!< CH6 (Bit 6)                                           */
#define PWM_EN_CH6_Msk                    (0x40UL)                  /*!< CH6 (Bitfield-Mask: 0x01)                             */
#define PWM_EN_CH5_Pos                    (5UL)                     /*!< CH5 (Bit 5)                                           */
#define PWM_EN_CH5_Msk                    (0x20UL)                  /*!< CH5 (Bitfield-Mask: 0x01)                             */
#define PWM_EN_CH4_Pos                    (4UL)                     /*!< CH4 (Bit 4)                                           */
#define PWM_EN_CH4_Msk                    (0x10UL)                  /*!< CH4 (Bitfield-Mask: 0x01)                             */
#define PWM_EN_CH3_Pos                    (3UL)                     /*!< CH3 (Bit 3)                                           */
#define PWM_EN_CH3_Msk                    (0x8UL)                   /*!< CH3 (Bitfield-Mask: 0x01)                             */
#define PWM_EN_CH2_Pos                    (2UL)                     /*!< CH2 (Bit 2)                                           */
#define PWM_EN_CH2_Msk                    (0x4UL)                   /*!< CH2 (Bitfield-Mask: 0x01)                             */
#define PWM_EN_CH1_Pos                    (1UL)                     /*!< CH1 (Bit 1)                                           */
#define PWM_EN_CH1_Msk                    (0x2UL)                   /*!< CH1 (Bitfield-Mask: 0x01)                             */
#define PWM_EN_CH0_Pos                    (0UL)                     /*!< CH0 (Bit 0)                                           */
#define PWM_EN_CH0_Msk                    (0x1UL)                   /*!< CH0 (Bitfield-Mask: 0x01)                             */
/* =========================================================  INTR  ========================================================== */
#define PWM_INTR_CH7_Pos                  (7UL)                     /*!< CH7 (Bit 7)                                           */
#define PWM_INTR_CH7_Msk                  (0x80UL)                  /*!< CH7 (Bitfield-Mask: 0x01)                             */
#define PWM_INTR_CH6_Pos                  (6UL)                     /*!< CH6 (Bit 6)                                           */
#define PWM_INTR_CH6_Msk                  (0x40UL)                  /*!< CH6 (Bitfield-Mask: 0x01)                             */
#define PWM_INTR_CH5_Pos                  (5UL)                     /*!< CH5 (Bit 5)                                           */
#define PWM_INTR_CH5_Msk                  (0x20UL)                  /*!< CH5 (Bitfield-Mask: 0x01)                             */
#define PWM_INTR_CH4_Pos                  (4UL)                     /*!< CH4 (Bit 4)                                           */
#define PWM_INTR_CH4_Msk                  (0x10UL)                  /*!< CH4 (Bitfield-Mask: 0x01)                             */
#define PWM_INTR_CH3_Pos                  (3UL)                     /*!< CH3 (Bit 3)                                           */
#define PWM_INTR_CH3_Msk                  (0x8UL)                   /*!< CH3 (Bitfield-Mask: 0x01)                             */
#define PWM_INTR_CH2_Pos                  (2UL)                     /*!< CH2 (Bit 2)                                           */
#define PWM_INTR_CH2_Msk                  (0x4UL)                   /*!< CH2 (Bitfield-Mask: 0x01)                             */
#define PWM_INTR_CH1_Pos                  (1UL)                     /*!< CH1 (Bit 1)                                           */
#define PWM_INTR_CH1_Msk                  (0x2UL)                   /*!< CH1 (Bitfield-Mask: 0x01)                             */
#define PWM_INTR_CH0_Pos                  (0UL)                     /*!< CH0 (Bit 0)                                           */
#define PWM_INTR_CH0_Msk                  (0x1UL)                   /*!< CH0 (Bitfield-Mask: 0x01)                             */
/* =========================================================  INTE  ========================================================== */
#define PWM_INTE_CH7_Pos                  (7UL)                     /*!< CH7 (Bit 7)                                           */
#define PWM_INTE_CH7_Msk                  (0x80UL)                  /*!< CH7 (Bitfield-Mask: 0x01)                             */
#define PWM_INTE_CH6_Pos                  (6UL)                     /*!< CH6 (Bit 6)                                           */
#define PWM_INTE_CH6_Msk                  (0x40UL)                  /*!< CH6 (Bitfield-Mask: 0x01)                             */
#define PWM_INTE_CH5_Pos                  (5UL)                     /*!< CH5 (Bit 5)                                           */
#define PWM_INTE_CH5_Msk                  (0x20UL)                  /*!< CH5 (Bitfield-Mask: 0x01)                             */
#define PWM_INTE_CH4_Pos                  (4UL)                     /*!< CH4 (Bit 4)                                           */
#define PWM_INTE_CH4_Msk                  (0x10UL)                  /*!< CH4 (Bitfield-Mask: 0x01)                             */
#define PWM_INTE_CH3_Pos                  (3UL)                     /*!< CH3 (Bit 3)                                           */
#define PWM_INTE_CH3_Msk                  (0x8UL)                   /*!< CH3 (Bitfield-Mask: 0x01)                             */
#define PWM_INTE_CH2_Pos                  (2UL)                     /*!< CH2 (Bit 2)                                           */
#define PWM_INTE_CH2_Msk                  (0x4UL)                   /*!< CH2 (Bitfield-Mask: 0x01)                             */
#define PWM_INTE_CH1_Pos                  (1UL)                     /*!< CH1 (Bit 1)                                           */
#define PWM_INTE_CH1_Msk                  (0x2UL)                   /*!< CH1 (Bitfield-Mask: 0x01)                             */
#define PWM_INTE_CH0_Pos                  (0UL)                     /*!< CH0 (Bit 0)                                           */
#define PWM_INTE_CH0_Msk                  (0x1UL)                   /*!< CH0 (Bitfield-Mask: 0x01)                             */
/* =========================================================  INTF  ========================================================== */
#define PWM_INTF_CH7_Pos                  (7UL)                     /*!< CH7 (Bit 7)                                           */
#define PWM_INTF_CH7_Msk                  (0x80UL)                  /*!< CH7 (Bitfield-Mask: 0x01)                             */
#define PWM_INTF_CH6_Pos                  (6UL)                     /*!< CH6 (Bit 6)                                           */
#define PWM_INTF_CH6_Msk                  (0x40UL)                  /*!< CH6 (Bitfield-Mask: 0x01)                             */
#define PWM_INTF_CH5_Pos                  (5UL)                     /*!< CH5 (Bit 5)                                           */
#define PWM_INTF_CH5_Msk                  (0x20UL)                  /*!< CH5 (Bitfield-Mask: 0x01)                             */
#define PWM_INTF_CH4_Pos                  (4UL)                     /*!< CH4 (Bit 4)                                           */
#define PWM_INTF_CH4_Msk                  (0x10UL)                  /*!< CH4 (Bitfield-Mask: 0x01)                             */
#define PWM_INTF_CH3_Pos                  (3UL)                     /*!< CH3 (Bit 3)                                           */
#define PWM_INTF_CH3_Msk                  (0x8UL)                   /*!< CH3 (Bitfield-Mask: 0x01)                             */
#define PWM_INTF_CH2_Pos                  (2UL)                     /*!< CH2 (Bit 2)                                           */
#define PWM_INTF_CH2_Msk                  (0x4UL)                   /*!< CH2 (Bitfield-Mask: 0x01)                             */
#define PWM_INTF_CH1_Pos                  (1UL)                     /*!< CH1 (Bit 1)                                           */
#define PWM_INTF_CH1_Msk                  (0x2UL)                   /*!< CH1 (Bitfield-Mask: 0x01)                             */
#define PWM_INTF_CH0_Pos                  (0UL)                     /*!< CH0 (Bit 0)                                           */
#define PWM_INTF_CH0_Msk                  (0x1UL)                   /*!< CH0 (Bitfield-Mask: 0x01)                             */
/* =========================================================  INTS  ========================================================== */
#define PWM_INTS_CH7_Pos                  (7UL)                     /*!< CH7 (Bit 7)                                           */
#define PWM_INTS_CH7_Msk                  (0x80UL)                  /*!< CH7 (Bitfield-Mask: 0x01)                             */
#define PWM_INTS_CH6_Pos                  (6UL)                     /*!< CH6 (Bit 6)                                           */
#define PWM_INTS_CH6_Msk                  (0x40UL)                  /*!< CH6 (Bitfield-Mask: 0x01)                             */
#define PWM_INTS_CH5_Pos                  (5UL)                     /*!< CH5 (Bit 5)                                           */
#define PWM_INTS_CH5_Msk                  (0x20UL)                  /*!< CH5 (Bitfield-Mask: 0x01)                             */
#define PWM_INTS_CH4_Pos                  (4UL)                     /*!< CH4 (Bit 4)                                           */
#define PWM_INTS_CH4_Msk                  (0x10UL)                  /*!< CH4 (Bitfield-Mask: 0x01)                             */
#define PWM_INTS_CH3_Pos                  (3UL)                     /*!< CH3 (Bit 3)                                           */
#define PWM_INTS_CH3_Msk                  (0x8UL)                   /*!< CH3 (Bitfield-Mask: 0x01)                             */
#define PWM_INTS_CH2_Pos                  (2UL)                     /*!< CH2 (Bit 2)                                           */
#define PWM_INTS_CH2_Msk                  (0x4UL)                   /*!< CH2 (Bitfield-Mask: 0x01)                             */
#define PWM_INTS_CH1_Pos                  (1UL)                     /*!< CH1 (Bit 1)                                           */
#define PWM_INTS_CH1_Msk                  (0x2UL)                   /*!< CH1 (Bitfield-Mask: 0x01)                             */
#define PWM_INTS_CH0_Pos                  (0UL)                     /*!< CH0 (Bit 0)                                           */
#define PWM_INTS_CH0_Msk                  (0x1UL)                   /*!< CH0 (Bitfield-Mask: 0x01)                             */


/* =========================================================================================================================== */
/* ================                                           TIMER                                           ================ */
/* =========================================================================================================================== */

/* ========================================================  TIMEHW  ========================================================= */
/* ========================================================  TIMELW  ========================================================= */
/* ========================================================  TIMEHR  ========================================================= */
/* ========================================================  TIMELR  ========================================================= */
/* ========================================================  ALARM0  ========================================================= */
/* ========================================================  ALARM1  ========================================================= */
/* ========================================================  ALARM2  ========================================================= */
/* ========================================================  ALARM3  ========================================================= */
/* =========================================================  ARMED  ========================================================= */
#define TIMER_ARMED_ARMED_Pos             (0UL)                     /*!< ARMED (Bit 0)                                         */
#define TIMER_ARMED_ARMED_Msk             (0xfUL)                   /*!< ARMED (Bitfield-Mask: 0x0f)                           */
/* =======================================================  TIMERAWH  ======================================================== */
/* =======================================================  TIMERAWL  ======================================================== */
/* =======================================================  DBGPAUSE  ======================================================== */
#define TIMER_DBGPAUSE_DBG1_Pos           (2UL)                     /*!< DBG1 (Bit 2)                                          */
#define TIMER_DBGPAUSE_DBG1_Msk           (0x4UL)                   /*!< DBG1 (Bitfield-Mask: 0x01)                            */
#define TIMER_DBGPAUSE_DBG0_Pos           (1UL)                     /*!< DBG0 (Bit 1)                                          */
#define TIMER_DBGPAUSE_DBG0_Msk           (0x2UL)                   /*!< DBG0 (Bitfield-Mask: 0x01)                            */
/* =========================================================  PAUSE  ========================================================= */
#define TIMER_PAUSE_PAUSE_Pos             (0UL)                     /*!< PAUSE (Bit 0)                                         */
#define TIMER_PAUSE_PAUSE_Msk             (0x1UL)                   /*!< PAUSE (Bitfield-Mask: 0x01)                           */
/* =========================================================  INTR  ========================================================== */
#define TIMER_INTR_ALARM_3_Pos            (3UL)                     /*!< ALARM_3 (Bit 3)                                       */
#define TIMER_INTR_ALARM_3_Msk            (0x8UL)                   /*!< ALARM_3 (Bitfield-Mask: 0x01)                         */
#define TIMER_INTR_ALARM_2_Pos            (2UL)                     /*!< ALARM_2 (Bit 2)                                       */
#define TIMER_INTR_ALARM_2_Msk            (0x4UL)                   /*!< ALARM_2 (Bitfield-Mask: 0x01)                         */
#define TIMER_INTR_ALARM_1_Pos            (1UL)                     /*!< ALARM_1 (Bit 1)                                       */
#define TIMER_INTR_ALARM_1_Msk            (0x2UL)                   /*!< ALARM_1 (Bitfield-Mask: 0x01)                         */
#define TIMER_INTR_ALARM_0_Pos            (0UL)                     /*!< ALARM_0 (Bit 0)                                       */
#define TIMER_INTR_ALARM_0_Msk            (0x1UL)                   /*!< ALARM_0 (Bitfield-Mask: 0x01)                         */
/* =========================================================  INTE  ========================================================== */
#define TIMER_INTE_ALARM_3_Pos            (3UL)                     /*!< ALARM_3 (Bit 3)                                       */
#define TIMER_INTE_ALARM_3_Msk            (0x8UL)                   /*!< ALARM_3 (Bitfield-Mask: 0x01)                         */
#define TIMER_INTE_ALARM_2_Pos            (2UL)                     /*!< ALARM_2 (Bit 2)                                       */
#define TIMER_INTE_ALARM_2_Msk            (0x4UL)                   /*!< ALARM_2 (Bitfield-Mask: 0x01)                         */
#define TIMER_INTE_ALARM_1_Pos            (1UL)                     /*!< ALARM_1 (Bit 1)                                       */
#define TIMER_INTE_ALARM_1_Msk            (0x2UL)                   /*!< ALARM_1 (Bitfield-Mask: 0x01)                         */
#define TIMER_INTE_ALARM_0_Pos            (0UL)                     /*!< ALARM_0 (Bit 0)                                       */
#define TIMER_INTE_ALARM_0_Msk            (0x1UL)                   /*!< ALARM_0 (Bitfield-Mask: 0x01)                         */
/* =========================================================  INTF  ========================================================== */
#define TIMER_INTF_ALARM_3_Pos            (3UL)                     /*!< ALARM_3 (Bit 3)                                       */
#define TIMER_INTF_ALARM_3_Msk            (0x8UL)                   /*!< ALARM_3 (Bitfield-Mask: 0x01)                         */
#define TIMER_INTF_ALARM_2_Pos            (2UL)                     /*!< ALARM_2 (Bit 2)                                       */
#define TIMER_INTF_ALARM_2_Msk            (0x4UL)                   /*!< ALARM_2 (Bitfield-Mask: 0x01)                         */
#define TIMER_INTF_ALARM_1_Pos            (1UL)                     /*!< ALARM_1 (Bit 1)                                       */
#define TIMER_INTF_ALARM_1_Msk            (0x2UL)                   /*!< ALARM_1 (Bitfield-Mask: 0x01)                         */
#define TIMER_INTF_ALARM_0_Pos            (0UL)                     /*!< ALARM_0 (Bit 0)                                       */
#define TIMER_INTF_ALARM_0_Msk            (0x1UL)                   /*!< ALARM_0 (Bitfield-Mask: 0x01)                         */
/* =========================================================  INTS  ========================================================== */
#define TIMER_INTS_ALARM_3_Pos            (3UL)                     /*!< ALARM_3 (Bit 3)                                       */
#define TIMER_INTS_ALARM_3_Msk            (0x8UL)                   /*!< ALARM_3 (Bitfield-Mask: 0x01)                         */
#define TIMER_INTS_ALARM_2_Pos            (2UL)                     /*!< ALARM_2 (Bit 2)                                       */
#define TIMER_INTS_ALARM_2_Msk            (0x4UL)                   /*!< ALARM_2 (Bitfield-Mask: 0x01)                         */
#define TIMER_INTS_ALARM_1_Pos            (1UL)                     /*!< ALARM_1 (Bit 1)                                       */
#define TIMER_INTS_ALARM_1_Msk            (0x2UL)                   /*!< ALARM_1 (Bitfield-Mask: 0x01)                         */
#define TIMER_INTS_ALARM_0_Pos            (0UL)                     /*!< ALARM_0 (Bit 0)                                       */
#define TIMER_INTS_ALARM_0_Msk            (0x1UL)                   /*!< ALARM_0 (Bitfield-Mask: 0x01)                         */


/* =========================================================================================================================== */
/* ================                                         WATCHDOG                                          ================ */
/* =========================================================================================================================== */

/* =========================================================  CTRL  ========================================================== */
#define WATCHDOG_CTRL_TRIGGER_Pos         (31UL)                    /*!< TRIGGER (Bit 31)                                      */
#define WATCHDOG_CTRL_TRIGGER_Msk         (0x80000000UL)            /*!< TRIGGER (Bitfield-Mask: 0x01)                         */
#define WATCHDOG_CTRL_ENABLE_Pos          (30UL)                    /*!< ENABLE (Bit 30)                                       */
#define WATCHDOG_CTRL_ENABLE_Msk          (0x40000000UL)            /*!< ENABLE (Bitfield-Mask: 0x01)                          */
#define WATCHDOG_CTRL_PAUSE_DBG1_Pos      (26UL)                    /*!< PAUSE_DBG1 (Bit 26)                                   */
#define WATCHDOG_CTRL_PAUSE_DBG1_Msk      (0x4000000UL)             /*!< PAUSE_DBG1 (Bitfield-Mask: 0x01)                      */
#define WATCHDOG_CTRL_PAUSE_DBG0_Pos      (25UL)                    /*!< PAUSE_DBG0 (Bit 25)                                   */
#define WATCHDOG_CTRL_PAUSE_DBG0_Msk      (0x2000000UL)             /*!< PAUSE_DBG0 (Bitfield-Mask: 0x01)                      */
#define WATCHDOG_CTRL_PAUSE_JTAG_Pos      (24UL)                    /*!< PAUSE_JTAG (Bit 24)                                   */
#define WATCHDOG_CTRL_PAUSE_JTAG_Msk      (0x1000000UL)             /*!< PAUSE_JTAG (Bitfield-Mask: 0x01)                      */
#define WATCHDOG_CTRL_TIME_Pos            (0UL)                     /*!< TIME (Bit 0)                                          */
#define WATCHDOG_CTRL_TIME_Msk            (0xffffffUL)              /*!< TIME (Bitfield-Mask: 0xffffff)                        */
/* =========================================================  LOAD  ========================================================== */
#define WATCHDOG_LOAD_LOAD_Pos            (0UL)                     /*!< LOAD (Bit 0)                                          */
#define WATCHDOG_LOAD_LOAD_Msk            (0xffffffUL)              /*!< LOAD (Bitfield-Mask: 0xffffff)                        */
/* ========================================================  REASON  ========================================================= */
#define WATCHDOG_REASON_FORCE_Pos         (1UL)                     /*!< FORCE (Bit 1)                                         */
#define WATCHDOG_REASON_FORCE_Msk         (0x2UL)                   /*!< FORCE (Bitfield-Mask: 0x01)                           */
#define WATCHDOG_REASON_TIMER_Pos         (0UL)                     /*!< TIMER (Bit 0)                                         */
#define WATCHDOG_REASON_TIMER_Msk         (0x1UL)                   /*!< TIMER (Bitfield-Mask: 0x01)                           */
/* =======================================================  SCRATCH0  ======================================================== */
/* =======================================================  SCRATCH1  ======================================================== */
/* =======================================================  SCRATCH2  ======================================================== */
/* =======================================================  SCRATCH3  ======================================================== */
/* =======================================================  SCRATCH4  ======================================================== */
/* =======================================================  SCRATCH5  ======================================================== */
/* =======================================================  SCRATCH6  ======================================================== */
/* =======================================================  SCRATCH7  ======================================================== */
/* =========================================================  TICK  ========================================================== */
#define WATCHDOG_TICK_COUNT_Pos           (11UL)                    /*!< COUNT (Bit 11)                                        */
#define WATCHDOG_TICK_COUNT_Msk           (0xff800UL)               /*!< COUNT (Bitfield-Mask: 0x1ff)                          */
#define WATCHDOG_TICK_RUNNING_Pos         (10UL)                    /*!< RUNNING (Bit 10)                                      */
#define WATCHDOG_TICK_RUNNING_Msk         (0x400UL)                 /*!< RUNNING (Bitfield-Mask: 0x01)                         */
#define WATCHDOG_TICK_ENABLE_Pos          (9UL)                     /*!< ENABLE (Bit 9)                                        */
#define WATCHDOG_TICK_ENABLE_Msk          (0x200UL)                 /*!< ENABLE (Bitfield-Mask: 0x01)                          */
#define WATCHDOG_TICK_CYCLES_Pos          (0UL)                     /*!< CYCLES (Bit 0)                                        */
#define WATCHDOG_TICK_CYCLES_Msk          (0x1ffUL)                 /*!< CYCLES (Bitfield-Mask: 0x1ff)                         */


/* =========================================================================================================================== */
/* ================                                            RTC                                            ================ */
/* =========================================================================================================================== */

/* =======================================================  CLKDIV_M1  ======================================================= */
#define RTC_CLKDIV_M1_CLKDIV_M1_Pos       (0UL)                     /*!< CLKDIV_M1 (Bit 0)                                     */
#define RTC_CLKDIV_M1_CLKDIV_M1_Msk       (0xffffUL)                /*!< CLKDIV_M1 (Bitfield-Mask: 0xffff)                     */
/* ========================================================  SETUP_0  ======================================================== */
#define RTC_SETUP_0_YEAR_Pos              (12UL)                    /*!< YEAR (Bit 12)                                         */
#define RTC_SETUP_0_YEAR_Msk              (0xfff000UL)              /*!< YEAR (Bitfield-Mask: 0xfff)                           */
#define RTC_SETUP_0_MONTH_Pos             (8UL)                     /*!< MONTH (Bit 8)                                         */
#define RTC_SETUP_0_MONTH_Msk             (0xf00UL)                 /*!< MONTH (Bitfield-Mask: 0x0f)                           */
#define RTC_SETUP_0_DAY_Pos               (0UL)                     /*!< DAY (Bit 0)                                           */
#define RTC_SETUP_0_DAY_Msk               (0x1fUL)                  /*!< DAY (Bitfield-Mask: 0x1f)                             */
/* ========================================================  SETUP_1  ======================================================== */
#define RTC_SETUP_1_DOTW_Pos              (24UL)                    /*!< DOTW (Bit 24)                                         */
#define RTC_SETUP_1_DOTW_Msk              (0x7000000UL)             /*!< DOTW (Bitfield-Mask: 0x07)                            */
#define RTC_SETUP_1_HOUR_Pos              (16UL)                    /*!< HOUR (Bit 16)                                         */
#define RTC_SETUP_1_HOUR_Msk              (0x1f0000UL)              /*!< HOUR (Bitfield-Mask: 0x1f)                            */
#define RTC_SETUP_1_MIN_Pos               (8UL)                     /*!< MIN (Bit 8)                                           */
#define RTC_SETUP_1_MIN_Msk               (0x3f00UL)                /*!< MIN (Bitfield-Mask: 0x3f)                             */
#define RTC_SETUP_1_SEC_Pos               (0UL)                     /*!< SEC (Bit 0)                                           */
#define RTC_SETUP_1_SEC_Msk               (0x3fUL)                  /*!< SEC (Bitfield-Mask: 0x3f)                             */
/* =========================================================  CTRL  ========================================================== */
#define RTC_CTRL_FORCE_NOTLEAPYEAR_Pos    (8UL)                     /*!< FORCE_NOTLEAPYEAR (Bit 8)                             */
#define RTC_CTRL_FORCE_NOTLEAPYEAR_Msk    (0x100UL)                 /*!< FORCE_NOTLEAPYEAR (Bitfield-Mask: 0x01)               */
#define RTC_CTRL_LOAD_Pos                 (4UL)                     /*!< LOAD (Bit 4)                                          */
#define RTC_CTRL_LOAD_Msk                 (0x10UL)                  /*!< LOAD (Bitfield-Mask: 0x01)                            */
#define RTC_CTRL_RTC_ACTIVE_Pos           (1UL)                     /*!< RTC_ACTIVE (Bit 1)                                    */
#define RTC_CTRL_RTC_ACTIVE_Msk           (0x2UL)                   /*!< RTC_ACTIVE (Bitfield-Mask: 0x01)                      */
#define RTC_CTRL_RTC_ENABLE_Pos           (0UL)                     /*!< RTC_ENABLE (Bit 0)                                    */
#define RTC_CTRL_RTC_ENABLE_Msk           (0x1UL)                   /*!< RTC_ENABLE (Bitfield-Mask: 0x01)                      */
/* ======================================================  IRQ_SETUP_0  ====================================================== */
#define RTC_IRQ_SETUP_0_MATCH_ACTIVE_Pos  (29UL)                    /*!< MATCH_ACTIVE (Bit 29)                                 */
#define RTC_IRQ_SETUP_0_MATCH_ACTIVE_Msk  (0x20000000UL)            /*!< MATCH_ACTIVE (Bitfield-Mask: 0x01)                    */
#define RTC_IRQ_SETUP_0_MATCH_ENA_Pos     (28UL)                    /*!< MATCH_ENA (Bit 28)                                    */
#define RTC_IRQ_SETUP_0_MATCH_ENA_Msk     (0x10000000UL)            /*!< MATCH_ENA (Bitfield-Mask: 0x01)                       */
#define RTC_IRQ_SETUP_0_YEAR_ENA_Pos      (26UL)                    /*!< YEAR_ENA (Bit 26)                                     */
#define RTC_IRQ_SETUP_0_YEAR_ENA_Msk      (0x4000000UL)             /*!< YEAR_ENA (Bitfield-Mask: 0x01)                        */
#define RTC_IRQ_SETUP_0_MONTH_ENA_Pos     (25UL)                    /*!< MONTH_ENA (Bit 25)                                    */
#define RTC_IRQ_SETUP_0_MONTH_ENA_Msk     (0x2000000UL)             /*!< MONTH_ENA (Bitfield-Mask: 0x01)                       */
#define RTC_IRQ_SETUP_0_DAY_ENA_Pos       (24UL)                    /*!< DAY_ENA (Bit 24)                                      */
#define RTC_IRQ_SETUP_0_DAY_ENA_Msk       (0x1000000UL)             /*!< DAY_ENA (Bitfield-Mask: 0x01)                         */
#define RTC_IRQ_SETUP_0_YEAR_Pos          (12UL)                    /*!< YEAR (Bit 12)                                         */
#define RTC_IRQ_SETUP_0_YEAR_Msk          (0xfff000UL)              /*!< YEAR (Bitfield-Mask: 0xfff)                           */
#define RTC_IRQ_SETUP_0_MONTH_Pos         (8UL)                     /*!< MONTH (Bit 8)                                         */
#define RTC_IRQ_SETUP_0_MONTH_Msk         (0xf00UL)                 /*!< MONTH (Bitfield-Mask: 0x0f)                           */
#define RTC_IRQ_SETUP_0_DAY_Pos           (0UL)                     /*!< DAY (Bit 0)                                           */
#define RTC_IRQ_SETUP_0_DAY_Msk           (0x1fUL)                  /*!< DAY (Bitfield-Mask: 0x1f)                             */
/* ======================================================  IRQ_SETUP_1  ====================================================== */
#define RTC_IRQ_SETUP_1_DOTW_ENA_Pos      (31UL)                    /*!< DOTW_ENA (Bit 31)                                     */
#define RTC_IRQ_SETUP_1_DOTW_ENA_Msk      (0x80000000UL)            /*!< DOTW_ENA (Bitfield-Mask: 0x01)                        */
#define RTC_IRQ_SETUP_1_HOUR_ENA_Pos      (30UL)                    /*!< HOUR_ENA (Bit 30)                                     */
#define RTC_IRQ_SETUP_1_HOUR_ENA_Msk      (0x40000000UL)            /*!< HOUR_ENA (Bitfield-Mask: 0x01)                        */
#define RTC_IRQ_SETUP_1_MIN_ENA_Pos       (29UL)                    /*!< MIN_ENA (Bit 29)                                      */
#define RTC_IRQ_SETUP_1_MIN_ENA_Msk       (0x20000000UL)            /*!< MIN_ENA (Bitfield-Mask: 0x01)                         */
#define RTC_IRQ_SETUP_1_SEC_ENA_Pos       (28UL)                    /*!< SEC_ENA (Bit 28)                                      */
#define RTC_IRQ_SETUP_1_SEC_ENA_Msk       (0x10000000UL)            /*!< SEC_ENA (Bitfield-Mask: 0x01)                         */
#define RTC_IRQ_SETUP_1_DOTW_Pos          (24UL)                    /*!< DOTW (Bit 24)                                         */
#define RTC_IRQ_SETUP_1_DOTW_Msk          (0x7000000UL)             /*!< DOTW (Bitfield-Mask: 0x07)                            */
#define RTC_IRQ_SETUP_1_HOUR_Pos          (16UL)                    /*!< HOUR (Bit 16)                                         */
#define RTC_IRQ_SETUP_1_HOUR_Msk          (0x1f0000UL)              /*!< HOUR (Bitfield-Mask: 0x1f)                            */
#define RTC_IRQ_SETUP_1_MIN_Pos           (8UL)                     /*!< MIN (Bit 8)                                           */
#define RTC_IRQ_SETUP_1_MIN_Msk           (0x3f00UL)                /*!< MIN (Bitfield-Mask: 0x3f)                             */
#define RTC_IRQ_SETUP_1_SEC_Pos           (0UL)                     /*!< SEC (Bit 0)                                           */
#define RTC_IRQ_SETUP_1_SEC_Msk           (0x3fUL)                  /*!< SEC (Bitfield-Mask: 0x3f)                             */
/* =========================================================  RTC_1  ========================================================= */
#define RTC_RTC_1_YEAR_Pos                (12UL)                    /*!< YEAR (Bit 12)                                         */
#define RTC_RTC_1_YEAR_Msk                (0xfff000UL)              /*!< YEAR (Bitfield-Mask: 0xfff)                           */
#define RTC_RTC_1_MONTH_Pos               (8UL)                     /*!< MONTH (Bit 8)                                         */
#define RTC_RTC_1_MONTH_Msk               (0xf00UL)                 /*!< MONTH (Bitfield-Mask: 0x0f)                           */
#define RTC_RTC_1_DAY_Pos                 (0UL)                     /*!< DAY (Bit 0)                                           */
#define RTC_RTC_1_DAY_Msk                 (0x1fUL)                  /*!< DAY (Bitfield-Mask: 0x1f)                             */
/* =========================================================  RTC_0  ========================================================= */
#define RTC_RTC_0_DOTW_Pos                (24UL)                    /*!< DOTW (Bit 24)                                         */
#define RTC_RTC_0_DOTW_Msk                (0x7000000UL)             /*!< DOTW (Bitfield-Mask: 0x07)                            */
#define RTC_RTC_0_HOUR_Pos                (16UL)                    /*!< HOUR (Bit 16)                                         */
#define RTC_RTC_0_HOUR_Msk                (0x1f0000UL)              /*!< HOUR (Bitfield-Mask: 0x1f)                            */
#define RTC_RTC_0_MIN_Pos                 (8UL)                     /*!< MIN (Bit 8)                                           */
#define RTC_RTC_0_MIN_Msk                 (0x3f00UL)                /*!< MIN (Bitfield-Mask: 0x3f)                             */
#define RTC_RTC_0_SEC_Pos                 (0UL)                     /*!< SEC (Bit 0)                                           */
#define RTC_RTC_0_SEC_Msk                 (0x3fUL)                  /*!< SEC (Bitfield-Mask: 0x3f)                             */
/* =========================================================  INTR  ========================================================== */
#define RTC_INTR_RTC_Pos                  (0UL)                     /*!< RTC (Bit 0)                                           */
#define RTC_INTR_RTC_Msk                  (0x1UL)                   /*!< RTC (Bitfield-Mask: 0x01)                             */
/* =========================================================  INTE  ========================================================== */
#define RTC_INTE_RTC_Pos                  (0UL)                     /*!< RTC (Bit 0)                                           */
#define RTC_INTE_RTC_Msk                  (0x1UL)                   /*!< RTC (Bitfield-Mask: 0x01)                             */
/* =========================================================  INTF  ========================================================== */
#define RTC_INTF_RTC_Pos                  (0UL)                     /*!< RTC (Bit 0)                                           */
#define RTC_INTF_RTC_Msk                  (0x1UL)                   /*!< RTC (Bitfield-Mask: 0x01)                             */
/* =========================================================  INTS  ========================================================== */
#define RTC_INTS_RTC_Pos                  (0UL)                     /*!< RTC (Bit 0)                                           */
#define RTC_INTS_RTC_Msk                  (0x1UL)                   /*!< RTC (Bitfield-Mask: 0x01)                             */


/* =========================================================================================================================== */
/* ================                                           ROSC                                            ================ */
/* =========================================================================================================================== */

/* =========================================================  CTRL  ========================================================== */
#define ROSC_CTRL_ENABLE_Pos              (12UL)                    /*!< ENABLE (Bit 12)                                       */
#define ROSC_CTRL_ENABLE_Msk              (0xfff000UL)              /*!< ENABLE (Bitfield-Mask: 0xfff)                         */
#define ROSC_CTRL_FREQ_RANGE_Pos          (0UL)                     /*!< FREQ_RANGE (Bit 0)                                    */
#define ROSC_CTRL_FREQ_RANGE_Msk          (0xfffUL)                 /*!< FREQ_RANGE (Bitfield-Mask: 0xfff)                     */
/* =========================================================  FREQA  ========================================================= */
#define ROSC_FREQA_PASSWD_Pos             (16UL)                    /*!< PASSWD (Bit 16)                                       */
#define ROSC_FREQA_PASSWD_Msk             (0xffff0000UL)            /*!< PASSWD (Bitfield-Mask: 0xffff)                        */
#define ROSC_FREQA_DS3_Pos                (12UL)                    /*!< DS3 (Bit 12)                                          */
#define ROSC_FREQA_DS3_Msk                (0x7000UL)                /*!< DS3 (Bitfield-Mask: 0x07)                             */
#define ROSC_FREQA_DS2_Pos                (8UL)                     /*!< DS2 (Bit 8)                                           */
#define ROSC_FREQA_DS2_Msk                (0x700UL)                 /*!< DS2 (Bitfield-Mask: 0x07)                             */
#define ROSC_FREQA_DS1_Pos                (4UL)                     /*!< DS1 (Bit 4)                                           */
#define ROSC_FREQA_DS1_Msk                (0x70UL)                  /*!< DS1 (Bitfield-Mask: 0x07)                             */
#define ROSC_FREQA_DS0_Pos                (0UL)                     /*!< DS0 (Bit 0)                                           */
#define ROSC_FREQA_DS0_Msk                (0x7UL)                   /*!< DS0 (Bitfield-Mask: 0x07)                             */
/* =========================================================  FREQB  ========================================================= */
#define ROSC_FREQB_PASSWD_Pos             (16UL)                    /*!< PASSWD (Bit 16)                                       */
#define ROSC_FREQB_PASSWD_Msk             (0xffff0000UL)            /*!< PASSWD (Bitfield-Mask: 0xffff)                        */
#define ROSC_FREQB_DS7_Pos                (12UL)                    /*!< DS7 (Bit 12)                                          */
#define ROSC_FREQB_DS7_Msk                (0x7000UL)                /*!< DS7 (Bitfield-Mask: 0x07)                             */
#define ROSC_FREQB_DS6_Pos                (8UL)                     /*!< DS6 (Bit 8)                                           */
#define ROSC_FREQB_DS6_Msk                (0x700UL)                 /*!< DS6 (Bitfield-Mask: 0x07)                             */
#define ROSC_FREQB_DS5_Pos                (4UL)                     /*!< DS5 (Bit 4)                                           */
#define ROSC_FREQB_DS5_Msk                (0x70UL)                  /*!< DS5 (Bitfield-Mask: 0x07)                             */
#define ROSC_FREQB_DS4_Pos                (0UL)                     /*!< DS4 (Bit 0)                                           */
#define ROSC_FREQB_DS4_Msk                (0x7UL)                   /*!< DS4 (Bitfield-Mask: 0x07)                             */
/* ========================================================  DORMANT  ======================================================== */
/* ==========================================================  DIV  ========================================================== */
#define ROSC_DIV_DIV_Pos                  (0UL)                     /*!< DIV (Bit 0)                                           */
#define ROSC_DIV_DIV_Msk                  (0xfffUL)                 /*!< DIV (Bitfield-Mask: 0xfff)                            */
/* =========================================================  PHASE  ========================================================= */
#define ROSC_PHASE_PASSWD_Pos             (4UL)                     /*!< PASSWD (Bit 4)                                        */
#define ROSC_PHASE_PASSWD_Msk             (0xff0UL)                 /*!< PASSWD (Bitfield-Mask: 0xff)                          */
#define ROSC_PHASE_ENABLE_Pos             (3UL)                     /*!< ENABLE (Bit 3)                                        */
#define ROSC_PHASE_ENABLE_Msk             (0x8UL)                   /*!< ENABLE (Bitfield-Mask: 0x01)                          */
#define ROSC_PHASE_FLIP_Pos               (2UL)                     /*!< FLIP (Bit 2)                                          */
#define ROSC_PHASE_FLIP_Msk               (0x4UL)                   /*!< FLIP (Bitfield-Mask: 0x01)                            */
#define ROSC_PHASE_SHIFT_Pos              (0UL)                     /*!< SHIFT (Bit 0)                                         */
#define ROSC_PHASE_SHIFT_Msk              (0x3UL)                   /*!< SHIFT (Bitfield-Mask: 0x03)                           */
/* ========================================================  STATUS  ========================================================= */
#define ROSC_STATUS_STABLE_Pos            (31UL)                    /*!< STABLE (Bit 31)                                       */
#define ROSC_STATUS_STABLE_Msk            (0x80000000UL)            /*!< STABLE (Bitfield-Mask: 0x01)                          */
#define ROSC_STATUS_BADWRITE_Pos          (24UL)                    /*!< BADWRITE (Bit 24)                                     */
#define ROSC_STATUS_BADWRITE_Msk          (0x1000000UL)             /*!< BADWRITE (Bitfield-Mask: 0x01)                        */
#define ROSC_STATUS_DIV_RUNNING_Pos       (16UL)                    /*!< DIV_RUNNING (Bit 16)                                  */
#define ROSC_STATUS_DIV_RUNNING_Msk       (0x10000UL)               /*!< DIV_RUNNING (Bitfield-Mask: 0x01)                     */
#define ROSC_STATUS_ENABLED_Pos           (12UL)                    /*!< ENABLED (Bit 12)                                      */
#define ROSC_STATUS_ENABLED_Msk           (0x1000UL)                /*!< ENABLED (Bitfield-Mask: 0x01)                         */
/* =======================================================  RANDOMBIT  ======================================================= */
#define ROSC_RANDOMBIT_RANDOMBIT_Pos      (0UL)                     /*!< RANDOMBIT (Bit 0)                                     */
#define ROSC_RANDOMBIT_RANDOMBIT_Msk      (0x1UL)                   /*!< RANDOMBIT (Bitfield-Mask: 0x01)                       */
/* =========================================================  COUNT  ========================================================= */
#define ROSC_COUNT_COUNT_Pos              (0UL)                     /*!< COUNT (Bit 0)                                         */
#define ROSC_COUNT_COUNT_Msk              (0xffUL)                  /*!< COUNT (Bitfield-Mask: 0xff)                           */


/* =========================================================================================================================== */
/* ================                                    VREG_AND_CHIP_RESET                                    ================ */
/* =========================================================================================================================== */

/* =========================================================  VREG  ========================================================== */
#define VREG_AND_CHIP_RESET_VREG_ROK_Pos  (12UL)                    /*!< ROK (Bit 12)                                          */
#define VREG_AND_CHIP_RESET_VREG_ROK_Msk  (0x1000UL)                /*!< ROK (Bitfield-Mask: 0x01)                             */
#define VREG_AND_CHIP_RESET_VREG_VSEL_Pos (4UL)                     /*!< VSEL (Bit 4)                                          */
#define VREG_AND_CHIP_RESET_VREG_VSEL_Msk (0xf0UL)                  /*!< VSEL (Bitfield-Mask: 0x0f)                            */
#define VREG_AND_CHIP_RESET_VREG_HIZ_Pos  (1UL)                     /*!< HIZ (Bit 1)                                           */
#define VREG_AND_CHIP_RESET_VREG_HIZ_Msk  (0x2UL)                   /*!< HIZ (Bitfield-Mask: 0x01)                             */
#define VREG_AND_CHIP_RESET_VREG_EN_Pos   (0UL)                     /*!< EN (Bit 0)                                            */
#define VREG_AND_CHIP_RESET_VREG_EN_Msk   (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01)                              */
/* ==========================================================  BOD  ========================================================== */
#define VREG_AND_CHIP_RESET_BOD_VSEL_Pos  (4UL)                     /*!< VSEL (Bit 4)                                          */
#define VREG_AND_CHIP_RESET_BOD_VSEL_Msk  (0xf0UL)                  /*!< VSEL (Bitfield-Mask: 0x0f)                            */
#define VREG_AND_CHIP_RESET_BOD_EN_Pos    (0UL)                     /*!< EN (Bit 0)                                            */
#define VREG_AND_CHIP_RESET_BOD_EN_Msk    (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01)                              */
/* ======================================================  CHIP_RESET  ======================================================= */
#define VREG_AND_CHIP_RESET_CHIP_RESET_PSM_RESTART_FLAG_Pos (24UL)  /*!< PSM_RESTART_FLAG (Bit 24)                             */
#define VREG_AND_CHIP_RESET_CHIP_RESET_PSM_RESTART_FLAG_Msk (0x1000000UL) /*!< PSM_RESTART_FLAG (Bitfield-Mask: 0x01)          */
#define VREG_AND_CHIP_RESET_CHIP_RESET_HAD_PSM_RESTART_Pos (20UL)   /*!< HAD_PSM_RESTART (Bit 20)                              */
#define VREG_AND_CHIP_RESET_CHIP_RESET_HAD_PSM_RESTART_Msk (0x100000UL) /*!< HAD_PSM_RESTART (Bitfield-Mask: 0x01)             */
#define VREG_AND_CHIP_RESET_CHIP_RESET_HAD_RUN_Pos (16UL)           /*!< HAD_RUN (Bit 16)                                      */
#define VREG_AND_CHIP_RESET_CHIP_RESET_HAD_RUN_Msk (0x10000UL)      /*!< HAD_RUN (Bitfield-Mask: 0x01)                         */
#define VREG_AND_CHIP_RESET_CHIP_RESET_HAD_POR_Pos (8UL)            /*!< HAD_POR (Bit 8)                                       */
#define VREG_AND_CHIP_RESET_CHIP_RESET_HAD_POR_Msk (0x100UL)        /*!< HAD_POR (Bitfield-Mask: 0x01)                         */


/* =========================================================================================================================== */
/* ================                                           TBMAN                                           ================ */
/* =========================================================================================================================== */

/* =======================================================  PLATFORM  ======================================================== */
#define TBMAN_PLATFORM_FPGA_Pos           (1UL)                     /*!< FPGA (Bit 1)                                          */
#define TBMAN_PLATFORM_FPGA_Msk           (0x2UL)                   /*!< FPGA (Bitfield-Mask: 0x01)                            */
#define TBMAN_PLATFORM_ASIC_Pos           (0UL)                     /*!< ASIC (Bit 0)                                          */
#define TBMAN_PLATFORM_ASIC_Msk           (0x1UL)                   /*!< ASIC (Bitfield-Mask: 0x01)                            */


/* =========================================================================================================================== */
/* ================                                            DMA                                            ================ */
/* =========================================================================================================================== */

/* =====================================================  CH0_READ_ADDR  ===================================================== */
/* ====================================================  CH0_WRITE_ADDR  ===================================================== */
/* ====================================================  CH0_TRANS_COUNT  ==================================================== */
/* =====================================================  CH0_CTRL_TRIG  ===================================================== */
#define DMA_CH0_CTRL_TRIG_AHB_ERROR_Pos   (31UL)                    /*!< AHB_ERROR (Bit 31)                                    */
#define DMA_CH0_CTRL_TRIG_AHB_ERROR_Msk   (0x80000000UL)            /*!< AHB_ERROR (Bitfield-Mask: 0x01)                       */
#define DMA_CH0_CTRL_TRIG_READ_ERROR_Pos  (30UL)                    /*!< READ_ERROR (Bit 30)                                   */
#define DMA_CH0_CTRL_TRIG_READ_ERROR_Msk  (0x40000000UL)            /*!< READ_ERROR (Bitfield-Mask: 0x01)                      */
#define DMA_CH0_CTRL_TRIG_WRITE_ERROR_Pos (29UL)                    /*!< WRITE_ERROR (Bit 29)                                  */
#define DMA_CH0_CTRL_TRIG_WRITE_ERROR_Msk (0x20000000UL)            /*!< WRITE_ERROR (Bitfield-Mask: 0x01)                     */
#define DMA_CH0_CTRL_TRIG_BUSY_Pos        (24UL)                    /*!< BUSY (Bit 24)                                         */
#define DMA_CH0_CTRL_TRIG_BUSY_Msk        (0x1000000UL)             /*!< BUSY (Bitfield-Mask: 0x01)                            */
#define DMA_CH0_CTRL_TRIG_SNIFF_EN_Pos    (23UL)                    /*!< SNIFF_EN (Bit 23)                                     */
#define DMA_CH0_CTRL_TRIG_SNIFF_EN_Msk    (0x800000UL)              /*!< SNIFF_EN (Bitfield-Mask: 0x01)                        */
#define DMA_CH0_CTRL_TRIG_BSWAP_Pos       (22UL)                    /*!< BSWAP (Bit 22)                                        */
#define DMA_CH0_CTRL_TRIG_BSWAP_Msk       (0x400000UL)              /*!< BSWAP (Bitfield-Mask: 0x01)                           */
#define DMA_CH0_CTRL_TRIG_IRQ_QUIET_Pos   (21UL)                    /*!< IRQ_QUIET (Bit 21)                                    */
#define DMA_CH0_CTRL_TRIG_IRQ_QUIET_Msk   (0x200000UL)              /*!< IRQ_QUIET (Bitfield-Mask: 0x01)                       */
#define DMA_CH0_CTRL_TRIG_TREQ_SEL_Pos    (15UL)                    /*!< TREQ_SEL (Bit 15)                                     */
#define DMA_CH0_CTRL_TRIG_TREQ_SEL_Msk    (0x1f8000UL)              /*!< TREQ_SEL (Bitfield-Mask: 0x3f)                        */
#define DMA_CH0_CTRL_TRIG_CHAIN_TO_Pos    (11UL)                    /*!< CHAIN_TO (Bit 11)                                     */
#define DMA_CH0_CTRL_TRIG_CHAIN_TO_Msk    (0x7800UL)                /*!< CHAIN_TO (Bitfield-Mask: 0x0f)                        */
#define DMA_CH0_CTRL_TRIG_RING_SEL_Pos    (10UL)                    /*!< RING_SEL (Bit 10)                                     */
#define DMA_CH0_CTRL_TRIG_RING_SEL_Msk    (0x400UL)                 /*!< RING_SEL (Bitfield-Mask: 0x01)                        */
#define DMA_CH0_CTRL_TRIG_RING_SIZE_Pos   (6UL)                     /*!< RING_SIZE (Bit 6)                                     */
#define DMA_CH0_CTRL_TRIG_RING_SIZE_Msk   (0x3c0UL)                 /*!< RING_SIZE (Bitfield-Mask: 0x0f)                       */
#define DMA_CH0_CTRL_TRIG_INCR_WRITE_Pos  (5UL)                     /*!< INCR_WRITE (Bit 5)                                    */
#define DMA_CH0_CTRL_TRIG_INCR_WRITE_Msk  (0x20UL)                  /*!< INCR_WRITE (Bitfield-Mask: 0x01)                      */
#define DMA_CH0_CTRL_TRIG_INCR_READ_Pos   (4UL)                     /*!< INCR_READ (Bit 4)                                     */
#define DMA_CH0_CTRL_TRIG_INCR_READ_Msk   (0x10UL)                  /*!< INCR_READ (Bitfield-Mask: 0x01)                       */
#define DMA_CH0_CTRL_TRIG_DATA_SIZE_Pos   (2UL)                     /*!< DATA_SIZE (Bit 2)                                     */
#define DMA_CH0_CTRL_TRIG_DATA_SIZE_Msk   (0xcUL)                   /*!< DATA_SIZE (Bitfield-Mask: 0x03)                       */
#define DMA_CH0_CTRL_TRIG_HIGH_PRIORITY_Pos (1UL)                   /*!< HIGH_PRIORITY (Bit 1)                                 */
#define DMA_CH0_CTRL_TRIG_HIGH_PRIORITY_Msk (0x2UL)                 /*!< HIGH_PRIORITY (Bitfield-Mask: 0x01)                   */
#define DMA_CH0_CTRL_TRIG_EN_Pos          (0UL)                     /*!< EN (Bit 0)                                            */
#define DMA_CH0_CTRL_TRIG_EN_Msk          (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01)                              */
/* =====================================================  CH0_AL1_CTRL  ====================================================== */
/* ===================================================  CH0_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH0_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH0_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH0_AL2_CTRL  ====================================================== */
/* ==================================================  CH0_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH0_AL2_READ_ADDR  =================================================== */
/* ================================================  CH0_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH0_AL3_CTRL  ====================================================== */
/* ==================================================  CH0_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH0_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH0_AL3_READ_ADDR_TRIG  ================================================= */
/* =====================================================  CH1_READ_ADDR  ===================================================== */
/* ====================================================  CH1_WRITE_ADDR  ===================================================== */
/* ====================================================  CH1_TRANS_COUNT  ==================================================== */
/* =====================================================  CH1_CTRL_TRIG  ===================================================== */
#define DMA_CH1_CTRL_TRIG_AHB_ERROR_Pos   (31UL)                    /*!< AHB_ERROR (Bit 31)                                    */
#define DMA_CH1_CTRL_TRIG_AHB_ERROR_Msk   (0x80000000UL)            /*!< AHB_ERROR (Bitfield-Mask: 0x01)                       */
#define DMA_CH1_CTRL_TRIG_READ_ERROR_Pos  (30UL)                    /*!< READ_ERROR (Bit 30)                                   */
#define DMA_CH1_CTRL_TRIG_READ_ERROR_Msk  (0x40000000UL)            /*!< READ_ERROR (Bitfield-Mask: 0x01)                      */
#define DMA_CH1_CTRL_TRIG_WRITE_ERROR_Pos (29UL)                    /*!< WRITE_ERROR (Bit 29)                                  */
#define DMA_CH1_CTRL_TRIG_WRITE_ERROR_Msk (0x20000000UL)            /*!< WRITE_ERROR (Bitfield-Mask: 0x01)                     */
#define DMA_CH1_CTRL_TRIG_BUSY_Pos        (24UL)                    /*!< BUSY (Bit 24)                                         */
#define DMA_CH1_CTRL_TRIG_BUSY_Msk        (0x1000000UL)             /*!< BUSY (Bitfield-Mask: 0x01)                            */
#define DMA_CH1_CTRL_TRIG_SNIFF_EN_Pos    (23UL)                    /*!< SNIFF_EN (Bit 23)                                     */
#define DMA_CH1_CTRL_TRIG_SNIFF_EN_Msk    (0x800000UL)              /*!< SNIFF_EN (Bitfield-Mask: 0x01)                        */
#define DMA_CH1_CTRL_TRIG_BSWAP_Pos       (22UL)                    /*!< BSWAP (Bit 22)                                        */
#define DMA_CH1_CTRL_TRIG_BSWAP_Msk       (0x400000UL)              /*!< BSWAP (Bitfield-Mask: 0x01)                           */
#define DMA_CH1_CTRL_TRIG_IRQ_QUIET_Pos   (21UL)                    /*!< IRQ_QUIET (Bit 21)                                    */
#define DMA_CH1_CTRL_TRIG_IRQ_QUIET_Msk   (0x200000UL)              /*!< IRQ_QUIET (Bitfield-Mask: 0x01)                       */
#define DMA_CH1_CTRL_TRIG_TREQ_SEL_Pos    (15UL)                    /*!< TREQ_SEL (Bit 15)                                     */
#define DMA_CH1_CTRL_TRIG_TREQ_SEL_Msk    (0x1f8000UL)              /*!< TREQ_SEL (Bitfield-Mask: 0x3f)                        */
#define DMA_CH1_CTRL_TRIG_CHAIN_TO_Pos    (11UL)                    /*!< CHAIN_TO (Bit 11)                                     */
#define DMA_CH1_CTRL_TRIG_CHAIN_TO_Msk    (0x7800UL)                /*!< CHAIN_TO (Bitfield-Mask: 0x0f)                        */
#define DMA_CH1_CTRL_TRIG_RING_SEL_Pos    (10UL)                    /*!< RING_SEL (Bit 10)                                     */
#define DMA_CH1_CTRL_TRIG_RING_SEL_Msk    (0x400UL)                 /*!< RING_SEL (Bitfield-Mask: 0x01)                        */
#define DMA_CH1_CTRL_TRIG_RING_SIZE_Pos   (6UL)                     /*!< RING_SIZE (Bit 6)                                     */
#define DMA_CH1_CTRL_TRIG_RING_SIZE_Msk   (0x3c0UL)                 /*!< RING_SIZE (Bitfield-Mask: 0x0f)                       */
#define DMA_CH1_CTRL_TRIG_INCR_WRITE_Pos  (5UL)                     /*!< INCR_WRITE (Bit 5)                                    */
#define DMA_CH1_CTRL_TRIG_INCR_WRITE_Msk  (0x20UL)                  /*!< INCR_WRITE (Bitfield-Mask: 0x01)                      */
#define DMA_CH1_CTRL_TRIG_INCR_READ_Pos   (4UL)                     /*!< INCR_READ (Bit 4)                                     */
#define DMA_CH1_CTRL_TRIG_INCR_READ_Msk   (0x10UL)                  /*!< INCR_READ (Bitfield-Mask: 0x01)                       */
#define DMA_CH1_CTRL_TRIG_DATA_SIZE_Pos   (2UL)                     /*!< DATA_SIZE (Bit 2)                                     */
#define DMA_CH1_CTRL_TRIG_DATA_SIZE_Msk   (0xcUL)                   /*!< DATA_SIZE (Bitfield-Mask: 0x03)                       */
#define DMA_CH1_CTRL_TRIG_HIGH_PRIORITY_Pos (1UL)                   /*!< HIGH_PRIORITY (Bit 1)                                 */
#define DMA_CH1_CTRL_TRIG_HIGH_PRIORITY_Msk (0x2UL)                 /*!< HIGH_PRIORITY (Bitfield-Mask: 0x01)                   */
#define DMA_CH1_CTRL_TRIG_EN_Pos          (0UL)                     /*!< EN (Bit 0)                                            */
#define DMA_CH1_CTRL_TRIG_EN_Msk          (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01)                              */
/* =====================================================  CH1_AL1_CTRL  ====================================================== */
/* ===================================================  CH1_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH1_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH1_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH1_AL2_CTRL  ====================================================== */
/* ==================================================  CH1_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH1_AL2_READ_ADDR  =================================================== */
/* ================================================  CH1_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH1_AL3_CTRL  ====================================================== */
/* ==================================================  CH1_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH1_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH1_AL3_READ_ADDR_TRIG  ================================================= */
/* =====================================================  CH2_READ_ADDR  ===================================================== */
/* ====================================================  CH2_WRITE_ADDR  ===================================================== */
/* ====================================================  CH2_TRANS_COUNT  ==================================================== */
/* =====================================================  CH2_CTRL_TRIG  ===================================================== */
#define DMA_CH2_CTRL_TRIG_AHB_ERROR_Pos   (31UL)                    /*!< AHB_ERROR (Bit 31)                                    */
#define DMA_CH2_CTRL_TRIG_AHB_ERROR_Msk   (0x80000000UL)            /*!< AHB_ERROR (Bitfield-Mask: 0x01)                       */
#define DMA_CH2_CTRL_TRIG_READ_ERROR_Pos  (30UL)                    /*!< READ_ERROR (Bit 30)                                   */
#define DMA_CH2_CTRL_TRIG_READ_ERROR_Msk  (0x40000000UL)            /*!< READ_ERROR (Bitfield-Mask: 0x01)                      */
#define DMA_CH2_CTRL_TRIG_WRITE_ERROR_Pos (29UL)                    /*!< WRITE_ERROR (Bit 29)                                  */
#define DMA_CH2_CTRL_TRIG_WRITE_ERROR_Msk (0x20000000UL)            /*!< WRITE_ERROR (Bitfield-Mask: 0x01)                     */
#define DMA_CH2_CTRL_TRIG_BUSY_Pos        (24UL)                    /*!< BUSY (Bit 24)                                         */
#define DMA_CH2_CTRL_TRIG_BUSY_Msk        (0x1000000UL)             /*!< BUSY (Bitfield-Mask: 0x01)                            */
#define DMA_CH2_CTRL_TRIG_SNIFF_EN_Pos    (23UL)                    /*!< SNIFF_EN (Bit 23)                                     */
#define DMA_CH2_CTRL_TRIG_SNIFF_EN_Msk    (0x800000UL)              /*!< SNIFF_EN (Bitfield-Mask: 0x01)                        */
#define DMA_CH2_CTRL_TRIG_BSWAP_Pos       (22UL)                    /*!< BSWAP (Bit 22)                                        */
#define DMA_CH2_CTRL_TRIG_BSWAP_Msk       (0x400000UL)              /*!< BSWAP (Bitfield-Mask: 0x01)                           */
#define DMA_CH2_CTRL_TRIG_IRQ_QUIET_Pos   (21UL)                    /*!< IRQ_QUIET (Bit 21)                                    */
#define DMA_CH2_CTRL_TRIG_IRQ_QUIET_Msk   (0x200000UL)              /*!< IRQ_QUIET (Bitfield-Mask: 0x01)                       */
#define DMA_CH2_CTRL_TRIG_TREQ_SEL_Pos    (15UL)                    /*!< TREQ_SEL (Bit 15)                                     */
#define DMA_CH2_CTRL_TRIG_TREQ_SEL_Msk    (0x1f8000UL)              /*!< TREQ_SEL (Bitfield-Mask: 0x3f)                        */
#define DMA_CH2_CTRL_TRIG_CHAIN_TO_Pos    (11UL)                    /*!< CHAIN_TO (Bit 11)                                     */
#define DMA_CH2_CTRL_TRIG_CHAIN_TO_Msk    (0x7800UL)                /*!< CHAIN_TO (Bitfield-Mask: 0x0f)                        */
#define DMA_CH2_CTRL_TRIG_RING_SEL_Pos    (10UL)                    /*!< RING_SEL (Bit 10)                                     */
#define DMA_CH2_CTRL_TRIG_RING_SEL_Msk    (0x400UL)                 /*!< RING_SEL (Bitfield-Mask: 0x01)                        */
#define DMA_CH2_CTRL_TRIG_RING_SIZE_Pos   (6UL)                     /*!< RING_SIZE (Bit 6)                                     */
#define DMA_CH2_CTRL_TRIG_RING_SIZE_Msk   (0x3c0UL)                 /*!< RING_SIZE (Bitfield-Mask: 0x0f)                       */
#define DMA_CH2_CTRL_TRIG_INCR_WRITE_Pos  (5UL)                     /*!< INCR_WRITE (Bit 5)                                    */
#define DMA_CH2_CTRL_TRIG_INCR_WRITE_Msk  (0x20UL)                  /*!< INCR_WRITE (Bitfield-Mask: 0x01)                      */
#define DMA_CH2_CTRL_TRIG_INCR_READ_Pos   (4UL)                     /*!< INCR_READ (Bit 4)                                     */
#define DMA_CH2_CTRL_TRIG_INCR_READ_Msk   (0x10UL)                  /*!< INCR_READ (Bitfield-Mask: 0x01)                       */
#define DMA_CH2_CTRL_TRIG_DATA_SIZE_Pos   (2UL)                     /*!< DATA_SIZE (Bit 2)                                     */
#define DMA_CH2_CTRL_TRIG_DATA_SIZE_Msk   (0xcUL)                   /*!< DATA_SIZE (Bitfield-Mask: 0x03)                       */
#define DMA_CH2_CTRL_TRIG_HIGH_PRIORITY_Pos (1UL)                   /*!< HIGH_PRIORITY (Bit 1)                                 */
#define DMA_CH2_CTRL_TRIG_HIGH_PRIORITY_Msk (0x2UL)                 /*!< HIGH_PRIORITY (Bitfield-Mask: 0x01)                   */
#define DMA_CH2_CTRL_TRIG_EN_Pos          (0UL)                     /*!< EN (Bit 0)                                            */
#define DMA_CH2_CTRL_TRIG_EN_Msk          (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01)                              */
/* =====================================================  CH2_AL1_CTRL  ====================================================== */
/* ===================================================  CH2_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH2_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH2_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH2_AL2_CTRL  ====================================================== */
/* ==================================================  CH2_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH2_AL2_READ_ADDR  =================================================== */
/* ================================================  CH2_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH2_AL3_CTRL  ====================================================== */
/* ==================================================  CH2_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH2_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH2_AL3_READ_ADDR_TRIG  ================================================= */
/* =====================================================  CH3_READ_ADDR  ===================================================== */
/* ====================================================  CH3_WRITE_ADDR  ===================================================== */
/* ====================================================  CH3_TRANS_COUNT  ==================================================== */
/* =====================================================  CH3_CTRL_TRIG  ===================================================== */
#define DMA_CH3_CTRL_TRIG_AHB_ERROR_Pos   (31UL)                    /*!< AHB_ERROR (Bit 31)                                    */
#define DMA_CH3_CTRL_TRIG_AHB_ERROR_Msk   (0x80000000UL)            /*!< AHB_ERROR (Bitfield-Mask: 0x01)                       */
#define DMA_CH3_CTRL_TRIG_READ_ERROR_Pos  (30UL)                    /*!< READ_ERROR (Bit 30)                                   */
#define DMA_CH3_CTRL_TRIG_READ_ERROR_Msk  (0x40000000UL)            /*!< READ_ERROR (Bitfield-Mask: 0x01)                      */
#define DMA_CH3_CTRL_TRIG_WRITE_ERROR_Pos (29UL)                    /*!< WRITE_ERROR (Bit 29)                                  */
#define DMA_CH3_CTRL_TRIG_WRITE_ERROR_Msk (0x20000000UL)            /*!< WRITE_ERROR (Bitfield-Mask: 0x01)                     */
#define DMA_CH3_CTRL_TRIG_BUSY_Pos        (24UL)                    /*!< BUSY (Bit 24)                                         */
#define DMA_CH3_CTRL_TRIG_BUSY_Msk        (0x1000000UL)             /*!< BUSY (Bitfield-Mask: 0x01)                            */
#define DMA_CH3_CTRL_TRIG_SNIFF_EN_Pos    (23UL)                    /*!< SNIFF_EN (Bit 23)                                     */
#define DMA_CH3_CTRL_TRIG_SNIFF_EN_Msk    (0x800000UL)              /*!< SNIFF_EN (Bitfield-Mask: 0x01)                        */
#define DMA_CH3_CTRL_TRIG_BSWAP_Pos       (22UL)                    /*!< BSWAP (Bit 22)                                        */
#define DMA_CH3_CTRL_TRIG_BSWAP_Msk       (0x400000UL)              /*!< BSWAP (Bitfield-Mask: 0x01)                           */
#define DMA_CH3_CTRL_TRIG_IRQ_QUIET_Pos   (21UL)                    /*!< IRQ_QUIET (Bit 21)                                    */
#define DMA_CH3_CTRL_TRIG_IRQ_QUIET_Msk   (0x200000UL)              /*!< IRQ_QUIET (Bitfield-Mask: 0x01)                       */
#define DMA_CH3_CTRL_TRIG_TREQ_SEL_Pos    (15UL)                    /*!< TREQ_SEL (Bit 15)                                     */
#define DMA_CH3_CTRL_TRIG_TREQ_SEL_Msk    (0x1f8000UL)              /*!< TREQ_SEL (Bitfield-Mask: 0x3f)                        */
#define DMA_CH3_CTRL_TRIG_CHAIN_TO_Pos    (11UL)                    /*!< CHAIN_TO (Bit 11)                                     */
#define DMA_CH3_CTRL_TRIG_CHAIN_TO_Msk    (0x7800UL)                /*!< CHAIN_TO (Bitfield-Mask: 0x0f)                        */
#define DMA_CH3_CTRL_TRIG_RING_SEL_Pos    (10UL)                    /*!< RING_SEL (Bit 10)                                     */
#define DMA_CH3_CTRL_TRIG_RING_SEL_Msk    (0x400UL)                 /*!< RING_SEL (Bitfield-Mask: 0x01)                        */
#define DMA_CH3_CTRL_TRIG_RING_SIZE_Pos   (6UL)                     /*!< RING_SIZE (Bit 6)                                     */
#define DMA_CH3_CTRL_TRIG_RING_SIZE_Msk   (0x3c0UL)                 /*!< RING_SIZE (Bitfield-Mask: 0x0f)                       */
#define DMA_CH3_CTRL_TRIG_INCR_WRITE_Pos  (5UL)                     /*!< INCR_WRITE (Bit 5)                                    */
#define DMA_CH3_CTRL_TRIG_INCR_WRITE_Msk  (0x20UL)                  /*!< INCR_WRITE (Bitfield-Mask: 0x01)                      */
#define DMA_CH3_CTRL_TRIG_INCR_READ_Pos   (4UL)                     /*!< INCR_READ (Bit 4)                                     */
#define DMA_CH3_CTRL_TRIG_INCR_READ_Msk   (0x10UL)                  /*!< INCR_READ (Bitfield-Mask: 0x01)                       */
#define DMA_CH3_CTRL_TRIG_DATA_SIZE_Pos   (2UL)                     /*!< DATA_SIZE (Bit 2)                                     */
#define DMA_CH3_CTRL_TRIG_DATA_SIZE_Msk   (0xcUL)                   /*!< DATA_SIZE (Bitfield-Mask: 0x03)                       */
#define DMA_CH3_CTRL_TRIG_HIGH_PRIORITY_Pos (1UL)                   /*!< HIGH_PRIORITY (Bit 1)                                 */
#define DMA_CH3_CTRL_TRIG_HIGH_PRIORITY_Msk (0x2UL)                 /*!< HIGH_PRIORITY (Bitfield-Mask: 0x01)                   */
#define DMA_CH3_CTRL_TRIG_EN_Pos          (0UL)                     /*!< EN (Bit 0)                                            */
#define DMA_CH3_CTRL_TRIG_EN_Msk          (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01)                              */
/* =====================================================  CH3_AL1_CTRL  ====================================================== */
/* ===================================================  CH3_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH3_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH3_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH3_AL2_CTRL  ====================================================== */
/* ==================================================  CH3_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH3_AL2_READ_ADDR  =================================================== */
/* ================================================  CH3_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH3_AL3_CTRL  ====================================================== */
/* ==================================================  CH3_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH3_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH3_AL3_READ_ADDR_TRIG  ================================================= */
/* =====================================================  CH4_READ_ADDR  ===================================================== */
/* ====================================================  CH4_WRITE_ADDR  ===================================================== */
/* ====================================================  CH4_TRANS_COUNT  ==================================================== */
/* =====================================================  CH4_CTRL_TRIG  ===================================================== */
#define DMA_CH4_CTRL_TRIG_AHB_ERROR_Pos   (31UL)                    /*!< AHB_ERROR (Bit 31)                                    */
#define DMA_CH4_CTRL_TRIG_AHB_ERROR_Msk   (0x80000000UL)            /*!< AHB_ERROR (Bitfield-Mask: 0x01)                       */
#define DMA_CH4_CTRL_TRIG_READ_ERROR_Pos  (30UL)                    /*!< READ_ERROR (Bit 30)                                   */
#define DMA_CH4_CTRL_TRIG_READ_ERROR_Msk  (0x40000000UL)            /*!< READ_ERROR (Bitfield-Mask: 0x01)                      */
#define DMA_CH4_CTRL_TRIG_WRITE_ERROR_Pos (29UL)                    /*!< WRITE_ERROR (Bit 29)                                  */
#define DMA_CH4_CTRL_TRIG_WRITE_ERROR_Msk (0x20000000UL)            /*!< WRITE_ERROR (Bitfield-Mask: 0x01)                     */
#define DMA_CH4_CTRL_TRIG_BUSY_Pos        (24UL)                    /*!< BUSY (Bit 24)                                         */
#define DMA_CH4_CTRL_TRIG_BUSY_Msk        (0x1000000UL)             /*!< BUSY (Bitfield-Mask: 0x01)                            */
#define DMA_CH4_CTRL_TRIG_SNIFF_EN_Pos    (23UL)                    /*!< SNIFF_EN (Bit 23)                                     */
#define DMA_CH4_CTRL_TRIG_SNIFF_EN_Msk    (0x800000UL)              /*!< SNIFF_EN (Bitfield-Mask: 0x01)                        */
#define DMA_CH4_CTRL_TRIG_BSWAP_Pos       (22UL)                    /*!< BSWAP (Bit 22)                                        */
#define DMA_CH4_CTRL_TRIG_BSWAP_Msk       (0x400000UL)              /*!< BSWAP (Bitfield-Mask: 0x01)                           */
#define DMA_CH4_CTRL_TRIG_IRQ_QUIET_Pos   (21UL)                    /*!< IRQ_QUIET (Bit 21)                                    */
#define DMA_CH4_CTRL_TRIG_IRQ_QUIET_Msk   (0x200000UL)              /*!< IRQ_QUIET (Bitfield-Mask: 0x01)                       */
#define DMA_CH4_CTRL_TRIG_TREQ_SEL_Pos    (15UL)                    /*!< TREQ_SEL (Bit 15)                                     */
#define DMA_CH4_CTRL_TRIG_TREQ_SEL_Msk    (0x1f8000UL)              /*!< TREQ_SEL (Bitfield-Mask: 0x3f)                        */
#define DMA_CH4_CTRL_TRIG_CHAIN_TO_Pos    (11UL)                    /*!< CHAIN_TO (Bit 11)                                     */
#define DMA_CH4_CTRL_TRIG_CHAIN_TO_Msk    (0x7800UL)                /*!< CHAIN_TO (Bitfield-Mask: 0x0f)                        */
#define DMA_CH4_CTRL_TRIG_RING_SEL_Pos    (10UL)                    /*!< RING_SEL (Bit 10)                                     */
#define DMA_CH4_CTRL_TRIG_RING_SEL_Msk    (0x400UL)                 /*!< RING_SEL (Bitfield-Mask: 0x01)                        */
#define DMA_CH4_CTRL_TRIG_RING_SIZE_Pos   (6UL)                     /*!< RING_SIZE (Bit 6)                                     */
#define DMA_CH4_CTRL_TRIG_RING_SIZE_Msk   (0x3c0UL)                 /*!< RING_SIZE (Bitfield-Mask: 0x0f)                       */
#define DMA_CH4_CTRL_TRIG_INCR_WRITE_Pos  (5UL)                     /*!< INCR_WRITE (Bit 5)                                    */
#define DMA_CH4_CTRL_TRIG_INCR_WRITE_Msk  (0x20UL)                  /*!< INCR_WRITE (Bitfield-Mask: 0x01)                      */
#define DMA_CH4_CTRL_TRIG_INCR_READ_Pos   (4UL)                     /*!< INCR_READ (Bit 4)                                     */
#define DMA_CH4_CTRL_TRIG_INCR_READ_Msk   (0x10UL)                  /*!< INCR_READ (Bitfield-Mask: 0x01)                       */
#define DMA_CH4_CTRL_TRIG_DATA_SIZE_Pos   (2UL)                     /*!< DATA_SIZE (Bit 2)                                     */
#define DMA_CH4_CTRL_TRIG_DATA_SIZE_Msk   (0xcUL)                   /*!< DATA_SIZE (Bitfield-Mask: 0x03)                       */
#define DMA_CH4_CTRL_TRIG_HIGH_PRIORITY_Pos (1UL)                   /*!< HIGH_PRIORITY (Bit 1)                                 */
#define DMA_CH4_CTRL_TRIG_HIGH_PRIORITY_Msk (0x2UL)                 /*!< HIGH_PRIORITY (Bitfield-Mask: 0x01)                   */
#define DMA_CH4_CTRL_TRIG_EN_Pos          (0UL)                     /*!< EN (Bit 0)                                            */
#define DMA_CH4_CTRL_TRIG_EN_Msk          (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01)                              */
/* =====================================================  CH4_AL1_CTRL  ====================================================== */
/* ===================================================  CH4_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH4_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH4_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH4_AL2_CTRL  ====================================================== */
/* ==================================================  CH4_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH4_AL2_READ_ADDR  =================================================== */
/* ================================================  CH4_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH4_AL3_CTRL  ====================================================== */
/* ==================================================  CH4_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH4_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH4_AL3_READ_ADDR_TRIG  ================================================= */
/* =====================================================  CH5_READ_ADDR  ===================================================== */
/* ====================================================  CH5_WRITE_ADDR  ===================================================== */
/* ====================================================  CH5_TRANS_COUNT  ==================================================== */
/* =====================================================  CH5_CTRL_TRIG  ===================================================== */
#define DMA_CH5_CTRL_TRIG_AHB_ERROR_Pos   (31UL)                    /*!< AHB_ERROR (Bit 31)                                    */
#define DMA_CH5_CTRL_TRIG_AHB_ERROR_Msk   (0x80000000UL)            /*!< AHB_ERROR (Bitfield-Mask: 0x01)                       */
#define DMA_CH5_CTRL_TRIG_READ_ERROR_Pos  (30UL)                    /*!< READ_ERROR (Bit 30)                                   */
#define DMA_CH5_CTRL_TRIG_READ_ERROR_Msk  (0x40000000UL)            /*!< READ_ERROR (Bitfield-Mask: 0x01)                      */
#define DMA_CH5_CTRL_TRIG_WRITE_ERROR_Pos (29UL)                    /*!< WRITE_ERROR (Bit 29)                                  */
#define DMA_CH5_CTRL_TRIG_WRITE_ERROR_Msk (0x20000000UL)            /*!< WRITE_ERROR (Bitfield-Mask: 0x01)                     */
#define DMA_CH5_CTRL_TRIG_BUSY_Pos        (24UL)                    /*!< BUSY (Bit 24)                                         */
#define DMA_CH5_CTRL_TRIG_BUSY_Msk        (0x1000000UL)             /*!< BUSY (Bitfield-Mask: 0x01)                            */
#define DMA_CH5_CTRL_TRIG_SNIFF_EN_Pos    (23UL)                    /*!< SNIFF_EN (Bit 23)                                     */
#define DMA_CH5_CTRL_TRIG_SNIFF_EN_Msk    (0x800000UL)              /*!< SNIFF_EN (Bitfield-Mask: 0x01)                        */
#define DMA_CH5_CTRL_TRIG_BSWAP_Pos       (22UL)                    /*!< BSWAP (Bit 22)                                        */
#define DMA_CH5_CTRL_TRIG_BSWAP_Msk       (0x400000UL)              /*!< BSWAP (Bitfield-Mask: 0x01)                           */
#define DMA_CH5_CTRL_TRIG_IRQ_QUIET_Pos   (21UL)                    /*!< IRQ_QUIET (Bit 21)                                    */
#define DMA_CH5_CTRL_TRIG_IRQ_QUIET_Msk   (0x200000UL)              /*!< IRQ_QUIET (Bitfield-Mask: 0x01)                       */
#define DMA_CH5_CTRL_TRIG_TREQ_SEL_Pos    (15UL)                    /*!< TREQ_SEL (Bit 15)                                     */
#define DMA_CH5_CTRL_TRIG_TREQ_SEL_Msk    (0x1f8000UL)              /*!< TREQ_SEL (Bitfield-Mask: 0x3f)                        */
#define DMA_CH5_CTRL_TRIG_CHAIN_TO_Pos    (11UL)                    /*!< CHAIN_TO (Bit 11)                                     */
#define DMA_CH5_CTRL_TRIG_CHAIN_TO_Msk    (0x7800UL)                /*!< CHAIN_TO (Bitfield-Mask: 0x0f)                        */
#define DMA_CH5_CTRL_TRIG_RING_SEL_Pos    (10UL)                    /*!< RING_SEL (Bit 10)                                     */
#define DMA_CH5_CTRL_TRIG_RING_SEL_Msk    (0x400UL)                 /*!< RING_SEL (Bitfield-Mask: 0x01)                        */
#define DMA_CH5_CTRL_TRIG_RING_SIZE_Pos   (6UL)                     /*!< RING_SIZE (Bit 6)                                     */
#define DMA_CH5_CTRL_TRIG_RING_SIZE_Msk   (0x3c0UL)                 /*!< RING_SIZE (Bitfield-Mask: 0x0f)                       */
#define DMA_CH5_CTRL_TRIG_INCR_WRITE_Pos  (5UL)                     /*!< INCR_WRITE (Bit 5)                                    */
#define DMA_CH5_CTRL_TRIG_INCR_WRITE_Msk  (0x20UL)                  /*!< INCR_WRITE (Bitfield-Mask: 0x01)                      */
#define DMA_CH5_CTRL_TRIG_INCR_READ_Pos   (4UL)                     /*!< INCR_READ (Bit 4)                                     */
#define DMA_CH5_CTRL_TRIG_INCR_READ_Msk   (0x10UL)                  /*!< INCR_READ (Bitfield-Mask: 0x01)                       */
#define DMA_CH5_CTRL_TRIG_DATA_SIZE_Pos   (2UL)                     /*!< DATA_SIZE (Bit 2)                                     */
#define DMA_CH5_CTRL_TRIG_DATA_SIZE_Msk   (0xcUL)                   /*!< DATA_SIZE (Bitfield-Mask: 0x03)                       */
#define DMA_CH5_CTRL_TRIG_HIGH_PRIORITY_Pos (1UL)                   /*!< HIGH_PRIORITY (Bit 1)                                 */
#define DMA_CH5_CTRL_TRIG_HIGH_PRIORITY_Msk (0x2UL)                 /*!< HIGH_PRIORITY (Bitfield-Mask: 0x01)                   */
#define DMA_CH5_CTRL_TRIG_EN_Pos          (0UL)                     /*!< EN (Bit 0)                                            */
#define DMA_CH5_CTRL_TRIG_EN_Msk          (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01)                              */
/* =====================================================  CH5_AL1_CTRL  ====================================================== */
/* ===================================================  CH5_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH5_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH5_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH5_AL2_CTRL  ====================================================== */
/* ==================================================  CH5_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH5_AL2_READ_ADDR  =================================================== */
/* ================================================  CH5_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH5_AL3_CTRL  ====================================================== */
/* ==================================================  CH5_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH5_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH5_AL3_READ_ADDR_TRIG  ================================================= */
/* =====================================================  CH6_READ_ADDR  ===================================================== */
/* ====================================================  CH6_WRITE_ADDR  ===================================================== */
/* ====================================================  CH6_TRANS_COUNT  ==================================================== */
/* =====================================================  CH6_CTRL_TRIG  ===================================================== */
#define DMA_CH6_CTRL_TRIG_AHB_ERROR_Pos   (31UL)                    /*!< AHB_ERROR (Bit 31)                                    */
#define DMA_CH6_CTRL_TRIG_AHB_ERROR_Msk   (0x80000000UL)            /*!< AHB_ERROR (Bitfield-Mask: 0x01)                       */
#define DMA_CH6_CTRL_TRIG_READ_ERROR_Pos  (30UL)                    /*!< READ_ERROR (Bit 30)                                   */
#define DMA_CH6_CTRL_TRIG_READ_ERROR_Msk  (0x40000000UL)            /*!< READ_ERROR (Bitfield-Mask: 0x01)                      */
#define DMA_CH6_CTRL_TRIG_WRITE_ERROR_Pos (29UL)                    /*!< WRITE_ERROR (Bit 29)                                  */
#define DMA_CH6_CTRL_TRIG_WRITE_ERROR_Msk (0x20000000UL)            /*!< WRITE_ERROR (Bitfield-Mask: 0x01)                     */
#define DMA_CH6_CTRL_TRIG_BUSY_Pos        (24UL)                    /*!< BUSY (Bit 24)                                         */
#define DMA_CH6_CTRL_TRIG_BUSY_Msk        (0x1000000UL)             /*!< BUSY (Bitfield-Mask: 0x01)                            */
#define DMA_CH6_CTRL_TRIG_SNIFF_EN_Pos    (23UL)                    /*!< SNIFF_EN (Bit 23)                                     */
#define DMA_CH6_CTRL_TRIG_SNIFF_EN_Msk    (0x800000UL)              /*!< SNIFF_EN (Bitfield-Mask: 0x01)                        */
#define DMA_CH6_CTRL_TRIG_BSWAP_Pos       (22UL)                    /*!< BSWAP (Bit 22)                                        */
#define DMA_CH6_CTRL_TRIG_BSWAP_Msk       (0x400000UL)              /*!< BSWAP (Bitfield-Mask: 0x01)                           */
#define DMA_CH6_CTRL_TRIG_IRQ_QUIET_Pos   (21UL)                    /*!< IRQ_QUIET (Bit 21)                                    */
#define DMA_CH6_CTRL_TRIG_IRQ_QUIET_Msk   (0x200000UL)              /*!< IRQ_QUIET (Bitfield-Mask: 0x01)                       */
#define DMA_CH6_CTRL_TRIG_TREQ_SEL_Pos    (15UL)                    /*!< TREQ_SEL (Bit 15)                                     */
#define DMA_CH6_CTRL_TRIG_TREQ_SEL_Msk    (0x1f8000UL)              /*!< TREQ_SEL (Bitfield-Mask: 0x3f)                        */
#define DMA_CH6_CTRL_TRIG_CHAIN_TO_Pos    (11UL)                    /*!< CHAIN_TO (Bit 11)                                     */
#define DMA_CH6_CTRL_TRIG_CHAIN_TO_Msk    (0x7800UL)                /*!< CHAIN_TO (Bitfield-Mask: 0x0f)                        */
#define DMA_CH6_CTRL_TRIG_RING_SEL_Pos    (10UL)                    /*!< RING_SEL (Bit 10)                                     */
#define DMA_CH6_CTRL_TRIG_RING_SEL_Msk    (0x400UL)                 /*!< RING_SEL (Bitfield-Mask: 0x01)                        */
#define DMA_CH6_CTRL_TRIG_RING_SIZE_Pos   (6UL)                     /*!< RING_SIZE (Bit 6)                                     */
#define DMA_CH6_CTRL_TRIG_RING_SIZE_Msk   (0x3c0UL)                 /*!< RING_SIZE (Bitfield-Mask: 0x0f)                       */
#define DMA_CH6_CTRL_TRIG_INCR_WRITE_Pos  (5UL)                     /*!< INCR_WRITE (Bit 5)                                    */
#define DMA_CH6_CTRL_TRIG_INCR_WRITE_Msk  (0x20UL)                  /*!< INCR_WRITE (Bitfield-Mask: 0x01)                      */
#define DMA_CH6_CTRL_TRIG_INCR_READ_Pos   (4UL)                     /*!< INCR_READ (Bit 4)                                     */
#define DMA_CH6_CTRL_TRIG_INCR_READ_Msk   (0x10UL)                  /*!< INCR_READ (Bitfield-Mask: 0x01)                       */
#define DMA_CH6_CTRL_TRIG_DATA_SIZE_Pos   (2UL)                     /*!< DATA_SIZE (Bit 2)                                     */
#define DMA_CH6_CTRL_TRIG_DATA_SIZE_Msk   (0xcUL)                   /*!< DATA_SIZE (Bitfield-Mask: 0x03)                       */
#define DMA_CH6_CTRL_TRIG_HIGH_PRIORITY_Pos (1UL)                   /*!< HIGH_PRIORITY (Bit 1)                                 */
#define DMA_CH6_CTRL_TRIG_HIGH_PRIORITY_Msk (0x2UL)                 /*!< HIGH_PRIORITY (Bitfield-Mask: 0x01)                   */
#define DMA_CH6_CTRL_TRIG_EN_Pos          (0UL)                     /*!< EN (Bit 0)                                            */
#define DMA_CH6_CTRL_TRIG_EN_Msk          (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01)                              */
/* =====================================================  CH6_AL1_CTRL  ====================================================== */
/* ===================================================  CH6_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH6_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH6_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH6_AL2_CTRL  ====================================================== */
/* ==================================================  CH6_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH6_AL2_READ_ADDR  =================================================== */
/* ================================================  CH6_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH6_AL3_CTRL  ====================================================== */
/* ==================================================  CH6_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH6_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH6_AL3_READ_ADDR_TRIG  ================================================= */
/* =====================================================  CH7_READ_ADDR  ===================================================== */
/* ====================================================  CH7_WRITE_ADDR  ===================================================== */
/* ====================================================  CH7_TRANS_COUNT  ==================================================== */
/* =====================================================  CH7_CTRL_TRIG  ===================================================== */
#define DMA_CH7_CTRL_TRIG_AHB_ERROR_Pos   (31UL)                    /*!< AHB_ERROR (Bit 31)                                    */
#define DMA_CH7_CTRL_TRIG_AHB_ERROR_Msk   (0x80000000UL)            /*!< AHB_ERROR (Bitfield-Mask: 0x01)                       */
#define DMA_CH7_CTRL_TRIG_READ_ERROR_Pos  (30UL)                    /*!< READ_ERROR (Bit 30)                                   */
#define DMA_CH7_CTRL_TRIG_READ_ERROR_Msk  (0x40000000UL)            /*!< READ_ERROR (Bitfield-Mask: 0x01)                      */
#define DMA_CH7_CTRL_TRIG_WRITE_ERROR_Pos (29UL)                    /*!< WRITE_ERROR (Bit 29)                                  */
#define DMA_CH7_CTRL_TRIG_WRITE_ERROR_Msk (0x20000000UL)            /*!< WRITE_ERROR (Bitfield-Mask: 0x01)                     */
#define DMA_CH7_CTRL_TRIG_BUSY_Pos        (24UL)                    /*!< BUSY (Bit 24)                                         */
#define DMA_CH7_CTRL_TRIG_BUSY_Msk        (0x1000000UL)             /*!< BUSY (Bitfield-Mask: 0x01)                            */
#define DMA_CH7_CTRL_TRIG_SNIFF_EN_Pos    (23UL)                    /*!< SNIFF_EN (Bit 23)                                     */
#define DMA_CH7_CTRL_TRIG_SNIFF_EN_Msk    (0x800000UL)              /*!< SNIFF_EN (Bitfield-Mask: 0x01)                        */
#define DMA_CH7_CTRL_TRIG_BSWAP_Pos       (22UL)                    /*!< BSWAP (Bit 22)                                        */
#define DMA_CH7_CTRL_TRIG_BSWAP_Msk       (0x400000UL)              /*!< BSWAP (Bitfield-Mask: 0x01)                           */
#define DMA_CH7_CTRL_TRIG_IRQ_QUIET_Pos   (21UL)                    /*!< IRQ_QUIET (Bit 21)                                    */
#define DMA_CH7_CTRL_TRIG_IRQ_QUIET_Msk   (0x200000UL)              /*!< IRQ_QUIET (Bitfield-Mask: 0x01)                       */
#define DMA_CH7_CTRL_TRIG_TREQ_SEL_Pos    (15UL)                    /*!< TREQ_SEL (Bit 15)                                     */
#define DMA_CH7_CTRL_TRIG_TREQ_SEL_Msk    (0x1f8000UL)              /*!< TREQ_SEL (Bitfield-Mask: 0x3f)                        */
#define DMA_CH7_CTRL_TRIG_CHAIN_TO_Pos    (11UL)                    /*!< CHAIN_TO (Bit 11)                                     */
#define DMA_CH7_CTRL_TRIG_CHAIN_TO_Msk    (0x7800UL)                /*!< CHAIN_TO (Bitfield-Mask: 0x0f)                        */
#define DMA_CH7_CTRL_TRIG_RING_SEL_Pos    (10UL)                    /*!< RING_SEL (Bit 10)                                     */
#define DMA_CH7_CTRL_TRIG_RING_SEL_Msk    (0x400UL)                 /*!< RING_SEL (Bitfield-Mask: 0x01)                        */
#define DMA_CH7_CTRL_TRIG_RING_SIZE_Pos   (6UL)                     /*!< RING_SIZE (Bit 6)                                     */
#define DMA_CH7_CTRL_TRIG_RING_SIZE_Msk   (0x3c0UL)                 /*!< RING_SIZE (Bitfield-Mask: 0x0f)                       */
#define DMA_CH7_CTRL_TRIG_INCR_WRITE_Pos  (5UL)                     /*!< INCR_WRITE (Bit 5)                                    */
#define DMA_CH7_CTRL_TRIG_INCR_WRITE_Msk  (0x20UL)                  /*!< INCR_WRITE (Bitfield-Mask: 0x01)                      */
#define DMA_CH7_CTRL_TRIG_INCR_READ_Pos   (4UL)                     /*!< INCR_READ (Bit 4)                                     */
#define DMA_CH7_CTRL_TRIG_INCR_READ_Msk   (0x10UL)                  /*!< INCR_READ (Bitfield-Mask: 0x01)                       */
#define DMA_CH7_CTRL_TRIG_DATA_SIZE_Pos   (2UL)                     /*!< DATA_SIZE (Bit 2)                                     */
#define DMA_CH7_CTRL_TRIG_DATA_SIZE_Msk   (0xcUL)                   /*!< DATA_SIZE (Bitfield-Mask: 0x03)                       */
#define DMA_CH7_CTRL_TRIG_HIGH_PRIORITY_Pos (1UL)                   /*!< HIGH_PRIORITY (Bit 1)                                 */
#define DMA_CH7_CTRL_TRIG_HIGH_PRIORITY_Msk (0x2UL)                 /*!< HIGH_PRIORITY (Bitfield-Mask: 0x01)                   */
#define DMA_CH7_CTRL_TRIG_EN_Pos          (0UL)                     /*!< EN (Bit 0)                                            */
#define DMA_CH7_CTRL_TRIG_EN_Msk          (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01)                              */
/* =====================================================  CH7_AL1_CTRL  ====================================================== */
/* ===================================================  CH7_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH7_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH7_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH7_AL2_CTRL  ====================================================== */
/* ==================================================  CH7_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH7_AL2_READ_ADDR  =================================================== */
/* ================================================  CH7_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH7_AL3_CTRL  ====================================================== */
/* ==================================================  CH7_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH7_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH7_AL3_READ_ADDR_TRIG  ================================================= */
/* =====================================================  CH8_READ_ADDR  ===================================================== */
/* ====================================================  CH8_WRITE_ADDR  ===================================================== */
/* ====================================================  CH8_TRANS_COUNT  ==================================================== */
/* =====================================================  CH8_CTRL_TRIG  ===================================================== */
#define DMA_CH8_CTRL_TRIG_AHB_ERROR_Pos   (31UL)                    /*!< AHB_ERROR (Bit 31)                                    */
#define DMA_CH8_CTRL_TRIG_AHB_ERROR_Msk   (0x80000000UL)            /*!< AHB_ERROR (Bitfield-Mask: 0x01)                       */
#define DMA_CH8_CTRL_TRIG_READ_ERROR_Pos  (30UL)                    /*!< READ_ERROR (Bit 30)                                   */
#define DMA_CH8_CTRL_TRIG_READ_ERROR_Msk  (0x40000000UL)            /*!< READ_ERROR (Bitfield-Mask: 0x01)                      */
#define DMA_CH8_CTRL_TRIG_WRITE_ERROR_Pos (29UL)                    /*!< WRITE_ERROR (Bit 29)                                  */
#define DMA_CH8_CTRL_TRIG_WRITE_ERROR_Msk (0x20000000UL)            /*!< WRITE_ERROR (Bitfield-Mask: 0x01)                     */
#define DMA_CH8_CTRL_TRIG_BUSY_Pos        (24UL)                    /*!< BUSY (Bit 24)                                         */
#define DMA_CH8_CTRL_TRIG_BUSY_Msk        (0x1000000UL)             /*!< BUSY (Bitfield-Mask: 0x01)                            */
#define DMA_CH8_CTRL_TRIG_SNIFF_EN_Pos    (23UL)                    /*!< SNIFF_EN (Bit 23)                                     */
#define DMA_CH8_CTRL_TRIG_SNIFF_EN_Msk    (0x800000UL)              /*!< SNIFF_EN (Bitfield-Mask: 0x01)                        */
#define DMA_CH8_CTRL_TRIG_BSWAP_Pos       (22UL)                    /*!< BSWAP (Bit 22)                                        */
#define DMA_CH8_CTRL_TRIG_BSWAP_Msk       (0x400000UL)              /*!< BSWAP (Bitfield-Mask: 0x01)                           */
#define DMA_CH8_CTRL_TRIG_IRQ_QUIET_Pos   (21UL)                    /*!< IRQ_QUIET (Bit 21)                                    */
#define DMA_CH8_CTRL_TRIG_IRQ_QUIET_Msk   (0x200000UL)              /*!< IRQ_QUIET (Bitfield-Mask: 0x01)                       */
#define DMA_CH8_CTRL_TRIG_TREQ_SEL_Pos    (15UL)                    /*!< TREQ_SEL (Bit 15)                                     */
#define DMA_CH8_CTRL_TRIG_TREQ_SEL_Msk    (0x1f8000UL)              /*!< TREQ_SEL (Bitfield-Mask: 0x3f)                        */
#define DMA_CH8_CTRL_TRIG_CHAIN_TO_Pos    (11UL)                    /*!< CHAIN_TO (Bit 11)                                     */
#define DMA_CH8_CTRL_TRIG_CHAIN_TO_Msk    (0x7800UL)                /*!< CHAIN_TO (Bitfield-Mask: 0x0f)                        */
#define DMA_CH8_CTRL_TRIG_RING_SEL_Pos    (10UL)                    /*!< RING_SEL (Bit 10)                                     */
#define DMA_CH8_CTRL_TRIG_RING_SEL_Msk    (0x400UL)                 /*!< RING_SEL (Bitfield-Mask: 0x01)                        */
#define DMA_CH8_CTRL_TRIG_RING_SIZE_Pos   (6UL)                     /*!< RING_SIZE (Bit 6)                                     */
#define DMA_CH8_CTRL_TRIG_RING_SIZE_Msk   (0x3c0UL)                 /*!< RING_SIZE (Bitfield-Mask: 0x0f)                       */
#define DMA_CH8_CTRL_TRIG_INCR_WRITE_Pos  (5UL)                     /*!< INCR_WRITE (Bit 5)                                    */
#define DMA_CH8_CTRL_TRIG_INCR_WRITE_Msk  (0x20UL)                  /*!< INCR_WRITE (Bitfield-Mask: 0x01)                      */
#define DMA_CH8_CTRL_TRIG_INCR_READ_Pos   (4UL)                     /*!< INCR_READ (Bit 4)                                     */
#define DMA_CH8_CTRL_TRIG_INCR_READ_Msk   (0x10UL)                  /*!< INCR_READ (Bitfield-Mask: 0x01)                       */
#define DMA_CH8_CTRL_TRIG_DATA_SIZE_Pos   (2UL)                     /*!< DATA_SIZE (Bit 2)                                     */
#define DMA_CH8_CTRL_TRIG_DATA_SIZE_Msk   (0xcUL)                   /*!< DATA_SIZE (Bitfield-Mask: 0x03)                       */
#define DMA_CH8_CTRL_TRIG_HIGH_PRIORITY_Pos (1UL)                   /*!< HIGH_PRIORITY (Bit 1)                                 */
#define DMA_CH8_CTRL_TRIG_HIGH_PRIORITY_Msk (0x2UL)                 /*!< HIGH_PRIORITY (Bitfield-Mask: 0x01)                   */
#define DMA_CH8_CTRL_TRIG_EN_Pos          (0UL)                     /*!< EN (Bit 0)                                            */
#define DMA_CH8_CTRL_TRIG_EN_Msk          (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01)                              */
/* =====================================================  CH8_AL1_CTRL  ====================================================== */
/* ===================================================  CH8_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH8_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH8_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH8_AL2_CTRL  ====================================================== */
/* ==================================================  CH8_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH8_AL2_READ_ADDR  =================================================== */
/* ================================================  CH8_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH8_AL3_CTRL  ====================================================== */
/* ==================================================  CH8_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH8_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH8_AL3_READ_ADDR_TRIG  ================================================= */
/* =====================================================  CH9_READ_ADDR  ===================================================== */
/* ====================================================  CH9_WRITE_ADDR  ===================================================== */
/* ====================================================  CH9_TRANS_COUNT  ==================================================== */
/* =====================================================  CH9_CTRL_TRIG  ===================================================== */
#define DMA_CH9_CTRL_TRIG_AHB_ERROR_Pos   (31UL)                    /*!< AHB_ERROR (Bit 31)                                    */
#define DMA_CH9_CTRL_TRIG_AHB_ERROR_Msk   (0x80000000UL)            /*!< AHB_ERROR (Bitfield-Mask: 0x01)                       */
#define DMA_CH9_CTRL_TRIG_READ_ERROR_Pos  (30UL)                    /*!< READ_ERROR (Bit 30)                                   */
#define DMA_CH9_CTRL_TRIG_READ_ERROR_Msk  (0x40000000UL)            /*!< READ_ERROR (Bitfield-Mask: 0x01)                      */
#define DMA_CH9_CTRL_TRIG_WRITE_ERROR_Pos (29UL)                    /*!< WRITE_ERROR (Bit 29)                                  */
#define DMA_CH9_CTRL_TRIG_WRITE_ERROR_Msk (0x20000000UL)            /*!< WRITE_ERROR (Bitfield-Mask: 0x01)                     */
#define DMA_CH9_CTRL_TRIG_BUSY_Pos        (24UL)                    /*!< BUSY (Bit 24)                                         */
#define DMA_CH9_CTRL_TRIG_BUSY_Msk        (0x1000000UL)             /*!< BUSY (Bitfield-Mask: 0x01)                            */
#define DMA_CH9_CTRL_TRIG_SNIFF_EN_Pos    (23UL)                    /*!< SNIFF_EN (Bit 23)                                     */
#define DMA_CH9_CTRL_TRIG_SNIFF_EN_Msk    (0x800000UL)              /*!< SNIFF_EN (Bitfield-Mask: 0x01)                        */
#define DMA_CH9_CTRL_TRIG_BSWAP_Pos       (22UL)                    /*!< BSWAP (Bit 22)                                        */
#define DMA_CH9_CTRL_TRIG_BSWAP_Msk       (0x400000UL)              /*!< BSWAP (Bitfield-Mask: 0x01)                           */
#define DMA_CH9_CTRL_TRIG_IRQ_QUIET_Pos   (21UL)                    /*!< IRQ_QUIET (Bit 21)                                    */
#define DMA_CH9_CTRL_TRIG_IRQ_QUIET_Msk   (0x200000UL)              /*!< IRQ_QUIET (Bitfield-Mask: 0x01)                       */
#define DMA_CH9_CTRL_TRIG_TREQ_SEL_Pos    (15UL)                    /*!< TREQ_SEL (Bit 15)                                     */
#define DMA_CH9_CTRL_TRIG_TREQ_SEL_Msk    (0x1f8000UL)              /*!< TREQ_SEL (Bitfield-Mask: 0x3f)                        */
#define DMA_CH9_CTRL_TRIG_CHAIN_TO_Pos    (11UL)                    /*!< CHAIN_TO (Bit 11)                                     */
#define DMA_CH9_CTRL_TRIG_CHAIN_TO_Msk    (0x7800UL)                /*!< CHAIN_TO (Bitfield-Mask: 0x0f)                        */
#define DMA_CH9_CTRL_TRIG_RING_SEL_Pos    (10UL)                    /*!< RING_SEL (Bit 10)                                     */
#define DMA_CH9_CTRL_TRIG_RING_SEL_Msk    (0x400UL)                 /*!< RING_SEL (Bitfield-Mask: 0x01)                        */
#define DMA_CH9_CTRL_TRIG_RING_SIZE_Pos   (6UL)                     /*!< RING_SIZE (Bit 6)                                     */
#define DMA_CH9_CTRL_TRIG_RING_SIZE_Msk   (0x3c0UL)                 /*!< RING_SIZE (Bitfield-Mask: 0x0f)                       */
#define DMA_CH9_CTRL_TRIG_INCR_WRITE_Pos  (5UL)                     /*!< INCR_WRITE (Bit 5)                                    */
#define DMA_CH9_CTRL_TRIG_INCR_WRITE_Msk  (0x20UL)                  /*!< INCR_WRITE (Bitfield-Mask: 0x01)                      */
#define DMA_CH9_CTRL_TRIG_INCR_READ_Pos   (4UL)                     /*!< INCR_READ (Bit 4)                                     */
#define DMA_CH9_CTRL_TRIG_INCR_READ_Msk   (0x10UL)                  /*!< INCR_READ (Bitfield-Mask: 0x01)                       */
#define DMA_CH9_CTRL_TRIG_DATA_SIZE_Pos   (2UL)                     /*!< DATA_SIZE (Bit 2)                                     */
#define DMA_CH9_CTRL_TRIG_DATA_SIZE_Msk   (0xcUL)                   /*!< DATA_SIZE (Bitfield-Mask: 0x03)                       */
#define DMA_CH9_CTRL_TRIG_HIGH_PRIORITY_Pos (1UL)                   /*!< HIGH_PRIORITY (Bit 1)                                 */
#define DMA_CH9_CTRL_TRIG_HIGH_PRIORITY_Msk (0x2UL)                 /*!< HIGH_PRIORITY (Bitfield-Mask: 0x01)                   */
#define DMA_CH9_CTRL_TRIG_EN_Pos          (0UL)                     /*!< EN (Bit 0)                                            */
#define DMA_CH9_CTRL_TRIG_EN_Msk          (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01)                              */
/* =====================================================  CH9_AL1_CTRL  ====================================================== */
/* ===================================================  CH9_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH9_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH9_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH9_AL2_CTRL  ====================================================== */
/* ==================================================  CH9_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH9_AL2_READ_ADDR  =================================================== */
/* ================================================  CH9_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH9_AL3_CTRL  ====================================================== */
/* ==================================================  CH9_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH9_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH9_AL3_READ_ADDR_TRIG  ================================================= */
/* ====================================================  CH10_READ_ADDR  ===================================================== */
/* ====================================================  CH10_WRITE_ADDR  ==================================================== */
/* ===================================================  CH10_TRANS_COUNT  ==================================================== */
/* ====================================================  CH10_CTRL_TRIG  ===================================================== */
#define DMA_CH10_CTRL_TRIG_AHB_ERROR_Pos  (31UL)                    /*!< AHB_ERROR (Bit 31)                                    */
#define DMA_CH10_CTRL_TRIG_AHB_ERROR_Msk  (0x80000000UL)            /*!< AHB_ERROR (Bitfield-Mask: 0x01)                       */
#define DMA_CH10_CTRL_TRIG_READ_ERROR_Pos (30UL)                    /*!< READ_ERROR (Bit 30)                                   */
#define DMA_CH10_CTRL_TRIG_READ_ERROR_Msk (0x40000000UL)            /*!< READ_ERROR (Bitfield-Mask: 0x01)                      */
#define DMA_CH10_CTRL_TRIG_WRITE_ERROR_Pos (29UL)                   /*!< WRITE_ERROR (Bit 29)                                  */
#define DMA_CH10_CTRL_TRIG_WRITE_ERROR_Msk (0x20000000UL)           /*!< WRITE_ERROR (Bitfield-Mask: 0x01)                     */
#define DMA_CH10_CTRL_TRIG_BUSY_Pos       (24UL)                    /*!< BUSY (Bit 24)                                         */
#define DMA_CH10_CTRL_TRIG_BUSY_Msk       (0x1000000UL)             /*!< BUSY (Bitfield-Mask: 0x01)                            */
#define DMA_CH10_CTRL_TRIG_SNIFF_EN_Pos   (23UL)                    /*!< SNIFF_EN (Bit 23)                                     */
#define DMA_CH10_CTRL_TRIG_SNIFF_EN_Msk   (0x800000UL)              /*!< SNIFF_EN (Bitfield-Mask: 0x01)                        */
#define DMA_CH10_CTRL_TRIG_BSWAP_Pos      (22UL)                    /*!< BSWAP (Bit 22)                                        */
#define DMA_CH10_CTRL_TRIG_BSWAP_Msk      (0x400000UL)              /*!< BSWAP (Bitfield-Mask: 0x01)                           */
#define DMA_CH10_CTRL_TRIG_IRQ_QUIET_Pos  (21UL)                    /*!< IRQ_QUIET (Bit 21)                                    */
#define DMA_CH10_CTRL_TRIG_IRQ_QUIET_Msk  (0x200000UL)              /*!< IRQ_QUIET (Bitfield-Mask: 0x01)                       */
#define DMA_CH10_CTRL_TRIG_TREQ_SEL_Pos   (15UL)                    /*!< TREQ_SEL (Bit 15)                                     */
#define DMA_CH10_CTRL_TRIG_TREQ_SEL_Msk   (0x1f8000UL)              /*!< TREQ_SEL (Bitfield-Mask: 0x3f)                        */
#define DMA_CH10_CTRL_TRIG_CHAIN_TO_Pos   (11UL)                    /*!< CHAIN_TO (Bit 11)                                     */
#define DMA_CH10_CTRL_TRIG_CHAIN_TO_Msk   (0x7800UL)                /*!< CHAIN_TO (Bitfield-Mask: 0x0f)                        */
#define DMA_CH10_CTRL_TRIG_RING_SEL_Pos   (10UL)                    /*!< RING_SEL (Bit 10)                                     */
#define DMA_CH10_CTRL_TRIG_RING_SEL_Msk   (0x400UL)                 /*!< RING_SEL (Bitfield-Mask: 0x01)                        */
#define DMA_CH10_CTRL_TRIG_RING_SIZE_Pos  (6UL)                     /*!< RING_SIZE (Bit 6)                                     */
#define DMA_CH10_CTRL_TRIG_RING_SIZE_Msk  (0x3c0UL)                 /*!< RING_SIZE (Bitfield-Mask: 0x0f)                       */
#define DMA_CH10_CTRL_TRIG_INCR_WRITE_Pos (5UL)                     /*!< INCR_WRITE (Bit 5)                                    */
#define DMA_CH10_CTRL_TRIG_INCR_WRITE_Msk (0x20UL)                  /*!< INCR_WRITE (Bitfield-Mask: 0x01)                      */
#define DMA_CH10_CTRL_TRIG_INCR_READ_Pos  (4UL)                     /*!< INCR_READ (Bit 4)                                     */
#define DMA_CH10_CTRL_TRIG_INCR_READ_Msk  (0x10UL)                  /*!< INCR_READ (Bitfield-Mask: 0x01)                       */
#define DMA_CH10_CTRL_TRIG_DATA_SIZE_Pos  (2UL)                     /*!< DATA_SIZE (Bit 2)                                     */
#define DMA_CH10_CTRL_TRIG_DATA_SIZE_Msk  (0xcUL)                   /*!< DATA_SIZE (Bitfield-Mask: 0x03)                       */
#define DMA_CH10_CTRL_TRIG_HIGH_PRIORITY_Pos (1UL)                  /*!< HIGH_PRIORITY (Bit 1)                                 */
#define DMA_CH10_CTRL_TRIG_HIGH_PRIORITY_Msk (0x2UL)                /*!< HIGH_PRIORITY (Bitfield-Mask: 0x01)                   */
#define DMA_CH10_CTRL_TRIG_EN_Pos         (0UL)                     /*!< EN (Bit 0)                                            */
#define DMA_CH10_CTRL_TRIG_EN_Msk         (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01)                              */
/* =====================================================  CH10_AL1_CTRL  ===================================================== */
/* ==================================================  CH10_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH10_AL1_WRITE_ADDR  ================================================== */
/* ===============================================  CH10_AL1_TRANS_COUNT_TRIG  =============================================== */
/* =====================================================  CH10_AL2_CTRL  ===================================================== */
/* =================================================  CH10_AL2_TRANS_COUNT  ================================================== */
/* ==================================================  CH10_AL2_READ_ADDR  =================================================== */
/* ===============================================  CH10_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH10_AL3_CTRL  ===================================================== */
/* ==================================================  CH10_AL3_WRITE_ADDR  ================================================== */
/* =================================================  CH10_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH10_AL3_READ_ADDR_TRIG  ================================================ */
/* ====================================================  CH11_READ_ADDR  ===================================================== */
/* ====================================================  CH11_WRITE_ADDR  ==================================================== */
/* ===================================================  CH11_TRANS_COUNT  ==================================================== */
/* ====================================================  CH11_CTRL_TRIG  ===================================================== */
#define DMA_CH11_CTRL_TRIG_AHB_ERROR_Pos  (31UL)                    /*!< AHB_ERROR (Bit 31)                                    */
#define DMA_CH11_CTRL_TRIG_AHB_ERROR_Msk  (0x80000000UL)            /*!< AHB_ERROR (Bitfield-Mask: 0x01)                       */
#define DMA_CH11_CTRL_TRIG_READ_ERROR_Pos (30UL)                    /*!< READ_ERROR (Bit 30)                                   */
#define DMA_CH11_CTRL_TRIG_READ_ERROR_Msk (0x40000000UL)            /*!< READ_ERROR (Bitfield-Mask: 0x01)                      */
#define DMA_CH11_CTRL_TRIG_WRITE_ERROR_Pos (29UL)                   /*!< WRITE_ERROR (Bit 29)                                  */
#define DMA_CH11_CTRL_TRIG_WRITE_ERROR_Msk (0x20000000UL)           /*!< WRITE_ERROR (Bitfield-Mask: 0x01)                     */
#define DMA_CH11_CTRL_TRIG_BUSY_Pos       (24UL)                    /*!< BUSY (Bit 24)                                         */
#define DMA_CH11_CTRL_TRIG_BUSY_Msk       (0x1000000UL)             /*!< BUSY (Bitfield-Mask: 0x01)                            */
#define DMA_CH11_CTRL_TRIG_SNIFF_EN_Pos   (23UL)                    /*!< SNIFF_EN (Bit 23)                                     */
#define DMA_CH11_CTRL_TRIG_SNIFF_EN_Msk   (0x800000UL)              /*!< SNIFF_EN (Bitfield-Mask: 0x01)                        */
#define DMA_CH11_CTRL_TRIG_BSWAP_Pos      (22UL)                    /*!< BSWAP (Bit 22)                                        */
#define DMA_CH11_CTRL_TRIG_BSWAP_Msk      (0x400000UL)              /*!< BSWAP (Bitfield-Mask: 0x01)                           */
#define DMA_CH11_CTRL_TRIG_IRQ_QUIET_Pos  (21UL)                    /*!< IRQ_QUIET (Bit 21)                                    */
#define DMA_CH11_CTRL_TRIG_IRQ_QUIET_Msk  (0x200000UL)              /*!< IRQ_QUIET (Bitfield-Mask: 0x01)                       */
#define DMA_CH11_CTRL_TRIG_TREQ_SEL_Pos   (15UL)                    /*!< TREQ_SEL (Bit 15)                                     */
#define DMA_CH11_CTRL_TRIG_TREQ_SEL_Msk   (0x1f8000UL)              /*!< TREQ_SEL (Bitfield-Mask: 0x3f)                        */
#define DMA_CH11_CTRL_TRIG_CHAIN_TO_Pos   (11UL)                    /*!< CHAIN_TO (Bit 11)                                     */
#define DMA_CH11_CTRL_TRIG_CHAIN_TO_Msk   (0x7800UL)                /*!< CHAIN_TO (Bitfield-Mask: 0x0f)                        */
#define DMA_CH11_CTRL_TRIG_RING_SEL_Pos   (10UL)                    /*!< RING_SEL (Bit 10)                                     */
#define DMA_CH11_CTRL_TRIG_RING_SEL_Msk   (0x400UL)                 /*!< RING_SEL (Bitfield-Mask: 0x01)                        */
#define DMA_CH11_CTRL_TRIG_RING_SIZE_Pos  (6UL)                     /*!< RING_SIZE (Bit 6)                                     */
#define DMA_CH11_CTRL_TRIG_RING_SIZE_Msk  (0x3c0UL)                 /*!< RING_SIZE (Bitfield-Mask: 0x0f)                       */
#define DMA_CH11_CTRL_TRIG_INCR_WRITE_Pos (5UL)                     /*!< INCR_WRITE (Bit 5)                                    */
#define DMA_CH11_CTRL_TRIG_INCR_WRITE_Msk (0x20UL)                  /*!< INCR_WRITE (Bitfield-Mask: 0x01)                      */
#define DMA_CH11_CTRL_TRIG_INCR_READ_Pos  (4UL)                     /*!< INCR_READ (Bit 4)                                     */
#define DMA_CH11_CTRL_TRIG_INCR_READ_Msk  (0x10UL)                  /*!< INCR_READ (Bitfield-Mask: 0x01)                       */
#define DMA_CH11_CTRL_TRIG_DATA_SIZE_Pos  (2UL)                     /*!< DATA_SIZE (Bit 2)                                     */
#define DMA_CH11_CTRL_TRIG_DATA_SIZE_Msk  (0xcUL)                   /*!< DATA_SIZE (Bitfield-Mask: 0x03)                       */
#define DMA_CH11_CTRL_TRIG_HIGH_PRIORITY_Pos (1UL)                  /*!< HIGH_PRIORITY (Bit 1)                                 */
#define DMA_CH11_CTRL_TRIG_HIGH_PRIORITY_Msk (0x2UL)                /*!< HIGH_PRIORITY (Bitfield-Mask: 0x01)                   */
#define DMA_CH11_CTRL_TRIG_EN_Pos         (0UL)                     /*!< EN (Bit 0)                                            */
#define DMA_CH11_CTRL_TRIG_EN_Msk         (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01)                              */
/* =====================================================  CH11_AL1_CTRL  ===================================================== */
/* ==================================================  CH11_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH11_AL1_WRITE_ADDR  ================================================== */
/* ===============================================  CH11_AL1_TRANS_COUNT_TRIG  =============================================== */
/* =====================================================  CH11_AL2_CTRL  ===================================================== */
/* =================================================  CH11_AL2_TRANS_COUNT  ================================================== */
/* ==================================================  CH11_AL2_READ_ADDR  =================================================== */
/* ===============================================  CH11_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH11_AL3_CTRL  ===================================================== */
/* ==================================================  CH11_AL3_WRITE_ADDR  ================================================== */
/* =================================================  CH11_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH11_AL3_READ_ADDR_TRIG  ================================================ */
/* =========================================================  INTR  ========================================================== */
#define DMA_INTR_INTR_Pos                 (0UL)                     /*!< INTR (Bit 0)                                          */
#define DMA_INTR_INTR_Msk                 (0xffffUL)                /*!< INTR (Bitfield-Mask: 0xffff)                          */
/* =========================================================  INTE0  ========================================================= */
#define DMA_INTE0_INTE0_Pos               (0UL)                     /*!< INTE0 (Bit 0)                                         */
#define DMA_INTE0_INTE0_Msk               (0xffffUL)                /*!< INTE0 (Bitfield-Mask: 0xffff)                         */
/* =========================================================  INTF0  ========================================================= */
#define DMA_INTF0_INTF0_Pos               (0UL)                     /*!< INTF0 (Bit 0)                                         */
#define DMA_INTF0_INTF0_Msk               (0xffffUL)                /*!< INTF0 (Bitfield-Mask: 0xffff)                         */
/* =========================================================  INTS0  ========================================================= */
#define DMA_INTS0_INTS0_Pos               (0UL)                     /*!< INTS0 (Bit 0)                                         */
#define DMA_INTS0_INTS0_Msk               (0xffffUL)                /*!< INTS0 (Bitfield-Mask: 0xffff)                         */
/* =========================================================  INTE1  ========================================================= */
#define DMA_INTE1_INTE1_Pos               (0UL)                     /*!< INTE1 (Bit 0)                                         */
#define DMA_INTE1_INTE1_Msk               (0xffffUL)                /*!< INTE1 (Bitfield-Mask: 0xffff)                         */
/* =========================================================  INTF1  ========================================================= */
#define DMA_INTF1_INTF1_Pos               (0UL)                     /*!< INTF1 (Bit 0)                                         */
#define DMA_INTF1_INTF1_Msk               (0xffffUL)                /*!< INTF1 (Bitfield-Mask: 0xffff)                         */
/* =========================================================  INTS1  ========================================================= */
#define DMA_INTS1_INTS1_Pos               (0UL)                     /*!< INTS1 (Bit 0)                                         */
#define DMA_INTS1_INTS1_Msk               (0xffffUL)                /*!< INTS1 (Bitfield-Mask: 0xffff)                         */
/* ========================================================  TIMER0  ========================================================= */
#define DMA_TIMER0_X_Pos                  (16UL)                    /*!< X (Bit 16)                                            */
#define DMA_TIMER0_X_Msk                  (0xffff0000UL)            /*!< X (Bitfield-Mask: 0xffff)                             */
#define DMA_TIMER0_Y_Pos                  (0UL)                     /*!< Y (Bit 0)                                             */
#define DMA_TIMER0_Y_Msk                  (0xffffUL)                /*!< Y (Bitfield-Mask: 0xffff)                             */
/* ========================================================  TIMER1  ========================================================= */
#define DMA_TIMER1_X_Pos                  (16UL)                    /*!< X (Bit 16)                                            */
#define DMA_TIMER1_X_Msk                  (0xffff0000UL)            /*!< X (Bitfield-Mask: 0xffff)                             */
#define DMA_TIMER1_Y_Pos                  (0UL)                     /*!< Y (Bit 0)                                             */
#define DMA_TIMER1_Y_Msk                  (0xffffUL)                /*!< Y (Bitfield-Mask: 0xffff)                             */
/* ==================================================  MULTI_CHAN_TRIGGER  =================================================== */
#define DMA_MULTI_CHAN_TRIGGER_MULTI_CHAN_TRIGGER_Pos (0UL)         /*!< MULTI_CHAN_TRIGGER (Bit 0)                            */
#define DMA_MULTI_CHAN_TRIGGER_MULTI_CHAN_TRIGGER_Msk (0xffffUL)    /*!< MULTI_CHAN_TRIGGER (Bitfield-Mask: 0xffff)            */
/* ======================================================  SNIFF_CTRL  ======================================================= */
#define DMA_SNIFF_CTRL_OUT_INV_Pos        (11UL)                    /*!< OUT_INV (Bit 11)                                      */
#define DMA_SNIFF_CTRL_OUT_INV_Msk        (0x800UL)                 /*!< OUT_INV (Bitfield-Mask: 0x01)                         */
#define DMA_SNIFF_CTRL_OUT_REV_Pos        (10UL)                    /*!< OUT_REV (Bit 10)                                      */
#define DMA_SNIFF_CTRL_OUT_REV_Msk        (0x400UL)                 /*!< OUT_REV (Bitfield-Mask: 0x01)                         */
#define DMA_SNIFF_CTRL_BSWAP_Pos          (9UL)                     /*!< BSWAP (Bit 9)                                         */
#define DMA_SNIFF_CTRL_BSWAP_Msk          (0x200UL)                 /*!< BSWAP (Bitfield-Mask: 0x01)                           */
#define DMA_SNIFF_CTRL_CALC_Pos           (5UL)                     /*!< CALC (Bit 5)                                          */
#define DMA_SNIFF_CTRL_CALC_Msk           (0x1e0UL)                 /*!< CALC (Bitfield-Mask: 0x0f)                            */
#define DMA_SNIFF_CTRL_DMACH_Pos          (1UL)                     /*!< DMACH (Bit 1)                                         */
#define DMA_SNIFF_CTRL_DMACH_Msk          (0x1eUL)                  /*!< DMACH (Bitfield-Mask: 0x0f)                           */
#define DMA_SNIFF_CTRL_EN_Pos             (0UL)                     /*!< EN (Bit 0)                                            */
#define DMA_SNIFF_CTRL_EN_Msk             (0x1UL)                   /*!< EN (Bitfield-Mask: 0x01)                              */
/* ======================================================  SNIFF_DATA  ======================================================= */
/* ======================================================  FIFO_LEVELS  ====================================================== */
#define DMA_FIFO_LEVELS_RAF_LVL_Pos       (16UL)                    /*!< RAF_LVL (Bit 16)                                      */
#define DMA_FIFO_LEVELS_RAF_LVL_Msk       (0xff0000UL)              /*!< RAF_LVL (Bitfield-Mask: 0xff)                         */
#define DMA_FIFO_LEVELS_WAF_LVL_Pos       (8UL)                     /*!< WAF_LVL (Bit 8)                                       */
#define DMA_FIFO_LEVELS_WAF_LVL_Msk       (0xff00UL)                /*!< WAF_LVL (Bitfield-Mask: 0xff)                         */
#define DMA_FIFO_LEVELS_TDF_LVL_Pos       (0UL)                     /*!< TDF_LVL (Bit 0)                                       */
#define DMA_FIFO_LEVELS_TDF_LVL_Msk       (0xffUL)                  /*!< TDF_LVL (Bitfield-Mask: 0xff)                         */
/* ======================================================  CHAN_ABORT  ======================================================= */
#define DMA_CHAN_ABORT_CHAN_ABORT_Pos     (0UL)                     /*!< CHAN_ABORT (Bit 0)                                    */
#define DMA_CHAN_ABORT_CHAN_ABORT_Msk     (0xffffUL)                /*!< CHAN_ABORT (Bitfield-Mask: 0xffff)                    */
/* ======================================================  N_CHANNELS  ======================================================= */
#define DMA_N_CHANNELS_N_CHANNELS_Pos     (0UL)                     /*!< N_CHANNELS (Bit 0)                                    */
#define DMA_N_CHANNELS_N_CHANNELS_Msk     (0x1fUL)                  /*!< N_CHANNELS (Bitfield-Mask: 0x1f)                      */
/* ====================================================  CH0_DBG_CTDREQ  ===================================================== */
#define DMA_CH0_DBG_CTDREQ_CH0_DBG_CTDREQ_Pos (0UL)                 /*!< CH0_DBG_CTDREQ (Bit 0)                                */
#define DMA_CH0_DBG_CTDREQ_CH0_DBG_CTDREQ_Msk (0x3fUL)              /*!< CH0_DBG_CTDREQ (Bitfield-Mask: 0x3f)                  */
/* ======================================================  CH0_DBG_TCR  ====================================================== */
/* ====================================================  CH1_DBG_CTDREQ  ===================================================== */
#define DMA_CH1_DBG_CTDREQ_CH1_DBG_CTDREQ_Pos (0UL)                 /*!< CH1_DBG_CTDREQ (Bit 0)                                */
#define DMA_CH1_DBG_CTDREQ_CH1_DBG_CTDREQ_Msk (0x3fUL)              /*!< CH1_DBG_CTDREQ (Bitfield-Mask: 0x3f)                  */
/* ======================================================  CH1_DBG_TCR  ====================================================== */
/* ====================================================  CH2_DBG_CTDREQ  ===================================================== */
#define DMA_CH2_DBG_CTDREQ_CH2_DBG_CTDREQ_Pos (0UL)                 /*!< CH2_DBG_CTDREQ (Bit 0)                                */
#define DMA_CH2_DBG_CTDREQ_CH2_DBG_CTDREQ_Msk (0x3fUL)              /*!< CH2_DBG_CTDREQ (Bitfield-Mask: 0x3f)                  */
/* ======================================================  CH2_DBG_TCR  ====================================================== */
/* ====================================================  CH3_DBG_CTDREQ  ===================================================== */
#define DMA_CH3_DBG_CTDREQ_CH3_DBG_CTDREQ_Pos (0UL)                 /*!< CH3_DBG_CTDREQ (Bit 0)                                */
#define DMA_CH3_DBG_CTDREQ_CH3_DBG_CTDREQ_Msk (0x3fUL)              /*!< CH3_DBG_CTDREQ (Bitfield-Mask: 0x3f)                  */
/* ======================================================  CH3_DBG_TCR  ====================================================== */
/* ====================================================  CH4_DBG_CTDREQ  ===================================================== */
#define DMA_CH4_DBG_CTDREQ_CH4_DBG_CTDREQ_Pos (0UL)                 /*!< CH4_DBG_CTDREQ (Bit 0)                                */
#define DMA_CH4_DBG_CTDREQ_CH4_DBG_CTDREQ_Msk (0x3fUL)              /*!< CH4_DBG_CTDREQ (Bitfield-Mask: 0x3f)                  */
/* ======================================================  CH4_DBG_TCR  ====================================================== */
/* ====================================================  CH5_DBG_CTDREQ  ===================================================== */
#define DMA_CH5_DBG_CTDREQ_CH5_DBG_CTDREQ_Pos (0UL)                 /*!< CH5_DBG_CTDREQ (Bit 0)                                */
#define DMA_CH5_DBG_CTDREQ_CH5_DBG_CTDREQ_Msk (0x3fUL)              /*!< CH5_DBG_CTDREQ (Bitfield-Mask: 0x3f)                  */
/* ======================================================  CH5_DBG_TCR  ====================================================== */
/* ====================================================  CH6_DBG_CTDREQ  ===================================================== */
#define DMA_CH6_DBG_CTDREQ_CH6_DBG_CTDREQ_Pos (0UL)                 /*!< CH6_DBG_CTDREQ (Bit 0)                                */
#define DMA_CH6_DBG_CTDREQ_CH6_DBG_CTDREQ_Msk (0x3fUL)              /*!< CH6_DBG_CTDREQ (Bitfield-Mask: 0x3f)                  */
/* ======================================================  CH6_DBG_TCR  ====================================================== */
/* ====================================================  CH7_DBG_CTDREQ  ===================================================== */
#define DMA_CH7_DBG_CTDREQ_CH7_DBG_CTDREQ_Pos (0UL)                 /*!< CH7_DBG_CTDREQ (Bit 0)                                */
#define DMA_CH7_DBG_CTDREQ_CH7_DBG_CTDREQ_Msk (0x3fUL)              /*!< CH7_DBG_CTDREQ (Bitfield-Mask: 0x3f)                  */
/* ======================================================  CH7_DBG_TCR  ====================================================== */
/* ====================================================  CH8_DBG_CTDREQ  ===================================================== */
#define DMA_CH8_DBG_CTDREQ_CH8_DBG_CTDREQ_Pos (0UL)                 /*!< CH8_DBG_CTDREQ (Bit 0)                                */
#define DMA_CH8_DBG_CTDREQ_CH8_DBG_CTDREQ_Msk (0x3fUL)              /*!< CH8_DBG_CTDREQ (Bitfield-Mask: 0x3f)                  */
/* ======================================================  CH8_DBG_TCR  ====================================================== */
/* ====================================================  CH9_DBG_CTDREQ  ===================================================== */
#define DMA_CH9_DBG_CTDREQ_CH9_DBG_CTDREQ_Pos (0UL)                 /*!< CH9_DBG_CTDREQ (Bit 0)                                */
#define DMA_CH9_DBG_CTDREQ_CH9_DBG_CTDREQ_Msk (0x3fUL)              /*!< CH9_DBG_CTDREQ (Bitfield-Mask: 0x3f)                  */
/* ======================================================  CH9_DBG_TCR  ====================================================== */
/* ====================================================  CH10_DBG_CTDREQ  ==================================================== */
#define DMA_CH10_DBG_CTDREQ_CH10_DBG_CTDREQ_Pos (0UL)               /*!< CH10_DBG_CTDREQ (Bit 0)                               */
#define DMA_CH10_DBG_CTDREQ_CH10_DBG_CTDREQ_Msk (0x3fUL)            /*!< CH10_DBG_CTDREQ (Bitfield-Mask: 0x3f)                 */
/* =====================================================  CH10_DBG_TCR  ====================================================== */
/* ====================================================  CH11_DBG_CTDREQ  ==================================================== */
#define DMA_CH11_DBG_CTDREQ_CH11_DBG_CTDREQ_Pos (0UL)               /*!< CH11_DBG_CTDREQ (Bit 0)                               */
#define DMA_CH11_DBG_CTDREQ_CH11_DBG_CTDREQ_Msk (0x3fUL)            /*!< CH11_DBG_CTDREQ (Bitfield-Mask: 0x3f)                 */
/* =====================================================  CH11_DBG_TCR  ====================================================== */


/* =========================================================================================================================== */
/* ================                                       USBCTRL_REGS                                        ================ */
/* =========================================================================================================================== */

/* =======================================================  ADDR_ENDP  ======================================================= */
#define USBCTRL_REGS_ADDR_ENDP_ENDPOINT_Pos (16UL)                  /*!< ENDPOINT (Bit 16)                                     */
#define USBCTRL_REGS_ADDR_ENDP_ENDPOINT_Msk (0xf0000UL)             /*!< ENDPOINT (Bitfield-Mask: 0x0f)                        */
#define USBCTRL_REGS_ADDR_ENDP_ADDRESS_Pos (0UL)                    /*!< ADDRESS (Bit 0)                                       */
#define USBCTRL_REGS_ADDR_ENDP_ADDRESS_Msk (0x7fUL)                 /*!< ADDRESS (Bitfield-Mask: 0x7f)                         */
/* ======================================================  ADDR_ENDP1  ======================================================= */
#define USBCTRL_REGS_ADDR_ENDP1_INTEP_PREAMBLE_Pos (26UL)           /*!< INTEP_PREAMBLE (Bit 26)                               */
#define USBCTRL_REGS_ADDR_ENDP1_INTEP_PREAMBLE_Msk (0x4000000UL)    /*!< INTEP_PREAMBLE (Bitfield-Mask: 0x01)                  */
#define USBCTRL_REGS_ADDR_ENDP1_INTEP_DIR_Pos (25UL)                /*!< INTEP_DIR (Bit 25)                                    */
#define USBCTRL_REGS_ADDR_ENDP1_INTEP_DIR_Msk (0x2000000UL)         /*!< INTEP_DIR (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_ADDR_ENDP1_ENDPOINT_Pos (16UL)                 /*!< ENDPOINT (Bit 16)                                     */
#define USBCTRL_REGS_ADDR_ENDP1_ENDPOINT_Msk (0xf0000UL)            /*!< ENDPOINT (Bitfield-Mask: 0x0f)                        */
#define USBCTRL_REGS_ADDR_ENDP1_ADDRESS_Pos (0UL)                   /*!< ADDRESS (Bit 0)                                       */
#define USBCTRL_REGS_ADDR_ENDP1_ADDRESS_Msk (0x7fUL)                /*!< ADDRESS (Bitfield-Mask: 0x7f)                         */
/* ======================================================  ADDR_ENDP2  ======================================================= */
#define USBCTRL_REGS_ADDR_ENDP2_INTEP_PREAMBLE_Pos (26UL)           /*!< INTEP_PREAMBLE (Bit 26)                               */
#define USBCTRL_REGS_ADDR_ENDP2_INTEP_PREAMBLE_Msk (0x4000000UL)    /*!< INTEP_PREAMBLE (Bitfield-Mask: 0x01)                  */
#define USBCTRL_REGS_ADDR_ENDP2_INTEP_DIR_Pos (25UL)                /*!< INTEP_DIR (Bit 25)                                    */
#define USBCTRL_REGS_ADDR_ENDP2_INTEP_DIR_Msk (0x2000000UL)         /*!< INTEP_DIR (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_ADDR_ENDP2_ENDPOINT_Pos (16UL)                 /*!< ENDPOINT (Bit 16)                                     */
#define USBCTRL_REGS_ADDR_ENDP2_ENDPOINT_Msk (0xf0000UL)            /*!< ENDPOINT (Bitfield-Mask: 0x0f)                        */
#define USBCTRL_REGS_ADDR_ENDP2_ADDRESS_Pos (0UL)                   /*!< ADDRESS (Bit 0)                                       */
#define USBCTRL_REGS_ADDR_ENDP2_ADDRESS_Msk (0x7fUL)                /*!< ADDRESS (Bitfield-Mask: 0x7f)                         */
/* ======================================================  ADDR_ENDP3  ======================================================= */
#define USBCTRL_REGS_ADDR_ENDP3_INTEP_PREAMBLE_Pos (26UL)           /*!< INTEP_PREAMBLE (Bit 26)                               */
#define USBCTRL_REGS_ADDR_ENDP3_INTEP_PREAMBLE_Msk (0x4000000UL)    /*!< INTEP_PREAMBLE (Bitfield-Mask: 0x01)                  */
#define USBCTRL_REGS_ADDR_ENDP3_INTEP_DIR_Pos (25UL)                /*!< INTEP_DIR (Bit 25)                                    */
#define USBCTRL_REGS_ADDR_ENDP3_INTEP_DIR_Msk (0x2000000UL)         /*!< INTEP_DIR (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_ADDR_ENDP3_ENDPOINT_Pos (16UL)                 /*!< ENDPOINT (Bit 16)                                     */
#define USBCTRL_REGS_ADDR_ENDP3_ENDPOINT_Msk (0xf0000UL)            /*!< ENDPOINT (Bitfield-Mask: 0x0f)                        */
#define USBCTRL_REGS_ADDR_ENDP3_ADDRESS_Pos (0UL)                   /*!< ADDRESS (Bit 0)                                       */
#define USBCTRL_REGS_ADDR_ENDP3_ADDRESS_Msk (0x7fUL)                /*!< ADDRESS (Bitfield-Mask: 0x7f)                         */
/* ======================================================  ADDR_ENDP4  ======================================================= */
#define USBCTRL_REGS_ADDR_ENDP4_INTEP_PREAMBLE_Pos (26UL)           /*!< INTEP_PREAMBLE (Bit 26)                               */
#define USBCTRL_REGS_ADDR_ENDP4_INTEP_PREAMBLE_Msk (0x4000000UL)    /*!< INTEP_PREAMBLE (Bitfield-Mask: 0x01)                  */
#define USBCTRL_REGS_ADDR_ENDP4_INTEP_DIR_Pos (25UL)                /*!< INTEP_DIR (Bit 25)                                    */
#define USBCTRL_REGS_ADDR_ENDP4_INTEP_DIR_Msk (0x2000000UL)         /*!< INTEP_DIR (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_ADDR_ENDP4_ENDPOINT_Pos (16UL)                 /*!< ENDPOINT (Bit 16)                                     */
#define USBCTRL_REGS_ADDR_ENDP4_ENDPOINT_Msk (0xf0000UL)            /*!< ENDPOINT (Bitfield-Mask: 0x0f)                        */
#define USBCTRL_REGS_ADDR_ENDP4_ADDRESS_Pos (0UL)                   /*!< ADDRESS (Bit 0)                                       */
#define USBCTRL_REGS_ADDR_ENDP4_ADDRESS_Msk (0x7fUL)                /*!< ADDRESS (Bitfield-Mask: 0x7f)                         */
/* ======================================================  ADDR_ENDP5  ======================================================= */
#define USBCTRL_REGS_ADDR_ENDP5_INTEP_PREAMBLE_Pos (26UL)           /*!< INTEP_PREAMBLE (Bit 26)                               */
#define USBCTRL_REGS_ADDR_ENDP5_INTEP_PREAMBLE_Msk (0x4000000UL)    /*!< INTEP_PREAMBLE (Bitfield-Mask: 0x01)                  */
#define USBCTRL_REGS_ADDR_ENDP5_INTEP_DIR_Pos (25UL)                /*!< INTEP_DIR (Bit 25)                                    */
#define USBCTRL_REGS_ADDR_ENDP5_INTEP_DIR_Msk (0x2000000UL)         /*!< INTEP_DIR (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_ADDR_ENDP5_ENDPOINT_Pos (16UL)                 /*!< ENDPOINT (Bit 16)                                     */
#define USBCTRL_REGS_ADDR_ENDP5_ENDPOINT_Msk (0xf0000UL)            /*!< ENDPOINT (Bitfield-Mask: 0x0f)                        */
#define USBCTRL_REGS_ADDR_ENDP5_ADDRESS_Pos (0UL)                   /*!< ADDRESS (Bit 0)                                       */
#define USBCTRL_REGS_ADDR_ENDP5_ADDRESS_Msk (0x7fUL)                /*!< ADDRESS (Bitfield-Mask: 0x7f)                         */
/* ======================================================  ADDR_ENDP6  ======================================================= */
#define USBCTRL_REGS_ADDR_ENDP6_INTEP_PREAMBLE_Pos (26UL)           /*!< INTEP_PREAMBLE (Bit 26)                               */
#define USBCTRL_REGS_ADDR_ENDP6_INTEP_PREAMBLE_Msk (0x4000000UL)    /*!< INTEP_PREAMBLE (Bitfield-Mask: 0x01)                  */
#define USBCTRL_REGS_ADDR_ENDP6_INTEP_DIR_Pos (25UL)                /*!< INTEP_DIR (Bit 25)                                    */
#define USBCTRL_REGS_ADDR_ENDP6_INTEP_DIR_Msk (0x2000000UL)         /*!< INTEP_DIR (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_ADDR_ENDP6_ENDPOINT_Pos (16UL)                 /*!< ENDPOINT (Bit 16)                                     */
#define USBCTRL_REGS_ADDR_ENDP6_ENDPOINT_Msk (0xf0000UL)            /*!< ENDPOINT (Bitfield-Mask: 0x0f)                        */
#define USBCTRL_REGS_ADDR_ENDP6_ADDRESS_Pos (0UL)                   /*!< ADDRESS (Bit 0)                                       */
#define USBCTRL_REGS_ADDR_ENDP6_ADDRESS_Msk (0x7fUL)                /*!< ADDRESS (Bitfield-Mask: 0x7f)                         */
/* ======================================================  ADDR_ENDP7  ======================================================= */
#define USBCTRL_REGS_ADDR_ENDP7_INTEP_PREAMBLE_Pos (26UL)           /*!< INTEP_PREAMBLE (Bit 26)                               */
#define USBCTRL_REGS_ADDR_ENDP7_INTEP_PREAMBLE_Msk (0x4000000UL)    /*!< INTEP_PREAMBLE (Bitfield-Mask: 0x01)                  */
#define USBCTRL_REGS_ADDR_ENDP7_INTEP_DIR_Pos (25UL)                /*!< INTEP_DIR (Bit 25)                                    */
#define USBCTRL_REGS_ADDR_ENDP7_INTEP_DIR_Msk (0x2000000UL)         /*!< INTEP_DIR (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_ADDR_ENDP7_ENDPOINT_Pos (16UL)                 /*!< ENDPOINT (Bit 16)                                     */
#define USBCTRL_REGS_ADDR_ENDP7_ENDPOINT_Msk (0xf0000UL)            /*!< ENDPOINT (Bitfield-Mask: 0x0f)                        */
#define USBCTRL_REGS_ADDR_ENDP7_ADDRESS_Pos (0UL)                   /*!< ADDRESS (Bit 0)                                       */
#define USBCTRL_REGS_ADDR_ENDP7_ADDRESS_Msk (0x7fUL)                /*!< ADDRESS (Bitfield-Mask: 0x7f)                         */
/* ======================================================  ADDR_ENDP8  ======================================================= */
#define USBCTRL_REGS_ADDR_ENDP8_INTEP_PREAMBLE_Pos (26UL)           /*!< INTEP_PREAMBLE (Bit 26)                               */
#define USBCTRL_REGS_ADDR_ENDP8_INTEP_PREAMBLE_Msk (0x4000000UL)    /*!< INTEP_PREAMBLE (Bitfield-Mask: 0x01)                  */
#define USBCTRL_REGS_ADDR_ENDP8_INTEP_DIR_Pos (25UL)                /*!< INTEP_DIR (Bit 25)                                    */
#define USBCTRL_REGS_ADDR_ENDP8_INTEP_DIR_Msk (0x2000000UL)         /*!< INTEP_DIR (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_ADDR_ENDP8_ENDPOINT_Pos (16UL)                 /*!< ENDPOINT (Bit 16)                                     */
#define USBCTRL_REGS_ADDR_ENDP8_ENDPOINT_Msk (0xf0000UL)            /*!< ENDPOINT (Bitfield-Mask: 0x0f)                        */
#define USBCTRL_REGS_ADDR_ENDP8_ADDRESS_Pos (0UL)                   /*!< ADDRESS (Bit 0)                                       */
#define USBCTRL_REGS_ADDR_ENDP8_ADDRESS_Msk (0x7fUL)                /*!< ADDRESS (Bitfield-Mask: 0x7f)                         */
/* ======================================================  ADDR_ENDP9  ======================================================= */
#define USBCTRL_REGS_ADDR_ENDP9_INTEP_PREAMBLE_Pos (26UL)           /*!< INTEP_PREAMBLE (Bit 26)                               */
#define USBCTRL_REGS_ADDR_ENDP9_INTEP_PREAMBLE_Msk (0x4000000UL)    /*!< INTEP_PREAMBLE (Bitfield-Mask: 0x01)                  */
#define USBCTRL_REGS_ADDR_ENDP9_INTEP_DIR_Pos (25UL)                /*!< INTEP_DIR (Bit 25)                                    */
#define USBCTRL_REGS_ADDR_ENDP9_INTEP_DIR_Msk (0x2000000UL)         /*!< INTEP_DIR (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_ADDR_ENDP9_ENDPOINT_Pos (16UL)                 /*!< ENDPOINT (Bit 16)                                     */
#define USBCTRL_REGS_ADDR_ENDP9_ENDPOINT_Msk (0xf0000UL)            /*!< ENDPOINT (Bitfield-Mask: 0x0f)                        */
#define USBCTRL_REGS_ADDR_ENDP9_ADDRESS_Pos (0UL)                   /*!< ADDRESS (Bit 0)                                       */
#define USBCTRL_REGS_ADDR_ENDP9_ADDRESS_Msk (0x7fUL)                /*!< ADDRESS (Bitfield-Mask: 0x7f)                         */
/* ======================================================  ADDR_ENDP10  ====================================================== */
#define USBCTRL_REGS_ADDR_ENDP10_INTEP_PREAMBLE_Pos (26UL)          /*!< INTEP_PREAMBLE (Bit 26)                               */
#define USBCTRL_REGS_ADDR_ENDP10_INTEP_PREAMBLE_Msk (0x4000000UL)   /*!< INTEP_PREAMBLE (Bitfield-Mask: 0x01)                  */
#define USBCTRL_REGS_ADDR_ENDP10_INTEP_DIR_Pos (25UL)               /*!< INTEP_DIR (Bit 25)                                    */
#define USBCTRL_REGS_ADDR_ENDP10_INTEP_DIR_Msk (0x2000000UL)        /*!< INTEP_DIR (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_ADDR_ENDP10_ENDPOINT_Pos (16UL)                /*!< ENDPOINT (Bit 16)                                     */
#define USBCTRL_REGS_ADDR_ENDP10_ENDPOINT_Msk (0xf0000UL)           /*!< ENDPOINT (Bitfield-Mask: 0x0f)                        */
#define USBCTRL_REGS_ADDR_ENDP10_ADDRESS_Pos (0UL)                  /*!< ADDRESS (Bit 0)                                       */
#define USBCTRL_REGS_ADDR_ENDP10_ADDRESS_Msk (0x7fUL)               /*!< ADDRESS (Bitfield-Mask: 0x7f)                         */
/* ======================================================  ADDR_ENDP11  ====================================================== */
#define USBCTRL_REGS_ADDR_ENDP11_INTEP_PREAMBLE_Pos (26UL)          /*!< INTEP_PREAMBLE (Bit 26)                               */
#define USBCTRL_REGS_ADDR_ENDP11_INTEP_PREAMBLE_Msk (0x4000000UL)   /*!< INTEP_PREAMBLE (Bitfield-Mask: 0x01)                  */
#define USBCTRL_REGS_ADDR_ENDP11_INTEP_DIR_Pos (25UL)               /*!< INTEP_DIR (Bit 25)                                    */
#define USBCTRL_REGS_ADDR_ENDP11_INTEP_DIR_Msk (0x2000000UL)        /*!< INTEP_DIR (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_ADDR_ENDP11_ENDPOINT_Pos (16UL)                /*!< ENDPOINT (Bit 16)                                     */
#define USBCTRL_REGS_ADDR_ENDP11_ENDPOINT_Msk (0xf0000UL)           /*!< ENDPOINT (Bitfield-Mask: 0x0f)                        */
#define USBCTRL_REGS_ADDR_ENDP11_ADDRESS_Pos (0UL)                  /*!< ADDRESS (Bit 0)                                       */
#define USBCTRL_REGS_ADDR_ENDP11_ADDRESS_Msk (0x7fUL)               /*!< ADDRESS (Bitfield-Mask: 0x7f)                         */
/* ======================================================  ADDR_ENDP12  ====================================================== */
#define USBCTRL_REGS_ADDR_ENDP12_INTEP_PREAMBLE_Pos (26UL)          /*!< INTEP_PREAMBLE (Bit 26)                               */
#define USBCTRL_REGS_ADDR_ENDP12_INTEP_PREAMBLE_Msk (0x4000000UL)   /*!< INTEP_PREAMBLE (Bitfield-Mask: 0x01)                  */
#define USBCTRL_REGS_ADDR_ENDP12_INTEP_DIR_Pos (25UL)               /*!< INTEP_DIR (Bit 25)                                    */
#define USBCTRL_REGS_ADDR_ENDP12_INTEP_DIR_Msk (0x2000000UL)        /*!< INTEP_DIR (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_ADDR_ENDP12_ENDPOINT_Pos (16UL)                /*!< ENDPOINT (Bit 16)                                     */
#define USBCTRL_REGS_ADDR_ENDP12_ENDPOINT_Msk (0xf0000UL)           /*!< ENDPOINT (Bitfield-Mask: 0x0f)                        */
#define USBCTRL_REGS_ADDR_ENDP12_ADDRESS_Pos (0UL)                  /*!< ADDRESS (Bit 0)                                       */
#define USBCTRL_REGS_ADDR_ENDP12_ADDRESS_Msk (0x7fUL)               /*!< ADDRESS (Bitfield-Mask: 0x7f)                         */
/* ======================================================  ADDR_ENDP13  ====================================================== */
#define USBCTRL_REGS_ADDR_ENDP13_INTEP_PREAMBLE_Pos (26UL)          /*!< INTEP_PREAMBLE (Bit 26)                               */
#define USBCTRL_REGS_ADDR_ENDP13_INTEP_PREAMBLE_Msk (0x4000000UL)   /*!< INTEP_PREAMBLE (Bitfield-Mask: 0x01)                  */
#define USBCTRL_REGS_ADDR_ENDP13_INTEP_DIR_Pos (25UL)               /*!< INTEP_DIR (Bit 25)                                    */
#define USBCTRL_REGS_ADDR_ENDP13_INTEP_DIR_Msk (0x2000000UL)        /*!< INTEP_DIR (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_ADDR_ENDP13_ENDPOINT_Pos (16UL)                /*!< ENDPOINT (Bit 16)                                     */
#define USBCTRL_REGS_ADDR_ENDP13_ENDPOINT_Msk (0xf0000UL)           /*!< ENDPOINT (Bitfield-Mask: 0x0f)                        */
#define USBCTRL_REGS_ADDR_ENDP13_ADDRESS_Pos (0UL)                  /*!< ADDRESS (Bit 0)                                       */
#define USBCTRL_REGS_ADDR_ENDP13_ADDRESS_Msk (0x7fUL)               /*!< ADDRESS (Bitfield-Mask: 0x7f)                         */
/* ======================================================  ADDR_ENDP14  ====================================================== */
#define USBCTRL_REGS_ADDR_ENDP14_INTEP_PREAMBLE_Pos (26UL)          /*!< INTEP_PREAMBLE (Bit 26)                               */
#define USBCTRL_REGS_ADDR_ENDP14_INTEP_PREAMBLE_Msk (0x4000000UL)   /*!< INTEP_PREAMBLE (Bitfield-Mask: 0x01)                  */
#define USBCTRL_REGS_ADDR_ENDP14_INTEP_DIR_Pos (25UL)               /*!< INTEP_DIR (Bit 25)                                    */
#define USBCTRL_REGS_ADDR_ENDP14_INTEP_DIR_Msk (0x2000000UL)        /*!< INTEP_DIR (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_ADDR_ENDP14_ENDPOINT_Pos (16UL)                /*!< ENDPOINT (Bit 16)                                     */
#define USBCTRL_REGS_ADDR_ENDP14_ENDPOINT_Msk (0xf0000UL)           /*!< ENDPOINT (Bitfield-Mask: 0x0f)                        */
#define USBCTRL_REGS_ADDR_ENDP14_ADDRESS_Pos (0UL)                  /*!< ADDRESS (Bit 0)                                       */
#define USBCTRL_REGS_ADDR_ENDP14_ADDRESS_Msk (0x7fUL)               /*!< ADDRESS (Bitfield-Mask: 0x7f)                         */
/* ======================================================  ADDR_ENDP15  ====================================================== */
#define USBCTRL_REGS_ADDR_ENDP15_INTEP_PREAMBLE_Pos (26UL)          /*!< INTEP_PREAMBLE (Bit 26)                               */
#define USBCTRL_REGS_ADDR_ENDP15_INTEP_PREAMBLE_Msk (0x4000000UL)   /*!< INTEP_PREAMBLE (Bitfield-Mask: 0x01)                  */
#define USBCTRL_REGS_ADDR_ENDP15_INTEP_DIR_Pos (25UL)               /*!< INTEP_DIR (Bit 25)                                    */
#define USBCTRL_REGS_ADDR_ENDP15_INTEP_DIR_Msk (0x2000000UL)        /*!< INTEP_DIR (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_ADDR_ENDP15_ENDPOINT_Pos (16UL)                /*!< ENDPOINT (Bit 16)                                     */
#define USBCTRL_REGS_ADDR_ENDP15_ENDPOINT_Msk (0xf0000UL)           /*!< ENDPOINT (Bitfield-Mask: 0x0f)                        */
#define USBCTRL_REGS_ADDR_ENDP15_ADDRESS_Pos (0UL)                  /*!< ADDRESS (Bit 0)                                       */
#define USBCTRL_REGS_ADDR_ENDP15_ADDRESS_Msk (0x7fUL)               /*!< ADDRESS (Bitfield-Mask: 0x7f)                         */
/* =======================================================  MAIN_CTRL  ======================================================= */
#define USBCTRL_REGS_MAIN_CTRL_SIM_TIMING_Pos (31UL)                /*!< SIM_TIMING (Bit 31)                                   */
#define USBCTRL_REGS_MAIN_CTRL_SIM_TIMING_Msk (0x80000000UL)        /*!< SIM_TIMING (Bitfield-Mask: 0x01)                      */
#define USBCTRL_REGS_MAIN_CTRL_HOST_NDEVICE_Pos (1UL)               /*!< HOST_NDEVICE (Bit 1)                                  */
#define USBCTRL_REGS_MAIN_CTRL_HOST_NDEVICE_Msk (0x2UL)             /*!< HOST_NDEVICE (Bitfield-Mask: 0x01)                    */
#define USBCTRL_REGS_MAIN_CTRL_CONTROLLER_EN_Pos (0UL)              /*!< CONTROLLER_EN (Bit 0)                                 */
#define USBCTRL_REGS_MAIN_CTRL_CONTROLLER_EN_Msk (0x1UL)            /*!< CONTROLLER_EN (Bitfield-Mask: 0x01)                   */
/* ========================================================  SOF_WR  ========================================================= */
#define USBCTRL_REGS_SOF_WR_COUNT_Pos     (0UL)                     /*!< COUNT (Bit 0)                                         */
#define USBCTRL_REGS_SOF_WR_COUNT_Msk     (0x7ffUL)                 /*!< COUNT (Bitfield-Mask: 0x7ff)                          */
/* ========================================================  SOF_RD  ========================================================= */
#define USBCTRL_REGS_SOF_RD_COUNT_Pos     (0UL)                     /*!< COUNT (Bit 0)                                         */
#define USBCTRL_REGS_SOF_RD_COUNT_Msk     (0x7ffUL)                 /*!< COUNT (Bitfield-Mask: 0x7ff)                          */
/* =======================================================  SIE_CTRL  ======================================================== */
#define USBCTRL_REGS_SIE_CTRL_EP0_INT_STALL_Pos (31UL)              /*!< EP0_INT_STALL (Bit 31)                                */
#define USBCTRL_REGS_SIE_CTRL_EP0_INT_STALL_Msk (0x80000000UL)      /*!< EP0_INT_STALL (Bitfield-Mask: 0x01)                   */
#define USBCTRL_REGS_SIE_CTRL_EP0_DOUBLE_BUF_Pos (30UL)             /*!< EP0_DOUBLE_BUF (Bit 30)                               */
#define USBCTRL_REGS_SIE_CTRL_EP0_DOUBLE_BUF_Msk (0x40000000UL)     /*!< EP0_DOUBLE_BUF (Bitfield-Mask: 0x01)                  */
#define USBCTRL_REGS_SIE_CTRL_EP0_INT_1BUF_Pos (29UL)               /*!< EP0_INT_1BUF (Bit 29)                                 */
#define USBCTRL_REGS_SIE_CTRL_EP0_INT_1BUF_Msk (0x20000000UL)       /*!< EP0_INT_1BUF (Bitfield-Mask: 0x01)                    */
#define USBCTRL_REGS_SIE_CTRL_EP0_INT_2BUF_Pos (28UL)               /*!< EP0_INT_2BUF (Bit 28)                                 */
#define USBCTRL_REGS_SIE_CTRL_EP0_INT_2BUF_Msk (0x10000000UL)       /*!< EP0_INT_2BUF (Bitfield-Mask: 0x01)                    */
#define USBCTRL_REGS_SIE_CTRL_EP0_INT_NAK_Pos (27UL)                /*!< EP0_INT_NAK (Bit 27)                                  */
#define USBCTRL_REGS_SIE_CTRL_EP0_INT_NAK_Msk (0x8000000UL)         /*!< EP0_INT_NAK (Bitfield-Mask: 0x01)                     */
#define USBCTRL_REGS_SIE_CTRL_DIRECT_EN_Pos (26UL)                  /*!< DIRECT_EN (Bit 26)                                    */
#define USBCTRL_REGS_SIE_CTRL_DIRECT_EN_Msk (0x4000000UL)           /*!< DIRECT_EN (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_SIE_CTRL_DIRECT_DP_Pos (25UL)                  /*!< DIRECT_DP (Bit 25)                                    */
#define USBCTRL_REGS_SIE_CTRL_DIRECT_DP_Msk (0x2000000UL)           /*!< DIRECT_DP (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_SIE_CTRL_DIRECT_DM_Pos (24UL)                  /*!< DIRECT_DM (Bit 24)                                    */
#define USBCTRL_REGS_SIE_CTRL_DIRECT_DM_Msk (0x1000000UL)           /*!< DIRECT_DM (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_SIE_CTRL_TRANSCEIVER_PD_Pos (18UL)             /*!< TRANSCEIVER_PD (Bit 18)                               */
#define USBCTRL_REGS_SIE_CTRL_TRANSCEIVER_PD_Msk (0x40000UL)        /*!< TRANSCEIVER_PD (Bitfield-Mask: 0x01)                  */
#define USBCTRL_REGS_SIE_CTRL_RPU_OPT_Pos (17UL)                    /*!< RPU_OPT (Bit 17)                                      */
#define USBCTRL_REGS_SIE_CTRL_RPU_OPT_Msk (0x20000UL)               /*!< RPU_OPT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_SIE_CTRL_PULLUP_EN_Pos (16UL)                  /*!< PULLUP_EN (Bit 16)                                    */
#define USBCTRL_REGS_SIE_CTRL_PULLUP_EN_Msk (0x10000UL)             /*!< PULLUP_EN (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_SIE_CTRL_PULLDOWN_EN_Pos (15UL)                /*!< PULLDOWN_EN (Bit 15)                                  */
#define USBCTRL_REGS_SIE_CTRL_PULLDOWN_EN_Msk (0x8000UL)            /*!< PULLDOWN_EN (Bitfield-Mask: 0x01)                     */
#define USBCTRL_REGS_SIE_CTRL_RESET_BUS_Pos (13UL)                  /*!< RESET_BUS (Bit 13)                                    */
#define USBCTRL_REGS_SIE_CTRL_RESET_BUS_Msk (0x2000UL)              /*!< RESET_BUS (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_SIE_CTRL_RESUME_Pos  (12UL)                    /*!< RESUME (Bit 12)                                       */
#define USBCTRL_REGS_SIE_CTRL_RESUME_Msk  (0x1000UL)                /*!< RESUME (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_SIE_CTRL_VBUS_EN_Pos (11UL)                    /*!< VBUS_EN (Bit 11)                                      */
#define USBCTRL_REGS_SIE_CTRL_VBUS_EN_Msk (0x800UL)                 /*!< VBUS_EN (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_SIE_CTRL_KEEP_ALIVE_EN_Pos (10UL)              /*!< KEEP_ALIVE_EN (Bit 10)                                */
#define USBCTRL_REGS_SIE_CTRL_KEEP_ALIVE_EN_Msk (0x400UL)           /*!< KEEP_ALIVE_EN (Bitfield-Mask: 0x01)                   */
#define USBCTRL_REGS_SIE_CTRL_SOF_EN_Pos  (9UL)                     /*!< SOF_EN (Bit 9)                                        */
#define USBCTRL_REGS_SIE_CTRL_SOF_EN_Msk  (0x200UL)                 /*!< SOF_EN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_SIE_CTRL_SOF_SYNC_Pos (8UL)                    /*!< SOF_SYNC (Bit 8)                                      */
#define USBCTRL_REGS_SIE_CTRL_SOF_SYNC_Msk (0x100UL)                /*!< SOF_SYNC (Bitfield-Mask: 0x01)                        */
#define USBCTRL_REGS_SIE_CTRL_PREAMBLE_EN_Pos (6UL)                 /*!< PREAMBLE_EN (Bit 6)                                   */
#define USBCTRL_REGS_SIE_CTRL_PREAMBLE_EN_Msk (0x40UL)              /*!< PREAMBLE_EN (Bitfield-Mask: 0x01)                     */
#define USBCTRL_REGS_SIE_CTRL_STOP_TRANS_Pos (4UL)                  /*!< STOP_TRANS (Bit 4)                                    */
#define USBCTRL_REGS_SIE_CTRL_STOP_TRANS_Msk (0x10UL)               /*!< STOP_TRANS (Bitfield-Mask: 0x01)                      */
#define USBCTRL_REGS_SIE_CTRL_RECEIVE_DATA_Pos (3UL)                /*!< RECEIVE_DATA (Bit 3)                                  */
#define USBCTRL_REGS_SIE_CTRL_RECEIVE_DATA_Msk (0x8UL)              /*!< RECEIVE_DATA (Bitfield-Mask: 0x01)                    */
#define USBCTRL_REGS_SIE_CTRL_SEND_DATA_Pos (2UL)                   /*!< SEND_DATA (Bit 2)                                     */
#define USBCTRL_REGS_SIE_CTRL_SEND_DATA_Msk (0x4UL)                 /*!< SEND_DATA (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_SIE_CTRL_SEND_SETUP_Pos (1UL)                  /*!< SEND_SETUP (Bit 1)                                    */
#define USBCTRL_REGS_SIE_CTRL_SEND_SETUP_Msk (0x2UL)                /*!< SEND_SETUP (Bitfield-Mask: 0x01)                      */
#define USBCTRL_REGS_SIE_CTRL_START_TRANS_Pos (0UL)                 /*!< START_TRANS (Bit 0)                                   */
#define USBCTRL_REGS_SIE_CTRL_START_TRANS_Msk (0x1UL)               /*!< START_TRANS (Bitfield-Mask: 0x01)                     */
/* ======================================================  SIE_STATUS  ======================================================= */
#define USBCTRL_REGS_SIE_STATUS_DATA_SEQ_ERROR_Pos (31UL)           /*!< DATA_SEQ_ERROR (Bit 31)                               */
#define USBCTRL_REGS_SIE_STATUS_DATA_SEQ_ERROR_Msk (0x80000000UL)   /*!< DATA_SEQ_ERROR (Bitfield-Mask: 0x01)                  */
#define USBCTRL_REGS_SIE_STATUS_ACK_REC_Pos (30UL)                  /*!< ACK_REC (Bit 30)                                      */
#define USBCTRL_REGS_SIE_STATUS_ACK_REC_Msk (0x40000000UL)          /*!< ACK_REC (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_SIE_STATUS_STALL_REC_Pos (29UL)                /*!< STALL_REC (Bit 29)                                    */
#define USBCTRL_REGS_SIE_STATUS_STALL_REC_Msk (0x20000000UL)        /*!< STALL_REC (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_SIE_STATUS_NAK_REC_Pos (28UL)                  /*!< NAK_REC (Bit 28)                                      */
#define USBCTRL_REGS_SIE_STATUS_NAK_REC_Msk (0x10000000UL)          /*!< NAK_REC (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_SIE_STATUS_RX_TIMEOUT_Pos (27UL)               /*!< RX_TIMEOUT (Bit 27)                                   */
#define USBCTRL_REGS_SIE_STATUS_RX_TIMEOUT_Msk (0x8000000UL)        /*!< RX_TIMEOUT (Bitfield-Mask: 0x01)                      */
#define USBCTRL_REGS_SIE_STATUS_RX_OVERFLOW_Pos (26UL)              /*!< RX_OVERFLOW (Bit 26)                                  */
#define USBCTRL_REGS_SIE_STATUS_RX_OVERFLOW_Msk (0x4000000UL)       /*!< RX_OVERFLOW (Bitfield-Mask: 0x01)                     */
#define USBCTRL_REGS_SIE_STATUS_BIT_STUFF_ERROR_Pos (25UL)          /*!< BIT_STUFF_ERROR (Bit 25)                              */
#define USBCTRL_REGS_SIE_STATUS_BIT_STUFF_ERROR_Msk (0x2000000UL)   /*!< BIT_STUFF_ERROR (Bitfield-Mask: 0x01)                 */
#define USBCTRL_REGS_SIE_STATUS_CRC_ERROR_Pos (24UL)                /*!< CRC_ERROR (Bit 24)                                    */
#define USBCTRL_REGS_SIE_STATUS_CRC_ERROR_Msk (0x1000000UL)         /*!< CRC_ERROR (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_SIE_STATUS_BUS_RESET_Pos (19UL)                /*!< BUS_RESET (Bit 19)                                    */
#define USBCTRL_REGS_SIE_STATUS_BUS_RESET_Msk (0x80000UL)           /*!< BUS_RESET (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_SIE_STATUS_TRANS_COMPLETE_Pos (18UL)           /*!< TRANS_COMPLETE (Bit 18)                               */
#define USBCTRL_REGS_SIE_STATUS_TRANS_COMPLETE_Msk (0x40000UL)      /*!< TRANS_COMPLETE (Bitfield-Mask: 0x01)                  */
#define USBCTRL_REGS_SIE_STATUS_SETUP_REC_Pos (17UL)                /*!< SETUP_REC (Bit 17)                                    */
#define USBCTRL_REGS_SIE_STATUS_SETUP_REC_Msk (0x20000UL)           /*!< SETUP_REC (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_SIE_STATUS_CONNECTED_Pos (16UL)                /*!< CONNECTED (Bit 16)                                    */
#define USBCTRL_REGS_SIE_STATUS_CONNECTED_Msk (0x10000UL)           /*!< CONNECTED (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_SIE_STATUS_RESUME_Pos (11UL)                   /*!< RESUME (Bit 11)                                       */
#define USBCTRL_REGS_SIE_STATUS_RESUME_Msk (0x800UL)                /*!< RESUME (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_SIE_STATUS_VBUS_OVER_CURR_Pos (10UL)           /*!< VBUS_OVER_CURR (Bit 10)                               */
#define USBCTRL_REGS_SIE_STATUS_VBUS_OVER_CURR_Msk (0x400UL)        /*!< VBUS_OVER_CURR (Bitfield-Mask: 0x01)                  */
#define USBCTRL_REGS_SIE_STATUS_SPEED_Pos (8UL)                     /*!< SPEED (Bit 8)                                         */
#define USBCTRL_REGS_SIE_STATUS_SPEED_Msk (0x300UL)                 /*!< SPEED (Bitfield-Mask: 0x03)                           */
#define USBCTRL_REGS_SIE_STATUS_SUSPENDED_Pos (4UL)                 /*!< SUSPENDED (Bit 4)                                     */
#define USBCTRL_REGS_SIE_STATUS_SUSPENDED_Msk (0x10UL)              /*!< SUSPENDED (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_SIE_STATUS_LINE_STATE_Pos (2UL)                /*!< LINE_STATE (Bit 2)                                    */
#define USBCTRL_REGS_SIE_STATUS_LINE_STATE_Msk (0xcUL)              /*!< LINE_STATE (Bitfield-Mask: 0x03)                      */
#define USBCTRL_REGS_SIE_STATUS_VBUS_DETECTED_Pos (0UL)             /*!< VBUS_DETECTED (Bit 0)                                 */
#define USBCTRL_REGS_SIE_STATUS_VBUS_DETECTED_Msk (0x1UL)           /*!< VBUS_DETECTED (Bitfield-Mask: 0x01)                   */
/* ======================================================  INT_EP_CTRL  ====================================================== */
#define USBCTRL_REGS_INT_EP_CTRL_INT_EP_ACTIVE_Pos (1UL)            /*!< INT_EP_ACTIVE (Bit 1)                                 */
#define USBCTRL_REGS_INT_EP_CTRL_INT_EP_ACTIVE_Msk (0xfffeUL)       /*!< INT_EP_ACTIVE (Bitfield-Mask: 0x7fff)                 */
/* ======================================================  BUFF_STATUS  ====================================================== */
#define USBCTRL_REGS_BUFF_STATUS_EP15_OUT_Pos (31UL)                /*!< EP15_OUT (Bit 31)                                     */
#define USBCTRL_REGS_BUFF_STATUS_EP15_OUT_Msk (0x80000000UL)        /*!< EP15_OUT (Bitfield-Mask: 0x01)                        */
#define USBCTRL_REGS_BUFF_STATUS_EP15_IN_Pos (30UL)                 /*!< EP15_IN (Bit 30)                                      */
#define USBCTRL_REGS_BUFF_STATUS_EP15_IN_Msk (0x40000000UL)         /*!< EP15_IN (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_BUFF_STATUS_EP14_OUT_Pos (29UL)                /*!< EP14_OUT (Bit 29)                                     */
#define USBCTRL_REGS_BUFF_STATUS_EP14_OUT_Msk (0x20000000UL)        /*!< EP14_OUT (Bitfield-Mask: 0x01)                        */
#define USBCTRL_REGS_BUFF_STATUS_EP14_IN_Pos (28UL)                 /*!< EP14_IN (Bit 28)                                      */
#define USBCTRL_REGS_BUFF_STATUS_EP14_IN_Msk (0x10000000UL)         /*!< EP14_IN (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_BUFF_STATUS_EP13_OUT_Pos (27UL)                /*!< EP13_OUT (Bit 27)                                     */
#define USBCTRL_REGS_BUFF_STATUS_EP13_OUT_Msk (0x8000000UL)         /*!< EP13_OUT (Bitfield-Mask: 0x01)                        */
#define USBCTRL_REGS_BUFF_STATUS_EP13_IN_Pos (26UL)                 /*!< EP13_IN (Bit 26)                                      */
#define USBCTRL_REGS_BUFF_STATUS_EP13_IN_Msk (0x4000000UL)          /*!< EP13_IN (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_BUFF_STATUS_EP12_OUT_Pos (25UL)                /*!< EP12_OUT (Bit 25)                                     */
#define USBCTRL_REGS_BUFF_STATUS_EP12_OUT_Msk (0x2000000UL)         /*!< EP12_OUT (Bitfield-Mask: 0x01)                        */
#define USBCTRL_REGS_BUFF_STATUS_EP12_IN_Pos (24UL)                 /*!< EP12_IN (Bit 24)                                      */
#define USBCTRL_REGS_BUFF_STATUS_EP12_IN_Msk (0x1000000UL)          /*!< EP12_IN (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_BUFF_STATUS_EP11_OUT_Pos (23UL)                /*!< EP11_OUT (Bit 23)                                     */
#define USBCTRL_REGS_BUFF_STATUS_EP11_OUT_Msk (0x800000UL)          /*!< EP11_OUT (Bitfield-Mask: 0x01)                        */
#define USBCTRL_REGS_BUFF_STATUS_EP11_IN_Pos (22UL)                 /*!< EP11_IN (Bit 22)                                      */
#define USBCTRL_REGS_BUFF_STATUS_EP11_IN_Msk (0x400000UL)           /*!< EP11_IN (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_BUFF_STATUS_EP10_OUT_Pos (21UL)                /*!< EP10_OUT (Bit 21)                                     */
#define USBCTRL_REGS_BUFF_STATUS_EP10_OUT_Msk (0x200000UL)          /*!< EP10_OUT (Bitfield-Mask: 0x01)                        */
#define USBCTRL_REGS_BUFF_STATUS_EP10_IN_Pos (20UL)                 /*!< EP10_IN (Bit 20)                                      */
#define USBCTRL_REGS_BUFF_STATUS_EP10_IN_Msk (0x100000UL)           /*!< EP10_IN (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_BUFF_STATUS_EP9_OUT_Pos (19UL)                 /*!< EP9_OUT (Bit 19)                                      */
#define USBCTRL_REGS_BUFF_STATUS_EP9_OUT_Msk (0x80000UL)            /*!< EP9_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_BUFF_STATUS_EP9_IN_Pos (18UL)                  /*!< EP9_IN (Bit 18)                                       */
#define USBCTRL_REGS_BUFF_STATUS_EP9_IN_Msk (0x40000UL)             /*!< EP9_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_BUFF_STATUS_EP8_OUT_Pos (17UL)                 /*!< EP8_OUT (Bit 17)                                      */
#define USBCTRL_REGS_BUFF_STATUS_EP8_OUT_Msk (0x20000UL)            /*!< EP8_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_BUFF_STATUS_EP8_IN_Pos (16UL)                  /*!< EP8_IN (Bit 16)                                       */
#define USBCTRL_REGS_BUFF_STATUS_EP8_IN_Msk (0x10000UL)             /*!< EP8_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_BUFF_STATUS_EP7_OUT_Pos (15UL)                 /*!< EP7_OUT (Bit 15)                                      */
#define USBCTRL_REGS_BUFF_STATUS_EP7_OUT_Msk (0x8000UL)             /*!< EP7_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_BUFF_STATUS_EP7_IN_Pos (14UL)                  /*!< EP7_IN (Bit 14)                                       */
#define USBCTRL_REGS_BUFF_STATUS_EP7_IN_Msk (0x4000UL)              /*!< EP7_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_BUFF_STATUS_EP6_OUT_Pos (13UL)                 /*!< EP6_OUT (Bit 13)                                      */
#define USBCTRL_REGS_BUFF_STATUS_EP6_OUT_Msk (0x2000UL)             /*!< EP6_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_BUFF_STATUS_EP6_IN_Pos (12UL)                  /*!< EP6_IN (Bit 12)                                       */
#define USBCTRL_REGS_BUFF_STATUS_EP6_IN_Msk (0x1000UL)              /*!< EP6_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_BUFF_STATUS_EP5_OUT_Pos (11UL)                 /*!< EP5_OUT (Bit 11)                                      */
#define USBCTRL_REGS_BUFF_STATUS_EP5_OUT_Msk (0x800UL)              /*!< EP5_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_BUFF_STATUS_EP5_IN_Pos (10UL)                  /*!< EP5_IN (Bit 10)                                       */
#define USBCTRL_REGS_BUFF_STATUS_EP5_IN_Msk (0x400UL)               /*!< EP5_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_BUFF_STATUS_EP4_OUT_Pos (9UL)                  /*!< EP4_OUT (Bit 9)                                       */
#define USBCTRL_REGS_BUFF_STATUS_EP4_OUT_Msk (0x200UL)              /*!< EP4_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_BUFF_STATUS_EP4_IN_Pos (8UL)                   /*!< EP4_IN (Bit 8)                                        */
#define USBCTRL_REGS_BUFF_STATUS_EP4_IN_Msk (0x100UL)               /*!< EP4_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_BUFF_STATUS_EP3_OUT_Pos (7UL)                  /*!< EP3_OUT (Bit 7)                                       */
#define USBCTRL_REGS_BUFF_STATUS_EP3_OUT_Msk (0x80UL)               /*!< EP3_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_BUFF_STATUS_EP3_IN_Pos (6UL)                   /*!< EP3_IN (Bit 6)                                        */
#define USBCTRL_REGS_BUFF_STATUS_EP3_IN_Msk (0x40UL)                /*!< EP3_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_BUFF_STATUS_EP2_OUT_Pos (5UL)                  /*!< EP2_OUT (Bit 5)                                       */
#define USBCTRL_REGS_BUFF_STATUS_EP2_OUT_Msk (0x20UL)               /*!< EP2_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_BUFF_STATUS_EP2_IN_Pos (4UL)                   /*!< EP2_IN (Bit 4)                                        */
#define USBCTRL_REGS_BUFF_STATUS_EP2_IN_Msk (0x10UL)                /*!< EP2_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_BUFF_STATUS_EP1_OUT_Pos (3UL)                  /*!< EP1_OUT (Bit 3)                                       */
#define USBCTRL_REGS_BUFF_STATUS_EP1_OUT_Msk (0x8UL)                /*!< EP1_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_BUFF_STATUS_EP1_IN_Pos (2UL)                   /*!< EP1_IN (Bit 2)                                        */
#define USBCTRL_REGS_BUFF_STATUS_EP1_IN_Msk (0x4UL)                 /*!< EP1_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_BUFF_STATUS_EP0_OUT_Pos (1UL)                  /*!< EP0_OUT (Bit 1)                                       */
#define USBCTRL_REGS_BUFF_STATUS_EP0_OUT_Msk (0x2UL)                /*!< EP0_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_BUFF_STATUS_EP0_IN_Pos (0UL)                   /*!< EP0_IN (Bit 0)                                        */
#define USBCTRL_REGS_BUFF_STATUS_EP0_IN_Msk (0x1UL)                 /*!< EP0_IN (Bitfield-Mask: 0x01)                          */
/* ================================================  BUFF_CPU_SHOULD_HANDLE  ================================================= */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP15_OUT_Pos (31UL)     /*!< EP15_OUT (Bit 31)                                     */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP15_OUT_Msk (0x80000000UL) /*!< EP15_OUT (Bitfield-Mask: 0x01)                    */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP15_IN_Pos (30UL)      /*!< EP15_IN (Bit 30)                                      */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP15_IN_Msk (0x40000000UL) /*!< EP15_IN (Bitfield-Mask: 0x01)                      */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP14_OUT_Pos (29UL)     /*!< EP14_OUT (Bit 29)                                     */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP14_OUT_Msk (0x20000000UL) /*!< EP14_OUT (Bitfield-Mask: 0x01)                    */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP14_IN_Pos (28UL)      /*!< EP14_IN (Bit 28)                                      */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP14_IN_Msk (0x10000000UL) /*!< EP14_IN (Bitfield-Mask: 0x01)                      */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP13_OUT_Pos (27UL)     /*!< EP13_OUT (Bit 27)                                     */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP13_OUT_Msk (0x8000000UL) /*!< EP13_OUT (Bitfield-Mask: 0x01)                     */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP13_IN_Pos (26UL)      /*!< EP13_IN (Bit 26)                                      */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP13_IN_Msk (0x4000000UL) /*!< EP13_IN (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP12_OUT_Pos (25UL)     /*!< EP12_OUT (Bit 25)                                     */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP12_OUT_Msk (0x2000000UL) /*!< EP12_OUT (Bitfield-Mask: 0x01)                     */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP12_IN_Pos (24UL)      /*!< EP12_IN (Bit 24)                                      */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP12_IN_Msk (0x1000000UL) /*!< EP12_IN (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP11_OUT_Pos (23UL)     /*!< EP11_OUT (Bit 23)                                     */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP11_OUT_Msk (0x800000UL) /*!< EP11_OUT (Bitfield-Mask: 0x01)                      */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP11_IN_Pos (22UL)      /*!< EP11_IN (Bit 22)                                      */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP11_IN_Msk (0x400000UL) /*!< EP11_IN (Bitfield-Mask: 0x01)                        */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP10_OUT_Pos (21UL)     /*!< EP10_OUT (Bit 21)                                     */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP10_OUT_Msk (0x200000UL) /*!< EP10_OUT (Bitfield-Mask: 0x01)                      */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP10_IN_Pos (20UL)      /*!< EP10_IN (Bit 20)                                      */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP10_IN_Msk (0x100000UL) /*!< EP10_IN (Bitfield-Mask: 0x01)                        */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP9_OUT_Pos (19UL)      /*!< EP9_OUT (Bit 19)                                      */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP9_OUT_Msk (0x80000UL) /*!< EP9_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP9_IN_Pos (18UL)       /*!< EP9_IN (Bit 18)                                       */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP9_IN_Msk (0x40000UL)  /*!< EP9_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP8_OUT_Pos (17UL)      /*!< EP8_OUT (Bit 17)                                      */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP8_OUT_Msk (0x20000UL) /*!< EP8_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP8_IN_Pos (16UL)       /*!< EP8_IN (Bit 16)                                       */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP8_IN_Msk (0x10000UL)  /*!< EP8_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP7_OUT_Pos (15UL)      /*!< EP7_OUT (Bit 15)                                      */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP7_OUT_Msk (0x8000UL)  /*!< EP7_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP7_IN_Pos (14UL)       /*!< EP7_IN (Bit 14)                                       */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP7_IN_Msk (0x4000UL)   /*!< EP7_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP6_OUT_Pos (13UL)      /*!< EP6_OUT (Bit 13)                                      */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP6_OUT_Msk (0x2000UL)  /*!< EP6_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP6_IN_Pos (12UL)       /*!< EP6_IN (Bit 12)                                       */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP6_IN_Msk (0x1000UL)   /*!< EP6_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP5_OUT_Pos (11UL)      /*!< EP5_OUT (Bit 11)                                      */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP5_OUT_Msk (0x800UL)   /*!< EP5_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP5_IN_Pos (10UL)       /*!< EP5_IN (Bit 10)                                       */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP5_IN_Msk (0x400UL)    /*!< EP5_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP4_OUT_Pos (9UL)       /*!< EP4_OUT (Bit 9)                                       */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP4_OUT_Msk (0x200UL)   /*!< EP4_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP4_IN_Pos (8UL)        /*!< EP4_IN (Bit 8)                                        */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP4_IN_Msk (0x100UL)    /*!< EP4_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP3_OUT_Pos (7UL)       /*!< EP3_OUT (Bit 7)                                       */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP3_OUT_Msk (0x80UL)    /*!< EP3_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP3_IN_Pos (6UL)        /*!< EP3_IN (Bit 6)                                        */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP3_IN_Msk (0x40UL)     /*!< EP3_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP2_OUT_Pos (5UL)       /*!< EP2_OUT (Bit 5)                                       */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP2_OUT_Msk (0x20UL)    /*!< EP2_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP2_IN_Pos (4UL)        /*!< EP2_IN (Bit 4)                                        */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP2_IN_Msk (0x10UL)     /*!< EP2_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP1_OUT_Pos (3UL)       /*!< EP1_OUT (Bit 3)                                       */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP1_OUT_Msk (0x8UL)     /*!< EP1_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP1_IN_Pos (2UL)        /*!< EP1_IN (Bit 2)                                        */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP1_IN_Msk (0x4UL)      /*!< EP1_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP0_OUT_Pos (1UL)       /*!< EP0_OUT (Bit 1)                                       */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP0_OUT_Msk (0x2UL)     /*!< EP0_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP0_IN_Pos (0UL)        /*!< EP0_IN (Bit 0)                                        */
#define USBCTRL_REGS_BUFF_CPU_SHOULD_HANDLE_EP0_IN_Msk (0x1UL)      /*!< EP0_IN (Bitfield-Mask: 0x01)                          */
/* =======================================================  EP_ABORT  ======================================================== */
#define USBCTRL_REGS_EP_ABORT_EP15_OUT_Pos (31UL)                   /*!< EP15_OUT (Bit 31)                                     */
#define USBCTRL_REGS_EP_ABORT_EP15_OUT_Msk (0x80000000UL)           /*!< EP15_OUT (Bitfield-Mask: 0x01)                        */
#define USBCTRL_REGS_EP_ABORT_EP15_IN_Pos (30UL)                    /*!< EP15_IN (Bit 30)                                      */
#define USBCTRL_REGS_EP_ABORT_EP15_IN_Msk (0x40000000UL)            /*!< EP15_IN (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_ABORT_EP14_OUT_Pos (29UL)                   /*!< EP14_OUT (Bit 29)                                     */
#define USBCTRL_REGS_EP_ABORT_EP14_OUT_Msk (0x20000000UL)           /*!< EP14_OUT (Bitfield-Mask: 0x01)                        */
#define USBCTRL_REGS_EP_ABORT_EP14_IN_Pos (28UL)                    /*!< EP14_IN (Bit 28)                                      */
#define USBCTRL_REGS_EP_ABORT_EP14_IN_Msk (0x10000000UL)            /*!< EP14_IN (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_ABORT_EP13_OUT_Pos (27UL)                   /*!< EP13_OUT (Bit 27)                                     */
#define USBCTRL_REGS_EP_ABORT_EP13_OUT_Msk (0x8000000UL)            /*!< EP13_OUT (Bitfield-Mask: 0x01)                        */
#define USBCTRL_REGS_EP_ABORT_EP13_IN_Pos (26UL)                    /*!< EP13_IN (Bit 26)                                      */
#define USBCTRL_REGS_EP_ABORT_EP13_IN_Msk (0x4000000UL)             /*!< EP13_IN (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_ABORT_EP12_OUT_Pos (25UL)                   /*!< EP12_OUT (Bit 25)                                     */
#define USBCTRL_REGS_EP_ABORT_EP12_OUT_Msk (0x2000000UL)            /*!< EP12_OUT (Bitfield-Mask: 0x01)                        */
#define USBCTRL_REGS_EP_ABORT_EP12_IN_Pos (24UL)                    /*!< EP12_IN (Bit 24)                                      */
#define USBCTRL_REGS_EP_ABORT_EP12_IN_Msk (0x1000000UL)             /*!< EP12_IN (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_ABORT_EP11_OUT_Pos (23UL)                   /*!< EP11_OUT (Bit 23)                                     */
#define USBCTRL_REGS_EP_ABORT_EP11_OUT_Msk (0x800000UL)             /*!< EP11_OUT (Bitfield-Mask: 0x01)                        */
#define USBCTRL_REGS_EP_ABORT_EP11_IN_Pos (22UL)                    /*!< EP11_IN (Bit 22)                                      */
#define USBCTRL_REGS_EP_ABORT_EP11_IN_Msk (0x400000UL)              /*!< EP11_IN (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_ABORT_EP10_OUT_Pos (21UL)                   /*!< EP10_OUT (Bit 21)                                     */
#define USBCTRL_REGS_EP_ABORT_EP10_OUT_Msk (0x200000UL)             /*!< EP10_OUT (Bitfield-Mask: 0x01)                        */
#define USBCTRL_REGS_EP_ABORT_EP10_IN_Pos (20UL)                    /*!< EP10_IN (Bit 20)                                      */
#define USBCTRL_REGS_EP_ABORT_EP10_IN_Msk (0x100000UL)              /*!< EP10_IN (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_ABORT_EP9_OUT_Pos (19UL)                    /*!< EP9_OUT (Bit 19)                                      */
#define USBCTRL_REGS_EP_ABORT_EP9_OUT_Msk (0x80000UL)               /*!< EP9_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_ABORT_EP9_IN_Pos  (18UL)                    /*!< EP9_IN (Bit 18)                                       */
#define USBCTRL_REGS_EP_ABORT_EP9_IN_Msk  (0x40000UL)               /*!< EP9_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_EP_ABORT_EP8_OUT_Pos (17UL)                    /*!< EP8_OUT (Bit 17)                                      */
#define USBCTRL_REGS_EP_ABORT_EP8_OUT_Msk (0x20000UL)               /*!< EP8_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_ABORT_EP8_IN_Pos  (16UL)                    /*!< EP8_IN (Bit 16)                                       */
#define USBCTRL_REGS_EP_ABORT_EP8_IN_Msk  (0x10000UL)               /*!< EP8_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_EP_ABORT_EP7_OUT_Pos (15UL)                    /*!< EP7_OUT (Bit 15)                                      */
#define USBCTRL_REGS_EP_ABORT_EP7_OUT_Msk (0x8000UL)                /*!< EP7_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_ABORT_EP7_IN_Pos  (14UL)                    /*!< EP7_IN (Bit 14)                                       */
#define USBCTRL_REGS_EP_ABORT_EP7_IN_Msk  (0x4000UL)                /*!< EP7_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_EP_ABORT_EP6_OUT_Pos (13UL)                    /*!< EP6_OUT (Bit 13)                                      */
#define USBCTRL_REGS_EP_ABORT_EP6_OUT_Msk (0x2000UL)                /*!< EP6_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_ABORT_EP6_IN_Pos  (12UL)                    /*!< EP6_IN (Bit 12)                                       */
#define USBCTRL_REGS_EP_ABORT_EP6_IN_Msk  (0x1000UL)                /*!< EP6_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_EP_ABORT_EP5_OUT_Pos (11UL)                    /*!< EP5_OUT (Bit 11)                                      */
#define USBCTRL_REGS_EP_ABORT_EP5_OUT_Msk (0x800UL)                 /*!< EP5_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_ABORT_EP5_IN_Pos  (10UL)                    /*!< EP5_IN (Bit 10)                                       */
#define USBCTRL_REGS_EP_ABORT_EP5_IN_Msk  (0x400UL)                 /*!< EP5_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_EP_ABORT_EP4_OUT_Pos (9UL)                     /*!< EP4_OUT (Bit 9)                                       */
#define USBCTRL_REGS_EP_ABORT_EP4_OUT_Msk (0x200UL)                 /*!< EP4_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_ABORT_EP4_IN_Pos  (8UL)                     /*!< EP4_IN (Bit 8)                                        */
#define USBCTRL_REGS_EP_ABORT_EP4_IN_Msk  (0x100UL)                 /*!< EP4_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_EP_ABORT_EP3_OUT_Pos (7UL)                     /*!< EP3_OUT (Bit 7)                                       */
#define USBCTRL_REGS_EP_ABORT_EP3_OUT_Msk (0x80UL)                  /*!< EP3_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_ABORT_EP3_IN_Pos  (6UL)                     /*!< EP3_IN (Bit 6)                                        */
#define USBCTRL_REGS_EP_ABORT_EP3_IN_Msk  (0x40UL)                  /*!< EP3_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_EP_ABORT_EP2_OUT_Pos (5UL)                     /*!< EP2_OUT (Bit 5)                                       */
#define USBCTRL_REGS_EP_ABORT_EP2_OUT_Msk (0x20UL)                  /*!< EP2_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_ABORT_EP2_IN_Pos  (4UL)                     /*!< EP2_IN (Bit 4)                                        */
#define USBCTRL_REGS_EP_ABORT_EP2_IN_Msk  (0x10UL)                  /*!< EP2_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_EP_ABORT_EP1_OUT_Pos (3UL)                     /*!< EP1_OUT (Bit 3)                                       */
#define USBCTRL_REGS_EP_ABORT_EP1_OUT_Msk (0x8UL)                   /*!< EP1_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_ABORT_EP1_IN_Pos  (2UL)                     /*!< EP1_IN (Bit 2)                                        */
#define USBCTRL_REGS_EP_ABORT_EP1_IN_Msk  (0x4UL)                   /*!< EP1_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_EP_ABORT_EP0_OUT_Pos (1UL)                     /*!< EP0_OUT (Bit 1)                                       */
#define USBCTRL_REGS_EP_ABORT_EP0_OUT_Msk (0x2UL)                   /*!< EP0_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_ABORT_EP0_IN_Pos  (0UL)                     /*!< EP0_IN (Bit 0)                                        */
#define USBCTRL_REGS_EP_ABORT_EP0_IN_Msk  (0x1UL)                   /*!< EP0_IN (Bitfield-Mask: 0x01)                          */
/* =====================================================  EP_ABORT_DONE  ===================================================== */
#define USBCTRL_REGS_EP_ABORT_DONE_EP15_OUT_Pos (31UL)              /*!< EP15_OUT (Bit 31)                                     */
#define USBCTRL_REGS_EP_ABORT_DONE_EP15_OUT_Msk (0x80000000UL)      /*!< EP15_OUT (Bitfield-Mask: 0x01)                        */
#define USBCTRL_REGS_EP_ABORT_DONE_EP15_IN_Pos (30UL)               /*!< EP15_IN (Bit 30)                                      */
#define USBCTRL_REGS_EP_ABORT_DONE_EP15_IN_Msk (0x40000000UL)       /*!< EP15_IN (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_ABORT_DONE_EP14_OUT_Pos (29UL)              /*!< EP14_OUT (Bit 29)                                     */
#define USBCTRL_REGS_EP_ABORT_DONE_EP14_OUT_Msk (0x20000000UL)      /*!< EP14_OUT (Bitfield-Mask: 0x01)                        */
#define USBCTRL_REGS_EP_ABORT_DONE_EP14_IN_Pos (28UL)               /*!< EP14_IN (Bit 28)                                      */
#define USBCTRL_REGS_EP_ABORT_DONE_EP14_IN_Msk (0x10000000UL)       /*!< EP14_IN (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_ABORT_DONE_EP13_OUT_Pos (27UL)              /*!< EP13_OUT (Bit 27)                                     */
#define USBCTRL_REGS_EP_ABORT_DONE_EP13_OUT_Msk (0x8000000UL)       /*!< EP13_OUT (Bitfield-Mask: 0x01)                        */
#define USBCTRL_REGS_EP_ABORT_DONE_EP13_IN_Pos (26UL)               /*!< EP13_IN (Bit 26)                                      */
#define USBCTRL_REGS_EP_ABORT_DONE_EP13_IN_Msk (0x4000000UL)        /*!< EP13_IN (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_ABORT_DONE_EP12_OUT_Pos (25UL)              /*!< EP12_OUT (Bit 25)                                     */
#define USBCTRL_REGS_EP_ABORT_DONE_EP12_OUT_Msk (0x2000000UL)       /*!< EP12_OUT (Bitfield-Mask: 0x01)                        */
#define USBCTRL_REGS_EP_ABORT_DONE_EP12_IN_Pos (24UL)               /*!< EP12_IN (Bit 24)                                      */
#define USBCTRL_REGS_EP_ABORT_DONE_EP12_IN_Msk (0x1000000UL)        /*!< EP12_IN (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_ABORT_DONE_EP11_OUT_Pos (23UL)              /*!< EP11_OUT (Bit 23)                                     */
#define USBCTRL_REGS_EP_ABORT_DONE_EP11_OUT_Msk (0x800000UL)        /*!< EP11_OUT (Bitfield-Mask: 0x01)                        */
#define USBCTRL_REGS_EP_ABORT_DONE_EP11_IN_Pos (22UL)               /*!< EP11_IN (Bit 22)                                      */
#define USBCTRL_REGS_EP_ABORT_DONE_EP11_IN_Msk (0x400000UL)         /*!< EP11_IN (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_ABORT_DONE_EP10_OUT_Pos (21UL)              /*!< EP10_OUT (Bit 21)                                     */
#define USBCTRL_REGS_EP_ABORT_DONE_EP10_OUT_Msk (0x200000UL)        /*!< EP10_OUT (Bitfield-Mask: 0x01)                        */
#define USBCTRL_REGS_EP_ABORT_DONE_EP10_IN_Pos (20UL)               /*!< EP10_IN (Bit 20)                                      */
#define USBCTRL_REGS_EP_ABORT_DONE_EP10_IN_Msk (0x100000UL)         /*!< EP10_IN (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_ABORT_DONE_EP9_OUT_Pos (19UL)               /*!< EP9_OUT (Bit 19)                                      */
#define USBCTRL_REGS_EP_ABORT_DONE_EP9_OUT_Msk (0x80000UL)          /*!< EP9_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_ABORT_DONE_EP9_IN_Pos (18UL)                /*!< EP9_IN (Bit 18)                                       */
#define USBCTRL_REGS_EP_ABORT_DONE_EP9_IN_Msk (0x40000UL)           /*!< EP9_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_EP_ABORT_DONE_EP8_OUT_Pos (17UL)               /*!< EP8_OUT (Bit 17)                                      */
#define USBCTRL_REGS_EP_ABORT_DONE_EP8_OUT_Msk (0x20000UL)          /*!< EP8_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_ABORT_DONE_EP8_IN_Pos (16UL)                /*!< EP8_IN (Bit 16)                                       */
#define USBCTRL_REGS_EP_ABORT_DONE_EP8_IN_Msk (0x10000UL)           /*!< EP8_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_EP_ABORT_DONE_EP7_OUT_Pos (15UL)               /*!< EP7_OUT (Bit 15)                                      */
#define USBCTRL_REGS_EP_ABORT_DONE_EP7_OUT_Msk (0x8000UL)           /*!< EP7_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_ABORT_DONE_EP7_IN_Pos (14UL)                /*!< EP7_IN (Bit 14)                                       */
#define USBCTRL_REGS_EP_ABORT_DONE_EP7_IN_Msk (0x4000UL)            /*!< EP7_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_EP_ABORT_DONE_EP6_OUT_Pos (13UL)               /*!< EP6_OUT (Bit 13)                                      */
#define USBCTRL_REGS_EP_ABORT_DONE_EP6_OUT_Msk (0x2000UL)           /*!< EP6_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_ABORT_DONE_EP6_IN_Pos (12UL)                /*!< EP6_IN (Bit 12)                                       */
#define USBCTRL_REGS_EP_ABORT_DONE_EP6_IN_Msk (0x1000UL)            /*!< EP6_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_EP_ABORT_DONE_EP5_OUT_Pos (11UL)               /*!< EP5_OUT (Bit 11)                                      */
#define USBCTRL_REGS_EP_ABORT_DONE_EP5_OUT_Msk (0x800UL)            /*!< EP5_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_ABORT_DONE_EP5_IN_Pos (10UL)                /*!< EP5_IN (Bit 10)                                       */
#define USBCTRL_REGS_EP_ABORT_DONE_EP5_IN_Msk (0x400UL)             /*!< EP5_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_EP_ABORT_DONE_EP4_OUT_Pos (9UL)                /*!< EP4_OUT (Bit 9)                                       */
#define USBCTRL_REGS_EP_ABORT_DONE_EP4_OUT_Msk (0x200UL)            /*!< EP4_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_ABORT_DONE_EP4_IN_Pos (8UL)                 /*!< EP4_IN (Bit 8)                                        */
#define USBCTRL_REGS_EP_ABORT_DONE_EP4_IN_Msk (0x100UL)             /*!< EP4_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_EP_ABORT_DONE_EP3_OUT_Pos (7UL)                /*!< EP3_OUT (Bit 7)                                       */
#define USBCTRL_REGS_EP_ABORT_DONE_EP3_OUT_Msk (0x80UL)             /*!< EP3_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_ABORT_DONE_EP3_IN_Pos (6UL)                 /*!< EP3_IN (Bit 6)                                        */
#define USBCTRL_REGS_EP_ABORT_DONE_EP3_IN_Msk (0x40UL)              /*!< EP3_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_EP_ABORT_DONE_EP2_OUT_Pos (5UL)                /*!< EP2_OUT (Bit 5)                                       */
#define USBCTRL_REGS_EP_ABORT_DONE_EP2_OUT_Msk (0x20UL)             /*!< EP2_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_ABORT_DONE_EP2_IN_Pos (4UL)                 /*!< EP2_IN (Bit 4)                                        */
#define USBCTRL_REGS_EP_ABORT_DONE_EP2_IN_Msk (0x10UL)              /*!< EP2_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_EP_ABORT_DONE_EP1_OUT_Pos (3UL)                /*!< EP1_OUT (Bit 3)                                       */
#define USBCTRL_REGS_EP_ABORT_DONE_EP1_OUT_Msk (0x8UL)              /*!< EP1_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_ABORT_DONE_EP1_IN_Pos (2UL)                 /*!< EP1_IN (Bit 2)                                        */
#define USBCTRL_REGS_EP_ABORT_DONE_EP1_IN_Msk (0x4UL)               /*!< EP1_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_EP_ABORT_DONE_EP0_OUT_Pos (1UL)                /*!< EP0_OUT (Bit 1)                                       */
#define USBCTRL_REGS_EP_ABORT_DONE_EP0_OUT_Msk (0x2UL)              /*!< EP0_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_ABORT_DONE_EP0_IN_Pos (0UL)                 /*!< EP0_IN (Bit 0)                                        */
#define USBCTRL_REGS_EP_ABORT_DONE_EP0_IN_Msk (0x1UL)               /*!< EP0_IN (Bitfield-Mask: 0x01)                          */
/* =====================================================  EP_STALL_ARM  ====================================================== */
#define USBCTRL_REGS_EP_STALL_ARM_EP0_OUT_Pos (1UL)                 /*!< EP0_OUT (Bit 1)                                       */
#define USBCTRL_REGS_EP_STALL_ARM_EP0_OUT_Msk (0x2UL)               /*!< EP0_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_STALL_ARM_EP0_IN_Pos (0UL)                  /*!< EP0_IN (Bit 0)                                        */
#define USBCTRL_REGS_EP_STALL_ARM_EP0_IN_Msk (0x1UL)                /*!< EP0_IN (Bitfield-Mask: 0x01)                          */
/* =======================================================  NAK_POLL  ======================================================== */
#define USBCTRL_REGS_NAK_POLL_DELAY_FS_Pos (16UL)                   /*!< DELAY_FS (Bit 16)                                     */
#define USBCTRL_REGS_NAK_POLL_DELAY_FS_Msk (0x3ff0000UL)            /*!< DELAY_FS (Bitfield-Mask: 0x3ff)                       */
#define USBCTRL_REGS_NAK_POLL_DELAY_LS_Pos (0UL)                    /*!< DELAY_LS (Bit 0)                                      */
#define USBCTRL_REGS_NAK_POLL_DELAY_LS_Msk (0x3ffUL)                /*!< DELAY_LS (Bitfield-Mask: 0x3ff)                       */
/* ==================================================  EP_STATUS_STALL_NAK  ================================================== */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP15_OUT_Pos (31UL)        /*!< EP15_OUT (Bit 31)                                     */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP15_OUT_Msk (0x80000000UL) /*!< EP15_OUT (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP15_IN_Pos (30UL)         /*!< EP15_IN (Bit 30)                                      */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP15_IN_Msk (0x40000000UL) /*!< EP15_IN (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP14_OUT_Pos (29UL)        /*!< EP14_OUT (Bit 29)                                     */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP14_OUT_Msk (0x20000000UL) /*!< EP14_OUT (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP14_IN_Pos (28UL)         /*!< EP14_IN (Bit 28)                                      */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP14_IN_Msk (0x10000000UL) /*!< EP14_IN (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP13_OUT_Pos (27UL)        /*!< EP13_OUT (Bit 27)                                     */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP13_OUT_Msk (0x8000000UL) /*!< EP13_OUT (Bitfield-Mask: 0x01)                        */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP13_IN_Pos (26UL)         /*!< EP13_IN (Bit 26)                                      */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP13_IN_Msk (0x4000000UL)  /*!< EP13_IN (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP12_OUT_Pos (25UL)        /*!< EP12_OUT (Bit 25)                                     */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP12_OUT_Msk (0x2000000UL) /*!< EP12_OUT (Bitfield-Mask: 0x01)                        */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP12_IN_Pos (24UL)         /*!< EP12_IN (Bit 24)                                      */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP12_IN_Msk (0x1000000UL)  /*!< EP12_IN (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP11_OUT_Pos (23UL)        /*!< EP11_OUT (Bit 23)                                     */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP11_OUT_Msk (0x800000UL)  /*!< EP11_OUT (Bitfield-Mask: 0x01)                        */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP11_IN_Pos (22UL)         /*!< EP11_IN (Bit 22)                                      */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP11_IN_Msk (0x400000UL)   /*!< EP11_IN (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP10_OUT_Pos (21UL)        /*!< EP10_OUT (Bit 21)                                     */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP10_OUT_Msk (0x200000UL)  /*!< EP10_OUT (Bitfield-Mask: 0x01)                        */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP10_IN_Pos (20UL)         /*!< EP10_IN (Bit 20)                                      */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP10_IN_Msk (0x100000UL)   /*!< EP10_IN (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP9_OUT_Pos (19UL)         /*!< EP9_OUT (Bit 19)                                      */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP9_OUT_Msk (0x80000UL)    /*!< EP9_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP9_IN_Pos (18UL)          /*!< EP9_IN (Bit 18)                                       */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP9_IN_Msk (0x40000UL)     /*!< EP9_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP8_OUT_Pos (17UL)         /*!< EP8_OUT (Bit 17)                                      */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP8_OUT_Msk (0x20000UL)    /*!< EP8_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP8_IN_Pos (16UL)          /*!< EP8_IN (Bit 16)                                       */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP8_IN_Msk (0x10000UL)     /*!< EP8_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP7_OUT_Pos (15UL)         /*!< EP7_OUT (Bit 15)                                      */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP7_OUT_Msk (0x8000UL)     /*!< EP7_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP7_IN_Pos (14UL)          /*!< EP7_IN (Bit 14)                                       */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP7_IN_Msk (0x4000UL)      /*!< EP7_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP6_OUT_Pos (13UL)         /*!< EP6_OUT (Bit 13)                                      */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP6_OUT_Msk (0x2000UL)     /*!< EP6_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP6_IN_Pos (12UL)          /*!< EP6_IN (Bit 12)                                       */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP6_IN_Msk (0x1000UL)      /*!< EP6_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP5_OUT_Pos (11UL)         /*!< EP5_OUT (Bit 11)                                      */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP5_OUT_Msk (0x800UL)      /*!< EP5_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP5_IN_Pos (10UL)          /*!< EP5_IN (Bit 10)                                       */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP5_IN_Msk (0x400UL)       /*!< EP5_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP4_OUT_Pos (9UL)          /*!< EP4_OUT (Bit 9)                                       */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP4_OUT_Msk (0x200UL)      /*!< EP4_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP4_IN_Pos (8UL)           /*!< EP4_IN (Bit 8)                                        */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP4_IN_Msk (0x100UL)       /*!< EP4_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP3_OUT_Pos (7UL)          /*!< EP3_OUT (Bit 7)                                       */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP3_OUT_Msk (0x80UL)       /*!< EP3_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP3_IN_Pos (6UL)           /*!< EP3_IN (Bit 6)                                        */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP3_IN_Msk (0x40UL)        /*!< EP3_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP2_OUT_Pos (5UL)          /*!< EP2_OUT (Bit 5)                                       */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP2_OUT_Msk (0x20UL)       /*!< EP2_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP2_IN_Pos (4UL)           /*!< EP2_IN (Bit 4)                                        */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP2_IN_Msk (0x10UL)        /*!< EP2_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP1_OUT_Pos (3UL)          /*!< EP1_OUT (Bit 3)                                       */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP1_OUT_Msk (0x8UL)        /*!< EP1_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP1_IN_Pos (2UL)           /*!< EP1_IN (Bit 2)                                        */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP1_IN_Msk (0x4UL)         /*!< EP1_IN (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP0_OUT_Pos (1UL)          /*!< EP0_OUT (Bit 1)                                       */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP0_OUT_Msk (0x2UL)        /*!< EP0_OUT (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP0_IN_Pos (0UL)           /*!< EP0_IN (Bit 0)                                        */
#define USBCTRL_REGS_EP_STATUS_STALL_NAK_EP0_IN_Msk (0x1UL)         /*!< EP0_IN (Bitfield-Mask: 0x01)                          */
/* ======================================================  USB_MUXING  ======================================================= */
#define USBCTRL_REGS_USB_MUXING_SOFTCON_Pos (3UL)                   /*!< SOFTCON (Bit 3)                                       */
#define USBCTRL_REGS_USB_MUXING_SOFTCON_Msk (0x8UL)                 /*!< SOFTCON (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_USB_MUXING_TO_DIGITAL_PAD_Pos (2UL)            /*!< TO_DIGITAL_PAD (Bit 2)                                */
#define USBCTRL_REGS_USB_MUXING_TO_DIGITAL_PAD_Msk (0x4UL)          /*!< TO_DIGITAL_PAD (Bitfield-Mask: 0x01)                  */
#define USBCTRL_REGS_USB_MUXING_TO_EXTPHY_Pos (1UL)                 /*!< TO_EXTPHY (Bit 1)                                     */
#define USBCTRL_REGS_USB_MUXING_TO_EXTPHY_Msk (0x2UL)               /*!< TO_EXTPHY (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_USB_MUXING_TO_PHY_Pos (0UL)                    /*!< TO_PHY (Bit 0)                                        */
#define USBCTRL_REGS_USB_MUXING_TO_PHY_Msk (0x1UL)                  /*!< TO_PHY (Bitfield-Mask: 0x01)                          */
/* ========================================================  USB_PWR  ======================================================== */
#define USBCTRL_REGS_USB_PWR_OVERCURR_DETECT_EN_Pos (5UL)           /*!< OVERCURR_DETECT_EN (Bit 5)                            */
#define USBCTRL_REGS_USB_PWR_OVERCURR_DETECT_EN_Msk (0x20UL)        /*!< OVERCURR_DETECT_EN (Bitfield-Mask: 0x01)              */
#define USBCTRL_REGS_USB_PWR_OVERCURR_DETECT_Pos (4UL)              /*!< OVERCURR_DETECT (Bit 4)                               */
#define USBCTRL_REGS_USB_PWR_OVERCURR_DETECT_Msk (0x10UL)           /*!< OVERCURR_DETECT (Bitfield-Mask: 0x01)                 */
#define USBCTRL_REGS_USB_PWR_VBUS_DETECT_OVERRIDE_EN_Pos (3UL)      /*!< VBUS_DETECT_OVERRIDE_EN (Bit 3)                       */
#define USBCTRL_REGS_USB_PWR_VBUS_DETECT_OVERRIDE_EN_Msk (0x8UL)    /*!< VBUS_DETECT_OVERRIDE_EN (Bitfield-Mask: 0x01)         */
#define USBCTRL_REGS_USB_PWR_VBUS_DETECT_Pos (2UL)                  /*!< VBUS_DETECT (Bit 2)                                   */
#define USBCTRL_REGS_USB_PWR_VBUS_DETECT_Msk (0x4UL)                /*!< VBUS_DETECT (Bitfield-Mask: 0x01)                     */
#define USBCTRL_REGS_USB_PWR_VBUS_EN_OVERRIDE_EN_Pos (1UL)          /*!< VBUS_EN_OVERRIDE_EN (Bit 1)                           */
#define USBCTRL_REGS_USB_PWR_VBUS_EN_OVERRIDE_EN_Msk (0x2UL)        /*!< VBUS_EN_OVERRIDE_EN (Bitfield-Mask: 0x01)             */
#define USBCTRL_REGS_USB_PWR_VBUS_EN_Pos  (0UL)                     /*!< VBUS_EN (Bit 0)                                       */
#define USBCTRL_REGS_USB_PWR_VBUS_EN_Msk  (0x1UL)                   /*!< VBUS_EN (Bitfield-Mask: 0x01)                         */
/* =====================================================  USBPHY_DIRECT  ===================================================== */
#define USBCTRL_REGS_USBPHY_DIRECT_DM_OVV_Pos (22UL)                /*!< DM_OVV (Bit 22)                                       */
#define USBCTRL_REGS_USBPHY_DIRECT_DM_OVV_Msk (0x400000UL)          /*!< DM_OVV (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_USBPHY_DIRECT_DP_OVV_Pos (21UL)                /*!< DP_OVV (Bit 21)                                       */
#define USBCTRL_REGS_USBPHY_DIRECT_DP_OVV_Msk (0x200000UL)          /*!< DP_OVV (Bitfield-Mask: 0x01)                          */
#define USBCTRL_REGS_USBPHY_DIRECT_DM_OVCN_Pos (20UL)               /*!< DM_OVCN (Bit 20)                                      */
#define USBCTRL_REGS_USBPHY_DIRECT_DM_OVCN_Msk (0x100000UL)         /*!< DM_OVCN (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_USBPHY_DIRECT_DP_OVCN_Pos (19UL)               /*!< DP_OVCN (Bit 19)                                      */
#define USBCTRL_REGS_USBPHY_DIRECT_DP_OVCN_Msk (0x80000UL)          /*!< DP_OVCN (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_USBPHY_DIRECT_RX_DM_Pos (18UL)                 /*!< RX_DM (Bit 18)                                        */
#define USBCTRL_REGS_USBPHY_DIRECT_RX_DM_Msk (0x40000UL)            /*!< RX_DM (Bitfield-Mask: 0x01)                           */
#define USBCTRL_REGS_USBPHY_DIRECT_RX_DP_Pos (17UL)                 /*!< RX_DP (Bit 17)                                        */
#define USBCTRL_REGS_USBPHY_DIRECT_RX_DP_Msk (0x20000UL)            /*!< RX_DP (Bitfield-Mask: 0x01)                           */
#define USBCTRL_REGS_USBPHY_DIRECT_RX_DD_Pos (16UL)                 /*!< RX_DD (Bit 16)                                        */
#define USBCTRL_REGS_USBPHY_DIRECT_RX_DD_Msk (0x10000UL)            /*!< RX_DD (Bitfield-Mask: 0x01)                           */
#define USBCTRL_REGS_USBPHY_DIRECT_TX_DIFFMODE_Pos (15UL)           /*!< TX_DIFFMODE (Bit 15)                                  */
#define USBCTRL_REGS_USBPHY_DIRECT_TX_DIFFMODE_Msk (0x8000UL)       /*!< TX_DIFFMODE (Bitfield-Mask: 0x01)                     */
#define USBCTRL_REGS_USBPHY_DIRECT_TX_FSSLEW_Pos (14UL)             /*!< TX_FSSLEW (Bit 14)                                    */
#define USBCTRL_REGS_USBPHY_DIRECT_TX_FSSLEW_Msk (0x4000UL)         /*!< TX_FSSLEW (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_USBPHY_DIRECT_TX_PD_Pos (13UL)                 /*!< TX_PD (Bit 13)                                        */
#define USBCTRL_REGS_USBPHY_DIRECT_TX_PD_Msk (0x2000UL)             /*!< TX_PD (Bitfield-Mask: 0x01)                           */
#define USBCTRL_REGS_USBPHY_DIRECT_RX_PD_Pos (12UL)                 /*!< RX_PD (Bit 12)                                        */
#define USBCTRL_REGS_USBPHY_DIRECT_RX_PD_Msk (0x1000UL)             /*!< RX_PD (Bitfield-Mask: 0x01)                           */
#define USBCTRL_REGS_USBPHY_DIRECT_TX_DM_Pos (11UL)                 /*!< TX_DM (Bit 11)                                        */
#define USBCTRL_REGS_USBPHY_DIRECT_TX_DM_Msk (0x800UL)              /*!< TX_DM (Bitfield-Mask: 0x01)                           */
#define USBCTRL_REGS_USBPHY_DIRECT_TX_DP_Pos (10UL)                 /*!< TX_DP (Bit 10)                                        */
#define USBCTRL_REGS_USBPHY_DIRECT_TX_DP_Msk (0x400UL)              /*!< TX_DP (Bitfield-Mask: 0x01)                           */
#define USBCTRL_REGS_USBPHY_DIRECT_TX_DM_OE_Pos (9UL)               /*!< TX_DM_OE (Bit 9)                                      */
#define USBCTRL_REGS_USBPHY_DIRECT_TX_DM_OE_Msk (0x200UL)           /*!< TX_DM_OE (Bitfield-Mask: 0x01)                        */
#define USBCTRL_REGS_USBPHY_DIRECT_TX_DP_OE_Pos (8UL)               /*!< TX_DP_OE (Bit 8)                                      */
#define USBCTRL_REGS_USBPHY_DIRECT_TX_DP_OE_Msk (0x100UL)           /*!< TX_DP_OE (Bitfield-Mask: 0x01)                        */
#define USBCTRL_REGS_USBPHY_DIRECT_DM_PULLDN_EN_Pos (6UL)           /*!< DM_PULLDN_EN (Bit 6)                                  */
#define USBCTRL_REGS_USBPHY_DIRECT_DM_PULLDN_EN_Msk (0x40UL)        /*!< DM_PULLDN_EN (Bitfield-Mask: 0x01)                    */
#define USBCTRL_REGS_USBPHY_DIRECT_DM_PULLUP_EN_Pos (5UL)           /*!< DM_PULLUP_EN (Bit 5)                                  */
#define USBCTRL_REGS_USBPHY_DIRECT_DM_PULLUP_EN_Msk (0x20UL)        /*!< DM_PULLUP_EN (Bitfield-Mask: 0x01)                    */
#define USBCTRL_REGS_USBPHY_DIRECT_DM_PULLUP_HISEL_Pos (4UL)        /*!< DM_PULLUP_HISEL (Bit 4)                               */
#define USBCTRL_REGS_USBPHY_DIRECT_DM_PULLUP_HISEL_Msk (0x10UL)     /*!< DM_PULLUP_HISEL (Bitfield-Mask: 0x01)                 */
#define USBCTRL_REGS_USBPHY_DIRECT_DP_PULLDN_EN_Pos (2UL)           /*!< DP_PULLDN_EN (Bit 2)                                  */
#define USBCTRL_REGS_USBPHY_DIRECT_DP_PULLDN_EN_Msk (0x4UL)         /*!< DP_PULLDN_EN (Bitfield-Mask: 0x01)                    */
#define USBCTRL_REGS_USBPHY_DIRECT_DP_PULLUP_EN_Pos (1UL)           /*!< DP_PULLUP_EN (Bit 1)                                  */
#define USBCTRL_REGS_USBPHY_DIRECT_DP_PULLUP_EN_Msk (0x2UL)         /*!< DP_PULLUP_EN (Bitfield-Mask: 0x01)                    */
#define USBCTRL_REGS_USBPHY_DIRECT_DP_PULLUP_HISEL_Pos (0UL)        /*!< DP_PULLUP_HISEL (Bit 0)                               */
#define USBCTRL_REGS_USBPHY_DIRECT_DP_PULLUP_HISEL_Msk (0x1UL)      /*!< DP_PULLUP_HISEL (Bitfield-Mask: 0x01)                 */
/* ================================================  USBPHY_DIRECT_OVERRIDE  ================================================= */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DIFFMODE_OVERRIDE_EN_Pos (15UL) /*!< TX_DIFFMODE_OVERRIDE_EN (Bit 15)           */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DIFFMODE_OVERRIDE_EN_Msk (0x8000UL) /*!< TX_DIFFMODE_OVERRIDE_EN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DM_PULLUP_OVERRIDE_EN_Pos (12UL) /*!< DM_PULLUP_OVERRIDE_EN (Bit 12)               */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DM_PULLUP_OVERRIDE_EN_Msk (0x1000UL) /*!< DM_PULLUP_OVERRIDE_EN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_FSSLEW_OVERRIDE_EN_Pos (11UL) /*!< TX_FSSLEW_OVERRIDE_EN (Bit 11)               */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_FSSLEW_OVERRIDE_EN_Msk (0x800UL) /*!< TX_FSSLEW_OVERRIDE_EN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_PD_OVERRIDE_EN_Pos (10UL) /*!< TX_PD_OVERRIDE_EN (Bit 10)                       */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_PD_OVERRIDE_EN_Msk (0x400UL) /*!< TX_PD_OVERRIDE_EN (Bitfield-Mask: 0x01)       */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_RX_PD_OVERRIDE_EN_Pos (9UL) /*!< RX_PD_OVERRIDE_EN (Bit 9)                         */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_RX_PD_OVERRIDE_EN_Msk (0x200UL) /*!< RX_PD_OVERRIDE_EN (Bitfield-Mask: 0x01)       */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DM_OVERRIDE_EN_Pos (8UL) /*!< TX_DM_OVERRIDE_EN (Bit 8)                         */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DM_OVERRIDE_EN_Msk (0x100UL) /*!< TX_DM_OVERRIDE_EN (Bitfield-Mask: 0x01)       */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DP_OVERRIDE_EN_Pos (7UL) /*!< TX_DP_OVERRIDE_EN (Bit 7)                         */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DP_OVERRIDE_EN_Msk (0x80UL) /*!< TX_DP_OVERRIDE_EN (Bitfield-Mask: 0x01)        */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DM_OE_OVERRIDE_EN_Pos (6UL) /*!< TX_DM_OE_OVERRIDE_EN (Bit 6)                   */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DM_OE_OVERRIDE_EN_Msk (0x40UL) /*!< TX_DM_OE_OVERRIDE_EN (Bitfield-Mask: 0x01)  */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DP_OE_OVERRIDE_EN_Pos (5UL) /*!< TX_DP_OE_OVERRIDE_EN (Bit 5)                   */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_TX_DP_OE_OVERRIDE_EN_Msk (0x20UL) /*!< TX_DP_OE_OVERRIDE_EN (Bitfield-Mask: 0x01)  */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DM_PULLDN_EN_OVERRIDE_EN_Pos (4UL) /*!< DM_PULLDN_EN_OVERRIDE_EN (Bit 4)           */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DM_PULLDN_EN_OVERRIDE_EN_Msk (0x10UL) /*!< DM_PULLDN_EN_OVERRIDE_EN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DP_PULLDN_EN_OVERRIDE_EN_Pos (3UL) /*!< DP_PULLDN_EN_OVERRIDE_EN (Bit 3)           */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DP_PULLDN_EN_OVERRIDE_EN_Msk (0x8UL) /*!< DP_PULLDN_EN_OVERRIDE_EN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DP_PULLUP_EN_OVERRIDE_EN_Pos (2UL) /*!< DP_PULLUP_EN_OVERRIDE_EN (Bit 2)           */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DP_PULLUP_EN_OVERRIDE_EN_Msk (0x4UL) /*!< DP_PULLUP_EN_OVERRIDE_EN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DM_PULLUP_HISEL_OVERRIDE_EN_Pos (1UL) /*!< DM_PULLUP_HISEL_OVERRIDE_EN (Bit 1)     */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DM_PULLUP_HISEL_OVERRIDE_EN_Msk (0x2UL) /*!< DM_PULLUP_HISEL_OVERRIDE_EN (Bitfield-Mask: 0x01) */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DP_PULLUP_HISEL_OVERRIDE_EN_Pos (0UL) /*!< DP_PULLUP_HISEL_OVERRIDE_EN (Bit 0)     */
#define USBCTRL_REGS_USBPHY_DIRECT_OVERRIDE_DP_PULLUP_HISEL_OVERRIDE_EN_Msk (0x1UL) /*!< DP_PULLUP_HISEL_OVERRIDE_EN (Bitfield-Mask: 0x01) */
/* ======================================================  USBPHY_TRIM  ====================================================== */
#define USBCTRL_REGS_USBPHY_TRIM_DM_PULLDN_TRIM_Pos (8UL)           /*!< DM_PULLDN_TRIM (Bit 8)                                */
#define USBCTRL_REGS_USBPHY_TRIM_DM_PULLDN_TRIM_Msk (0x1f00UL)      /*!< DM_PULLDN_TRIM (Bitfield-Mask: 0x1f)                  */
#define USBCTRL_REGS_USBPHY_TRIM_DP_PULLDN_TRIM_Pos (0UL)           /*!< DP_PULLDN_TRIM (Bit 0)                                */
#define USBCTRL_REGS_USBPHY_TRIM_DP_PULLDN_TRIM_Msk (0x1fUL)        /*!< DP_PULLDN_TRIM (Bitfield-Mask: 0x1f)                  */
/* =========================================================  INTR  ========================================================== */
#define USBCTRL_REGS_INTR_EP_STALL_NAK_Pos (19UL)                   /*!< EP_STALL_NAK (Bit 19)                                 */
#define USBCTRL_REGS_INTR_EP_STALL_NAK_Msk (0x80000UL)              /*!< EP_STALL_NAK (Bitfield-Mask: 0x01)                    */
#define USBCTRL_REGS_INTR_ABORT_DONE_Pos  (18UL)                    /*!< ABORT_DONE (Bit 18)                                   */
#define USBCTRL_REGS_INTR_ABORT_DONE_Msk  (0x40000UL)               /*!< ABORT_DONE (Bitfield-Mask: 0x01)                      */
#define USBCTRL_REGS_INTR_DEV_SOF_Pos     (17UL)                    /*!< DEV_SOF (Bit 17)                                      */
#define USBCTRL_REGS_INTR_DEV_SOF_Msk     (0x20000UL)               /*!< DEV_SOF (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_INTR_SETUP_REQ_Pos   (16UL)                    /*!< SETUP_REQ (Bit 16)                                    */
#define USBCTRL_REGS_INTR_SETUP_REQ_Msk   (0x10000UL)               /*!< SETUP_REQ (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_INTR_DEV_RESUME_FROM_HOST_Pos (15UL)           /*!< DEV_RESUME_FROM_HOST (Bit 15)                         */
#define USBCTRL_REGS_INTR_DEV_RESUME_FROM_HOST_Msk (0x8000UL)       /*!< DEV_RESUME_FROM_HOST (Bitfield-Mask: 0x01)            */
#define USBCTRL_REGS_INTR_DEV_SUSPEND_Pos (14UL)                    /*!< DEV_SUSPEND (Bit 14)                                  */
#define USBCTRL_REGS_INTR_DEV_SUSPEND_Msk (0x4000UL)                /*!< DEV_SUSPEND (Bitfield-Mask: 0x01)                     */
#define USBCTRL_REGS_INTR_DEV_CONN_DIS_Pos (13UL)                   /*!< DEV_CONN_DIS (Bit 13)                                 */
#define USBCTRL_REGS_INTR_DEV_CONN_DIS_Msk (0x2000UL)               /*!< DEV_CONN_DIS (Bitfield-Mask: 0x01)                    */
#define USBCTRL_REGS_INTR_BUS_RESET_Pos   (12UL)                    /*!< BUS_RESET (Bit 12)                                    */
#define USBCTRL_REGS_INTR_BUS_RESET_Msk   (0x1000UL)                /*!< BUS_RESET (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_INTR_VBUS_DETECT_Pos (11UL)                    /*!< VBUS_DETECT (Bit 11)                                  */
#define USBCTRL_REGS_INTR_VBUS_DETECT_Msk (0x800UL)                 /*!< VBUS_DETECT (Bitfield-Mask: 0x01)                     */
#define USBCTRL_REGS_INTR_STALL_Pos       (10UL)                    /*!< STALL (Bit 10)                                        */
#define USBCTRL_REGS_INTR_STALL_Msk       (0x400UL)                 /*!< STALL (Bitfield-Mask: 0x01)                           */
#define USBCTRL_REGS_INTR_ERROR_CRC_Pos   (9UL)                     /*!< ERROR_CRC (Bit 9)                                     */
#define USBCTRL_REGS_INTR_ERROR_CRC_Msk   (0x200UL)                 /*!< ERROR_CRC (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_INTR_ERROR_BIT_STUFF_Pos (8UL)                 /*!< ERROR_BIT_STUFF (Bit 8)                               */
#define USBCTRL_REGS_INTR_ERROR_BIT_STUFF_Msk (0x100UL)             /*!< ERROR_BIT_STUFF (Bitfield-Mask: 0x01)                 */
#define USBCTRL_REGS_INTR_ERROR_RX_OVERFLOW_Pos (7UL)               /*!< ERROR_RX_OVERFLOW (Bit 7)                             */
#define USBCTRL_REGS_INTR_ERROR_RX_OVERFLOW_Msk (0x80UL)            /*!< ERROR_RX_OVERFLOW (Bitfield-Mask: 0x01)               */
#define USBCTRL_REGS_INTR_ERROR_RX_TIMEOUT_Pos (6UL)                /*!< ERROR_RX_TIMEOUT (Bit 6)                              */
#define USBCTRL_REGS_INTR_ERROR_RX_TIMEOUT_Msk (0x40UL)             /*!< ERROR_RX_TIMEOUT (Bitfield-Mask: 0x01)                */
#define USBCTRL_REGS_INTR_ERROR_DATA_SEQ_Pos (5UL)                  /*!< ERROR_DATA_SEQ (Bit 5)                                */
#define USBCTRL_REGS_INTR_ERROR_DATA_SEQ_Msk (0x20UL)               /*!< ERROR_DATA_SEQ (Bitfield-Mask: 0x01)                  */
#define USBCTRL_REGS_INTR_BUFF_STATUS_Pos (4UL)                     /*!< BUFF_STATUS (Bit 4)                                   */
#define USBCTRL_REGS_INTR_BUFF_STATUS_Msk (0x10UL)                  /*!< BUFF_STATUS (Bitfield-Mask: 0x01)                     */
#define USBCTRL_REGS_INTR_TRANS_COMPLETE_Pos (3UL)                  /*!< TRANS_COMPLETE (Bit 3)                                */
#define USBCTRL_REGS_INTR_TRANS_COMPLETE_Msk (0x8UL)                /*!< TRANS_COMPLETE (Bitfield-Mask: 0x01)                  */
#define USBCTRL_REGS_INTR_HOST_SOF_Pos    (2UL)                     /*!< HOST_SOF (Bit 2)                                      */
#define USBCTRL_REGS_INTR_HOST_SOF_Msk    (0x4UL)                   /*!< HOST_SOF (Bitfield-Mask: 0x01)                        */
#define USBCTRL_REGS_INTR_HOST_RESUME_Pos (1UL)                     /*!< HOST_RESUME (Bit 1)                                   */
#define USBCTRL_REGS_INTR_HOST_RESUME_Msk (0x2UL)                   /*!< HOST_RESUME (Bitfield-Mask: 0x01)                     */
#define USBCTRL_REGS_INTR_HOST_CONN_DIS_Pos (0UL)                   /*!< HOST_CONN_DIS (Bit 0)                                 */
#define USBCTRL_REGS_INTR_HOST_CONN_DIS_Msk (0x1UL)                 /*!< HOST_CONN_DIS (Bitfield-Mask: 0x01)                   */
/* =========================================================  INTE  ========================================================== */
#define USBCTRL_REGS_INTE_EP_STALL_NAK_Pos (19UL)                   /*!< EP_STALL_NAK (Bit 19)                                 */
#define USBCTRL_REGS_INTE_EP_STALL_NAK_Msk (0x80000UL)              /*!< EP_STALL_NAK (Bitfield-Mask: 0x01)                    */
#define USBCTRL_REGS_INTE_ABORT_DONE_Pos  (18UL)                    /*!< ABORT_DONE (Bit 18)                                   */
#define USBCTRL_REGS_INTE_ABORT_DONE_Msk  (0x40000UL)               /*!< ABORT_DONE (Bitfield-Mask: 0x01)                      */
#define USBCTRL_REGS_INTE_DEV_SOF_Pos     (17UL)                    /*!< DEV_SOF (Bit 17)                                      */
#define USBCTRL_REGS_INTE_DEV_SOF_Msk     (0x20000UL)               /*!< DEV_SOF (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_INTE_SETUP_REQ_Pos   (16UL)                    /*!< SETUP_REQ (Bit 16)                                    */
#define USBCTRL_REGS_INTE_SETUP_REQ_Msk   (0x10000UL)               /*!< SETUP_REQ (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_INTE_DEV_RESUME_FROM_HOST_Pos (15UL)           /*!< DEV_RESUME_FROM_HOST (Bit 15)                         */
#define USBCTRL_REGS_INTE_DEV_RESUME_FROM_HOST_Msk (0x8000UL)       /*!< DEV_RESUME_FROM_HOST (Bitfield-Mask: 0x01)            */
#define USBCTRL_REGS_INTE_DEV_SUSPEND_Pos (14UL)                    /*!< DEV_SUSPEND (Bit 14)                                  */
#define USBCTRL_REGS_INTE_DEV_SUSPEND_Msk (0x4000UL)                /*!< DEV_SUSPEND (Bitfield-Mask: 0x01)                     */
#define USBCTRL_REGS_INTE_DEV_CONN_DIS_Pos (13UL)                   /*!< DEV_CONN_DIS (Bit 13)                                 */
#define USBCTRL_REGS_INTE_DEV_CONN_DIS_Msk (0x2000UL)               /*!< DEV_CONN_DIS (Bitfield-Mask: 0x01)                    */
#define USBCTRL_REGS_INTE_BUS_RESET_Pos   (12UL)                    /*!< BUS_RESET (Bit 12)                                    */
#define USBCTRL_REGS_INTE_BUS_RESET_Msk   (0x1000UL)                /*!< BUS_RESET (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_INTE_VBUS_DETECT_Pos (11UL)                    /*!< VBUS_DETECT (Bit 11)                                  */
#define USBCTRL_REGS_INTE_VBUS_DETECT_Msk (0x800UL)                 /*!< VBUS_DETECT (Bitfield-Mask: 0x01)                     */
#define USBCTRL_REGS_INTE_STALL_Pos       (10UL)                    /*!< STALL (Bit 10)                                        */
#define USBCTRL_REGS_INTE_STALL_Msk       (0x400UL)                 /*!< STALL (Bitfield-Mask: 0x01)                           */
#define USBCTRL_REGS_INTE_ERROR_CRC_Pos   (9UL)                     /*!< ERROR_CRC (Bit 9)                                     */
#define USBCTRL_REGS_INTE_ERROR_CRC_Msk   (0x200UL)                 /*!< ERROR_CRC (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_INTE_ERROR_BIT_STUFF_Pos (8UL)                 /*!< ERROR_BIT_STUFF (Bit 8)                               */
#define USBCTRL_REGS_INTE_ERROR_BIT_STUFF_Msk (0x100UL)             /*!< ERROR_BIT_STUFF (Bitfield-Mask: 0x01)                 */
#define USBCTRL_REGS_INTE_ERROR_RX_OVERFLOW_Pos (7UL)               /*!< ERROR_RX_OVERFLOW (Bit 7)                             */
#define USBCTRL_REGS_INTE_ERROR_RX_OVERFLOW_Msk (0x80UL)            /*!< ERROR_RX_OVERFLOW (Bitfield-Mask: 0x01)               */
#define USBCTRL_REGS_INTE_ERROR_RX_TIMEOUT_Pos (6UL)                /*!< ERROR_RX_TIMEOUT (Bit 6)                              */
#define USBCTRL_REGS_INTE_ERROR_RX_TIMEOUT_Msk (0x40UL)             /*!< ERROR_RX_TIMEOUT (Bitfield-Mask: 0x01)                */
#define USBCTRL_REGS_INTE_ERROR_DATA_SEQ_Pos (5UL)                  /*!< ERROR_DATA_SEQ (Bit 5)                                */
#define USBCTRL_REGS_INTE_ERROR_DATA_SEQ_Msk (0x20UL)               /*!< ERROR_DATA_SEQ (Bitfield-Mask: 0x01)                  */
#define USBCTRL_REGS_INTE_BUFF_STATUS_Pos (4UL)                     /*!< BUFF_STATUS (Bit 4)                                   */
#define USBCTRL_REGS_INTE_BUFF_STATUS_Msk (0x10UL)                  /*!< BUFF_STATUS (Bitfield-Mask: 0x01)                     */
#define USBCTRL_REGS_INTE_TRANS_COMPLETE_Pos (3UL)                  /*!< TRANS_COMPLETE (Bit 3)                                */
#define USBCTRL_REGS_INTE_TRANS_COMPLETE_Msk (0x8UL)                /*!< TRANS_COMPLETE (Bitfield-Mask: 0x01)                  */
#define USBCTRL_REGS_INTE_HOST_SOF_Pos    (2UL)                     /*!< HOST_SOF (Bit 2)                                      */
#define USBCTRL_REGS_INTE_HOST_SOF_Msk    (0x4UL)                   /*!< HOST_SOF (Bitfield-Mask: 0x01)                        */
#define USBCTRL_REGS_INTE_HOST_RESUME_Pos (1UL)                     /*!< HOST_RESUME (Bit 1)                                   */
#define USBCTRL_REGS_INTE_HOST_RESUME_Msk (0x2UL)                   /*!< HOST_RESUME (Bitfield-Mask: 0x01)                     */
#define USBCTRL_REGS_INTE_HOST_CONN_DIS_Pos (0UL)                   /*!< HOST_CONN_DIS (Bit 0)                                 */
#define USBCTRL_REGS_INTE_HOST_CONN_DIS_Msk (0x1UL)                 /*!< HOST_CONN_DIS (Bitfield-Mask: 0x01)                   */
/* =========================================================  INTF  ========================================================== */
#define USBCTRL_REGS_INTF_EP_STALL_NAK_Pos (19UL)                   /*!< EP_STALL_NAK (Bit 19)                                 */
#define USBCTRL_REGS_INTF_EP_STALL_NAK_Msk (0x80000UL)              /*!< EP_STALL_NAK (Bitfield-Mask: 0x01)                    */
#define USBCTRL_REGS_INTF_ABORT_DONE_Pos  (18UL)                    /*!< ABORT_DONE (Bit 18)                                   */
#define USBCTRL_REGS_INTF_ABORT_DONE_Msk  (0x40000UL)               /*!< ABORT_DONE (Bitfield-Mask: 0x01)                      */
#define USBCTRL_REGS_INTF_DEV_SOF_Pos     (17UL)                    /*!< DEV_SOF (Bit 17)                                      */
#define USBCTRL_REGS_INTF_DEV_SOF_Msk     (0x20000UL)               /*!< DEV_SOF (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_INTF_SETUP_REQ_Pos   (16UL)                    /*!< SETUP_REQ (Bit 16)                                    */
#define USBCTRL_REGS_INTF_SETUP_REQ_Msk   (0x10000UL)               /*!< SETUP_REQ (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_INTF_DEV_RESUME_FROM_HOST_Pos (15UL)           /*!< DEV_RESUME_FROM_HOST (Bit 15)                         */
#define USBCTRL_REGS_INTF_DEV_RESUME_FROM_HOST_Msk (0x8000UL)       /*!< DEV_RESUME_FROM_HOST (Bitfield-Mask: 0x01)            */
#define USBCTRL_REGS_INTF_DEV_SUSPEND_Pos (14UL)                    /*!< DEV_SUSPEND (Bit 14)                                  */
#define USBCTRL_REGS_INTF_DEV_SUSPEND_Msk (0x4000UL)                /*!< DEV_SUSPEND (Bitfield-Mask: 0x01)                     */
#define USBCTRL_REGS_INTF_DEV_CONN_DIS_Pos (13UL)                   /*!< DEV_CONN_DIS (Bit 13)                                 */
#define USBCTRL_REGS_INTF_DEV_CONN_DIS_Msk (0x2000UL)               /*!< DEV_CONN_DIS (Bitfield-Mask: 0x01)                    */
#define USBCTRL_REGS_INTF_BUS_RESET_Pos   (12UL)                    /*!< BUS_RESET (Bit 12)                                    */
#define USBCTRL_REGS_INTF_BUS_RESET_Msk   (0x1000UL)                /*!< BUS_RESET (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_INTF_VBUS_DETECT_Pos (11UL)                    /*!< VBUS_DETECT (Bit 11)                                  */
#define USBCTRL_REGS_INTF_VBUS_DETECT_Msk (0x800UL)                 /*!< VBUS_DETECT (Bitfield-Mask: 0x01)                     */
#define USBCTRL_REGS_INTF_STALL_Pos       (10UL)                    /*!< STALL (Bit 10)                                        */
#define USBCTRL_REGS_INTF_STALL_Msk       (0x400UL)                 /*!< STALL (Bitfield-Mask: 0x01)                           */
#define USBCTRL_REGS_INTF_ERROR_CRC_Pos   (9UL)                     /*!< ERROR_CRC (Bit 9)                                     */
#define USBCTRL_REGS_INTF_ERROR_CRC_Msk   (0x200UL)                 /*!< ERROR_CRC (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_INTF_ERROR_BIT_STUFF_Pos (8UL)                 /*!< ERROR_BIT_STUFF (Bit 8)                               */
#define USBCTRL_REGS_INTF_ERROR_BIT_STUFF_Msk (0x100UL)             /*!< ERROR_BIT_STUFF (Bitfield-Mask: 0x01)                 */
#define USBCTRL_REGS_INTF_ERROR_RX_OVERFLOW_Pos (7UL)               /*!< ERROR_RX_OVERFLOW (Bit 7)                             */
#define USBCTRL_REGS_INTF_ERROR_RX_OVERFLOW_Msk (0x80UL)            /*!< ERROR_RX_OVERFLOW (Bitfield-Mask: 0x01)               */
#define USBCTRL_REGS_INTF_ERROR_RX_TIMEOUT_Pos (6UL)                /*!< ERROR_RX_TIMEOUT (Bit 6)                              */
#define USBCTRL_REGS_INTF_ERROR_RX_TIMEOUT_Msk (0x40UL)             /*!< ERROR_RX_TIMEOUT (Bitfield-Mask: 0x01)                */
#define USBCTRL_REGS_INTF_ERROR_DATA_SEQ_Pos (5UL)                  /*!< ERROR_DATA_SEQ (Bit 5)                                */
#define USBCTRL_REGS_INTF_ERROR_DATA_SEQ_Msk (0x20UL)               /*!< ERROR_DATA_SEQ (Bitfield-Mask: 0x01)                  */
#define USBCTRL_REGS_INTF_BUFF_STATUS_Pos (4UL)                     /*!< BUFF_STATUS (Bit 4)                                   */
#define USBCTRL_REGS_INTF_BUFF_STATUS_Msk (0x10UL)                  /*!< BUFF_STATUS (Bitfield-Mask: 0x01)                     */
#define USBCTRL_REGS_INTF_TRANS_COMPLETE_Pos (3UL)                  /*!< TRANS_COMPLETE (Bit 3)                                */
#define USBCTRL_REGS_INTF_TRANS_COMPLETE_Msk (0x8UL)                /*!< TRANS_COMPLETE (Bitfield-Mask: 0x01)                  */
#define USBCTRL_REGS_INTF_HOST_SOF_Pos    (2UL)                     /*!< HOST_SOF (Bit 2)                                      */
#define USBCTRL_REGS_INTF_HOST_SOF_Msk    (0x4UL)                   /*!< HOST_SOF (Bitfield-Mask: 0x01)                        */
#define USBCTRL_REGS_INTF_HOST_RESUME_Pos (1UL)                     /*!< HOST_RESUME (Bit 1)                                   */
#define USBCTRL_REGS_INTF_HOST_RESUME_Msk (0x2UL)                   /*!< HOST_RESUME (Bitfield-Mask: 0x01)                     */
#define USBCTRL_REGS_INTF_HOST_CONN_DIS_Pos (0UL)                   /*!< HOST_CONN_DIS (Bit 0)                                 */
#define USBCTRL_REGS_INTF_HOST_CONN_DIS_Msk (0x1UL)                 /*!< HOST_CONN_DIS (Bitfield-Mask: 0x01)                   */
/* =========================================================  INTS  ========================================================== */
#define USBCTRL_REGS_INTS_EP_STALL_NAK_Pos (19UL)                   /*!< EP_STALL_NAK (Bit 19)                                 */
#define USBCTRL_REGS_INTS_EP_STALL_NAK_Msk (0x80000UL)              /*!< EP_STALL_NAK (Bitfield-Mask: 0x01)                    */
#define USBCTRL_REGS_INTS_ABORT_DONE_Pos  (18UL)                    /*!< ABORT_DONE (Bit 18)                                   */
#define USBCTRL_REGS_INTS_ABORT_DONE_Msk  (0x40000UL)               /*!< ABORT_DONE (Bitfield-Mask: 0x01)                      */
#define USBCTRL_REGS_INTS_DEV_SOF_Pos     (17UL)                    /*!< DEV_SOF (Bit 17)                                      */
#define USBCTRL_REGS_INTS_DEV_SOF_Msk     (0x20000UL)               /*!< DEV_SOF (Bitfield-Mask: 0x01)                         */
#define USBCTRL_REGS_INTS_SETUP_REQ_Pos   (16UL)                    /*!< SETUP_REQ (Bit 16)                                    */
#define USBCTRL_REGS_INTS_SETUP_REQ_Msk   (0x10000UL)               /*!< SETUP_REQ (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_INTS_DEV_RESUME_FROM_HOST_Pos (15UL)           /*!< DEV_RESUME_FROM_HOST (Bit 15)                         */
#define USBCTRL_REGS_INTS_DEV_RESUME_FROM_HOST_Msk (0x8000UL)       /*!< DEV_RESUME_FROM_HOST (Bitfield-Mask: 0x01)            */
#define USBCTRL_REGS_INTS_DEV_SUSPEND_Pos (14UL)                    /*!< DEV_SUSPEND (Bit 14)                                  */
#define USBCTRL_REGS_INTS_DEV_SUSPEND_Msk (0x4000UL)                /*!< DEV_SUSPEND (Bitfield-Mask: 0x01)                     */
#define USBCTRL_REGS_INTS_DEV_CONN_DIS_Pos (13UL)                   /*!< DEV_CONN_DIS (Bit 13)                                 */
#define USBCTRL_REGS_INTS_DEV_CONN_DIS_Msk (0x2000UL)               /*!< DEV_CONN_DIS (Bitfield-Mask: 0x01)                    */
#define USBCTRL_REGS_INTS_BUS_RESET_Pos   (12UL)                    /*!< BUS_RESET (Bit 12)                                    */
#define USBCTRL_REGS_INTS_BUS_RESET_Msk   (0x1000UL)                /*!< BUS_RESET (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_INTS_VBUS_DETECT_Pos (11UL)                    /*!< VBUS_DETECT (Bit 11)                                  */
#define USBCTRL_REGS_INTS_VBUS_DETECT_Msk (0x800UL)                 /*!< VBUS_DETECT (Bitfield-Mask: 0x01)                     */
#define USBCTRL_REGS_INTS_STALL_Pos       (10UL)                    /*!< STALL (Bit 10)                                        */
#define USBCTRL_REGS_INTS_STALL_Msk       (0x400UL)                 /*!< STALL (Bitfield-Mask: 0x01)                           */
#define USBCTRL_REGS_INTS_ERROR_CRC_Pos   (9UL)                     /*!< ERROR_CRC (Bit 9)                                     */
#define USBCTRL_REGS_INTS_ERROR_CRC_Msk   (0x200UL)                 /*!< ERROR_CRC (Bitfield-Mask: 0x01)                       */
#define USBCTRL_REGS_INTS_ERROR_BIT_STUFF_Pos (8UL)                 /*!< ERROR_BIT_STUFF (Bit 8)                               */
#define USBCTRL_REGS_INTS_ERROR_BIT_STUFF_Msk (0x100UL)             /*!< ERROR_BIT_STUFF (Bitfield-Mask: 0x01)                 */
#define USBCTRL_REGS_INTS_ERROR_RX_OVERFLOW_Pos (7UL)               /*!< ERROR_RX_OVERFLOW (Bit 7)                             */
#define USBCTRL_REGS_INTS_ERROR_RX_OVERFLOW_Msk (0x80UL)            /*!< ERROR_RX_OVERFLOW (Bitfield-Mask: 0x01)               */
#define USBCTRL_REGS_INTS_ERROR_RX_TIMEOUT_Pos (6UL)                /*!< ERROR_RX_TIMEOUT (Bit 6)                              */
#define USBCTRL_REGS_INTS_ERROR_RX_TIMEOUT_Msk (0x40UL)             /*!< ERROR_RX_TIMEOUT (Bitfield-Mask: 0x01)                */
#define USBCTRL_REGS_INTS_ERROR_DATA_SEQ_Pos (5UL)                  /*!< ERROR_DATA_SEQ (Bit 5)                                */
#define USBCTRL_REGS_INTS_ERROR_DATA_SEQ_Msk (0x20UL)               /*!< ERROR_DATA_SEQ (Bitfield-Mask: 0x01)                  */
#define USBCTRL_REGS_INTS_BUFF_STATUS_Pos (4UL)                     /*!< BUFF_STATUS (Bit 4)                                   */
#define USBCTRL_REGS_INTS_BUFF_STATUS_Msk (0x10UL)                  /*!< BUFF_STATUS (Bitfield-Mask: 0x01)                     */
#define USBCTRL_REGS_INTS_TRANS_COMPLETE_Pos (3UL)                  /*!< TRANS_COMPLETE (Bit 3)                                */
#define USBCTRL_REGS_INTS_TRANS_COMPLETE_Msk (0x8UL)                /*!< TRANS_COMPLETE (Bitfield-Mask: 0x01)                  */
#define USBCTRL_REGS_INTS_HOST_SOF_Pos    (2UL)                     /*!< HOST_SOF (Bit 2)                                      */
#define USBCTRL_REGS_INTS_HOST_SOF_Msk    (0x4UL)                   /*!< HOST_SOF (Bitfield-Mask: 0x01)                        */
#define USBCTRL_REGS_INTS_HOST_RESUME_Pos (1UL)                     /*!< HOST_RESUME (Bit 1)                                   */
#define USBCTRL_REGS_INTS_HOST_RESUME_Msk (0x2UL)                   /*!< HOST_RESUME (Bitfield-Mask: 0x01)                     */
#define USBCTRL_REGS_INTS_HOST_CONN_DIS_Pos (0UL)                   /*!< HOST_CONN_DIS (Bit 0)                                 */
#define USBCTRL_REGS_INTS_HOST_CONN_DIS_Msk (0x1UL)                 /*!< HOST_CONN_DIS (Bitfield-Mask: 0x01)                   */


/* =========================================================================================================================== */
/* ================                                           PIO0                                            ================ */
/* =========================================================================================================================== */

/* =========================================================  CTRL  ========================================================== */
#define PIO0_CTRL_CLKDIV_RESTART_Pos      (8UL)                     /*!< CLKDIV_RESTART (Bit 8)                                */
#define PIO0_CTRL_CLKDIV_RESTART_Msk      (0xf00UL)                 /*!< CLKDIV_RESTART (Bitfield-Mask: 0x0f)                  */
#define PIO0_CTRL_SM_RESTART_Pos          (4UL)                     /*!< SM_RESTART (Bit 4)                                    */
#define PIO0_CTRL_SM_RESTART_Msk          (0xf0UL)                  /*!< SM_RESTART (Bitfield-Mask: 0x0f)                      */
#define PIO0_CTRL_SM_ENABLE_Pos           (0UL)                     /*!< SM_ENABLE (Bit 0)                                     */
#define PIO0_CTRL_SM_ENABLE_Msk           (0xfUL)                   /*!< SM_ENABLE (Bitfield-Mask: 0x0f)                       */
/* =========================================================  FSTAT  ========================================================= */
#define PIO0_FSTAT_TXEMPTY_Pos            (24UL)                    /*!< TXEMPTY (Bit 24)                                      */
#define PIO0_FSTAT_TXEMPTY_Msk            (0xf000000UL)             /*!< TXEMPTY (Bitfield-Mask: 0x0f)                         */
#define PIO0_FSTAT_TXFULL_Pos             (16UL)                    /*!< TXFULL (Bit 16)                                       */
#define PIO0_FSTAT_TXFULL_Msk             (0xf0000UL)               /*!< TXFULL (Bitfield-Mask: 0x0f)                          */
#define PIO0_FSTAT_RXEMPTY_Pos            (8UL)                     /*!< RXEMPTY (Bit 8)                                       */
#define PIO0_FSTAT_RXEMPTY_Msk            (0xf00UL)                 /*!< RXEMPTY (Bitfield-Mask: 0x0f)                         */
#define PIO0_FSTAT_RXFULL_Pos             (0UL)                     /*!< RXFULL (Bit 0)                                        */
#define PIO0_FSTAT_RXFULL_Msk             (0xfUL)                   /*!< RXFULL (Bitfield-Mask: 0x0f)                          */
/* ========================================================  FDEBUG  ========================================================= */
#define PIO0_FDEBUG_TXSTALL_Pos           (24UL)                    /*!< TXSTALL (Bit 24)                                      */
#define PIO0_FDEBUG_TXSTALL_Msk           (0xf000000UL)             /*!< TXSTALL (Bitfield-Mask: 0x0f)                         */
#define PIO0_FDEBUG_TXOVER_Pos            (16UL)                    /*!< TXOVER (Bit 16)                                       */
#define PIO0_FDEBUG_TXOVER_Msk            (0xf0000UL)               /*!< TXOVER (Bitfield-Mask: 0x0f)                          */
#define PIO0_FDEBUG_RXUNDER_Pos           (8UL)                     /*!< RXUNDER (Bit 8)                                       */
#define PIO0_FDEBUG_RXUNDER_Msk           (0xf00UL)                 /*!< RXUNDER (Bitfield-Mask: 0x0f)                         */
#define PIO0_FDEBUG_RXSTALL_Pos           (0UL)                     /*!< RXSTALL (Bit 0)                                       */
#define PIO0_FDEBUG_RXSTALL_Msk           (0xfUL)                   /*!< RXSTALL (Bitfield-Mask: 0x0f)                         */
/* ========================================================  FLEVEL  ========================================================= */
#define PIO0_FLEVEL_RX3_Pos               (28UL)                    /*!< RX3 (Bit 28)                                          */
#define PIO0_FLEVEL_RX3_Msk               (0xf0000000UL)            /*!< RX3 (Bitfield-Mask: 0x0f)                             */
#define PIO0_FLEVEL_TX3_Pos               (24UL)                    /*!< TX3 (Bit 24)                                          */
#define PIO0_FLEVEL_TX3_Msk               (0xf000000UL)             /*!< TX3 (Bitfield-Mask: 0x0f)                             */
#define PIO0_FLEVEL_RX2_Pos               (20UL)                    /*!< RX2 (Bit 20)                                          */
#define PIO0_FLEVEL_RX2_Msk               (0xf00000UL)              /*!< RX2 (Bitfield-Mask: 0x0f)                             */
#define PIO0_FLEVEL_TX2_Pos               (16UL)                    /*!< TX2 (Bit 16)                                          */
#define PIO0_FLEVEL_TX2_Msk               (0xf0000UL)               /*!< TX2 (Bitfield-Mask: 0x0f)                             */
#define PIO0_FLEVEL_RX1_Pos               (12UL)                    /*!< RX1 (Bit 12)                                          */
#define PIO0_FLEVEL_RX1_Msk               (0xf000UL)                /*!< RX1 (Bitfield-Mask: 0x0f)                             */
#define PIO0_FLEVEL_TX1_Pos               (8UL)                     /*!< TX1 (Bit 8)                                           */
#define PIO0_FLEVEL_TX1_Msk               (0xf00UL)                 /*!< TX1 (Bitfield-Mask: 0x0f)                             */
#define PIO0_FLEVEL_RX0_Pos               (4UL)                     /*!< RX0 (Bit 4)                                           */
#define PIO0_FLEVEL_RX0_Msk               (0xf0UL)                  /*!< RX0 (Bitfield-Mask: 0x0f)                             */
#define PIO0_FLEVEL_TX0_Pos               (0UL)                     /*!< TX0 (Bit 0)                                           */
#define PIO0_FLEVEL_TX0_Msk               (0xfUL)                   /*!< TX0 (Bitfield-Mask: 0x0f)                             */
/* =========================================================  TXF0  ========================================================== */
/* =========================================================  TXF1  ========================================================== */
/* =========================================================  TXF2  ========================================================== */
/* =========================================================  TXF3  ========================================================== */
/* =========================================================  RXF0  ========================================================== */
/* =========================================================  RXF1  ========================================================== */
/* =========================================================  RXF2  ========================================================== */
/* =========================================================  RXF3  ========================================================== */
/* ==========================================================  IRQ  ========================================================== */
#define PIO0_IRQ_IRQ_Pos                  (0UL)                     /*!< IRQ (Bit 0)                                           */
#define PIO0_IRQ_IRQ_Msk                  (0xffUL)                  /*!< IRQ (Bitfield-Mask: 0xff)                             */
/* =======================================================  IRQ_FORCE  ======================================================= */
#define PIO0_IRQ_FORCE_IRQ_FORCE_Pos      (0UL)                     /*!< IRQ_FORCE (Bit 0)                                     */
#define PIO0_IRQ_FORCE_IRQ_FORCE_Msk      (0xffUL)                  /*!< IRQ_FORCE (Bitfield-Mask: 0xff)                       */
/* ===================================================  INPUT_SYNC_BYPASS  =================================================== */
/* ======================================================  DBG_PADOUT  ======================================================= */
/* =======================================================  DBG_PADOE  ======================================================= */
/* ======================================================  DBG_CFGINFO  ====================================================== */
#define PIO0_DBG_CFGINFO_IMEM_SIZE_Pos    (16UL)                    /*!< IMEM_SIZE (Bit 16)                                    */
#define PIO0_DBG_CFGINFO_IMEM_SIZE_Msk    (0x3f0000UL)              /*!< IMEM_SIZE (Bitfield-Mask: 0x3f)                       */
#define PIO0_DBG_CFGINFO_SM_COUNT_Pos     (8UL)                     /*!< SM_COUNT (Bit 8)                                      */
#define PIO0_DBG_CFGINFO_SM_COUNT_Msk     (0xf00UL)                 /*!< SM_COUNT (Bitfield-Mask: 0x0f)                        */
#define PIO0_DBG_CFGINFO_FIFO_DEPTH_Pos   (0UL)                     /*!< FIFO_DEPTH (Bit 0)                                    */
#define PIO0_DBG_CFGINFO_FIFO_DEPTH_Msk   (0x3fUL)                  /*!< FIFO_DEPTH (Bitfield-Mask: 0x3f)                      */
/* ======================================================  INSTR_MEM0  ======================================================= */
#define PIO0_INSTR_MEM0_INSTR_MEM0_Pos    (0UL)                     /*!< INSTR_MEM0 (Bit 0)                                    */
#define PIO0_INSTR_MEM0_INSTR_MEM0_Msk    (0xffffUL)                /*!< INSTR_MEM0 (Bitfield-Mask: 0xffff)                    */
/* ======================================================  INSTR_MEM1  ======================================================= */
#define PIO0_INSTR_MEM1_INSTR_MEM1_Pos    (0UL)                     /*!< INSTR_MEM1 (Bit 0)                                    */
#define PIO0_INSTR_MEM1_INSTR_MEM1_Msk    (0xffffUL)                /*!< INSTR_MEM1 (Bitfield-Mask: 0xffff)                    */
/* ======================================================  INSTR_MEM2  ======================================================= */
#define PIO0_INSTR_MEM2_INSTR_MEM2_Pos    (0UL)                     /*!< INSTR_MEM2 (Bit 0)                                    */
#define PIO0_INSTR_MEM2_INSTR_MEM2_Msk    (0xffffUL)                /*!< INSTR_MEM2 (Bitfield-Mask: 0xffff)                    */
/* ======================================================  INSTR_MEM3  ======================================================= */
#define PIO0_INSTR_MEM3_INSTR_MEM3_Pos    (0UL)                     /*!< INSTR_MEM3 (Bit 0)                                    */
#define PIO0_INSTR_MEM3_INSTR_MEM3_Msk    (0xffffUL)                /*!< INSTR_MEM3 (Bitfield-Mask: 0xffff)                    */
/* ======================================================  INSTR_MEM4  ======================================================= */
#define PIO0_INSTR_MEM4_INSTR_MEM4_Pos    (0UL)                     /*!< INSTR_MEM4 (Bit 0)                                    */
#define PIO0_INSTR_MEM4_INSTR_MEM4_Msk    (0xffffUL)                /*!< INSTR_MEM4 (Bitfield-Mask: 0xffff)                    */
/* ======================================================  INSTR_MEM5  ======================================================= */
#define PIO0_INSTR_MEM5_INSTR_MEM5_Pos    (0UL)                     /*!< INSTR_MEM5 (Bit 0)                                    */
#define PIO0_INSTR_MEM5_INSTR_MEM5_Msk    (0xffffUL)                /*!< INSTR_MEM5 (Bitfield-Mask: 0xffff)                    */
/* ======================================================  INSTR_MEM6  ======================================================= */
#define PIO0_INSTR_MEM6_INSTR_MEM6_Pos    (0UL)                     /*!< INSTR_MEM6 (Bit 0)                                    */
#define PIO0_INSTR_MEM6_INSTR_MEM6_Msk    (0xffffUL)                /*!< INSTR_MEM6 (Bitfield-Mask: 0xffff)                    */
/* ======================================================  INSTR_MEM7  ======================================================= */
#define PIO0_INSTR_MEM7_INSTR_MEM7_Pos    (0UL)                     /*!< INSTR_MEM7 (Bit 0)                                    */
#define PIO0_INSTR_MEM7_INSTR_MEM7_Msk    (0xffffUL)                /*!< INSTR_MEM7 (Bitfield-Mask: 0xffff)                    */
/* ======================================================  INSTR_MEM8  ======================================================= */
#define PIO0_INSTR_MEM8_INSTR_MEM8_Pos    (0UL)                     /*!< INSTR_MEM8 (Bit 0)                                    */
#define PIO0_INSTR_MEM8_INSTR_MEM8_Msk    (0xffffUL)                /*!< INSTR_MEM8 (Bitfield-Mask: 0xffff)                    */
/* ======================================================  INSTR_MEM9  ======================================================= */
#define PIO0_INSTR_MEM9_INSTR_MEM9_Pos    (0UL)                     /*!< INSTR_MEM9 (Bit 0)                                    */
#define PIO0_INSTR_MEM9_INSTR_MEM9_Msk    (0xffffUL)                /*!< INSTR_MEM9 (Bitfield-Mask: 0xffff)                    */
/* ======================================================  INSTR_MEM10  ====================================================== */
#define PIO0_INSTR_MEM10_INSTR_MEM10_Pos  (0UL)                     /*!< INSTR_MEM10 (Bit 0)                                   */
#define PIO0_INSTR_MEM10_INSTR_MEM10_Msk  (0xffffUL)                /*!< INSTR_MEM10 (Bitfield-Mask: 0xffff)                   */
/* ======================================================  INSTR_MEM11  ====================================================== */
#define PIO0_INSTR_MEM11_INSTR_MEM11_Pos  (0UL)                     /*!< INSTR_MEM11 (Bit 0)                                   */
#define PIO0_INSTR_MEM11_INSTR_MEM11_Msk  (0xffffUL)                /*!< INSTR_MEM11 (Bitfield-Mask: 0xffff)                   */
/* ======================================================  INSTR_MEM12  ====================================================== */
#define PIO0_INSTR_MEM12_INSTR_MEM12_Pos  (0UL)                     /*!< INSTR_MEM12 (Bit 0)                                   */
#define PIO0_INSTR_MEM12_INSTR_MEM12_Msk  (0xffffUL)                /*!< INSTR_MEM12 (Bitfield-Mask: 0xffff)                   */
/* ======================================================  INSTR_MEM13  ====================================================== */
#define PIO0_INSTR_MEM13_INSTR_MEM13_Pos  (0UL)                     /*!< INSTR_MEM13 (Bit 0)                                   */
#define PIO0_INSTR_MEM13_INSTR_MEM13_Msk  (0xffffUL)                /*!< INSTR_MEM13 (Bitfield-Mask: 0xffff)                   */
/* ======================================================  INSTR_MEM14  ====================================================== */
#define PIO0_INSTR_MEM14_INSTR_MEM14_Pos  (0UL)                     /*!< INSTR_MEM14 (Bit 0)                                   */
#define PIO0_INSTR_MEM14_INSTR_MEM14_Msk  (0xffffUL)                /*!< INSTR_MEM14 (Bitfield-Mask: 0xffff)                   */
/* ======================================================  INSTR_MEM15  ====================================================== */
#define PIO0_INSTR_MEM15_INSTR_MEM15_Pos  (0UL)                     /*!< INSTR_MEM15 (Bit 0)                                   */
#define PIO0_INSTR_MEM15_INSTR_MEM15_Msk  (0xffffUL)                /*!< INSTR_MEM15 (Bitfield-Mask: 0xffff)                   */
/* ======================================================  INSTR_MEM16  ====================================================== */
#define PIO0_INSTR_MEM16_INSTR_MEM16_Pos  (0UL)                     /*!< INSTR_MEM16 (Bit 0)                                   */
#define PIO0_INSTR_MEM16_INSTR_MEM16_Msk  (0xffffUL)                /*!< INSTR_MEM16 (Bitfield-Mask: 0xffff)                   */
/* ======================================================  INSTR_MEM17  ====================================================== */
#define PIO0_INSTR_MEM17_INSTR_MEM17_Pos  (0UL)                     /*!< INSTR_MEM17 (Bit 0)                                   */
#define PIO0_INSTR_MEM17_INSTR_MEM17_Msk  (0xffffUL)                /*!< INSTR_MEM17 (Bitfield-Mask: 0xffff)                   */
/* ======================================================  INSTR_MEM18  ====================================================== */
#define PIO0_INSTR_MEM18_INSTR_MEM18_Pos  (0UL)                     /*!< INSTR_MEM18 (Bit 0)                                   */
#define PIO0_INSTR_MEM18_INSTR_MEM18_Msk  (0xffffUL)                /*!< INSTR_MEM18 (Bitfield-Mask: 0xffff)                   */
/* ======================================================  INSTR_MEM19  ====================================================== */
#define PIO0_INSTR_MEM19_INSTR_MEM19_Pos  (0UL)                     /*!< INSTR_MEM19 (Bit 0)                                   */
#define PIO0_INSTR_MEM19_INSTR_MEM19_Msk  (0xffffUL)                /*!< INSTR_MEM19 (Bitfield-Mask: 0xffff)                   */
/* ======================================================  INSTR_MEM20  ====================================================== */
#define PIO0_INSTR_MEM20_INSTR_MEM20_Pos  (0UL)                     /*!< INSTR_MEM20 (Bit 0)                                   */
#define PIO0_INSTR_MEM20_INSTR_MEM20_Msk  (0xffffUL)                /*!< INSTR_MEM20 (Bitfield-Mask: 0xffff)                   */
/* ======================================================  INSTR_MEM21  ====================================================== */
#define PIO0_INSTR_MEM21_INSTR_MEM21_Pos  (0UL)                     /*!< INSTR_MEM21 (Bit 0)                                   */
#define PIO0_INSTR_MEM21_INSTR_MEM21_Msk  (0xffffUL)                /*!< INSTR_MEM21 (Bitfield-Mask: 0xffff)                   */
/* ======================================================  INSTR_MEM22  ====================================================== */
#define PIO0_INSTR_MEM22_INSTR_MEM22_Pos  (0UL)                     /*!< INSTR_MEM22 (Bit 0)                                   */
#define PIO0_INSTR_MEM22_INSTR_MEM22_Msk  (0xffffUL)                /*!< INSTR_MEM22 (Bitfield-Mask: 0xffff)                   */
/* ======================================================  INSTR_MEM23  ====================================================== */
#define PIO0_INSTR_MEM23_INSTR_MEM23_Pos  (0UL)                     /*!< INSTR_MEM23 (Bit 0)                                   */
#define PIO0_INSTR_MEM23_INSTR_MEM23_Msk  (0xffffUL)                /*!< INSTR_MEM23 (Bitfield-Mask: 0xffff)                   */
/* ======================================================  INSTR_MEM24  ====================================================== */
#define PIO0_INSTR_MEM24_INSTR_MEM24_Pos  (0UL)                     /*!< INSTR_MEM24 (Bit 0)                                   */
#define PIO0_INSTR_MEM24_INSTR_MEM24_Msk  (0xffffUL)                /*!< INSTR_MEM24 (Bitfield-Mask: 0xffff)                   */
/* ======================================================  INSTR_MEM25  ====================================================== */
#define PIO0_INSTR_MEM25_INSTR_MEM25_Pos  (0UL)                     /*!< INSTR_MEM25 (Bit 0)                                   */
#define PIO0_INSTR_MEM25_INSTR_MEM25_Msk  (0xffffUL)                /*!< INSTR_MEM25 (Bitfield-Mask: 0xffff)                   */
/* ======================================================  INSTR_MEM26  ====================================================== */
#define PIO0_INSTR_MEM26_INSTR_MEM26_Pos  (0UL)                     /*!< INSTR_MEM26 (Bit 0)                                   */
#define PIO0_INSTR_MEM26_INSTR_MEM26_Msk  (0xffffUL)                /*!< INSTR_MEM26 (Bitfield-Mask: 0xffff)                   */
/* ======================================================  INSTR_MEM27  ====================================================== */
#define PIO0_INSTR_MEM27_INSTR_MEM27_Pos  (0UL)                     /*!< INSTR_MEM27 (Bit 0)                                   */
#define PIO0_INSTR_MEM27_INSTR_MEM27_Msk  (0xffffUL)                /*!< INSTR_MEM27 (Bitfield-Mask: 0xffff)                   */
/* ======================================================  INSTR_MEM28  ====================================================== */
#define PIO0_INSTR_MEM28_INSTR_MEM28_Pos  (0UL)                     /*!< INSTR_MEM28 (Bit 0)                                   */
#define PIO0_INSTR_MEM28_INSTR_MEM28_Msk  (0xffffUL)                /*!< INSTR_MEM28 (Bitfield-Mask: 0xffff)                   */
/* ======================================================  INSTR_MEM29  ====================================================== */
#define PIO0_INSTR_MEM29_INSTR_MEM29_Pos  (0UL)                     /*!< INSTR_MEM29 (Bit 0)                                   */
#define PIO0_INSTR_MEM29_INSTR_MEM29_Msk  (0xffffUL)                /*!< INSTR_MEM29 (Bitfield-Mask: 0xffff)                   */
/* ======================================================  INSTR_MEM30  ====================================================== */
#define PIO0_INSTR_MEM30_INSTR_MEM30_Pos  (0UL)                     /*!< INSTR_MEM30 (Bit 0)                                   */
#define PIO0_INSTR_MEM30_INSTR_MEM30_Msk  (0xffffUL)                /*!< INSTR_MEM30 (Bitfield-Mask: 0xffff)                   */
/* ======================================================  INSTR_MEM31  ====================================================== */
#define PIO0_INSTR_MEM31_INSTR_MEM31_Pos  (0UL)                     /*!< INSTR_MEM31 (Bit 0)                                   */
#define PIO0_INSTR_MEM31_INSTR_MEM31_Msk  (0xffffUL)                /*!< INSTR_MEM31 (Bitfield-Mask: 0xffff)                   */
/* ======================================================  SM0_CLKDIV  ======================================================= */
#define PIO0_SM0_CLKDIV_INT_Pos           (16UL)                    /*!< INT (Bit 16)                                          */
#define PIO0_SM0_CLKDIV_INT_Msk           (0xffff0000UL)            /*!< INT (Bitfield-Mask: 0xffff)                           */
#define PIO0_SM0_CLKDIV_FRAC_Pos          (8UL)                     /*!< FRAC (Bit 8)                                          */
#define PIO0_SM0_CLKDIV_FRAC_Msk          (0xff00UL)                /*!< FRAC (Bitfield-Mask: 0xff)                            */
/* =====================================================  SM0_EXECCTRL  ====================================================== */
#define PIO0_SM0_EXECCTRL_EXEC_STALLED_Pos (31UL)                   /*!< EXEC_STALLED (Bit 31)                                 */
#define PIO0_SM0_EXECCTRL_EXEC_STALLED_Msk (0x80000000UL)           /*!< EXEC_STALLED (Bitfield-Mask: 0x01)                    */
#define PIO0_SM0_EXECCTRL_SIDE_EN_Pos     (30UL)                    /*!< SIDE_EN (Bit 30)                                      */
#define PIO0_SM0_EXECCTRL_SIDE_EN_Msk     (0x40000000UL)            /*!< SIDE_EN (Bitfield-Mask: 0x01)                         */
#define PIO0_SM0_EXECCTRL_SIDE_PINDIR_Pos (29UL)                    /*!< SIDE_PINDIR (Bit 29)                                  */
#define PIO0_SM0_EXECCTRL_SIDE_PINDIR_Msk (0x20000000UL)            /*!< SIDE_PINDIR (Bitfield-Mask: 0x01)                     */
#define PIO0_SM0_EXECCTRL_JMP_PIN_Pos     (24UL)                    /*!< JMP_PIN (Bit 24)                                      */
#define PIO0_SM0_EXECCTRL_JMP_PIN_Msk     (0x1f000000UL)            /*!< JMP_PIN (Bitfield-Mask: 0x1f)                         */
#define PIO0_SM0_EXECCTRL_OUT_EN_SEL_Pos  (19UL)                    /*!< OUT_EN_SEL (Bit 19)                                   */
#define PIO0_SM0_EXECCTRL_OUT_EN_SEL_Msk  (0xf80000UL)              /*!< OUT_EN_SEL (Bitfield-Mask: 0x1f)                      */
#define PIO0_SM0_EXECCTRL_INLINE_OUT_EN_Pos (18UL)                  /*!< INLINE_OUT_EN (Bit 18)                                */
#define PIO0_SM0_EXECCTRL_INLINE_OUT_EN_Msk (0x40000UL)             /*!< INLINE_OUT_EN (Bitfield-Mask: 0x01)                   */
#define PIO0_SM0_EXECCTRL_OUT_STICKY_Pos  (17UL)                    /*!< OUT_STICKY (Bit 17)                                   */
#define PIO0_SM0_EXECCTRL_OUT_STICKY_Msk  (0x20000UL)               /*!< OUT_STICKY (Bitfield-Mask: 0x01)                      */
#define PIO0_SM0_EXECCTRL_WRAP_TOP_Pos    (12UL)                    /*!< WRAP_TOP (Bit 12)                                     */
#define PIO0_SM0_EXECCTRL_WRAP_TOP_Msk    (0x1f000UL)               /*!< WRAP_TOP (Bitfield-Mask: 0x1f)                        */
#define PIO0_SM0_EXECCTRL_WRAP_BOTTOM_Pos (7UL)                     /*!< WRAP_BOTTOM (Bit 7)                                   */
#define PIO0_SM0_EXECCTRL_WRAP_BOTTOM_Msk (0xf80UL)                 /*!< WRAP_BOTTOM (Bitfield-Mask: 0x1f)                     */
#define PIO0_SM0_EXECCTRL_STATUS_SEL_Pos  (4UL)                     /*!< STATUS_SEL (Bit 4)                                    */
#define PIO0_SM0_EXECCTRL_STATUS_SEL_Msk  (0x10UL)                  /*!< STATUS_SEL (Bitfield-Mask: 0x01)                      */
#define PIO0_SM0_EXECCTRL_STATUS_N_Pos    (0UL)                     /*!< STATUS_N (Bit 0)                                      */
#define PIO0_SM0_EXECCTRL_STATUS_N_Msk    (0xfUL)                   /*!< STATUS_N (Bitfield-Mask: 0x0f)                        */
/* =====================================================  SM0_SHIFTCTRL  ===================================================== */
#define PIO0_SM0_SHIFTCTRL_FJOIN_RX_Pos   (31UL)                    /*!< FJOIN_RX (Bit 31)                                     */
#define PIO0_SM0_SHIFTCTRL_FJOIN_RX_Msk   (0x80000000UL)            /*!< FJOIN_RX (Bitfield-Mask: 0x01)                        */
#define PIO0_SM0_SHIFTCTRL_FJOIN_TX_Pos   (30UL)                    /*!< FJOIN_TX (Bit 30)                                     */
#define PIO0_SM0_SHIFTCTRL_FJOIN_TX_Msk   (0x40000000UL)            /*!< FJOIN_TX (Bitfield-Mask: 0x01)                        */
#define PIO0_SM0_SHIFTCTRL_PULL_THRESH_Pos (25UL)                   /*!< PULL_THRESH (Bit 25)                                  */
#define PIO0_SM0_SHIFTCTRL_PULL_THRESH_Msk (0x3e000000UL)           /*!< PULL_THRESH (Bitfield-Mask: 0x1f)                     */
#define PIO0_SM0_SHIFTCTRL_PUSH_THRESH_Pos (20UL)                   /*!< PUSH_THRESH (Bit 20)                                  */
#define PIO0_SM0_SHIFTCTRL_PUSH_THRESH_Msk (0x1f00000UL)            /*!< PUSH_THRESH (Bitfield-Mask: 0x1f)                     */
#define PIO0_SM0_SHIFTCTRL_OUT_SHIFTDIR_Pos (19UL)                  /*!< OUT_SHIFTDIR (Bit 19)                                 */
#define PIO0_SM0_SHIFTCTRL_OUT_SHIFTDIR_Msk (0x80000UL)             /*!< OUT_SHIFTDIR (Bitfield-Mask: 0x01)                    */
#define PIO0_SM0_SHIFTCTRL_IN_SHIFTDIR_Pos (18UL)                   /*!< IN_SHIFTDIR (Bit 18)                                  */
#define PIO0_SM0_SHIFTCTRL_IN_SHIFTDIR_Msk (0x40000UL)              /*!< IN_SHIFTDIR (Bitfield-Mask: 0x01)                     */
#define PIO0_SM0_SHIFTCTRL_AUTOPULL_Pos   (17UL)                    /*!< AUTOPULL (Bit 17)                                     */
#define PIO0_SM0_SHIFTCTRL_AUTOPULL_Msk   (0x20000UL)               /*!< AUTOPULL (Bitfield-Mask: 0x01)                        */
#define PIO0_SM0_SHIFTCTRL_AUTOPUSH_Pos   (16UL)                    /*!< AUTOPUSH (Bit 16)                                     */
#define PIO0_SM0_SHIFTCTRL_AUTOPUSH_Msk   (0x10000UL)               /*!< AUTOPUSH (Bitfield-Mask: 0x01)                        */
/* =======================================================  SM0_ADDR  ======================================================== */
#define PIO0_SM0_ADDR_SM0_ADDR_Pos        (0UL)                     /*!< SM0_ADDR (Bit 0)                                      */
#define PIO0_SM0_ADDR_SM0_ADDR_Msk        (0x1fUL)                  /*!< SM0_ADDR (Bitfield-Mask: 0x1f)                        */
/* =======================================================  SM0_INSTR  ======================================================= */
#define PIO0_SM0_INSTR_SM0_INSTR_Pos      (0UL)                     /*!< SM0_INSTR (Bit 0)                                     */
#define PIO0_SM0_INSTR_SM0_INSTR_Msk      (0xffffUL)                /*!< SM0_INSTR (Bitfield-Mask: 0xffff)                     */
/* ======================================================  SM0_PINCTRL  ====================================================== */
#define PIO0_SM0_PINCTRL_SIDESET_COUNT_Pos (29UL)                   /*!< SIDESET_COUNT (Bit 29)                                */
#define PIO0_SM0_PINCTRL_SIDESET_COUNT_Msk (0xe0000000UL)           /*!< SIDESET_COUNT (Bitfield-Mask: 0x07)                   */
#define PIO0_SM0_PINCTRL_SET_COUNT_Pos    (26UL)                    /*!< SET_COUNT (Bit 26)                                    */
#define PIO0_SM0_PINCTRL_SET_COUNT_Msk    (0x1c000000UL)            /*!< SET_COUNT (Bitfield-Mask: 0x07)                       */
#define PIO0_SM0_PINCTRL_OUT_COUNT_Pos    (20UL)                    /*!< OUT_COUNT (Bit 20)                                    */
#define PIO0_SM0_PINCTRL_OUT_COUNT_Msk    (0x3f00000UL)             /*!< OUT_COUNT (Bitfield-Mask: 0x3f)                       */
#define PIO0_SM0_PINCTRL_IN_BASE_Pos      (15UL)                    /*!< IN_BASE (Bit 15)                                      */
#define PIO0_SM0_PINCTRL_IN_BASE_Msk      (0xf8000UL)               /*!< IN_BASE (Bitfield-Mask: 0x1f)                         */
#define PIO0_SM0_PINCTRL_SIDESET_BASE_Pos (10UL)                    /*!< SIDESET_BASE (Bit 10)                                 */
#define PIO0_SM0_PINCTRL_SIDESET_BASE_Msk (0x7c00UL)                /*!< SIDESET_BASE (Bitfield-Mask: 0x1f)                    */
#define PIO0_SM0_PINCTRL_SET_BASE_Pos     (5UL)                     /*!< SET_BASE (Bit 5)                                      */
#define PIO0_SM0_PINCTRL_SET_BASE_Msk     (0x3e0UL)                 /*!< SET_BASE (Bitfield-Mask: 0x1f)                        */
#define PIO0_SM0_PINCTRL_OUT_BASE_Pos     (0UL)                     /*!< OUT_BASE (Bit 0)                                      */
#define PIO0_SM0_PINCTRL_OUT_BASE_Msk     (0x1fUL)                  /*!< OUT_BASE (Bitfield-Mask: 0x1f)                        */
/* ======================================================  SM1_CLKDIV  ======================================================= */
#define PIO0_SM1_CLKDIV_INT_Pos           (16UL)                    /*!< INT (Bit 16)                                          */
#define PIO0_SM1_CLKDIV_INT_Msk           (0xffff0000UL)            /*!< INT (Bitfield-Mask: 0xffff)                           */
#define PIO0_SM1_CLKDIV_FRAC_Pos          (8UL)                     /*!< FRAC (Bit 8)                                          */
#define PIO0_SM1_CLKDIV_FRAC_Msk          (0xff00UL)                /*!< FRAC (Bitfield-Mask: 0xff)                            */
/* =====================================================  SM1_EXECCTRL  ====================================================== */
#define PIO0_SM1_EXECCTRL_EXEC_STALLED_Pos (31UL)                   /*!< EXEC_STALLED (Bit 31)                                 */
#define PIO0_SM1_EXECCTRL_EXEC_STALLED_Msk (0x80000000UL)           /*!< EXEC_STALLED (Bitfield-Mask: 0x01)                    */
#define PIO0_SM1_EXECCTRL_SIDE_EN_Pos     (30UL)                    /*!< SIDE_EN (Bit 30)                                      */
#define PIO0_SM1_EXECCTRL_SIDE_EN_Msk     (0x40000000UL)            /*!< SIDE_EN (Bitfield-Mask: 0x01)                         */
#define PIO0_SM1_EXECCTRL_SIDE_PINDIR_Pos (29UL)                    /*!< SIDE_PINDIR (Bit 29)                                  */
#define PIO0_SM1_EXECCTRL_SIDE_PINDIR_Msk (0x20000000UL)            /*!< SIDE_PINDIR (Bitfield-Mask: 0x01)                     */
#define PIO0_SM1_EXECCTRL_JMP_PIN_Pos     (24UL)                    /*!< JMP_PIN (Bit 24)                                      */
#define PIO0_SM1_EXECCTRL_JMP_PIN_Msk     (0x1f000000UL)            /*!< JMP_PIN (Bitfield-Mask: 0x1f)                         */
#define PIO0_SM1_EXECCTRL_OUT_EN_SEL_Pos  (19UL)                    /*!< OUT_EN_SEL (Bit 19)                                   */
#define PIO0_SM1_EXECCTRL_OUT_EN_SEL_Msk  (0xf80000UL)              /*!< OUT_EN_SEL (Bitfield-Mask: 0x1f)                      */
#define PIO0_SM1_EXECCTRL_INLINE_OUT_EN_Pos (18UL)                  /*!< INLINE_OUT_EN (Bit 18)                                */
#define PIO0_SM1_EXECCTRL_INLINE_OUT_EN_Msk (0x40000UL)             /*!< INLINE_OUT_EN (Bitfield-Mask: 0x01)                   */
#define PIO0_SM1_EXECCTRL_OUT_STICKY_Pos  (17UL)                    /*!< OUT_STICKY (Bit 17)                                   */
#define PIO0_SM1_EXECCTRL_OUT_STICKY_Msk  (0x20000UL)               /*!< OUT_STICKY (Bitfield-Mask: 0x01)                      */
#define PIO0_SM1_EXECCTRL_WRAP_TOP_Pos    (12UL)                    /*!< WRAP_TOP (Bit 12)                                     */
#define PIO0_SM1_EXECCTRL_WRAP_TOP_Msk    (0x1f000UL)               /*!< WRAP_TOP (Bitfield-Mask: 0x1f)                        */
#define PIO0_SM1_EXECCTRL_WRAP_BOTTOM_Pos (7UL)                     /*!< WRAP_BOTTOM (Bit 7)                                   */
#define PIO0_SM1_EXECCTRL_WRAP_BOTTOM_Msk (0xf80UL)                 /*!< WRAP_BOTTOM (Bitfield-Mask: 0x1f)                     */
#define PIO0_SM1_EXECCTRL_STATUS_SEL_Pos  (4UL)                     /*!< STATUS_SEL (Bit 4)                                    */
#define PIO0_SM1_EXECCTRL_STATUS_SEL_Msk  (0x10UL)                  /*!< STATUS_SEL (Bitfield-Mask: 0x01)                      */
#define PIO0_SM1_EXECCTRL_STATUS_N_Pos    (0UL)                     /*!< STATUS_N (Bit 0)                                      */
#define PIO0_SM1_EXECCTRL_STATUS_N_Msk    (0xfUL)                   /*!< STATUS_N (Bitfield-Mask: 0x0f)                        */
/* =====================================================  SM1_SHIFTCTRL  ===================================================== */
#define PIO0_SM1_SHIFTCTRL_FJOIN_RX_Pos   (31UL)                    /*!< FJOIN_RX (Bit 31)                                     */
#define PIO0_SM1_SHIFTCTRL_FJOIN_RX_Msk   (0x80000000UL)            /*!< FJOIN_RX (Bitfield-Mask: 0x01)                        */
#define PIO0_SM1_SHIFTCTRL_FJOIN_TX_Pos   (30UL)                    /*!< FJOIN_TX (Bit 30)                                     */
#define PIO0_SM1_SHIFTCTRL_FJOIN_TX_Msk   (0x40000000UL)            /*!< FJOIN_TX (Bitfield-Mask: 0x01)                        */
#define PIO0_SM1_SHIFTCTRL_PULL_THRESH_Pos (25UL)                   /*!< PULL_THRESH (Bit 25)                                  */
#define PIO0_SM1_SHIFTCTRL_PULL_THRESH_Msk (0x3e000000UL)           /*!< PULL_THRESH (Bitfield-Mask: 0x1f)                     */
#define PIO0_SM1_SHIFTCTRL_PUSH_THRESH_Pos (20UL)                   /*!< PUSH_THRESH (Bit 20)                                  */
#define PIO0_SM1_SHIFTCTRL_PUSH_THRESH_Msk (0x1f00000UL)            /*!< PUSH_THRESH (Bitfield-Mask: 0x1f)                     */
#define PIO0_SM1_SHIFTCTRL_OUT_SHIFTDIR_Pos (19UL)                  /*!< OUT_SHIFTDIR (Bit 19)                                 */
#define PIO0_SM1_SHIFTCTRL_OUT_SHIFTDIR_Msk (0x80000UL)             /*!< OUT_SHIFTDIR (Bitfield-Mask: 0x01)                    */
#define PIO0_SM1_SHIFTCTRL_IN_SHIFTDIR_Pos (18UL)                   /*!< IN_SHIFTDIR (Bit 18)                                  */
#define PIO0_SM1_SHIFTCTRL_IN_SHIFTDIR_Msk (0x40000UL)              /*!< IN_SHIFTDIR (Bitfield-Mask: 0x01)                     */
#define PIO0_SM1_SHIFTCTRL_AUTOPULL_Pos   (17UL)                    /*!< AUTOPULL (Bit 17)                                     */
#define PIO0_SM1_SHIFTCTRL_AUTOPULL_Msk   (0x20000UL)               /*!< AUTOPULL (Bitfield-Mask: 0x01)                        */
#define PIO0_SM1_SHIFTCTRL_AUTOPUSH_Pos   (16UL)                    /*!< AUTOPUSH (Bit 16)                                     */
#define PIO0_SM1_SHIFTCTRL_AUTOPUSH_Msk   (0x10000UL)               /*!< AUTOPUSH (Bitfield-Mask: 0x01)                        */
/* =======================================================  SM1_ADDR  ======================================================== */
#define PIO0_SM1_ADDR_SM1_ADDR_Pos        (0UL)                     /*!< SM1_ADDR (Bit 0)                                      */
#define PIO0_SM1_ADDR_SM1_ADDR_Msk        (0x1fUL)                  /*!< SM1_ADDR (Bitfield-Mask: 0x1f)                        */
/* =======================================================  SM1_INSTR  ======================================================= */
#define PIO0_SM1_INSTR_SM1_INSTR_Pos      (0UL)                     /*!< SM1_INSTR (Bit 0)                                     */
#define PIO0_SM1_INSTR_SM1_INSTR_Msk      (0xffffUL)                /*!< SM1_INSTR (Bitfield-Mask: 0xffff)                     */
/* ======================================================  SM1_PINCTRL  ====================================================== */
#define PIO0_SM1_PINCTRL_SIDESET_COUNT_Pos (29UL)                   /*!< SIDESET_COUNT (Bit 29)                                */
#define PIO0_SM1_PINCTRL_SIDESET_COUNT_Msk (0xe0000000UL)           /*!< SIDESET_COUNT (Bitfield-Mask: 0x07)                   */
#define PIO0_SM1_PINCTRL_SET_COUNT_Pos    (26UL)                    /*!< SET_COUNT (Bit 26)                                    */
#define PIO0_SM1_PINCTRL_SET_COUNT_Msk    (0x1c000000UL)            /*!< SET_COUNT (Bitfield-Mask: 0x07)                       */
#define PIO0_SM1_PINCTRL_OUT_COUNT_Pos    (20UL)                    /*!< OUT_COUNT (Bit 20)                                    */
#define PIO0_SM1_PINCTRL_OUT_COUNT_Msk    (0x3f00000UL)             /*!< OUT_COUNT (Bitfield-Mask: 0x3f)                       */
#define PIO0_SM1_PINCTRL_IN_BASE_Pos      (15UL)                    /*!< IN_BASE (Bit 15)                                      */
#define PIO0_SM1_PINCTRL_IN_BASE_Msk      (0xf8000UL)               /*!< IN_BASE (Bitfield-Mask: 0x1f)                         */
#define PIO0_SM1_PINCTRL_SIDESET_BASE_Pos (10UL)                    /*!< SIDESET_BASE (Bit 10)                                 */
#define PIO0_SM1_PINCTRL_SIDESET_BASE_Msk (0x7c00UL)                /*!< SIDESET_BASE (Bitfield-Mask: 0x1f)                    */
#define PIO0_SM1_PINCTRL_SET_BASE_Pos     (5UL)                     /*!< SET_BASE (Bit 5)                                      */
#define PIO0_SM1_PINCTRL_SET_BASE_Msk     (0x3e0UL)                 /*!< SET_BASE (Bitfield-Mask: 0x1f)                        */
#define PIO0_SM1_PINCTRL_OUT_BASE_Pos     (0UL)                     /*!< OUT_BASE (Bit 0)                                      */
#define PIO0_SM1_PINCTRL_OUT_BASE_Msk     (0x1fUL)                  /*!< OUT_BASE (Bitfield-Mask: 0x1f)                        */
/* ======================================================  SM2_CLKDIV  ======================================================= */
#define PIO0_SM2_CLKDIV_INT_Pos           (16UL)                    /*!< INT (Bit 16)                                          */
#define PIO0_SM2_CLKDIV_INT_Msk           (0xffff0000UL)            /*!< INT (Bitfield-Mask: 0xffff)                           */
#define PIO0_SM2_CLKDIV_FRAC_Pos          (8UL)                     /*!< FRAC (Bit 8)                                          */
#define PIO0_SM2_CLKDIV_FRAC_Msk          (0xff00UL)                /*!< FRAC (Bitfield-Mask: 0xff)                            */
/* =====================================================  SM2_EXECCTRL  ====================================================== */
#define PIO0_SM2_EXECCTRL_EXEC_STALLED_Pos (31UL)                   /*!< EXEC_STALLED (Bit 31)                                 */
#define PIO0_SM2_EXECCTRL_EXEC_STALLED_Msk (0x80000000UL)           /*!< EXEC_STALLED (Bitfield-Mask: 0x01)                    */
#define PIO0_SM2_EXECCTRL_SIDE_EN_Pos     (30UL)                    /*!< SIDE_EN (Bit 30)                                      */
#define PIO0_SM2_EXECCTRL_SIDE_EN_Msk     (0x40000000UL)            /*!< SIDE_EN (Bitfield-Mask: 0x01)                         */
#define PIO0_SM2_EXECCTRL_SIDE_PINDIR_Pos (29UL)                    /*!< SIDE_PINDIR (Bit 29)                                  */
#define PIO0_SM2_EXECCTRL_SIDE_PINDIR_Msk (0x20000000UL)            /*!< SIDE_PINDIR (Bitfield-Mask: 0x01)                     */
#define PIO0_SM2_EXECCTRL_JMP_PIN_Pos     (24UL)                    /*!< JMP_PIN (Bit 24)                                      */
#define PIO0_SM2_EXECCTRL_JMP_PIN_Msk     (0x1f000000UL)            /*!< JMP_PIN (Bitfield-Mask: 0x1f)                         */
#define PIO0_SM2_EXECCTRL_OUT_EN_SEL_Pos  (19UL)                    /*!< OUT_EN_SEL (Bit 19)                                   */
#define PIO0_SM2_EXECCTRL_OUT_EN_SEL_Msk  (0xf80000UL)              /*!< OUT_EN_SEL (Bitfield-Mask: 0x1f)                      */
#define PIO0_SM2_EXECCTRL_INLINE_OUT_EN_Pos (18UL)                  /*!< INLINE_OUT_EN (Bit 18)                                */
#define PIO0_SM2_EXECCTRL_INLINE_OUT_EN_Msk (0x40000UL)             /*!< INLINE_OUT_EN (Bitfield-Mask: 0x01)                   */
#define PIO0_SM2_EXECCTRL_OUT_STICKY_Pos  (17UL)                    /*!< OUT_STICKY (Bit 17)                                   */
#define PIO0_SM2_EXECCTRL_OUT_STICKY_Msk  (0x20000UL)               /*!< OUT_STICKY (Bitfield-Mask: 0x01)                      */
#define PIO0_SM2_EXECCTRL_WRAP_TOP_Pos    (12UL)                    /*!< WRAP_TOP (Bit 12)                                     */
#define PIO0_SM2_EXECCTRL_WRAP_TOP_Msk    (0x1f000UL)               /*!< WRAP_TOP (Bitfield-Mask: 0x1f)                        */
#define PIO0_SM2_EXECCTRL_WRAP_BOTTOM_Pos (7UL)                     /*!< WRAP_BOTTOM (Bit 7)                                   */
#define PIO0_SM2_EXECCTRL_WRAP_BOTTOM_Msk (0xf80UL)                 /*!< WRAP_BOTTOM (Bitfield-Mask: 0x1f)                     */
#define PIO0_SM2_EXECCTRL_STATUS_SEL_Pos  (4UL)                     /*!< STATUS_SEL (Bit 4)                                    */
#define PIO0_SM2_EXECCTRL_STATUS_SEL_Msk  (0x10UL)                  /*!< STATUS_SEL (Bitfield-Mask: 0x01)                      */
#define PIO0_SM2_EXECCTRL_STATUS_N_Pos    (0UL)                     /*!< STATUS_N (Bit 0)                                      */
#define PIO0_SM2_EXECCTRL_STATUS_N_Msk    (0xfUL)                   /*!< STATUS_N (Bitfield-Mask: 0x0f)                        */
/* =====================================================  SM2_SHIFTCTRL  ===================================================== */
#define PIO0_SM2_SHIFTCTRL_FJOIN_RX_Pos   (31UL)                    /*!< FJOIN_RX (Bit 31)                                     */
#define PIO0_SM2_SHIFTCTRL_FJOIN_RX_Msk   (0x80000000UL)            /*!< FJOIN_RX (Bitfield-Mask: 0x01)                        */
#define PIO0_SM2_SHIFTCTRL_FJOIN_TX_Pos   (30UL)                    /*!< FJOIN_TX (Bit 30)                                     */
#define PIO0_SM2_SHIFTCTRL_FJOIN_TX_Msk   (0x40000000UL)            /*!< FJOIN_TX (Bitfield-Mask: 0x01)                        */
#define PIO0_SM2_SHIFTCTRL_PULL_THRESH_Pos (25UL)                   /*!< PULL_THRESH (Bit 25)                                  */
#define PIO0_SM2_SHIFTCTRL_PULL_THRESH_Msk (0x3e000000UL)           /*!< PULL_THRESH (Bitfield-Mask: 0x1f)                     */
#define PIO0_SM2_SHIFTCTRL_PUSH_THRESH_Pos (20UL)                   /*!< PUSH_THRESH (Bit 20)                                  */
#define PIO0_SM2_SHIFTCTRL_PUSH_THRESH_Msk (0x1f00000UL)            /*!< PUSH_THRESH (Bitfield-Mask: 0x1f)                     */
#define PIO0_SM2_SHIFTCTRL_OUT_SHIFTDIR_Pos (19UL)                  /*!< OUT_SHIFTDIR (Bit 19)                                 */
#define PIO0_SM2_SHIFTCTRL_OUT_SHIFTDIR_Msk (0x80000UL)             /*!< OUT_SHIFTDIR (Bitfield-Mask: 0x01)                    */
#define PIO0_SM2_SHIFTCTRL_IN_SHIFTDIR_Pos (18UL)                   /*!< IN_SHIFTDIR (Bit 18)                                  */
#define PIO0_SM2_SHIFTCTRL_IN_SHIFTDIR_Msk (0x40000UL)              /*!< IN_SHIFTDIR (Bitfield-Mask: 0x01)                     */
#define PIO0_SM2_SHIFTCTRL_AUTOPULL_Pos   (17UL)                    /*!< AUTOPULL (Bit 17)                                     */
#define PIO0_SM2_SHIFTCTRL_AUTOPULL_Msk   (0x20000UL)               /*!< AUTOPULL (Bitfield-Mask: 0x01)                        */
#define PIO0_SM2_SHIFTCTRL_AUTOPUSH_Pos   (16UL)                    /*!< AUTOPUSH (Bit 16)                                     */
#define PIO0_SM2_SHIFTCTRL_AUTOPUSH_Msk   (0x10000UL)               /*!< AUTOPUSH (Bitfield-Mask: 0x01)                        */
/* =======================================================  SM2_ADDR  ======================================================== */
#define PIO0_SM2_ADDR_SM2_ADDR_Pos        (0UL)                     /*!< SM2_ADDR (Bit 0)                                      */
#define PIO0_SM2_ADDR_SM2_ADDR_Msk        (0x1fUL)                  /*!< SM2_ADDR (Bitfield-Mask: 0x1f)                        */
/* =======================================================  SM2_INSTR  ======================================================= */
#define PIO0_SM2_INSTR_SM2_INSTR_Pos      (0UL)                     /*!< SM2_INSTR (Bit 0)                                     */
#define PIO0_SM2_INSTR_SM2_INSTR_Msk      (0xffffUL)                /*!< SM2_INSTR (Bitfield-Mask: 0xffff)                     */
/* ======================================================  SM2_PINCTRL  ====================================================== */
#define PIO0_SM2_PINCTRL_SIDESET_COUNT_Pos (29UL)                   /*!< SIDESET_COUNT (Bit 29)                                */
#define PIO0_SM2_PINCTRL_SIDESET_COUNT_Msk (0xe0000000UL)           /*!< SIDESET_COUNT (Bitfield-Mask: 0x07)                   */
#define PIO0_SM2_PINCTRL_SET_COUNT_Pos    (26UL)                    /*!< SET_COUNT (Bit 26)                                    */
#define PIO0_SM2_PINCTRL_SET_COUNT_Msk    (0x1c000000UL)            /*!< SET_COUNT (Bitfield-Mask: 0x07)                       */
#define PIO0_SM2_PINCTRL_OUT_COUNT_Pos    (20UL)                    /*!< OUT_COUNT (Bit 20)                                    */
#define PIO0_SM2_PINCTRL_OUT_COUNT_Msk    (0x3f00000UL)             /*!< OUT_COUNT (Bitfield-Mask: 0x3f)                       */
#define PIO0_SM2_PINCTRL_IN_BASE_Pos      (15UL)                    /*!< IN_BASE (Bit 15)                                      */
#define PIO0_SM2_PINCTRL_IN_BASE_Msk      (0xf8000UL)               /*!< IN_BASE (Bitfield-Mask: 0x1f)                         */
#define PIO0_SM2_PINCTRL_SIDESET_BASE_Pos (10UL)                    /*!< SIDESET_BASE (Bit 10)                                 */
#define PIO0_SM2_PINCTRL_SIDESET_BASE_Msk (0x7c00UL)                /*!< SIDESET_BASE (Bitfield-Mask: 0x1f)                    */
#define PIO0_SM2_PINCTRL_SET_BASE_Pos     (5UL)                     /*!< SET_BASE (Bit 5)                                      */
#define PIO0_SM2_PINCTRL_SET_BASE_Msk     (0x3e0UL)                 /*!< SET_BASE (Bitfield-Mask: 0x1f)                        */
#define PIO0_SM2_PINCTRL_OUT_BASE_Pos     (0UL)                     /*!< OUT_BASE (Bit 0)                                      */
#define PIO0_SM2_PINCTRL_OUT_BASE_Msk     (0x1fUL)                  /*!< OUT_BASE (Bitfield-Mask: 0x1f)                        */
/* ======================================================  SM3_CLKDIV  ======================================================= */
#define PIO0_SM3_CLKDIV_INT_Pos           (16UL)                    /*!< INT (Bit 16)                                          */
#define PIO0_SM3_CLKDIV_INT_Msk           (0xffff0000UL)            /*!< INT (Bitfield-Mask: 0xffff)                           */
#define PIO0_SM3_CLKDIV_FRAC_Pos          (8UL)                     /*!< FRAC (Bit 8)                                          */
#define PIO0_SM3_CLKDIV_FRAC_Msk          (0xff00UL)                /*!< FRAC (Bitfield-Mask: 0xff)                            */
/* =====================================================  SM3_EXECCTRL  ====================================================== */
#define PIO0_SM3_EXECCTRL_EXEC_STALLED_Pos (31UL)                   /*!< EXEC_STALLED (Bit 31)                                 */
#define PIO0_SM3_EXECCTRL_EXEC_STALLED_Msk (0x80000000UL)           /*!< EXEC_STALLED (Bitfield-Mask: 0x01)                    */
#define PIO0_SM3_EXECCTRL_SIDE_EN_Pos     (30UL)                    /*!< SIDE_EN (Bit 30)                                      */
#define PIO0_SM3_EXECCTRL_SIDE_EN_Msk     (0x40000000UL)            /*!< SIDE_EN (Bitfield-Mask: 0x01)                         */
#define PIO0_SM3_EXECCTRL_SIDE_PINDIR_Pos (29UL)                    /*!< SIDE_PINDIR (Bit 29)                                  */
#define PIO0_SM3_EXECCTRL_SIDE_PINDIR_Msk (0x20000000UL)            /*!< SIDE_PINDIR (Bitfield-Mask: 0x01)                     */
#define PIO0_SM3_EXECCTRL_JMP_PIN_Pos     (24UL)                    /*!< JMP_PIN (Bit 24)                                      */
#define PIO0_SM3_EXECCTRL_JMP_PIN_Msk     (0x1f000000UL)            /*!< JMP_PIN (Bitfield-Mask: 0x1f)                         */
#define PIO0_SM3_EXECCTRL_OUT_EN_SEL_Pos  (19UL)                    /*!< OUT_EN_SEL (Bit 19)                                   */
#define PIO0_SM3_EXECCTRL_OUT_EN_SEL_Msk  (0xf80000UL)              /*!< OUT_EN_SEL (Bitfield-Mask: 0x1f)                      */
#define PIO0_SM3_EXECCTRL_INLINE_OUT_EN_Pos (18UL)                  /*!< INLINE_OUT_EN (Bit 18)                                */
#define PIO0_SM3_EXECCTRL_INLINE_OUT_EN_Msk (0x40000UL)             /*!< INLINE_OUT_EN (Bitfield-Mask: 0x01)                   */
#define PIO0_SM3_EXECCTRL_OUT_STICKY_Pos  (17UL)                    /*!< OUT_STICKY (Bit 17)                                   */
#define PIO0_SM3_EXECCTRL_OUT_STICKY_Msk  (0x20000UL)               /*!< OUT_STICKY (Bitfield-Mask: 0x01)                      */
#define PIO0_SM3_EXECCTRL_WRAP_TOP_Pos    (12UL)                    /*!< WRAP_TOP (Bit 12)                                     */
#define PIO0_SM3_EXECCTRL_WRAP_TOP_Msk    (0x1f000UL)               /*!< WRAP_TOP (Bitfield-Mask: 0x1f)                        */
#define PIO0_SM3_EXECCTRL_WRAP_BOTTOM_Pos (7UL)                     /*!< WRAP_BOTTOM (Bit 7)                                   */
#define PIO0_SM3_EXECCTRL_WRAP_BOTTOM_Msk (0xf80UL)                 /*!< WRAP_BOTTOM (Bitfield-Mask: 0x1f)                     */
#define PIO0_SM3_EXECCTRL_STATUS_SEL_Pos  (4UL)                     /*!< STATUS_SEL (Bit 4)                                    */
#define PIO0_SM3_EXECCTRL_STATUS_SEL_Msk  (0x10UL)                  /*!< STATUS_SEL (Bitfield-Mask: 0x01)                      */
#define PIO0_SM3_EXECCTRL_STATUS_N_Pos    (0UL)                     /*!< STATUS_N (Bit 0)                                      */
#define PIO0_SM3_EXECCTRL_STATUS_N_Msk    (0xfUL)                   /*!< STATUS_N (Bitfield-Mask: 0x0f)                        */
/* =====================================================  SM3_SHIFTCTRL  ===================================================== */
#define PIO0_SM3_SHIFTCTRL_FJOIN_RX_Pos   (31UL)                    /*!< FJOIN_RX (Bit 31)                                     */
#define PIO0_SM3_SHIFTCTRL_FJOIN_RX_Msk   (0x80000000UL)            /*!< FJOIN_RX (Bitfield-Mask: 0x01)                        */
#define PIO0_SM3_SHIFTCTRL_FJOIN_TX_Pos   (30UL)                    /*!< FJOIN_TX (Bit 30)                                     */
#define PIO0_SM3_SHIFTCTRL_FJOIN_TX_Msk   (0x40000000UL)            /*!< FJOIN_TX (Bitfield-Mask: 0x01)                        */
#define PIO0_SM3_SHIFTCTRL_PULL_THRESH_Pos (25UL)                   /*!< PULL_THRESH (Bit 25)                                  */
#define PIO0_SM3_SHIFTCTRL_PULL_THRESH_Msk (0x3e000000UL)           /*!< PULL_THRESH (Bitfield-Mask: 0x1f)                     */
#define PIO0_SM3_SHIFTCTRL_PUSH_THRESH_Pos (20UL)                   /*!< PUSH_THRESH (Bit 20)                                  */
#define PIO0_SM3_SHIFTCTRL_PUSH_THRESH_Msk (0x1f00000UL)            /*!< PUSH_THRESH (Bitfield-Mask: 0x1f)                     */
#define PIO0_SM3_SHIFTCTRL_OUT_SHIFTDIR_Pos (19UL)                  /*!< OUT_SHIFTDIR (Bit 19)                                 */
#define PIO0_SM3_SHIFTCTRL_OUT_SHIFTDIR_Msk (0x80000UL)             /*!< OUT_SHIFTDIR (Bitfield-Mask: 0x01)                    */
#define PIO0_SM3_SHIFTCTRL_IN_SHIFTDIR_Pos (18UL)                   /*!< IN_SHIFTDIR (Bit 18)                                  */
#define PIO0_SM3_SHIFTCTRL_IN_SHIFTDIR_Msk (0x40000UL)              /*!< IN_SHIFTDIR (Bitfield-Mask: 0x01)                     */
#define PIO0_SM3_SHIFTCTRL_AUTOPULL_Pos   (17UL)                    /*!< AUTOPULL (Bit 17)                                     */
#define PIO0_SM3_SHIFTCTRL_AUTOPULL_Msk   (0x20000UL)               /*!< AUTOPULL (Bitfield-Mask: 0x01)                        */
#define PIO0_SM3_SHIFTCTRL_AUTOPUSH_Pos   (16UL)                    /*!< AUTOPUSH (Bit 16)                                     */
#define PIO0_SM3_SHIFTCTRL_AUTOPUSH_Msk   (0x10000UL)               /*!< AUTOPUSH (Bitfield-Mask: 0x01)                        */
/* =======================================================  SM3_ADDR  ======================================================== */
#define PIO0_SM3_ADDR_SM3_ADDR_Pos        (0UL)                     /*!< SM3_ADDR (Bit 0)                                      */
#define PIO0_SM3_ADDR_SM3_ADDR_Msk        (0x1fUL)                  /*!< SM3_ADDR (Bitfield-Mask: 0x1f)                        */
/* =======================================================  SM3_INSTR  ======================================================= */
#define PIO0_SM3_INSTR_SM3_INSTR_Pos      (0UL)                     /*!< SM3_INSTR (Bit 0)                                     */
#define PIO0_SM3_INSTR_SM3_INSTR_Msk      (0xffffUL)                /*!< SM3_INSTR (Bitfield-Mask: 0xffff)                     */
/* ======================================================  SM3_PINCTRL  ====================================================== */
#define PIO0_SM3_PINCTRL_SIDESET_COUNT_Pos (29UL)                   /*!< SIDESET_COUNT (Bit 29)                                */
#define PIO0_SM3_PINCTRL_SIDESET_COUNT_Msk (0xe0000000UL)           /*!< SIDESET_COUNT (Bitfield-Mask: 0x07)                   */
#define PIO0_SM3_PINCTRL_SET_COUNT_Pos    (26UL)                    /*!< SET_COUNT (Bit 26)                                    */
#define PIO0_SM3_PINCTRL_SET_COUNT_Msk    (0x1c000000UL)            /*!< SET_COUNT (Bitfield-Mask: 0x07)                       */
#define PIO0_SM3_PINCTRL_OUT_COUNT_Pos    (20UL)                    /*!< OUT_COUNT (Bit 20)                                    */
#define PIO0_SM3_PINCTRL_OUT_COUNT_Msk    (0x3f00000UL)             /*!< OUT_COUNT (Bitfield-Mask: 0x3f)                       */
#define PIO0_SM3_PINCTRL_IN_BASE_Pos      (15UL)                    /*!< IN_BASE (Bit 15)                                      */
#define PIO0_SM3_PINCTRL_IN_BASE_Msk      (0xf8000UL)               /*!< IN_BASE (Bitfield-Mask: 0x1f)                         */
#define PIO0_SM3_PINCTRL_SIDESET_BASE_Pos (10UL)                    /*!< SIDESET_BASE (Bit 10)                                 */
#define PIO0_SM3_PINCTRL_SIDESET_BASE_Msk (0x7c00UL)                /*!< SIDESET_BASE (Bitfield-Mask: 0x1f)                    */
#define PIO0_SM3_PINCTRL_SET_BASE_Pos     (5UL)                     /*!< SET_BASE (Bit 5)                                      */
#define PIO0_SM3_PINCTRL_SET_BASE_Msk     (0x3e0UL)                 /*!< SET_BASE (Bitfield-Mask: 0x1f)                        */
#define PIO0_SM3_PINCTRL_OUT_BASE_Pos     (0UL)                     /*!< OUT_BASE (Bit 0)                                      */
#define PIO0_SM3_PINCTRL_OUT_BASE_Msk     (0x1fUL)                  /*!< OUT_BASE (Bitfield-Mask: 0x1f)                        */
/* =========================================================  INTR  ========================================================== */
#define PIO0_INTR_SM3_Pos                 (11UL)                    /*!< SM3 (Bit 11)                                          */
#define PIO0_INTR_SM3_Msk                 (0x800UL)                 /*!< SM3 (Bitfield-Mask: 0x01)                             */
#define PIO0_INTR_SM2_Pos                 (10UL)                    /*!< SM2 (Bit 10)                                          */
#define PIO0_INTR_SM2_Msk                 (0x400UL)                 /*!< SM2 (Bitfield-Mask: 0x01)                             */
#define PIO0_INTR_SM1_Pos                 (9UL)                     /*!< SM1 (Bit 9)                                           */
#define PIO0_INTR_SM1_Msk                 (0x200UL)                 /*!< SM1 (Bitfield-Mask: 0x01)                             */
#define PIO0_INTR_SM0_Pos                 (8UL)                     /*!< SM0 (Bit 8)                                           */
#define PIO0_INTR_SM0_Msk                 (0x100UL)                 /*!< SM0 (Bitfield-Mask: 0x01)                             */
#define PIO0_INTR_SM3_TXNFULL_Pos         (7UL)                     /*!< SM3_TXNFULL (Bit 7)                                   */
#define PIO0_INTR_SM3_TXNFULL_Msk         (0x80UL)                  /*!< SM3_TXNFULL (Bitfield-Mask: 0x01)                     */
#define PIO0_INTR_SM2_TXNFULL_Pos         (6UL)                     /*!< SM2_TXNFULL (Bit 6)                                   */
#define PIO0_INTR_SM2_TXNFULL_Msk         (0x40UL)                  /*!< SM2_TXNFULL (Bitfield-Mask: 0x01)                     */
#define PIO0_INTR_SM1_TXNFULL_Pos         (5UL)                     /*!< SM1_TXNFULL (Bit 5)                                   */
#define PIO0_INTR_SM1_TXNFULL_Msk         (0x20UL)                  /*!< SM1_TXNFULL (Bitfield-Mask: 0x01)                     */
#define PIO0_INTR_SM0_TXNFULL_Pos         (4UL)                     /*!< SM0_TXNFULL (Bit 4)                                   */
#define PIO0_INTR_SM0_TXNFULL_Msk         (0x10UL)                  /*!< SM0_TXNFULL (Bitfield-Mask: 0x01)                     */
#define PIO0_INTR_SM3_RXNEMPTY_Pos        (3UL)                     /*!< SM3_RXNEMPTY (Bit 3)                                  */
#define PIO0_INTR_SM3_RXNEMPTY_Msk        (0x8UL)                   /*!< SM3_RXNEMPTY (Bitfield-Mask: 0x01)                    */
#define PIO0_INTR_SM2_RXNEMPTY_Pos        (2UL)                     /*!< SM2_RXNEMPTY (Bit 2)                                  */
#define PIO0_INTR_SM2_RXNEMPTY_Msk        (0x4UL)                   /*!< SM2_RXNEMPTY (Bitfield-Mask: 0x01)                    */
#define PIO0_INTR_SM1_RXNEMPTY_Pos        (1UL)                     /*!< SM1_RXNEMPTY (Bit 1)                                  */
#define PIO0_INTR_SM1_RXNEMPTY_Msk        (0x2UL)                   /*!< SM1_RXNEMPTY (Bitfield-Mask: 0x01)                    */
#define PIO0_INTR_SM0_RXNEMPTY_Pos        (0UL)                     /*!< SM0_RXNEMPTY (Bit 0)                                  */
#define PIO0_INTR_SM0_RXNEMPTY_Msk        (0x1UL)                   /*!< SM0_RXNEMPTY (Bitfield-Mask: 0x01)                    */
/* =======================================================  IRQ0_INTE  ======================================================= */
#define PIO0_IRQ0_INTE_SM3_Pos            (11UL)                    /*!< SM3 (Bit 11)                                          */
#define PIO0_IRQ0_INTE_SM3_Msk            (0x800UL)                 /*!< SM3 (Bitfield-Mask: 0x01)                             */
#define PIO0_IRQ0_INTE_SM2_Pos            (10UL)                    /*!< SM2 (Bit 10)                                          */
#define PIO0_IRQ0_INTE_SM2_Msk            (0x400UL)                 /*!< SM2 (Bitfield-Mask: 0x01)                             */
#define PIO0_IRQ0_INTE_SM1_Pos            (9UL)                     /*!< SM1 (Bit 9)                                           */
#define PIO0_IRQ0_INTE_SM1_Msk            (0x200UL)                 /*!< SM1 (Bitfield-Mask: 0x01)                             */
#define PIO0_IRQ0_INTE_SM0_Pos            (8UL)                     /*!< SM0 (Bit 8)                                           */
#define PIO0_IRQ0_INTE_SM0_Msk            (0x100UL)                 /*!< SM0 (Bitfield-Mask: 0x01)                             */
#define PIO0_IRQ0_INTE_SM3_TXNFULL_Pos    (7UL)                     /*!< SM3_TXNFULL (Bit 7)                                   */
#define PIO0_IRQ0_INTE_SM3_TXNFULL_Msk    (0x80UL)                  /*!< SM3_TXNFULL (Bitfield-Mask: 0x01)                     */
#define PIO0_IRQ0_INTE_SM2_TXNFULL_Pos    (6UL)                     /*!< SM2_TXNFULL (Bit 6)                                   */
#define PIO0_IRQ0_INTE_SM2_TXNFULL_Msk    (0x40UL)                  /*!< SM2_TXNFULL (Bitfield-Mask: 0x01)                     */
#define PIO0_IRQ0_INTE_SM1_TXNFULL_Pos    (5UL)                     /*!< SM1_TXNFULL (Bit 5)                                   */
#define PIO0_IRQ0_INTE_SM1_TXNFULL_Msk    (0x20UL)                  /*!< SM1_TXNFULL (Bitfield-Mask: 0x01)                     */
#define PIO0_IRQ0_INTE_SM0_TXNFULL_Pos    (4UL)                     /*!< SM0_TXNFULL (Bit 4)                                   */
#define PIO0_IRQ0_INTE_SM0_TXNFULL_Msk    (0x10UL)                  /*!< SM0_TXNFULL (Bitfield-Mask: 0x01)                     */
#define PIO0_IRQ0_INTE_SM3_RXNEMPTY_Pos   (3UL)                     /*!< SM3_RXNEMPTY (Bit 3)                                  */
#define PIO0_IRQ0_INTE_SM3_RXNEMPTY_Msk   (0x8UL)                   /*!< SM3_RXNEMPTY (Bitfield-Mask: 0x01)                    */
#define PIO0_IRQ0_INTE_SM2_RXNEMPTY_Pos   (2UL)                     /*!< SM2_RXNEMPTY (Bit 2)                                  */
#define PIO0_IRQ0_INTE_SM2_RXNEMPTY_Msk   (0x4UL)                   /*!< SM2_RXNEMPTY (Bitfield-Mask: 0x01)                    */
#define PIO0_IRQ0_INTE_SM1_RXNEMPTY_Pos   (1UL)                     /*!< SM1_RXNEMPTY (Bit 1)                                  */
#define PIO0_IRQ0_INTE_SM1_RXNEMPTY_Msk   (0x2UL)                   /*!< SM1_RXNEMPTY (Bitfield-Mask: 0x01)                    */
#define PIO0_IRQ0_INTE_SM0_RXNEMPTY_Pos   (0UL)                     /*!< SM0_RXNEMPTY (Bit 0)                                  */
#define PIO0_IRQ0_INTE_SM0_RXNEMPTY_Msk   (0x1UL)                   /*!< SM0_RXNEMPTY (Bitfield-Mask: 0x01)                    */
/* =======================================================  IRQ0_INTF  ======================================================= */
#define PIO0_IRQ0_INTF_SM3_Pos            (11UL)                    /*!< SM3 (Bit 11)                                          */
#define PIO0_IRQ0_INTF_SM3_Msk            (0x800UL)                 /*!< SM3 (Bitfield-Mask: 0x01)                             */
#define PIO0_IRQ0_INTF_SM2_Pos            (10UL)                    /*!< SM2 (Bit 10)                                          */
#define PIO0_IRQ0_INTF_SM2_Msk            (0x400UL)                 /*!< SM2 (Bitfield-Mask: 0x01)                             */
#define PIO0_IRQ0_INTF_SM1_Pos            (9UL)                     /*!< SM1 (Bit 9)                                           */
#define PIO0_IRQ0_INTF_SM1_Msk            (0x200UL)                 /*!< SM1 (Bitfield-Mask: 0x01)                             */
#define PIO0_IRQ0_INTF_SM0_Pos            (8UL)                     /*!< SM0 (Bit 8)                                           */
#define PIO0_IRQ0_INTF_SM0_Msk            (0x100UL)                 /*!< SM0 (Bitfield-Mask: 0x01)                             */
#define PIO0_IRQ0_INTF_SM3_TXNFULL_Pos    (7UL)                     /*!< SM3_TXNFULL (Bit 7)                                   */
#define PIO0_IRQ0_INTF_SM3_TXNFULL_Msk    (0x80UL)                  /*!< SM3_TXNFULL (Bitfield-Mask: 0x01)                     */
#define PIO0_IRQ0_INTF_SM2_TXNFULL_Pos    (6UL)                     /*!< SM2_TXNFULL (Bit 6)                                   */
#define PIO0_IRQ0_INTF_SM2_TXNFULL_Msk    (0x40UL)                  /*!< SM2_TXNFULL (Bitfield-Mask: 0x01)                     */
#define PIO0_IRQ0_INTF_SM1_TXNFULL_Pos    (5UL)                     /*!< SM1_TXNFULL (Bit 5)                                   */
#define PIO0_IRQ0_INTF_SM1_TXNFULL_Msk    (0x20UL)                  /*!< SM1_TXNFULL (Bitfield-Mask: 0x01)                     */
#define PIO0_IRQ0_INTF_SM0_TXNFULL_Pos    (4UL)                     /*!< SM0_TXNFULL (Bit 4)                                   */
#define PIO0_IRQ0_INTF_SM0_TXNFULL_Msk    (0x10UL)                  /*!< SM0_TXNFULL (Bitfield-Mask: 0x01)                     */
#define PIO0_IRQ0_INTF_SM3_RXNEMPTY_Pos   (3UL)                     /*!< SM3_RXNEMPTY (Bit 3)                                  */
#define PIO0_IRQ0_INTF_SM3_RXNEMPTY_Msk   (0x8UL)                   /*!< SM3_RXNEMPTY (Bitfield-Mask: 0x01)                    */
#define PIO0_IRQ0_INTF_SM2_RXNEMPTY_Pos   (2UL)                     /*!< SM2_RXNEMPTY (Bit 2)                                  */
#define PIO0_IRQ0_INTF_SM2_RXNEMPTY_Msk   (0x4UL)                   /*!< SM2_RXNEMPTY (Bitfield-Mask: 0x01)                    */
#define PIO0_IRQ0_INTF_SM1_RXNEMPTY_Pos   (1UL)                     /*!< SM1_RXNEMPTY (Bit 1)                                  */
#define PIO0_IRQ0_INTF_SM1_RXNEMPTY_Msk   (0x2UL)                   /*!< SM1_RXNEMPTY (Bitfield-Mask: 0x01)                    */
#define PIO0_IRQ0_INTF_SM0_RXNEMPTY_Pos   (0UL)                     /*!< SM0_RXNEMPTY (Bit 0)                                  */
#define PIO0_IRQ0_INTF_SM0_RXNEMPTY_Msk   (0x1UL)                   /*!< SM0_RXNEMPTY (Bitfield-Mask: 0x01)                    */
/* =======================================================  IRQ0_INTS  ======================================================= */
#define PIO0_IRQ0_INTS_SM3_Pos            (11UL)                    /*!< SM3 (Bit 11)                                          */
#define PIO0_IRQ0_INTS_SM3_Msk            (0x800UL)                 /*!< SM3 (Bitfield-Mask: 0x01)                             */
#define PIO0_IRQ0_INTS_SM2_Pos            (10UL)                    /*!< SM2 (Bit 10)                                          */
#define PIO0_IRQ0_INTS_SM2_Msk            (0x400UL)                 /*!< SM2 (Bitfield-Mask: 0x01)                             */
#define PIO0_IRQ0_INTS_SM1_Pos            (9UL)                     /*!< SM1 (Bit 9)                                           */
#define PIO0_IRQ0_INTS_SM1_Msk            (0x200UL)                 /*!< SM1 (Bitfield-Mask: 0x01)                             */
#define PIO0_IRQ0_INTS_SM0_Pos            (8UL)                     /*!< SM0 (Bit 8)                                           */
#define PIO0_IRQ0_INTS_SM0_Msk            (0x100UL)                 /*!< SM0 (Bitfield-Mask: 0x01)                             */
#define PIO0_IRQ0_INTS_SM3_TXNFULL_Pos    (7UL)                     /*!< SM3_TXNFULL (Bit 7)                                   */
#define PIO0_IRQ0_INTS_SM3_TXNFULL_Msk    (0x80UL)                  /*!< SM3_TXNFULL (Bitfield-Mask: 0x01)                     */
#define PIO0_IRQ0_INTS_SM2_TXNFULL_Pos    (6UL)                     /*!< SM2_TXNFULL (Bit 6)                                   */
#define PIO0_IRQ0_INTS_SM2_TXNFULL_Msk    (0x40UL)                  /*!< SM2_TXNFULL (Bitfield-Mask: 0x01)                     */
#define PIO0_IRQ0_INTS_SM1_TXNFULL_Pos    (5UL)                     /*!< SM1_TXNFULL (Bit 5)                                   */
#define PIO0_IRQ0_INTS_SM1_TXNFULL_Msk    (0x20UL)                  /*!< SM1_TXNFULL (Bitfield-Mask: 0x01)                     */
#define PIO0_IRQ0_INTS_SM0_TXNFULL_Pos    (4UL)                     /*!< SM0_TXNFULL (Bit 4)                                   */
#define PIO0_IRQ0_INTS_SM0_TXNFULL_Msk    (0x10UL)                  /*!< SM0_TXNFULL (Bitfield-Mask: 0x01)                     */
#define PIO0_IRQ0_INTS_SM3_RXNEMPTY_Pos   (3UL)                     /*!< SM3_RXNEMPTY (Bit 3)                                  */
#define PIO0_IRQ0_INTS_SM3_RXNEMPTY_Msk   (0x8UL)                   /*!< SM3_RXNEMPTY (Bitfield-Mask: 0x01)                    */
#define PIO0_IRQ0_INTS_SM2_RXNEMPTY_Pos   (2UL)                     /*!< SM2_RXNEMPTY (Bit 2)                                  */
#define PIO0_IRQ0_INTS_SM2_RXNEMPTY_Msk   (0x4UL)                   /*!< SM2_RXNEMPTY (Bitfield-Mask: 0x01)                    */
#define PIO0_IRQ0_INTS_SM1_RXNEMPTY_Pos   (1UL)                     /*!< SM1_RXNEMPTY (Bit 1)                                  */
#define PIO0_IRQ0_INTS_SM1_RXNEMPTY_Msk   (0x2UL)                   /*!< SM1_RXNEMPTY (Bitfield-Mask: 0x01)                    */
#define PIO0_IRQ0_INTS_SM0_RXNEMPTY_Pos   (0UL)                     /*!< SM0_RXNEMPTY (Bit 0)                                  */
#define PIO0_IRQ0_INTS_SM0_RXNEMPTY_Msk   (0x1UL)                   /*!< SM0_RXNEMPTY (Bitfield-Mask: 0x01)                    */
/* =======================================================  IRQ1_INTE  ======================================================= */
#define PIO0_IRQ1_INTE_SM3_Pos            (11UL)                    /*!< SM3 (Bit 11)                                          */
#define PIO0_IRQ1_INTE_SM3_Msk            (0x800UL)                 /*!< SM3 (Bitfield-Mask: 0x01)                             */
#define PIO0_IRQ1_INTE_SM2_Pos            (10UL)                    /*!< SM2 (Bit 10)                                          */
#define PIO0_IRQ1_INTE_SM2_Msk            (0x400UL)                 /*!< SM2 (Bitfield-Mask: 0x01)                             */
#define PIO0_IRQ1_INTE_SM1_Pos            (9UL)                     /*!< SM1 (Bit 9)                                           */
#define PIO0_IRQ1_INTE_SM1_Msk            (0x200UL)                 /*!< SM1 (Bitfield-Mask: 0x01)                             */
#define PIO0_IRQ1_INTE_SM0_Pos            (8UL)                     /*!< SM0 (Bit 8)                                           */
#define PIO0_IRQ1_INTE_SM0_Msk            (0x100UL)                 /*!< SM0 (Bitfield-Mask: 0x01)                             */
#define PIO0_IRQ1_INTE_SM3_TXNFULL_Pos    (7UL)                     /*!< SM3_TXNFULL (Bit 7)                                   */
#define PIO0_IRQ1_INTE_SM3_TXNFULL_Msk    (0x80UL)                  /*!< SM3_TXNFULL (Bitfield-Mask: 0x01)                     */
#define PIO0_IRQ1_INTE_SM2_TXNFULL_Pos    (6UL)                     /*!< SM2_TXNFULL (Bit 6)                                   */
#define PIO0_IRQ1_INTE_SM2_TXNFULL_Msk    (0x40UL)                  /*!< SM2_TXNFULL (Bitfield-Mask: 0x01)                     */
#define PIO0_IRQ1_INTE_SM1_TXNFULL_Pos    (5UL)                     /*!< SM1_TXNFULL (Bit 5)                                   */
#define PIO0_IRQ1_INTE_SM1_TXNFULL_Msk    (0x20UL)                  /*!< SM1_TXNFULL (Bitfield-Mask: 0x01)                     */
#define PIO0_IRQ1_INTE_SM0_TXNFULL_Pos    (4UL)                     /*!< SM0_TXNFULL (Bit 4)                                   */
#define PIO0_IRQ1_INTE_SM0_TXNFULL_Msk    (0x10UL)                  /*!< SM0_TXNFULL (Bitfield-Mask: 0x01)                     */
#define PIO0_IRQ1_INTE_SM3_RXNEMPTY_Pos   (3UL)                     /*!< SM3_RXNEMPTY (Bit 3)                                  */
#define PIO0_IRQ1_INTE_SM3_RXNEMPTY_Msk   (0x8UL)                   /*!< SM3_RXNEMPTY (Bitfield-Mask: 0x01)                    */
#define PIO0_IRQ1_INTE_SM2_RXNEMPTY_Pos   (2UL)                     /*!< SM2_RXNEMPTY (Bit 2)                                  */
#define PIO0_IRQ1_INTE_SM2_RXNEMPTY_Msk   (0x4UL)                   /*!< SM2_RXNEMPTY (Bitfield-Mask: 0x01)                    */
#define PIO0_IRQ1_INTE_SM1_RXNEMPTY_Pos   (1UL)                     /*!< SM1_RXNEMPTY (Bit 1)                                  */
#define PIO0_IRQ1_INTE_SM1_RXNEMPTY_Msk   (0x2UL)                   /*!< SM1_RXNEMPTY (Bitfield-Mask: 0x01)                    */
#define PIO0_IRQ1_INTE_SM0_RXNEMPTY_Pos   (0UL)                     /*!< SM0_RXNEMPTY (Bit 0)                                  */
#define PIO0_IRQ1_INTE_SM0_RXNEMPTY_Msk   (0x1UL)                   /*!< SM0_RXNEMPTY (Bitfield-Mask: 0x01)                    */
/* =======================================================  IRQ1_INTF  ======================================================= */
#define PIO0_IRQ1_INTF_SM3_Pos            (11UL)                    /*!< SM3 (Bit 11)                                          */
#define PIO0_IRQ1_INTF_SM3_Msk            (0x800UL)                 /*!< SM3 (Bitfield-Mask: 0x01)                             */
#define PIO0_IRQ1_INTF_SM2_Pos            (10UL)                    /*!< SM2 (Bit 10)                                          */
#define PIO0_IRQ1_INTF_SM2_Msk            (0x400UL)                 /*!< SM2 (Bitfield-Mask: 0x01)                             */
#define PIO0_IRQ1_INTF_SM1_Pos            (9UL)                     /*!< SM1 (Bit 9)                                           */
#define PIO0_IRQ1_INTF_SM1_Msk            (0x200UL)                 /*!< SM1 (Bitfield-Mask: 0x01)                             */
#define PIO0_IRQ1_INTF_SM0_Pos            (8UL)                     /*!< SM0 (Bit 8)                                           */
#define PIO0_IRQ1_INTF_SM0_Msk            (0x100UL)                 /*!< SM0 (Bitfield-Mask: 0x01)                             */
#define PIO0_IRQ1_INTF_SM3_TXNFULL_Pos    (7UL)                     /*!< SM3_TXNFULL (Bit 7)                                   */
#define PIO0_IRQ1_INTF_SM3_TXNFULL_Msk    (0x80UL)                  /*!< SM3_TXNFULL (Bitfield-Mask: 0x01)                     */
#define PIO0_IRQ1_INTF_SM2_TXNFULL_Pos    (6UL)                     /*!< SM2_TXNFULL (Bit 6)                                   */
#define PIO0_IRQ1_INTF_SM2_TXNFULL_Msk    (0x40UL)                  /*!< SM2_TXNFULL (Bitfield-Mask: 0x01)                     */
#define PIO0_IRQ1_INTF_SM1_TXNFULL_Pos    (5UL)                     /*!< SM1_TXNFULL (Bit 5)                                   */
#define PIO0_IRQ1_INTF_SM1_TXNFULL_Msk    (0x20UL)                  /*!< SM1_TXNFULL (Bitfield-Mask: 0x01)                     */
#define PIO0_IRQ1_INTF_SM0_TXNFULL_Pos    (4UL)                     /*!< SM0_TXNFULL (Bit 4)                                   */
#define PIO0_IRQ1_INTF_SM0_TXNFULL_Msk    (0x10UL)                  /*!< SM0_TXNFULL (Bitfield-Mask: 0x01)                     */
#define PIO0_IRQ1_INTF_SM3_RXNEMPTY_Pos   (3UL)                     /*!< SM3_RXNEMPTY (Bit 3)                                  */
#define PIO0_IRQ1_INTF_SM3_RXNEMPTY_Msk   (0x8UL)                   /*!< SM3_RXNEMPTY (Bitfield-Mask: 0x01)                    */
#define PIO0_IRQ1_INTF_SM2_RXNEMPTY_Pos   (2UL)                     /*!< SM2_RXNEMPTY (Bit 2)                                  */
#define PIO0_IRQ1_INTF_SM2_RXNEMPTY_Msk   (0x4UL)                   /*!< SM2_RXNEMPTY (Bitfield-Mask: 0x01)                    */
#define PIO0_IRQ1_INTF_SM1_RXNEMPTY_Pos   (1UL)                     /*!< SM1_RXNEMPTY (Bit 1)                                  */
#define PIO0_IRQ1_INTF_SM1_RXNEMPTY_Msk   (0x2UL)                   /*!< SM1_RXNEMPTY (Bitfield-Mask: 0x01)                    */
#define PIO0_IRQ1_INTF_SM0_RXNEMPTY_Pos   (0UL)                     /*!< SM0_RXNEMPTY (Bit 0)                                  */
#define PIO0_IRQ1_INTF_SM0_RXNEMPTY_Msk   (0x1UL)                   /*!< SM0_RXNEMPTY (Bitfield-Mask: 0x01)                    */
/* =======================================================  IRQ1_INTS  ======================================================= */
#define PIO0_IRQ1_INTS_SM3_Pos            (11UL)                    /*!< SM3 (Bit 11)                                          */
#define PIO0_IRQ1_INTS_SM3_Msk            (0x800UL)                 /*!< SM3 (Bitfield-Mask: 0x01)                             */
#define PIO0_IRQ1_INTS_SM2_Pos            (10UL)                    /*!< SM2 (Bit 10)                                          */
#define PIO0_IRQ1_INTS_SM2_Msk            (0x400UL)                 /*!< SM2 (Bitfield-Mask: 0x01)                             */
#define PIO0_IRQ1_INTS_SM1_Pos            (9UL)                     /*!< SM1 (Bit 9)                                           */
#define PIO0_IRQ1_INTS_SM1_Msk            (0x200UL)                 /*!< SM1 (Bitfield-Mask: 0x01)                             */
#define PIO0_IRQ1_INTS_SM0_Pos            (8UL)                     /*!< SM0 (Bit 8)                                           */
#define PIO0_IRQ1_INTS_SM0_Msk            (0x100UL)                 /*!< SM0 (Bitfield-Mask: 0x01)                             */
#define PIO0_IRQ1_INTS_SM3_TXNFULL_Pos    (7UL)                     /*!< SM3_TXNFULL (Bit 7)                                   */
#define PIO0_IRQ1_INTS_SM3_TXNFULL_Msk    (0x80UL)                  /*!< SM3_TXNFULL (Bitfield-Mask: 0x01)                     */
#define PIO0_IRQ1_INTS_SM2_TXNFULL_Pos    (6UL)                     /*!< SM2_TXNFULL (Bit 6)                                   */
#define PIO0_IRQ1_INTS_SM2_TXNFULL_Msk    (0x40UL)                  /*!< SM2_TXNFULL (Bitfield-Mask: 0x01)                     */
#define PIO0_IRQ1_INTS_SM1_TXNFULL_Pos    (5UL)                     /*!< SM1_TXNFULL (Bit 5)                                   */
#define PIO0_IRQ1_INTS_SM1_TXNFULL_Msk    (0x20UL)                  /*!< SM1_TXNFULL (Bitfield-Mask: 0x01)                     */
#define PIO0_IRQ1_INTS_SM0_TXNFULL_Pos    (4UL)                     /*!< SM0_TXNFULL (Bit 4)                                   */
#define PIO0_IRQ1_INTS_SM0_TXNFULL_Msk    (0x10UL)                  /*!< SM0_TXNFULL (Bitfield-Mask: 0x01)                     */
#define PIO0_IRQ1_INTS_SM3_RXNEMPTY_Pos   (3UL)                     /*!< SM3_RXNEMPTY (Bit 3)                                  */
#define PIO0_IRQ1_INTS_SM3_RXNEMPTY_Msk   (0x8UL)                   /*!< SM3_RXNEMPTY (Bitfield-Mask: 0x01)                    */
#define PIO0_IRQ1_INTS_SM2_RXNEMPTY_Pos   (2UL)                     /*!< SM2_RXNEMPTY (Bit 2)                                  */
#define PIO0_IRQ1_INTS_SM2_RXNEMPTY_Msk   (0x4UL)                   /*!< SM2_RXNEMPTY (Bitfield-Mask: 0x01)                    */
#define PIO0_IRQ1_INTS_SM1_RXNEMPTY_Pos   (1UL)                     /*!< SM1_RXNEMPTY (Bit 1)                                  */
#define PIO0_IRQ1_INTS_SM1_RXNEMPTY_Msk   (0x2UL)                   /*!< SM1_RXNEMPTY (Bitfield-Mask: 0x01)                    */
#define PIO0_IRQ1_INTS_SM0_RXNEMPTY_Pos   (0UL)                     /*!< SM0_RXNEMPTY (Bit 0)                                  */
#define PIO0_IRQ1_INTS_SM0_RXNEMPTY_Msk   (0x1UL)                   /*!< SM0_RXNEMPTY (Bitfield-Mask: 0x01)                    */


/* =========================================================================================================================== */
/* ================                                            SIO                                            ================ */
/* =========================================================================================================================== */

/* =========================================================  CPUID  ========================================================= */
/* ========================================================  GPIO_IN  ======================================================== */
#define SIO_GPIO_IN_GPIO_IN_Pos           (0UL)                     /*!< GPIO_IN (Bit 0)                                       */
#define SIO_GPIO_IN_GPIO_IN_Msk           (0x3fffffffUL)            /*!< GPIO_IN (Bitfield-Mask: 0x3fffffff)                   */
/* ======================================================  GPIO_HI_IN  ======================================================= */
#define SIO_GPIO_HI_IN_GPIO_HI_IN_Pos     (0UL)                     /*!< GPIO_HI_IN (Bit 0)                                    */
#define SIO_GPIO_HI_IN_GPIO_HI_IN_Msk     (0x3fUL)                  /*!< GPIO_HI_IN (Bitfield-Mask: 0x3f)                      */
/* =======================================================  GPIO_OUT  ======================================================== */
#define SIO_GPIO_OUT_GPIO_OUT_Pos         (0UL)                     /*!< GPIO_OUT (Bit 0)                                      */
#define SIO_GPIO_OUT_GPIO_OUT_Msk         (0x3fffffffUL)            /*!< GPIO_OUT (Bitfield-Mask: 0x3fffffff)                  */
/* =====================================================  GPIO_OUT_SET  ====================================================== */
#define SIO_GPIO_OUT_SET_GPIO_OUT_SET_Pos (0UL)                     /*!< GPIO_OUT_SET (Bit 0)                                  */
#define SIO_GPIO_OUT_SET_GPIO_OUT_SET_Msk (0x3fffffffUL)            /*!< GPIO_OUT_SET (Bitfield-Mask: 0x3fffffff)              */
/* =====================================================  GPIO_OUT_CLR  ====================================================== */
#define SIO_GPIO_OUT_CLR_GPIO_OUT_CLR_Pos (0UL)                     /*!< GPIO_OUT_CLR (Bit 0)                                  */
#define SIO_GPIO_OUT_CLR_GPIO_OUT_CLR_Msk (0x3fffffffUL)            /*!< GPIO_OUT_CLR (Bitfield-Mask: 0x3fffffff)              */
/* =====================================================  GPIO_OUT_XOR  ====================================================== */
#define SIO_GPIO_OUT_XOR_GPIO_OUT_XOR_Pos (0UL)                     /*!< GPIO_OUT_XOR (Bit 0)                                  */
#define SIO_GPIO_OUT_XOR_GPIO_OUT_XOR_Msk (0x3fffffffUL)            /*!< GPIO_OUT_XOR (Bitfield-Mask: 0x3fffffff)              */
/* ========================================================  GPIO_OE  ======================================================== */
#define SIO_GPIO_OE_GPIO_OE_Pos           (0UL)                     /*!< GPIO_OE (Bit 0)                                       */
#define SIO_GPIO_OE_GPIO_OE_Msk           (0x3fffffffUL)            /*!< GPIO_OE (Bitfield-Mask: 0x3fffffff)                   */
/* ======================================================  GPIO_OE_SET  ====================================================== */
#define SIO_GPIO_OE_SET_GPIO_OE_SET_Pos   (0UL)                     /*!< GPIO_OE_SET (Bit 0)                                   */
#define SIO_GPIO_OE_SET_GPIO_OE_SET_Msk   (0x3fffffffUL)            /*!< GPIO_OE_SET (Bitfield-Mask: 0x3fffffff)               */
/* ======================================================  GPIO_OE_CLR  ====================================================== */
#define SIO_GPIO_OE_CLR_GPIO_OE_CLR_Pos   (0UL)                     /*!< GPIO_OE_CLR (Bit 0)                                   */
#define SIO_GPIO_OE_CLR_GPIO_OE_CLR_Msk   (0x3fffffffUL)            /*!< GPIO_OE_CLR (Bitfield-Mask: 0x3fffffff)               */
/* ======================================================  GPIO_OE_XOR  ====================================================== */
#define SIO_GPIO_OE_XOR_GPIO_OE_XOR_Pos   (0UL)                     /*!< GPIO_OE_XOR (Bit 0)                                   */
#define SIO_GPIO_OE_XOR_GPIO_OE_XOR_Msk   (0x3fffffffUL)            /*!< GPIO_OE_XOR (Bitfield-Mask: 0x3fffffff)               */
/* ======================================================  GPIO_HI_OUT  ====================================================== */
#define SIO_GPIO_HI_OUT_GPIO_HI_OUT_Pos   (0UL)                     /*!< GPIO_HI_OUT (Bit 0)                                   */
#define SIO_GPIO_HI_OUT_GPIO_HI_OUT_Msk   (0x3fUL)                  /*!< GPIO_HI_OUT (Bitfield-Mask: 0x3f)                     */
/* ====================================================  GPIO_HI_OUT_SET  ==================================================== */
#define SIO_GPIO_HI_OUT_SET_GPIO_HI_OUT_SET_Pos (0UL)               /*!< GPIO_HI_OUT_SET (Bit 0)                               */
#define SIO_GPIO_HI_OUT_SET_GPIO_HI_OUT_SET_Msk (0x3fUL)            /*!< GPIO_HI_OUT_SET (Bitfield-Mask: 0x3f)                 */
/* ====================================================  GPIO_HI_OUT_CLR  ==================================================== */
#define SIO_GPIO_HI_OUT_CLR_GPIO_HI_OUT_CLR_Pos (0UL)               /*!< GPIO_HI_OUT_CLR (Bit 0)                               */
#define SIO_GPIO_HI_OUT_CLR_GPIO_HI_OUT_CLR_Msk (0x3fUL)            /*!< GPIO_HI_OUT_CLR (Bitfield-Mask: 0x3f)                 */
/* ====================================================  GPIO_HI_OUT_XOR  ==================================================== */
#define SIO_GPIO_HI_OUT_XOR_GPIO_HI_OUT_XOR_Pos (0UL)               /*!< GPIO_HI_OUT_XOR (Bit 0)                               */
#define SIO_GPIO_HI_OUT_XOR_GPIO_HI_OUT_XOR_Msk (0x3fUL)            /*!< GPIO_HI_OUT_XOR (Bitfield-Mask: 0x3f)                 */
/* ======================================================  GPIO_HI_OE  ======================================================= */
#define SIO_GPIO_HI_OE_GPIO_HI_OE_Pos     (0UL)                     /*!< GPIO_HI_OE (Bit 0)                                    */
#define SIO_GPIO_HI_OE_GPIO_HI_OE_Msk     (0x3fUL)                  /*!< GPIO_HI_OE (Bitfield-Mask: 0x3f)                      */
/* ====================================================  GPIO_HI_OE_SET  ===================================================== */
#define SIO_GPIO_HI_OE_SET_GPIO_HI_OE_SET_Pos (0UL)                 /*!< GPIO_HI_OE_SET (Bit 0)                                */
#define SIO_GPIO_HI_OE_SET_GPIO_HI_OE_SET_Msk (0x3fUL)              /*!< GPIO_HI_OE_SET (Bitfield-Mask: 0x3f)                  */
/* ====================================================  GPIO_HI_OE_CLR  ===================================================== */
#define SIO_GPIO_HI_OE_CLR_GPIO_HI_OE_CLR_Pos (0UL)                 /*!< GPIO_HI_OE_CLR (Bit 0)                                */
#define SIO_GPIO_HI_OE_CLR_GPIO_HI_OE_CLR_Msk (0x3fUL)              /*!< GPIO_HI_OE_CLR (Bitfield-Mask: 0x3f)                  */
/* ====================================================  GPIO_HI_OE_XOR  ===================================================== */
#define SIO_GPIO_HI_OE_XOR_GPIO_HI_OE_XOR_Pos (0UL)                 /*!< GPIO_HI_OE_XOR (Bit 0)                                */
#define SIO_GPIO_HI_OE_XOR_GPIO_HI_OE_XOR_Msk (0x3fUL)              /*!< GPIO_HI_OE_XOR (Bitfield-Mask: 0x3f)                  */
/* ========================================================  FIFO_ST  ======================================================== */
#define SIO_FIFO_ST_ROE_Pos               (3UL)                     /*!< ROE (Bit 3)                                           */
#define SIO_FIFO_ST_ROE_Msk               (0x8UL)                   /*!< ROE (Bitfield-Mask: 0x01)                             */
#define SIO_FIFO_ST_WOF_Pos               (2UL)                     /*!< WOF (Bit 2)                                           */
#define SIO_FIFO_ST_WOF_Msk               (0x4UL)                   /*!< WOF (Bitfield-Mask: 0x01)                             */
#define SIO_FIFO_ST_RDY_Pos               (1UL)                     /*!< RDY (Bit 1)                                           */
#define SIO_FIFO_ST_RDY_Msk               (0x2UL)                   /*!< RDY (Bitfield-Mask: 0x01)                             */
#define SIO_FIFO_ST_VLD_Pos               (0UL)                     /*!< VLD (Bit 0)                                           */
#define SIO_FIFO_ST_VLD_Msk               (0x1UL)                   /*!< VLD (Bitfield-Mask: 0x01)                             */
/* ========================================================  FIFO_WR  ======================================================== */
/* ========================================================  FIFO_RD  ======================================================== */
/* ======================================================  SPINLOCK_ST  ====================================================== */
/* =====================================================  DIV_UDIVIDEND  ===================================================== */
/* =====================================================  DIV_UDIVISOR  ====================================================== */
/* =====================================================  DIV_SDIVIDEND  ===================================================== */
/* =====================================================  DIV_SDIVISOR  ====================================================== */
/* =====================================================  DIV_QUOTIENT  ====================================================== */
/* =====================================================  DIV_REMAINDER  ===================================================== */
/* ========================================================  DIV_CSR  ======================================================== */
#define SIO_DIV_CSR_DIRTY_Pos             (1UL)                     /*!< DIRTY (Bit 1)                                         */
#define SIO_DIV_CSR_DIRTY_Msk             (0x2UL)                   /*!< DIRTY (Bitfield-Mask: 0x01)                           */
#define SIO_DIV_CSR_READY_Pos             (0UL)                     /*!< READY (Bit 0)                                         */
#define SIO_DIV_CSR_READY_Msk             (0x1UL)                   /*!< READY (Bitfield-Mask: 0x01)                           */
/* ====================================================  INTERP0_ACCUM0  ===================================================== */
/* ====================================================  INTERP0_ACCUM1  ===================================================== */
/* =====================================================  INTERP0_BASE0  ===================================================== */
/* =====================================================  INTERP0_BASE1  ===================================================== */
/* =====================================================  INTERP0_BASE2  ===================================================== */
/* ===================================================  INTERP0_POP_LANE0  =================================================== */
/* ===================================================  INTERP0_POP_LANE1  =================================================== */
/* ===================================================  INTERP0_POP_FULL  ==================================================== */
/* ==================================================  INTERP0_PEEK_LANE0  =================================================== */
/* ==================================================  INTERP0_PEEK_LANE1  =================================================== */
/* ===================================================  INTERP0_PEEK_FULL  =================================================== */
/* ==================================================  INTERP0_CTRL_LANE0  =================================================== */
#define SIO_INTERP0_CTRL_LANE0_OVERF_Pos  (25UL)                    /*!< OVERF (Bit 25)                                        */
#define SIO_INTERP0_CTRL_LANE0_OVERF_Msk  (0x2000000UL)             /*!< OVERF (Bitfield-Mask: 0x01)                           */
#define SIO_INTERP0_CTRL_LANE0_OVERF1_Pos (24UL)                    /*!< OVERF1 (Bit 24)                                       */
#define SIO_INTERP0_CTRL_LANE0_OVERF1_Msk (0x1000000UL)             /*!< OVERF1 (Bitfield-Mask: 0x01)                          */
#define SIO_INTERP0_CTRL_LANE0_OVERF0_Pos (23UL)                    /*!< OVERF0 (Bit 23)                                       */
#define SIO_INTERP0_CTRL_LANE0_OVERF0_Msk (0x800000UL)              /*!< OVERF0 (Bitfield-Mask: 0x01)                          */
#define SIO_INTERP0_CTRL_LANE0_BLEND_Pos  (21UL)                    /*!< BLEND (Bit 21)                                        */
#define SIO_INTERP0_CTRL_LANE0_BLEND_Msk  (0x200000UL)              /*!< BLEND (Bitfield-Mask: 0x01)                           */
#define SIO_INTERP0_CTRL_LANE0_FORCE_MSB_Pos (19UL)                 /*!< FORCE_MSB (Bit 19)                                    */
#define SIO_INTERP0_CTRL_LANE0_FORCE_MSB_Msk (0x180000UL)           /*!< FORCE_MSB (Bitfield-Mask: 0x03)                       */
#define SIO_INTERP0_CTRL_LANE0_ADD_RAW_Pos (18UL)                   /*!< ADD_RAW (Bit 18)                                      */
#define SIO_INTERP0_CTRL_LANE0_ADD_RAW_Msk (0x40000UL)              /*!< ADD_RAW (Bitfield-Mask: 0x01)                         */
#define SIO_INTERP0_CTRL_LANE0_CROSS_RESULT_Pos (17UL)              /*!< CROSS_RESULT (Bit 17)                                 */
#define SIO_INTERP0_CTRL_LANE0_CROSS_RESULT_Msk (0x20000UL)         /*!< CROSS_RESULT (Bitfield-Mask: 0x01)                    */
#define SIO_INTERP0_CTRL_LANE0_CROSS_INPUT_Pos (16UL)               /*!< CROSS_INPUT (Bit 16)                                  */
#define SIO_INTERP0_CTRL_LANE0_CROSS_INPUT_Msk (0x10000UL)          /*!< CROSS_INPUT (Bitfield-Mask: 0x01)                     */
#define SIO_INTERP0_CTRL_LANE0_SIGNED_Pos (15UL)                    /*!< SIGNED (Bit 15)                                       */
#define SIO_INTERP0_CTRL_LANE0_SIGNED_Msk (0x8000UL)                /*!< SIGNED (Bitfield-Mask: 0x01)                          */
#define SIO_INTERP0_CTRL_LANE0_MASK_MSB_Pos (10UL)                  /*!< MASK_MSB (Bit 10)                                     */
#define SIO_INTERP0_CTRL_LANE0_MASK_MSB_Msk (0x7c00UL)              /*!< MASK_MSB (Bitfield-Mask: 0x1f)                        */
#define SIO_INTERP0_CTRL_LANE0_MASK_LSB_Pos (5UL)                   /*!< MASK_LSB (Bit 5)                                      */
#define SIO_INTERP0_CTRL_LANE0_MASK_LSB_Msk (0x3e0UL)               /*!< MASK_LSB (Bitfield-Mask: 0x1f)                        */
#define SIO_INTERP0_CTRL_LANE0_SHIFT_Pos  (0UL)                     /*!< SHIFT (Bit 0)                                         */
#define SIO_INTERP0_CTRL_LANE0_SHIFT_Msk  (0x1fUL)                  /*!< SHIFT (Bitfield-Mask: 0x1f)                           */
/* ==================================================  INTERP0_CTRL_LANE1  =================================================== */
#define SIO_INTERP0_CTRL_LANE1_FORCE_MSB_Pos (19UL)                 /*!< FORCE_MSB (Bit 19)                                    */
#define SIO_INTERP0_CTRL_LANE1_FORCE_MSB_Msk (0x180000UL)           /*!< FORCE_MSB (Bitfield-Mask: 0x03)                       */
#define SIO_INTERP0_CTRL_LANE1_ADD_RAW_Pos (18UL)                   /*!< ADD_RAW (Bit 18)                                      */
#define SIO_INTERP0_CTRL_LANE1_ADD_RAW_Msk (0x40000UL)              /*!< ADD_RAW (Bitfield-Mask: 0x01)                         */
#define SIO_INTERP0_CTRL_LANE1_CROSS_RESULT_Pos (17UL)              /*!< CROSS_RESULT (Bit 17)                                 */
#define SIO_INTERP0_CTRL_LANE1_CROSS_RESULT_Msk (0x20000UL)         /*!< CROSS_RESULT (Bitfield-Mask: 0x01)                    */
#define SIO_INTERP0_CTRL_LANE1_CROSS_INPUT_Pos (16UL)               /*!< CROSS_INPUT (Bit 16)                                  */
#define SIO_INTERP0_CTRL_LANE1_CROSS_INPUT_Msk (0x10000UL)          /*!< CROSS_INPUT (Bitfield-Mask: 0x01)                     */
#define SIO_INTERP0_CTRL_LANE1_SIGNED_Pos (15UL)                    /*!< SIGNED (Bit 15)                                       */
#define SIO_INTERP0_CTRL_LANE1_SIGNED_Msk (0x8000UL)                /*!< SIGNED (Bitfield-Mask: 0x01)                          */
#define SIO_INTERP0_CTRL_LANE1_MASK_MSB_Pos (10UL)                  /*!< MASK_MSB (Bit 10)                                     */
#define SIO_INTERP0_CTRL_LANE1_MASK_MSB_Msk (0x7c00UL)              /*!< MASK_MSB (Bitfield-Mask: 0x1f)                        */
#define SIO_INTERP0_CTRL_LANE1_MASK_LSB_Pos (5UL)                   /*!< MASK_LSB (Bit 5)                                      */
#define SIO_INTERP0_CTRL_LANE1_MASK_LSB_Msk (0x3e0UL)               /*!< MASK_LSB (Bitfield-Mask: 0x1f)                        */
#define SIO_INTERP0_CTRL_LANE1_SHIFT_Pos  (0UL)                     /*!< SHIFT (Bit 0)                                         */
#define SIO_INTERP0_CTRL_LANE1_SHIFT_Msk  (0x1fUL)                  /*!< SHIFT (Bitfield-Mask: 0x1f)                           */
/* ==================================================  INTERP0_ACCUM0_ADD  =================================================== */
#define SIO_INTERP0_ACCUM0_ADD_INTERP0_ACCUM0_ADD_Pos (0UL)         /*!< INTERP0_ACCUM0_ADD (Bit 0)                            */
#define SIO_INTERP0_ACCUM0_ADD_INTERP0_ACCUM0_ADD_Msk (0xffffffUL)  /*!< INTERP0_ACCUM0_ADD (Bitfield-Mask: 0xffffff)          */
/* ==================================================  INTERP0_ACCUM1_ADD  =================================================== */
#define SIO_INTERP0_ACCUM1_ADD_INTERP0_ACCUM1_ADD_Pos (0UL)         /*!< INTERP0_ACCUM1_ADD (Bit 0)                            */
#define SIO_INTERP0_ACCUM1_ADD_INTERP0_ACCUM1_ADD_Msk (0xffffffUL)  /*!< INTERP0_ACCUM1_ADD (Bitfield-Mask: 0xffffff)          */
/* ==================================================  INTERP0_BASE_1AND0  =================================================== */
/* ====================================================  INTERP1_ACCUM0  ===================================================== */
/* ====================================================  INTERP1_ACCUM1  ===================================================== */
/* =====================================================  INTERP1_BASE0  ===================================================== */
/* =====================================================  INTERP1_BASE1  ===================================================== */
/* =====================================================  INTERP1_BASE2  ===================================================== */
/* ===================================================  INTERP1_POP_LANE0  =================================================== */
/* ===================================================  INTERP1_POP_LANE1  =================================================== */
/* ===================================================  INTERP1_POP_FULL  ==================================================== */
/* ==================================================  INTERP1_PEEK_LANE0  =================================================== */
/* ==================================================  INTERP1_PEEK_LANE1  =================================================== */
/* ===================================================  INTERP1_PEEK_FULL  =================================================== */
/* ==================================================  INTERP1_CTRL_LANE0  =================================================== */
#define SIO_INTERP1_CTRL_LANE0_OVERF_Pos  (25UL)                    /*!< OVERF (Bit 25)                                        */
#define SIO_INTERP1_CTRL_LANE0_OVERF_Msk  (0x2000000UL)             /*!< OVERF (Bitfield-Mask: 0x01)                           */
#define SIO_INTERP1_CTRL_LANE0_OVERF1_Pos (24UL)                    /*!< OVERF1 (Bit 24)                                       */
#define SIO_INTERP1_CTRL_LANE0_OVERF1_Msk (0x1000000UL)             /*!< OVERF1 (Bitfield-Mask: 0x01)                          */
#define SIO_INTERP1_CTRL_LANE0_OVERF0_Pos (23UL)                    /*!< OVERF0 (Bit 23)                                       */
#define SIO_INTERP1_CTRL_LANE0_OVERF0_Msk (0x800000UL)              /*!< OVERF0 (Bitfield-Mask: 0x01)                          */
#define SIO_INTERP1_CTRL_LANE0_CLAMP_Pos  (22UL)                    /*!< CLAMP (Bit 22)                                        */
#define SIO_INTERP1_CTRL_LANE0_CLAMP_Msk  (0x400000UL)              /*!< CLAMP (Bitfield-Mask: 0x01)                           */
#define SIO_INTERP1_CTRL_LANE0_FORCE_MSB_Pos (19UL)                 /*!< FORCE_MSB (Bit 19)                                    */
#define SIO_INTERP1_CTRL_LANE0_FORCE_MSB_Msk (0x180000UL)           /*!< FORCE_MSB (Bitfield-Mask: 0x03)                       */
#define SIO_INTERP1_CTRL_LANE0_ADD_RAW_Pos (18UL)                   /*!< ADD_RAW (Bit 18)                                      */
#define SIO_INTERP1_CTRL_LANE0_ADD_RAW_Msk (0x40000UL)              /*!< ADD_RAW (Bitfield-Mask: 0x01)                         */
#define SIO_INTERP1_CTRL_LANE0_CROSS_RESULT_Pos (17UL)              /*!< CROSS_RESULT (Bit 17)                                 */
#define SIO_INTERP1_CTRL_LANE0_CROSS_RESULT_Msk (0x20000UL)         /*!< CROSS_RESULT (Bitfield-Mask: 0x01)                    */
#define SIO_INTERP1_CTRL_LANE0_CROSS_INPUT_Pos (16UL)               /*!< CROSS_INPUT (Bit 16)                                  */
#define SIO_INTERP1_CTRL_LANE0_CROSS_INPUT_Msk (0x10000UL)          /*!< CROSS_INPUT (Bitfield-Mask: 0x01)                     */
#define SIO_INTERP1_CTRL_LANE0_SIGNED_Pos (15UL)                    /*!< SIGNED (Bit 15)                                       */
#define SIO_INTERP1_CTRL_LANE0_SIGNED_Msk (0x8000UL)                /*!< SIGNED (Bitfield-Mask: 0x01)                          */
#define SIO_INTERP1_CTRL_LANE0_MASK_MSB_Pos (10UL)                  /*!< MASK_MSB (Bit 10)                                     */
#define SIO_INTERP1_CTRL_LANE0_MASK_MSB_Msk (0x7c00UL)              /*!< MASK_MSB (Bitfield-Mask: 0x1f)                        */
#define SIO_INTERP1_CTRL_LANE0_MASK_LSB_Pos (5UL)                   /*!< MASK_LSB (Bit 5)                                      */
#define SIO_INTERP1_CTRL_LANE0_MASK_LSB_Msk (0x3e0UL)               /*!< MASK_LSB (Bitfield-Mask: 0x1f)                        */
#define SIO_INTERP1_CTRL_LANE0_SHIFT_Pos  (0UL)                     /*!< SHIFT (Bit 0)                                         */
#define SIO_INTERP1_CTRL_LANE0_SHIFT_Msk  (0x1fUL)                  /*!< SHIFT (Bitfield-Mask: 0x1f)                           */
/* ==================================================  INTERP1_CTRL_LANE1  =================================================== */
#define SIO_INTERP1_CTRL_LANE1_FORCE_MSB_Pos (19UL)                 /*!< FORCE_MSB (Bit 19)                                    */
#define SIO_INTERP1_CTRL_LANE1_FORCE_MSB_Msk (0x180000UL)           /*!< FORCE_MSB (Bitfield-Mask: 0x03)                       */
#define SIO_INTERP1_CTRL_LANE1_ADD_RAW_Pos (18UL)                   /*!< ADD_RAW (Bit 18)                                      */
#define SIO_INTERP1_CTRL_LANE1_ADD_RAW_Msk (0x40000UL)              /*!< ADD_RAW (Bitfield-Mask: 0x01)                         */
#define SIO_INTERP1_CTRL_LANE1_CROSS_RESULT_Pos (17UL)              /*!< CROSS_RESULT (Bit 17)                                 */
#define SIO_INTERP1_CTRL_LANE1_CROSS_RESULT_Msk (0x20000UL)         /*!< CROSS_RESULT (Bitfield-Mask: 0x01)                    */
#define SIO_INTERP1_CTRL_LANE1_CROSS_INPUT_Pos (16UL)               /*!< CROSS_INPUT (Bit 16)                                  */
#define SIO_INTERP1_CTRL_LANE1_CROSS_INPUT_Msk (0x10000UL)          /*!< CROSS_INPUT (Bitfield-Mask: 0x01)                     */
#define SIO_INTERP1_CTRL_LANE1_SIGNED_Pos (15UL)                    /*!< SIGNED (Bit 15)                                       */
#define SIO_INTERP1_CTRL_LANE1_SIGNED_Msk (0x8000UL)                /*!< SIGNED (Bitfield-Mask: 0x01)                          */
#define SIO_INTERP1_CTRL_LANE1_MASK_MSB_Pos (10UL)                  /*!< MASK_MSB (Bit 10)                                     */
#define SIO_INTERP1_CTRL_LANE1_MASK_MSB_Msk (0x7c00UL)              /*!< MASK_MSB (Bitfield-Mask: 0x1f)                        */
#define SIO_INTERP1_CTRL_LANE1_MASK_LSB_Pos (5UL)                   /*!< MASK_LSB (Bit 5)                                      */
#define SIO_INTERP1_CTRL_LANE1_MASK_LSB_Msk (0x3e0UL)               /*!< MASK_LSB (Bitfield-Mask: 0x1f)                        */
#define SIO_INTERP1_CTRL_LANE1_SHIFT_Pos  (0UL)                     /*!< SHIFT (Bit 0)                                         */
#define SIO_INTERP1_CTRL_LANE1_SHIFT_Msk  (0x1fUL)                  /*!< SHIFT (Bitfield-Mask: 0x1f)                           */
/* ==================================================  INTERP1_ACCUM0_ADD  =================================================== */
#define SIO_INTERP1_ACCUM0_ADD_INTERP1_ACCUM0_ADD_Pos (0UL)         /*!< INTERP1_ACCUM0_ADD (Bit 0)                            */
#define SIO_INTERP1_ACCUM0_ADD_INTERP1_ACCUM0_ADD_Msk (0xffffffUL)  /*!< INTERP1_ACCUM0_ADD (Bitfield-Mask: 0xffffff)          */
/* ==================================================  INTERP1_ACCUM1_ADD  =================================================== */
#define SIO_INTERP1_ACCUM1_ADD_INTERP1_ACCUM1_ADD_Pos (0UL)         /*!< INTERP1_ACCUM1_ADD (Bit 0)                            */
#define SIO_INTERP1_ACCUM1_ADD_INTERP1_ACCUM1_ADD_Msk (0xffffffUL)  /*!< INTERP1_ACCUM1_ADD (Bitfield-Mask: 0xffffff)          */
/* ==================================================  INTERP1_BASE_1AND0  =================================================== */
/* =======================================================  SPINLOCK0  ======================================================= */
/* =======================================================  SPINLOCK1  ======================================================= */
/* =======================================================  SPINLOCK2  ======================================================= */
/* =======================================================  SPINLOCK3  ======================================================= */
/* =======================================================  SPINLOCK4  ======================================================= */
/* =======================================================  SPINLOCK5  ======================================================= */
/* =======================================================  SPINLOCK6  ======================================================= */
/* =======================================================  SPINLOCK7  ======================================================= */
/* =======================================================  SPINLOCK8  ======================================================= */
/* =======================================================  SPINLOCK9  ======================================================= */
/* ======================================================  SPINLOCK10  ======================================================= */
/* ======================================================  SPINLOCK11  ======================================================= */
/* ======================================================  SPINLOCK12  ======================================================= */
/* ======================================================  SPINLOCK13  ======================================================= */
/* ======================================================  SPINLOCK14  ======================================================= */
/* ======================================================  SPINLOCK15  ======================================================= */
/* ======================================================  SPINLOCK16  ======================================================= */
/* ======================================================  SPINLOCK17  ======================================================= */
/* ======================================================  SPINLOCK18  ======================================================= */
/* ======================================================  SPINLOCK19  ======================================================= */
/* ======================================================  SPINLOCK20  ======================================================= */
/* ======================================================  SPINLOCK21  ======================================================= */
/* ======================================================  SPINLOCK22  ======================================================= */
/* ======================================================  SPINLOCK23  ======================================================= */
/* ======================================================  SPINLOCK24  ======================================================= */
/* ======================================================  SPINLOCK25  ======================================================= */
/* ======================================================  SPINLOCK26  ======================================================= */
/* ======================================================  SPINLOCK27  ======================================================= */
/* ======================================================  SPINLOCK28  ======================================================= */
/* ======================================================  SPINLOCK29  ======================================================= */
/* ======================================================  SPINLOCK30  ======================================================= */
/* ======================================================  SPINLOCK31  ======================================================= */


/* =========================================================================================================================== */
/* ================                                            PPB                                            ================ */
/* =========================================================================================================================== */

/* =======================================================  SYST_CSR  ======================================================== */
#define PPB_SYST_CSR_COUNTFLAG_Pos        (16UL)                    /*!< COUNTFLAG (Bit 16)                                    */
#define PPB_SYST_CSR_COUNTFLAG_Msk        (0x10000UL)               /*!< COUNTFLAG (Bitfield-Mask: 0x01)                       */
#define PPB_SYST_CSR_CLKSOURCE_Pos        (2UL)                     /*!< CLKSOURCE (Bit 2)                                     */
#define PPB_SYST_CSR_CLKSOURCE_Msk        (0x4UL)                   /*!< CLKSOURCE (Bitfield-Mask: 0x01)                       */
#define PPB_SYST_CSR_TICKINT_Pos          (1UL)                     /*!< TICKINT (Bit 1)                                       */
#define PPB_SYST_CSR_TICKINT_Msk          (0x2UL)                   /*!< TICKINT (Bitfield-Mask: 0x01)                         */
#define PPB_SYST_CSR_ENABLE_Pos           (0UL)                     /*!< ENABLE (Bit 0)                                        */
#define PPB_SYST_CSR_ENABLE_Msk           (0x1UL)                   /*!< ENABLE (Bitfield-Mask: 0x01)                          */
/* =======================================================  SYST_RVR  ======================================================== */
#define PPB_SYST_RVR_RELOAD_Pos           (0UL)                     /*!< RELOAD (Bit 0)                                        */
#define PPB_SYST_RVR_RELOAD_Msk           (0xffffffUL)              /*!< RELOAD (Bitfield-Mask: 0xffffff)                      */
/* =======================================================  SYST_CVR  ======================================================== */
#define PPB_SYST_CVR_CURRENT_Pos          (0UL)                     /*!< CURRENT (Bit 0)                                       */
#define PPB_SYST_CVR_CURRENT_Msk          (0xffffffUL)              /*!< CURRENT (Bitfield-Mask: 0xffffff)                     */
/* ======================================================  SYST_CALIB  ======================================================= */
#define PPB_SYST_CALIB_NOREF_Pos          (31UL)                    /*!< NOREF (Bit 31)                                        */
#define PPB_SYST_CALIB_NOREF_Msk          (0x80000000UL)            /*!< NOREF (Bitfield-Mask: 0x01)                           */
#define PPB_SYST_CALIB_SKEW_Pos           (30UL)                    /*!< SKEW (Bit 30)                                         */
#define PPB_SYST_CALIB_SKEW_Msk           (0x40000000UL)            /*!< SKEW (Bitfield-Mask: 0x01)                            */
#define PPB_SYST_CALIB_TENMS_Pos          (0UL)                     /*!< TENMS (Bit 0)                                         */
#define PPB_SYST_CALIB_TENMS_Msk          (0xffffffUL)              /*!< TENMS (Bitfield-Mask: 0xffffff)                       */
/* =======================================================  NVIC_ISER  ======================================================= */
#define PPB_NVIC_ISER_SETENA_Pos          (0UL)                     /*!< SETENA (Bit 0)                                        */
#define PPB_NVIC_ISER_SETENA_Msk          (0xffffffffUL)            /*!< SETENA (Bitfield-Mask: 0xffffffff)                    */
/* =======================================================  NVIC_ICER  ======================================================= */
#define PPB_NVIC_ICER_CLRENA_Pos          (0UL)                     /*!< CLRENA (Bit 0)                                        */
#define PPB_NVIC_ICER_CLRENA_Msk          (0xffffffffUL)            /*!< CLRENA (Bitfield-Mask: 0xffffffff)                    */
/* =======================================================  NVIC_ISPR  ======================================================= */
#define PPB_NVIC_ISPR_SETPEND_Pos         (0UL)                     /*!< SETPEND (Bit 0)                                       */
#define PPB_NVIC_ISPR_SETPEND_Msk         (0xffffffffUL)            /*!< SETPEND (Bitfield-Mask: 0xffffffff)                   */
/* =======================================================  NVIC_ICPR  ======================================================= */
#define PPB_NVIC_ICPR_CLRPEND_Pos         (0UL)                     /*!< CLRPEND (Bit 0)                                       */
#define PPB_NVIC_ICPR_CLRPEND_Msk         (0xffffffffUL)            /*!< CLRPEND (Bitfield-Mask: 0xffffffff)                   */
/* =======================================================  NVIC_IPR0  ======================================================= */
#define PPB_NVIC_IPR0_IP_3_Pos            (30UL)                    /*!< IP_3 (Bit 30)                                         */
#define PPB_NVIC_IPR0_IP_3_Msk            (0xc0000000UL)            /*!< IP_3 (Bitfield-Mask: 0x03)                            */
#define PPB_NVIC_IPR0_IP_2_Pos            (22UL)                    /*!< IP_2 (Bit 22)                                         */
#define PPB_NVIC_IPR0_IP_2_Msk            (0xc00000UL)              /*!< IP_2 (Bitfield-Mask: 0x03)                            */
#define PPB_NVIC_IPR0_IP_1_Pos            (14UL)                    /*!< IP_1 (Bit 14)                                         */
#define PPB_NVIC_IPR0_IP_1_Msk            (0xc000UL)                /*!< IP_1 (Bitfield-Mask: 0x03)                            */
#define PPB_NVIC_IPR0_IP_0_Pos            (6UL)                     /*!< IP_0 (Bit 6)                                          */
#define PPB_NVIC_IPR0_IP_0_Msk            (0xc0UL)                  /*!< IP_0 (Bitfield-Mask: 0x03)                            */
/* =======================================================  NVIC_IPR1  ======================================================= */
#define PPB_NVIC_IPR1_IP_7_Pos            (30UL)                    /*!< IP_7 (Bit 30)                                         */
#define PPB_NVIC_IPR1_IP_7_Msk            (0xc0000000UL)            /*!< IP_7 (Bitfield-Mask: 0x03)                            */
#define PPB_NVIC_IPR1_IP_6_Pos            (22UL)                    /*!< IP_6 (Bit 22)                                         */
#define PPB_NVIC_IPR1_IP_6_Msk            (0xc00000UL)              /*!< IP_6 (Bitfield-Mask: 0x03)                            */
#define PPB_NVIC_IPR1_IP_5_Pos            (14UL)                    /*!< IP_5 (Bit 14)                                         */
#define PPB_NVIC_IPR1_IP_5_Msk            (0xc000UL)                /*!< IP_5 (Bitfield-Mask: 0x03)                            */
#define PPB_NVIC_IPR1_IP_4_Pos            (6UL)                     /*!< IP_4 (Bit 6)                                          */
#define PPB_NVIC_IPR1_IP_4_Msk            (0xc0UL)                  /*!< IP_4 (Bitfield-Mask: 0x03)                            */
/* =======================================================  NVIC_IPR2  ======================================================= */
#define PPB_NVIC_IPR2_IP_11_Pos           (30UL)                    /*!< IP_11 (Bit 30)                                        */
#define PPB_NVIC_IPR2_IP_11_Msk           (0xc0000000UL)            /*!< IP_11 (Bitfield-Mask: 0x03)                           */
#define PPB_NVIC_IPR2_IP_10_Pos           (22UL)                    /*!< IP_10 (Bit 22)                                        */
#define PPB_NVIC_IPR2_IP_10_Msk           (0xc00000UL)              /*!< IP_10 (Bitfield-Mask: 0x03)                           */
#define PPB_NVIC_IPR2_IP_9_Pos            (14UL)                    /*!< IP_9 (Bit 14)                                         */
#define PPB_NVIC_IPR2_IP_9_Msk            (0xc000UL)                /*!< IP_9 (Bitfield-Mask: 0x03)                            */
#define PPB_NVIC_IPR2_IP_8_Pos            (6UL)                     /*!< IP_8 (Bit 6)                                          */
#define PPB_NVIC_IPR2_IP_8_Msk            (0xc0UL)                  /*!< IP_8 (Bitfield-Mask: 0x03)                            */
/* =======================================================  NVIC_IPR3  ======================================================= */
#define PPB_NVIC_IPR3_IP_15_Pos           (30UL)                    /*!< IP_15 (Bit 30)                                        */
#define PPB_NVIC_IPR3_IP_15_Msk           (0xc0000000UL)            /*!< IP_15 (Bitfield-Mask: 0x03)                           */
#define PPB_NVIC_IPR3_IP_14_Pos           (22UL)                    /*!< IP_14 (Bit 22)                                        */
#define PPB_NVIC_IPR3_IP_14_Msk           (0xc00000UL)              /*!< IP_14 (Bitfield-Mask: 0x03)                           */
#define PPB_NVIC_IPR3_IP_13_Pos           (14UL)                    /*!< IP_13 (Bit 14)                                        */
#define PPB_NVIC_IPR3_IP_13_Msk           (0xc000UL)                /*!< IP_13 (Bitfield-Mask: 0x03)                           */
#define PPB_NVIC_IPR3_IP_12_Pos           (6UL)                     /*!< IP_12 (Bit 6)                                         */
#define PPB_NVIC_IPR3_IP_12_Msk           (0xc0UL)                  /*!< IP_12 (Bitfield-Mask: 0x03)                           */
/* =======================================================  NVIC_IPR4  ======================================================= */
#define PPB_NVIC_IPR4_IP_19_Pos           (30UL)                    /*!< IP_19 (Bit 30)                                        */
#define PPB_NVIC_IPR4_IP_19_Msk           (0xc0000000UL)            /*!< IP_19 (Bitfield-Mask: 0x03)                           */
#define PPB_NVIC_IPR4_IP_18_Pos           (22UL)                    /*!< IP_18 (Bit 22)                                        */
#define PPB_NVIC_IPR4_IP_18_Msk           (0xc00000UL)              /*!< IP_18 (Bitfield-Mask: 0x03)                           */
#define PPB_NVIC_IPR4_IP_17_Pos           (14UL)                    /*!< IP_17 (Bit 14)                                        */
#define PPB_NVIC_IPR4_IP_17_Msk           (0xc000UL)                /*!< IP_17 (Bitfield-Mask: 0x03)                           */
#define PPB_NVIC_IPR4_IP_16_Pos           (6UL)                     /*!< IP_16 (Bit 6)                                         */
#define PPB_NVIC_IPR4_IP_16_Msk           (0xc0UL)                  /*!< IP_16 (Bitfield-Mask: 0x03)                           */
/* =======================================================  NVIC_IPR5  ======================================================= */
#define PPB_NVIC_IPR5_IP_23_Pos           (30UL)                    /*!< IP_23 (Bit 30)                                        */
#define PPB_NVIC_IPR5_IP_23_Msk           (0xc0000000UL)            /*!< IP_23 (Bitfield-Mask: 0x03)                           */
#define PPB_NVIC_IPR5_IP_22_Pos           (22UL)                    /*!< IP_22 (Bit 22)                                        */
#define PPB_NVIC_IPR5_IP_22_Msk           (0xc00000UL)              /*!< IP_22 (Bitfield-Mask: 0x03)                           */
#define PPB_NVIC_IPR5_IP_21_Pos           (14UL)                    /*!< IP_21 (Bit 14)                                        */
#define PPB_NVIC_IPR5_IP_21_Msk           (0xc000UL)                /*!< IP_21 (Bitfield-Mask: 0x03)                           */
#define PPB_NVIC_IPR5_IP_20_Pos           (6UL)                     /*!< IP_20 (Bit 6)                                         */
#define PPB_NVIC_IPR5_IP_20_Msk           (0xc0UL)                  /*!< IP_20 (Bitfield-Mask: 0x03)                           */
/* =======================================================  NVIC_IPR6  ======================================================= */
#define PPB_NVIC_IPR6_IP_27_Pos           (30UL)                    /*!< IP_27 (Bit 30)                                        */
#define PPB_NVIC_IPR6_IP_27_Msk           (0xc0000000UL)            /*!< IP_27 (Bitfield-Mask: 0x03)                           */
#define PPB_NVIC_IPR6_IP_26_Pos           (22UL)                    /*!< IP_26 (Bit 22)                                        */
#define PPB_NVIC_IPR6_IP_26_Msk           (0xc00000UL)              /*!< IP_26 (Bitfield-Mask: 0x03)                           */
#define PPB_NVIC_IPR6_IP_25_Pos           (14UL)                    /*!< IP_25 (Bit 14)                                        */
#define PPB_NVIC_IPR6_IP_25_Msk           (0xc000UL)                /*!< IP_25 (Bitfield-Mask: 0x03)                           */
#define PPB_NVIC_IPR6_IP_24_Pos           (6UL)                     /*!< IP_24 (Bit 6)                                         */
#define PPB_NVIC_IPR6_IP_24_Msk           (0xc0UL)                  /*!< IP_24 (Bitfield-Mask: 0x03)                           */
/* =======================================================  NVIC_IPR7  ======================================================= */
#define PPB_NVIC_IPR7_IP_31_Pos           (30UL)                    /*!< IP_31 (Bit 30)                                        */
#define PPB_NVIC_IPR7_IP_31_Msk           (0xc0000000UL)            /*!< IP_31 (Bitfield-Mask: 0x03)                           */
#define PPB_NVIC_IPR7_IP_30_Pos           (22UL)                    /*!< IP_30 (Bit 22)                                        */
#define PPB_NVIC_IPR7_IP_30_Msk           (0xc00000UL)              /*!< IP_30 (Bitfield-Mask: 0x03)                           */
#define PPB_NVIC_IPR7_IP_29_Pos           (14UL)                    /*!< IP_29 (Bit 14)                                        */
#define PPB_NVIC_IPR7_IP_29_Msk           (0xc000UL)                /*!< IP_29 (Bitfield-Mask: 0x03)                           */
#define PPB_NVIC_IPR7_IP_28_Pos           (6UL)                     /*!< IP_28 (Bit 6)                                         */
#define PPB_NVIC_IPR7_IP_28_Msk           (0xc0UL)                  /*!< IP_28 (Bitfield-Mask: 0x03)                           */
/* =========================================================  CPUID  ========================================================= */
#define PPB_CPUID_IMPLEMENTER_Pos         (24UL)                    /*!< IMPLEMENTER (Bit 24)                                  */
#define PPB_CPUID_IMPLEMENTER_Msk         (0xff000000UL)            /*!< IMPLEMENTER (Bitfield-Mask: 0xff)                     */
#define PPB_CPUID_VARIANT_Pos             (20UL)                    /*!< VARIANT (Bit 20)                                      */
#define PPB_CPUID_VARIANT_Msk             (0xf00000UL)              /*!< VARIANT (Bitfield-Mask: 0x0f)                         */
#define PPB_CPUID_ARCHITECTURE_Pos        (16UL)                    /*!< ARCHITECTURE (Bit 16)                                 */
#define PPB_CPUID_ARCHITECTURE_Msk        (0xf0000UL)               /*!< ARCHITECTURE (Bitfield-Mask: 0x0f)                    */
#define PPB_CPUID_PARTNO_Pos              (4UL)                     /*!< PARTNO (Bit 4)                                        */
#define PPB_CPUID_PARTNO_Msk              (0xfff0UL)                /*!< PARTNO (Bitfield-Mask: 0xfff)                         */
#define PPB_CPUID_REVISION_Pos            (0UL)                     /*!< REVISION (Bit 0)                                      */
#define PPB_CPUID_REVISION_Msk            (0xfUL)                   /*!< REVISION (Bitfield-Mask: 0x0f)                        */
/* =========================================================  ICSR  ========================================================== */
#define PPB_ICSR_NMIPENDSET_Pos           (31UL)                    /*!< NMIPENDSET (Bit 31)                                   */
#define PPB_ICSR_NMIPENDSET_Msk           (0x80000000UL)            /*!< NMIPENDSET (Bitfield-Mask: 0x01)                      */
#define PPB_ICSR_PENDSVSET_Pos            (28UL)                    /*!< PENDSVSET (Bit 28)                                    */
#define PPB_ICSR_PENDSVSET_Msk            (0x10000000UL)            /*!< PENDSVSET (Bitfield-Mask: 0x01)                       */
#define PPB_ICSR_PENDSVCLR_Pos            (27UL)                    /*!< PENDSVCLR (Bit 27)                                    */
#define PPB_ICSR_PENDSVCLR_Msk            (0x8000000UL)             /*!< PENDSVCLR (Bitfield-Mask: 0x01)                       */
#define PPB_ICSR_PENDSTSET_Pos            (26UL)                    /*!< PENDSTSET (Bit 26)                                    */
#define PPB_ICSR_PENDSTSET_Msk            (0x4000000UL)             /*!< PENDSTSET (Bitfield-Mask: 0x01)                       */
#define PPB_ICSR_PENDSTCLR_Pos            (25UL)                    /*!< PENDSTCLR (Bit 25)                                    */
#define PPB_ICSR_PENDSTCLR_Msk            (0x2000000UL)             /*!< PENDSTCLR (Bitfield-Mask: 0x01)                       */
#define PPB_ICSR_ISRPREEMPT_Pos           (23UL)                    /*!< ISRPREEMPT (Bit 23)                                   */
#define PPB_ICSR_ISRPREEMPT_Msk           (0x800000UL)              /*!< ISRPREEMPT (Bitfield-Mask: 0x01)                      */
#define PPB_ICSR_ISRPENDING_Pos           (22UL)                    /*!< ISRPENDING (Bit 22)                                   */
#define PPB_ICSR_ISRPENDING_Msk           (0x400000UL)              /*!< ISRPENDING (Bitfield-Mask: 0x01)                      */
#define PPB_ICSR_VECTPENDING_Pos          (12UL)                    /*!< VECTPENDING (Bit 12)                                  */
#define PPB_ICSR_VECTPENDING_Msk          (0x1ff000UL)              /*!< VECTPENDING (Bitfield-Mask: 0x1ff)                    */
#define PPB_ICSR_VECTACTIVE_Pos           (0UL)                     /*!< VECTACTIVE (Bit 0)                                    */
#define PPB_ICSR_VECTACTIVE_Msk           (0x1ffUL)                 /*!< VECTACTIVE (Bitfield-Mask: 0x1ff)                     */
/* =========================================================  VTOR  ========================================================== */
#define PPB_VTOR_TBLOFF_Pos               (8UL)                     /*!< TBLOFF (Bit 8)                                        */
#define PPB_VTOR_TBLOFF_Msk               (0xffffff00UL)            /*!< TBLOFF (Bitfield-Mask: 0xffffff)                      */
/* =========================================================  AIRCR  ========================================================= */
#define PPB_AIRCR_VECTKEY_Pos             (16UL)                    /*!< VECTKEY (Bit 16)                                      */
#define PPB_AIRCR_VECTKEY_Msk             (0xffff0000UL)            /*!< VECTKEY (Bitfield-Mask: 0xffff)                       */
#define PPB_AIRCR_ENDIANESS_Pos           (15UL)                    /*!< ENDIANESS (Bit 15)                                    */
#define PPB_AIRCR_ENDIANESS_Msk           (0x8000UL)                /*!< ENDIANESS (Bitfield-Mask: 0x01)                       */
#define PPB_AIRCR_SYSRESETREQ_Pos         (2UL)                     /*!< SYSRESETREQ (Bit 2)                                   */
#define PPB_AIRCR_SYSRESETREQ_Msk         (0x4UL)                   /*!< SYSRESETREQ (Bitfield-Mask: 0x01)                     */
#define PPB_AIRCR_VECTCLRACTIVE_Pos       (1UL)                     /*!< VECTCLRACTIVE (Bit 1)                                 */
#define PPB_AIRCR_VECTCLRACTIVE_Msk       (0x2UL)                   /*!< VECTCLRACTIVE (Bitfield-Mask: 0x01)                   */
/* ==========================================================  SCR  ========================================================== */
#define PPB_SCR_SEVONPEND_Pos             (4UL)                     /*!< SEVONPEND (Bit 4)                                     */
#define PPB_SCR_SEVONPEND_Msk             (0x10UL)                  /*!< SEVONPEND (Bitfield-Mask: 0x01)                       */
#define PPB_SCR_SLEEPDEEP_Pos             (2UL)                     /*!< SLEEPDEEP (Bit 2)                                     */
#define PPB_SCR_SLEEPDEEP_Msk             (0x4UL)                   /*!< SLEEPDEEP (Bitfield-Mask: 0x01)                       */
#define PPB_SCR_SLEEPONEXIT_Pos           (1UL)                     /*!< SLEEPONEXIT (Bit 1)                                   */
#define PPB_SCR_SLEEPONEXIT_Msk           (0x2UL)                   /*!< SLEEPONEXIT (Bitfield-Mask: 0x01)                     */
/* ==========================================================  CCR  ========================================================== */
#define PPB_CCR_STKALIGN_Pos              (9UL)                     /*!< STKALIGN (Bit 9)                                      */
#define PPB_CCR_STKALIGN_Msk              (0x200UL)                 /*!< STKALIGN (Bitfield-Mask: 0x01)                        */
#define PPB_CCR_UNALIGN_TRP_Pos           (3UL)                     /*!< UNALIGN_TRP (Bit 3)                                   */
#define PPB_CCR_UNALIGN_TRP_Msk           (0x8UL)                   /*!< UNALIGN_TRP (Bitfield-Mask: 0x01)                     */
/* =========================================================  SHPR2  ========================================================= */
#define PPB_SHPR2_PRI_11_Pos              (30UL)                    /*!< PRI_11 (Bit 30)                                       */
#define PPB_SHPR2_PRI_11_Msk              (0xc0000000UL)            /*!< PRI_11 (Bitfield-Mask: 0x03)                          */
/* =========================================================  SHPR3  ========================================================= */
#define PPB_SHPR3_PRI_15_Pos              (30UL)                    /*!< PRI_15 (Bit 30)                                       */
#define PPB_SHPR3_PRI_15_Msk              (0xc0000000UL)            /*!< PRI_15 (Bitfield-Mask: 0x03)                          */
#define PPB_SHPR3_PRI_14_Pos              (22UL)                    /*!< PRI_14 (Bit 22)                                       */
#define PPB_SHPR3_PRI_14_Msk              (0xc00000UL)              /*!< PRI_14 (Bitfield-Mask: 0x03)                          */
/* =========================================================  SHCSR  ========================================================= */
#define PPB_SHCSR_SVCALLPENDED_Pos        (15UL)                    /*!< SVCALLPENDED (Bit 15)                                 */
#define PPB_SHCSR_SVCALLPENDED_Msk        (0x8000UL)                /*!< SVCALLPENDED (Bitfield-Mask: 0x01)                    */
/* =======================================================  MPU_TYPE  ======================================================== */
#define PPB_MPU_TYPE_IREGION_Pos          (16UL)                    /*!< IREGION (Bit 16)                                      */
#define PPB_MPU_TYPE_IREGION_Msk          (0xff0000UL)              /*!< IREGION (Bitfield-Mask: 0xff)                         */
#define PPB_MPU_TYPE_DREGION_Pos          (8UL)                     /*!< DREGION (Bit 8)                                       */
#define PPB_MPU_TYPE_DREGION_Msk          (0xff00UL)                /*!< DREGION (Bitfield-Mask: 0xff)                         */
#define PPB_MPU_TYPE_SEPARATE_Pos         (0UL)                     /*!< SEPARATE (Bit 0)                                      */
#define PPB_MPU_TYPE_SEPARATE_Msk         (0x1UL)                   /*!< SEPARATE (Bitfield-Mask: 0x01)                        */
/* =======================================================  MPU_CTRL  ======================================================== */
#define PPB_MPU_CTRL_PRIVDEFENA_Pos       (2UL)                     /*!< PRIVDEFENA (Bit 2)                                    */
#define PPB_MPU_CTRL_PRIVDEFENA_Msk       (0x4UL)                   /*!< PRIVDEFENA (Bitfield-Mask: 0x01)                      */
#define PPB_MPU_CTRL_HFNMIENA_Pos         (1UL)                     /*!< HFNMIENA (Bit 1)                                      */
#define PPB_MPU_CTRL_HFNMIENA_Msk         (0x2UL)                   /*!< HFNMIENA (Bitfield-Mask: 0x01)                        */
#define PPB_MPU_CTRL_ENABLE_Pos           (0UL)                     /*!< ENABLE (Bit 0)                                        */
#define PPB_MPU_CTRL_ENABLE_Msk           (0x1UL)                   /*!< ENABLE (Bitfield-Mask: 0x01)                          */
/* ========================================================  MPU_RNR  ======================================================== */
#define PPB_MPU_RNR_REGION_Pos            (0UL)                     /*!< REGION (Bit 0)                                        */
#define PPB_MPU_RNR_REGION_Msk            (0xfUL)                   /*!< REGION (Bitfield-Mask: 0x0f)                          */
/* =======================================================  MPU_RBAR  ======================================================== */
#define PPB_MPU_RBAR_ADDR_Pos             (8UL)                     /*!< ADDR (Bit 8)                                          */
#define PPB_MPU_RBAR_ADDR_Msk             (0xffffff00UL)            /*!< ADDR (Bitfield-Mask: 0xffffff)                        */
#define PPB_MPU_RBAR_VALID_Pos            (4UL)                     /*!< VALID (Bit 4)                                         */
#define PPB_MPU_RBAR_VALID_Msk            (0x10UL)                  /*!< VALID (Bitfield-Mask: 0x01)                           */
#define PPB_MPU_RBAR_REGION_Pos           (0UL)                     /*!< REGION (Bit 0)                                        */
#define PPB_MPU_RBAR_REGION_Msk           (0xfUL)                   /*!< REGION (Bitfield-Mask: 0x0f)                          */
/* =======================================================  MPU_RASR  ======================================================== */
#define PPB_MPU_RASR_ATTRS_Pos            (16UL)                    /*!< ATTRS (Bit 16)                                        */
#define PPB_MPU_RASR_ATTRS_Msk            (0xffff0000UL)            /*!< ATTRS (Bitfield-Mask: 0xffff)                         */
#define PPB_MPU_RASR_SRD_Pos              (8UL)                     /*!< SRD (Bit 8)                                           */
#define PPB_MPU_RASR_SRD_Msk              (0xff00UL)                /*!< SRD (Bitfield-Mask: 0xff)                             */
#define PPB_MPU_RASR_SIZE_Pos             (1UL)                     /*!< SIZE (Bit 1)                                          */
#define PPB_MPU_RASR_SIZE_Msk             (0x3eUL)                  /*!< SIZE (Bitfield-Mask: 0x1f)                            */
#define PPB_MPU_RASR_ENABLE_Pos           (0UL)                     /*!< ENABLE (Bit 0)                                        */
#define PPB_MPU_RASR_ENABLE_Msk           (0x1UL)                   /*!< ENABLE (Bitfield-Mask: 0x01)                          */

/** @} */ /* End of group PosMask_peripherals */


/* =========================================================================================================================== */
/* ================                           Enumerated Values Peripheral Section                            ================ */
/* =========================================================================================================================== */


/** @addtogroup EnumValue_peripherals
  * @{
  */



/* =========================================================================================================================== */
/* ================                                         XIP_CTRL                                          ================ */
/* =========================================================================================================================== */

/* =========================================================  CTRL  ========================================================== */
/* =========================================================  FLUSH  ========================================================= */
/* =========================================================  STAT  ========================================================== */
/* ========================================================  CTR_HIT  ======================================================== */
/* ========================================================  CTR_ACC  ======================================================== */
/* ======================================================  STREAM_ADDR  ====================================================== */
/* ======================================================  STREAM_CTR  ======================================================= */
/* ======================================================  STREAM_FIFO  ====================================================== */


/* =========================================================================================================================== */
/* ================                                          XIP_SSI                                          ================ */
/* =========================================================================================================================== */

/* ========================================================  CTRLR0  ========================================================= */
/* ============================================  XIP_SSI CTRLR0 SPI_FRF [21..22]  ============================================ */
typedef enum {                                  /*!< XIP_SSI_CTRLR0_SPI_FRF                                                    */
  XIP_SSI_CTRLR0_SPI_FRF_STD           = 0,     /*!< STD : Standard 1-bit SPI frame format; 1 bit per SCK, full-duplex         */
  XIP_SSI_CTRLR0_SPI_FRF_DUAL          = 1,     /*!< DUAL : Dual-SPI frame format; two bits per SCK, half-duplex               */
  XIP_SSI_CTRLR0_SPI_FRF_QUAD          = 2,     /*!< QUAD : Quad-SPI frame format; four bits per SCK, half-duplex              */
} XIP_SSI_CTRLR0_SPI_FRF_Enum;

/* ==============================================  XIP_SSI CTRLR0 TMOD [8..9]  =============================================== */
typedef enum {                                  /*!< XIP_SSI_CTRLR0_TMOD                                                       */
  XIP_SSI_CTRLR0_TMOD_TX_AND_RX        = 0,     /*!< TX_AND_RX : Both transmit and receive                                     */
  XIP_SSI_CTRLR0_TMOD_TX_ONLY          = 1,     /*!< TX_ONLY : Transmit only (not for FRF == 0, standard SPI mode)             */
  XIP_SSI_CTRLR0_TMOD_RX_ONLY          = 2,     /*!< RX_ONLY : Receive only (not for FRF == 0, standard SPI mode)              */
  XIP_SSI_CTRLR0_TMOD_EEPROM_READ      = 3,     /*!< EEPROM_READ : EEPROM read mode (TX then RX; RX starts after
                                                     control data TX'd)                                                        */
} XIP_SSI_CTRLR0_TMOD_Enum;

/* ========================================================  CTRLR1  ========================================================= */
/* ========================================================  SSIENR  ========================================================= */
/* =========================================================  MWCR  ========================================================== */
/* ==========================================================  SER  ========================================================== */
/* =========================================================  BAUDR  ========================================================= */
/* ========================================================  TXFTLR  ========================================================= */
/* ========================================================  RXFTLR  ========================================================= */
/* =========================================================  TXFLR  ========================================================= */
/* =========================================================  RXFLR  ========================================================= */
/* ==========================================================  SR  =========================================================== */
/* ==========================================================  IMR  ========================================================== */
/* ==========================================================  ISR  ========================================================== */
/* =========================================================  RISR  ========================================================== */
/* ========================================================  TXOICR  ========================================================= */
/* ========================================================  RXOICR  ========================================================= */
/* ========================================================  RXUICR  ========================================================= */
/* ========================================================  MSTICR  ========================================================= */
/* ==========================================================  ICR  ========================================================== */
/* =========================================================  DMACR  ========================================================= */
/* ========================================================  DMATDLR  ======================================================== */
/* ========================================================  DMARDLR  ======================================================== */
/* ==========================================================  IDR  ========================================================== */
/* ====================================================  SSI_VERSION_ID  ===================================================== */
/* ==========================================================  DR0  ========================================================== */
/* =====================================================  RX_SAMPLE_DLY  ===================================================== */
/* ======================================================  SPI_CTRLR0  ======================================================= */
/* ===========================================  XIP_SSI SPI_CTRLR0 INST_L [8..9]  ============================================ */
typedef enum {                                  /*!< XIP_SSI_SPI_CTRLR0_INST_L                                                 */
  XIP_SSI_SPI_CTRLR0_INST_L_NONE       = 0,     /*!< NONE : No instruction                                                     */
  XIP_SSI_SPI_CTRLR0_INST_L_4B         = 1,     /*!< 4B : 4-bit instruction                                                    */
  XIP_SSI_SPI_CTRLR0_INST_L_8B         = 2,     /*!< 8B : 8-bit instruction                                                    */
  XIP_SSI_SPI_CTRLR0_INST_L_16B        = 3,     /*!< 16B : 16-bit instruction                                                  */
} XIP_SSI_SPI_CTRLR0_INST_L_Enum;

/* =========================================  XIP_SSI SPI_CTRLR0 TRANS_TYPE [0..1]  ========================================== */
typedef enum {                                  /*!< XIP_SSI_SPI_CTRLR0_TRANS_TYPE                                             */
  XIP_SSI_SPI_CTRLR0_TRANS_TYPE_1C1A   = 0,     /*!< 1C1A : Command and address both in standard SPI frame format              */
  XIP_SSI_SPI_CTRLR0_TRANS_TYPE_1C2A   = 1,     /*!< 1C2A : Command in standard SPI format, address in format specified
                                                     by FRF                                                                    */
  XIP_SSI_SPI_CTRLR0_TRANS_TYPE_2C2A   = 2,     /*!< 2C2A : Command and address both in format specified by FRF (e.g.
                                                     Dual-SPI)                                                                 */
} XIP_SSI_SPI_CTRLR0_TRANS_TYPE_Enum;

/* ====================================================  TXD_DRIVE_EDGE  ===================================================== */


/* =========================================================================================================================== */
/* ================                                          SYSINFO                                          ================ */
/* =========================================================================================================================== */

/* ========================================================  CHIP_ID  ======================================================== */
/* =======================================================  PLATFORM  ======================================================== */
/* =====================================================  GITREF_RP2040  ===================================================== */


/* =========================================================================================================================== */
/* ================                                          SYSCFG                                           ================ */
/* =========================================================================================================================== */

/* ====================================================  PROC0_NMI_MASK  ===================================================== */
/* ====================================================  PROC1_NMI_MASK  ===================================================== */
/* ======================================================  PROC_CONFIG  ====================================================== */
/* ==================================================  PROC_IN_SYNC_BYPASS  ================================================== */
/* ================================================  PROC_IN_SYNC_BYPASS_HI  ================================================= */
/* =======================================================  DBGFORCE  ======================================================== */
/* =====================================================  MEMPOWERDOWN  ====================================================== */


/* =========================================================================================================================== */
/* ================                                          CLOCKS                                           ================ */
/* =========================================================================================================================== */

/* ====================================================  CLK_GPOUT0_CTRL  ==================================================== */
/* =========================================  CLOCKS CLK_GPOUT0_CTRL AUXSRC [5..8]  ========================================== */
typedef enum {                                  /*!< CLOCKS_CLK_GPOUT0_CTRL_AUXSRC                                             */
  CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_clksrc_pll_sys = 0,/*!< clksrc_pll_sys : clksrc_pll_sys                                        */
  CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_clksrc_gpin0 = 1,/*!< clksrc_gpin0 : clksrc_gpin0                                              */
  CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_clksrc_gpin1 = 2,/*!< clksrc_gpin1 : clksrc_gpin1                                              */
  CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_clksrc_pll_usb = 3,/*!< clksrc_pll_usb : clksrc_pll_usb                                        */
  CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_rosc_clksrc = 4,/*!< rosc_clksrc : rosc_clksrc                                                 */
  CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_xosc_clksrc = 5,/*!< xosc_clksrc : xosc_clksrc                                                 */
  CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_clk_sys = 6,    /*!< clk_sys : clk_sys                                                         */
  CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_clk_usb = 7,    /*!< clk_usb : clk_usb                                                         */
  CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_clk_adc = 8,    /*!< clk_adc : clk_adc                                                         */
  CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_clk_rtc = 9,    /*!< clk_rtc : clk_rtc                                                         */
  CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_clk_ref = 10,   /*!< clk_ref : clk_ref                                                         */
} CLOCKS_CLK_GPOUT0_CTRL_AUXSRC_Enum;

/* ====================================================  CLK_GPOUT0_DIV  ===================================================== */
/* ==================================================  CLK_GPOUT0_SELECTED  ================================================== */
/* ====================================================  CLK_GPOUT1_CTRL  ==================================================== */
/* =========================================  CLOCKS CLK_GPOUT1_CTRL AUXSRC [5..8]  ========================================== */
typedef enum {                                  /*!< CLOCKS_CLK_GPOUT1_CTRL_AUXSRC                                             */
  CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_clksrc_pll_sys = 0,/*!< clksrc_pll_sys : clksrc_pll_sys                                        */
  CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_clksrc_gpin0 = 1,/*!< clksrc_gpin0 : clksrc_gpin0                                              */
  CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_clksrc_gpin1 = 2,/*!< clksrc_gpin1 : clksrc_gpin1                                              */
  CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_clksrc_pll_usb = 3,/*!< clksrc_pll_usb : clksrc_pll_usb                                        */
  CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_rosc_clksrc = 4,/*!< rosc_clksrc : rosc_clksrc                                                 */
  CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_xosc_clksrc = 5,/*!< xosc_clksrc : xosc_clksrc                                                 */
  CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_clk_sys = 6,    /*!< clk_sys : clk_sys                                                         */
  CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_clk_usb = 7,    /*!< clk_usb : clk_usb                                                         */
  CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_clk_adc = 8,    /*!< clk_adc : clk_adc                                                         */
  CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_clk_rtc = 9,    /*!< clk_rtc : clk_rtc                                                         */
  CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_clk_ref = 10,   /*!< clk_ref : clk_ref                                                         */
} CLOCKS_CLK_GPOUT1_CTRL_AUXSRC_Enum;

/* ====================================================  CLK_GPOUT1_DIV  ===================================================== */
/* ==================================================  CLK_GPOUT1_SELECTED  ================================================== */
/* ====================================================  CLK_GPOUT2_CTRL  ==================================================== */
/* =========================================  CLOCKS CLK_GPOUT2_CTRL AUXSRC [5..8]  ========================================== */
typedef enum {                                  /*!< CLOCKS_CLK_GPOUT2_CTRL_AUXSRC                                             */
  CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_clksrc_pll_sys = 0,/*!< clksrc_pll_sys : clksrc_pll_sys                                        */
  CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_clksrc_gpin0 = 1,/*!< clksrc_gpin0 : clksrc_gpin0                                              */
  CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_clksrc_gpin1 = 2,/*!< clksrc_gpin1 : clksrc_gpin1                                              */
  CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_clksrc_pll_usb = 3,/*!< clksrc_pll_usb : clksrc_pll_usb                                        */
  CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_rosc_clksrc_ph = 4,/*!< rosc_clksrc_ph : rosc_clksrc_ph                                        */
  CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_xosc_clksrc = 5,/*!< xosc_clksrc : xosc_clksrc                                                 */
  CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_clk_sys = 6,    /*!< clk_sys : clk_sys                                                         */
  CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_clk_usb = 7,    /*!< clk_usb : clk_usb                                                         */
  CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_clk_adc = 8,    /*!< clk_adc : clk_adc                                                         */
  CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_clk_rtc = 9,    /*!< clk_rtc : clk_rtc                                                         */
  CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_clk_ref = 10,   /*!< clk_ref : clk_ref                                                         */
} CLOCKS_CLK_GPOUT2_CTRL_AUXSRC_Enum;

/* ====================================================  CLK_GPOUT2_DIV  ===================================================== */
/* ==================================================  CLK_GPOUT2_SELECTED  ================================================== */
/* ====================================================  CLK_GPOUT3_CTRL  ==================================================== */
/* =========================================  CLOCKS CLK_GPOUT3_CTRL AUXSRC [5..8]  ========================================== */
typedef enum {                                  /*!< CLOCKS_CLK_GPOUT3_CTRL_AUXSRC                                             */
  CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_clksrc_pll_sys = 0,/*!< clksrc_pll_sys : clksrc_pll_sys                                        */
  CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_clksrc_gpin0 = 1,/*!< clksrc_gpin0 : clksrc_gpin0                                              */
  CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_clksrc_gpin1 = 2,/*!< clksrc_gpin1 : clksrc_gpin1                                              */
  CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_clksrc_pll_usb = 3,/*!< clksrc_pll_usb : clksrc_pll_usb                                        */
  CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_rosc_clksrc_ph = 4,/*!< rosc_clksrc_ph : rosc_clksrc_ph                                        */
  CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_xosc_clksrc = 5,/*!< xosc_clksrc : xosc_clksrc                                                 */
  CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_clk_sys = 6,    /*!< clk_sys : clk_sys                                                         */
  CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_clk_usb = 7,    /*!< clk_usb : clk_usb                                                         */
  CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_clk_adc = 8,    /*!< clk_adc : clk_adc                                                         */
  CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_clk_rtc = 9,    /*!< clk_rtc : clk_rtc                                                         */
  CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_clk_ref = 10,   /*!< clk_ref : clk_ref                                                         */
} CLOCKS_CLK_GPOUT3_CTRL_AUXSRC_Enum;

/* ====================================================  CLK_GPOUT3_DIV  ===================================================== */
/* ==================================================  CLK_GPOUT3_SELECTED  ================================================== */
/* =====================================================  CLK_REF_CTRL  ====================================================== */
/* ===========================================  CLOCKS CLK_REF_CTRL AUXSRC [5..6]  =========================================== */
typedef enum {                                  /*!< CLOCKS_CLK_REF_CTRL_AUXSRC                                                */
  CLOCKS_CLK_REF_CTRL_AUXSRC_clksrc_pll_usb = 0,/*!< clksrc_pll_usb : clksrc_pll_usb                                           */
  CLOCKS_CLK_REF_CTRL_AUXSRC_clksrc_gpin0 = 1,  /*!< clksrc_gpin0 : clksrc_gpin0                                               */
  CLOCKS_CLK_REF_CTRL_AUXSRC_clksrc_gpin1 = 2,  /*!< clksrc_gpin1 : clksrc_gpin1                                               */
} CLOCKS_CLK_REF_CTRL_AUXSRC_Enum;

/* ============================================  CLOCKS CLK_REF_CTRL SRC [0..1]  ============================================= */
typedef enum {                                  /*!< CLOCKS_CLK_REF_CTRL_SRC                                                   */
  CLOCKS_CLK_REF_CTRL_SRC_rosc_clksrc_ph = 0,   /*!< rosc_clksrc_ph : rosc_clksrc_ph                                           */
  CLOCKS_CLK_REF_CTRL_SRC_clksrc_clk_ref_aux = 1,/*!< clksrc_clk_ref_aux : clksrc_clk_ref_aux                                  */
  CLOCKS_CLK_REF_CTRL_SRC_xosc_clksrc  = 2,     /*!< xosc_clksrc : xosc_clksrc                                                 */
} CLOCKS_CLK_REF_CTRL_SRC_Enum;

/* ======================================================  CLK_REF_DIV  ====================================================== */
/* ===================================================  CLK_REF_SELECTED  ==================================================== */
/* =====================================================  CLK_SYS_CTRL  ====================================================== */
/* ===========================================  CLOCKS CLK_SYS_CTRL AUXSRC [5..7]  =========================================== */
typedef enum {                                  /*!< CLOCKS_CLK_SYS_CTRL_AUXSRC                                                */
  CLOCKS_CLK_SYS_CTRL_AUXSRC_clksrc_pll_sys = 0,/*!< clksrc_pll_sys : clksrc_pll_sys                                           */
  CLOCKS_CLK_SYS_CTRL_AUXSRC_clksrc_pll_usb = 1,/*!< clksrc_pll_usb : clksrc_pll_usb                                           */
  CLOCKS_CLK_SYS_CTRL_AUXSRC_rosc_clksrc = 2,   /*!< rosc_clksrc : rosc_clksrc                                                 */
  CLOCKS_CLK_SYS_CTRL_AUXSRC_xosc_clksrc = 3,   /*!< xosc_clksrc : xosc_clksrc                                                 */
  CLOCKS_CLK_SYS_CTRL_AUXSRC_clksrc_gpin0 = 4,  /*!< clksrc_gpin0 : clksrc_gpin0                                               */
  CLOCKS_CLK_SYS_CTRL_AUXSRC_clksrc_gpin1 = 5,  /*!< clksrc_gpin1 : clksrc_gpin1                                               */
} CLOCKS_CLK_SYS_CTRL_AUXSRC_Enum;

/* ============================================  CLOCKS CLK_SYS_CTRL SRC [0..0]  ============================================= */
typedef enum {                                  /*!< CLOCKS_CLK_SYS_CTRL_SRC                                                   */
  CLOCKS_CLK_SYS_CTRL_SRC_clk_ref      = 0,     /*!< clk_ref : clk_ref                                                         */
  CLOCKS_CLK_SYS_CTRL_SRC_clksrc_clk_sys_aux = 1,/*!< clksrc_clk_sys_aux : clksrc_clk_sys_aux                                  */
} CLOCKS_CLK_SYS_CTRL_SRC_Enum;

/* ======================================================  CLK_SYS_DIV  ====================================================== */
/* ===================================================  CLK_SYS_SELECTED  ==================================================== */
/* =====================================================  CLK_PERI_CTRL  ===================================================== */
/* ==========================================  CLOCKS CLK_PERI_CTRL AUXSRC [5..7]  =========================================== */
typedef enum {                                  /*!< CLOCKS_CLK_PERI_CTRL_AUXSRC                                               */
  CLOCKS_CLK_PERI_CTRL_AUXSRC_clk_sys  = 0,     /*!< clk_sys : clk_sys                                                         */
  CLOCKS_CLK_PERI_CTRL_AUXSRC_clksrc_pll_sys = 1,/*!< clksrc_pll_sys : clksrc_pll_sys                                          */
  CLOCKS_CLK_PERI_CTRL_AUXSRC_clksrc_pll_usb = 2,/*!< clksrc_pll_usb : clksrc_pll_usb                                          */
  CLOCKS_CLK_PERI_CTRL_AUXSRC_rosc_clksrc_ph = 3,/*!< rosc_clksrc_ph : rosc_clksrc_ph                                          */
  CLOCKS_CLK_PERI_CTRL_AUXSRC_xosc_clksrc = 4,  /*!< xosc_clksrc : xosc_clksrc                                                 */
  CLOCKS_CLK_PERI_CTRL_AUXSRC_clksrc_gpin0 = 5, /*!< clksrc_gpin0 : clksrc_gpin0                                               */
  CLOCKS_CLK_PERI_CTRL_AUXSRC_clksrc_gpin1 = 6, /*!< clksrc_gpin1 : clksrc_gpin1                                               */
} CLOCKS_CLK_PERI_CTRL_AUXSRC_Enum;

/* ===================================================  CLK_PERI_SELECTED  =================================================== */
/* =====================================================  CLK_USB_CTRL  ====================================================== */
/* ===========================================  CLOCKS CLK_USB_CTRL AUXSRC [5..7]  =========================================== */
typedef enum {                                  /*!< CLOCKS_CLK_USB_CTRL_AUXSRC                                                */
  CLOCKS_CLK_USB_CTRL_AUXSRC_clksrc_pll_usb = 0,/*!< clksrc_pll_usb : clksrc_pll_usb                                           */
  CLOCKS_CLK_USB_CTRL_AUXSRC_clksrc_pll_sys = 1,/*!< clksrc_pll_sys : clksrc_pll_sys                                           */
  CLOCKS_CLK_USB_CTRL_AUXSRC_rosc_clksrc_ph = 2,/*!< rosc_clksrc_ph : rosc_clksrc_ph                                           */
  CLOCKS_CLK_USB_CTRL_AUXSRC_xosc_clksrc = 3,   /*!< xosc_clksrc : xosc_clksrc                                                 */
  CLOCKS_CLK_USB_CTRL_AUXSRC_clksrc_gpin0 = 4,  /*!< clksrc_gpin0 : clksrc_gpin0                                               */
  CLOCKS_CLK_USB_CTRL_AUXSRC_clksrc_gpin1 = 5,  /*!< clksrc_gpin1 : clksrc_gpin1                                               */
} CLOCKS_CLK_USB_CTRL_AUXSRC_Enum;

/* ======================================================  CLK_USB_DIV  ====================================================== */
/* ===================================================  CLK_USB_SELECTED  ==================================================== */
/* =====================================================  CLK_ADC_CTRL  ====================================================== */
/* ===========================================  CLOCKS CLK_ADC_CTRL AUXSRC [5..7]  =========================================== */
typedef enum {                                  /*!< CLOCKS_CLK_ADC_CTRL_AUXSRC                                                */
  CLOCKS_CLK_ADC_CTRL_AUXSRC_clksrc_pll_usb = 0,/*!< clksrc_pll_usb : clksrc_pll_usb                                           */
  CLOCKS_CLK_ADC_CTRL_AUXSRC_clksrc_pll_sys = 1,/*!< clksrc_pll_sys : clksrc_pll_sys                                           */
  CLOCKS_CLK_ADC_CTRL_AUXSRC_rosc_clksrc_ph = 2,/*!< rosc_clksrc_ph : rosc_clksrc_ph                                           */
  CLOCKS_CLK_ADC_CTRL_AUXSRC_xosc_clksrc = 3,   /*!< xosc_clksrc : xosc_clksrc                                                 */
  CLOCKS_CLK_ADC_CTRL_AUXSRC_clksrc_gpin0 = 4,  /*!< clksrc_gpin0 : clksrc_gpin0                                               */
  CLOCKS_CLK_ADC_CTRL_AUXSRC_clksrc_gpin1 = 5,  /*!< clksrc_gpin1 : clksrc_gpin1                                               */
} CLOCKS_CLK_ADC_CTRL_AUXSRC_Enum;

/* ======================================================  CLK_ADC_DIV  ====================================================== */
/* ===================================================  CLK_ADC_SELECTED  ==================================================== */
/* =====================================================  CLK_RTC_CTRL  ====================================================== */
/* ===========================================  CLOCKS CLK_RTC_CTRL AUXSRC [5..7]  =========================================== */
typedef enum {                                  /*!< CLOCKS_CLK_RTC_CTRL_AUXSRC                                                */
  CLOCKS_CLK_RTC_CTRL_AUXSRC_clksrc_pll_usb = 0,/*!< clksrc_pll_usb : clksrc_pll_usb                                           */
  CLOCKS_CLK_RTC_CTRL_AUXSRC_clksrc_pll_sys = 1,/*!< clksrc_pll_sys : clksrc_pll_sys                                           */
  CLOCKS_CLK_RTC_CTRL_AUXSRC_rosc_clksrc_ph = 2,/*!< rosc_clksrc_ph : rosc_clksrc_ph                                           */
  CLOCKS_CLK_RTC_CTRL_AUXSRC_xosc_clksrc = 3,   /*!< xosc_clksrc : xosc_clksrc                                                 */
  CLOCKS_CLK_RTC_CTRL_AUXSRC_clksrc_gpin0 = 4,  /*!< clksrc_gpin0 : clksrc_gpin0                                               */
  CLOCKS_CLK_RTC_CTRL_AUXSRC_clksrc_gpin1 = 5,  /*!< clksrc_gpin1 : clksrc_gpin1                                               */
} CLOCKS_CLK_RTC_CTRL_AUXSRC_Enum;

/* ======================================================  CLK_RTC_DIV  ====================================================== */
/* ===================================================  CLK_RTC_SELECTED  ==================================================== */
/* ==================================================  CLK_SYS_RESUS_CTRL  =================================================== */
/* =================================================  CLK_SYS_RESUS_STATUS  ================================================== */
/* ======================================================  FC0_REF_KHZ  ====================================================== */
/* ======================================================  FC0_MIN_KHZ  ====================================================== */
/* ======================================================  FC0_MAX_KHZ  ====================================================== */
/* =======================================================  FC0_DELAY  ======================================================= */
/* =====================================================  FC0_INTERVAL  ====================================================== */
/* ========================================================  FC0_SRC  ======================================================== */
/* =============================================  CLOCKS FC0_SRC FC0_SRC [0..7]  ============================================= */
typedef enum {                                  /*!< CLOCKS_FC0_SRC_FC0_SRC                                                    */
  CLOCKS_FC0_SRC_FC0_SRC_NULL          = 0,     /*!< NULL : NULL                                                               */
  CLOCKS_FC0_SRC_FC0_SRC_pll_sys_clksrc_primary = 1,/*!< pll_sys_clksrc_primary : pll_sys_clksrc_primary                       */
  CLOCKS_FC0_SRC_FC0_SRC_pll_usb_clksrc_primary = 2,/*!< pll_usb_clksrc_primary : pll_usb_clksrc_primary                       */
  CLOCKS_FC0_SRC_FC0_SRC_rosc_clksrc   = 3,     /*!< rosc_clksrc : rosc_clksrc                                                 */
  CLOCKS_FC0_SRC_FC0_SRC_rosc_clksrc_ph = 4,    /*!< rosc_clksrc_ph : rosc_clksrc_ph                                           */
  CLOCKS_FC0_SRC_FC0_SRC_xosc_clksrc   = 5,     /*!< xosc_clksrc : xosc_clksrc                                                 */
  CLOCKS_FC0_SRC_FC0_SRC_clksrc_gpin0  = 6,     /*!< clksrc_gpin0 : clksrc_gpin0                                               */
  CLOCKS_FC0_SRC_FC0_SRC_clksrc_gpin1  = 7,     /*!< clksrc_gpin1 : clksrc_gpin1                                               */
  CLOCKS_FC0_SRC_FC0_SRC_clk_ref       = 8,     /*!< clk_ref : clk_ref                                                         */
  CLOCKS_FC0_SRC_FC0_SRC_clk_sys       = 9,     /*!< clk_sys : clk_sys                                                         */
  CLOCKS_FC0_SRC_FC0_SRC_clk_peri      = 10,    /*!< clk_peri : clk_peri                                                       */
  CLOCKS_FC0_SRC_FC0_SRC_clk_usb       = 11,    /*!< clk_usb : clk_usb                                                         */
  CLOCKS_FC0_SRC_FC0_SRC_clk_adc       = 12,    /*!< clk_adc : clk_adc                                                         */
  CLOCKS_FC0_SRC_FC0_SRC_clk_rtc       = 13,    /*!< clk_rtc : clk_rtc                                                         */
} CLOCKS_FC0_SRC_FC0_SRC_Enum;

/* ======================================================  FC0_STATUS  ======================================================= */
/* ======================================================  FC0_RESULT  ======================================================= */
/* =======================================================  WAKE_EN0  ======================================================== */
/* =======================================================  WAKE_EN1  ======================================================== */
/* =======================================================  SLEEP_EN0  ======================================================= */
/* =======================================================  SLEEP_EN1  ======================================================= */
/* =======================================================  ENABLED0  ======================================================== */
/* =======================================================  ENABLED1  ======================================================== */
/* =========================================================  INTR  ========================================================== */
/* =========================================================  INTE  ========================================================== */
/* =========================================================  INTF  ========================================================== */
/* =========================================================  INTS  ========================================================== */


/* =========================================================================================================================== */
/* ================                                          RESETS                                           ================ */
/* =========================================================================================================================== */

/* =========================================================  RESET  ========================================================= */
/* =========================================================  WDSEL  ========================================================= */
/* ======================================================  RESET_DONE  ======================================================= */


/* =========================================================================================================================== */
/* ================                                            PSM                                            ================ */
/* =========================================================================================================================== */

/* ========================================================  FRCE_ON  ======================================================== */
/* =======================================================  FRCE_OFF  ======================================================== */
/* =========================================================  WDSEL  ========================================================= */
/* =========================================================  DONE  ========================================================== */


/* =========================================================================================================================== */
/* ================                                         IO_BANK0                                          ================ */
/* =========================================================================================================================== */

/* =====================================================  GPIO0_STATUS  ====================================================== */
/* ======================================================  GPIO0_CTRL  ======================================================= */
/* =========================================  IO_BANK0 GPIO0_CTRL IRQOVER [28..29]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO0_CTRL_IRQOVER                                               */
  IO_BANK0_GPIO0_CTRL_IRQOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the interrupt                                       */
  IO_BANK0_GPIO0_CTRL_IRQOVER_INVERT   = 1,     /*!< INVERT : invert the interrupt                                             */
  IO_BANK0_GPIO0_CTRL_IRQOVER_LOW      = 2,     /*!< LOW : drive interrupt low                                                 */
  IO_BANK0_GPIO0_CTRL_IRQOVER_HIGH     = 3,     /*!< HIGH : drive interrupt high                                               */
} IO_BANK0_GPIO0_CTRL_IRQOVER_Enum;

/* ==========================================  IO_BANK0 GPIO0_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO0_CTRL_INOVER                                                */
  IO_BANK0_GPIO0_CTRL_INOVER_NORMAL    = 0,     /*!< NORMAL : don't invert the peri input                                      */
  IO_BANK0_GPIO0_CTRL_INOVER_INVERT    = 1,     /*!< INVERT : invert the peri input                                            */
  IO_BANK0_GPIO0_CTRL_INOVER_LOW       = 2,     /*!< LOW : drive peri input low                                                */
  IO_BANK0_GPIO0_CTRL_INOVER_HIGH      = 3,     /*!< HIGH : drive peri input high                                              */
} IO_BANK0_GPIO0_CTRL_INOVER_Enum;

/* ==========================================  IO_BANK0 GPIO0_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO0_CTRL_OEOVER                                                */
  IO_BANK0_GPIO0_CTRL_OEOVER_NORMAL    = 0,     /*!< NORMAL : drive output enable from peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO0_CTRL_OEOVER_INVERT    = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal
                                                     selected by funcsel                                                       */
  IO_BANK0_GPIO0_CTRL_OEOVER_DISABLE   = 2,     /*!< DISABLE : disable output                                                  */
  IO_BANK0_GPIO0_CTRL_OEOVER_ENABLE    = 3,     /*!< ENABLE : enable output                                                    */
} IO_BANK0_GPIO0_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO0_CTRL OUTOVER [8..9]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO0_CTRL_OUTOVER                                               */
  IO_BANK0_GPIO0_CTRL_OUTOVER_NORMAL   = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel          */
  IO_BANK0_GPIO0_CTRL_OUTOVER_INVERT   = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO0_CTRL_OUTOVER_LOW      = 2,     /*!< LOW : drive output low                                                    */
  IO_BANK0_GPIO0_CTRL_OUTOVER_HIGH     = 3,     /*!< HIGH : drive output high                                                  */
} IO_BANK0_GPIO0_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO0_CTRL FUNCSEL [0..4]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO0_CTRL_FUNCSEL                                               */
  IO_BANK0_GPIO0_CTRL_FUNCSEL_jtag_tck = 0,     /*!< jtag_tck : jtag_tck                                                       */
  IO_BANK0_GPIO0_CTRL_FUNCSEL_spi0_rx  = 1,     /*!< spi0_rx : spi0_rx                                                         */
  IO_BANK0_GPIO0_CTRL_FUNCSEL_uart0_tx = 2,     /*!< uart0_tx : uart0_tx                                                       */
  IO_BANK0_GPIO0_CTRL_FUNCSEL_i2c0_sda = 3,     /*!< i2c0_sda : i2c0_sda                                                       */
  IO_BANK0_GPIO0_CTRL_FUNCSEL_pwm_a_0  = 4,     /*!< pwm_a_0 : pwm_a_0                                                         */
  IO_BANK0_GPIO0_CTRL_FUNCSEL_sio_0    = 5,     /*!< sio_0 : sio_0                                                             */
  IO_BANK0_GPIO0_CTRL_FUNCSEL_pio0_0   = 6,     /*!< pio0_0 : pio0_0                                                           */
  IO_BANK0_GPIO0_CTRL_FUNCSEL_pio1_0   = 7,     /*!< pio1_0 : pio1_0                                                           */
  IO_BANK0_GPIO0_CTRL_FUNCSEL_usb_muxing_overcurr_detect = 9,/*!< usb_muxing_overcurr_detect : usb_muxing_overcurr_detect      */
  IO_BANK0_GPIO0_CTRL_FUNCSEL_null     = 31,    /*!< null : null                                                               */
} IO_BANK0_GPIO0_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO1_STATUS  ====================================================== */
/* ======================================================  GPIO1_CTRL  ======================================================= */
/* =========================================  IO_BANK0 GPIO1_CTRL IRQOVER [28..29]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO1_CTRL_IRQOVER                                               */
  IO_BANK0_GPIO1_CTRL_IRQOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the interrupt                                       */
  IO_BANK0_GPIO1_CTRL_IRQOVER_INVERT   = 1,     /*!< INVERT : invert the interrupt                                             */
  IO_BANK0_GPIO1_CTRL_IRQOVER_LOW      = 2,     /*!< LOW : drive interrupt low                                                 */
  IO_BANK0_GPIO1_CTRL_IRQOVER_HIGH     = 3,     /*!< HIGH : drive interrupt high                                               */
} IO_BANK0_GPIO1_CTRL_IRQOVER_Enum;

/* ==========================================  IO_BANK0 GPIO1_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO1_CTRL_INOVER                                                */
  IO_BANK0_GPIO1_CTRL_INOVER_NORMAL    = 0,     /*!< NORMAL : don't invert the peri input                                      */
  IO_BANK0_GPIO1_CTRL_INOVER_INVERT    = 1,     /*!< INVERT : invert the peri input                                            */
  IO_BANK0_GPIO1_CTRL_INOVER_LOW       = 2,     /*!< LOW : drive peri input low                                                */
  IO_BANK0_GPIO1_CTRL_INOVER_HIGH      = 3,     /*!< HIGH : drive peri input high                                              */
} IO_BANK0_GPIO1_CTRL_INOVER_Enum;

/* ==========================================  IO_BANK0 GPIO1_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO1_CTRL_OEOVER                                                */
  IO_BANK0_GPIO1_CTRL_OEOVER_NORMAL    = 0,     /*!< NORMAL : drive output enable from peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO1_CTRL_OEOVER_INVERT    = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal
                                                     selected by funcsel                                                       */
  IO_BANK0_GPIO1_CTRL_OEOVER_DISABLE   = 2,     /*!< DISABLE : disable output                                                  */
  IO_BANK0_GPIO1_CTRL_OEOVER_ENABLE    = 3,     /*!< ENABLE : enable output                                                    */
} IO_BANK0_GPIO1_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO1_CTRL OUTOVER [8..9]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO1_CTRL_OUTOVER                                               */
  IO_BANK0_GPIO1_CTRL_OUTOVER_NORMAL   = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel          */
  IO_BANK0_GPIO1_CTRL_OUTOVER_INVERT   = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO1_CTRL_OUTOVER_LOW      = 2,     /*!< LOW : drive output low                                                    */
  IO_BANK0_GPIO1_CTRL_OUTOVER_HIGH     = 3,     /*!< HIGH : drive output high                                                  */
} IO_BANK0_GPIO1_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO1_CTRL FUNCSEL [0..4]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO1_CTRL_FUNCSEL                                               */
  IO_BANK0_GPIO1_CTRL_FUNCSEL_jtag_tms = 0,     /*!< jtag_tms : jtag_tms                                                       */
  IO_BANK0_GPIO1_CTRL_FUNCSEL_spi0_ss_n = 1,    /*!< spi0_ss_n : spi0_ss_n                                                     */
  IO_BANK0_GPIO1_CTRL_FUNCSEL_uart0_rx = 2,     /*!< uart0_rx : uart0_rx                                                       */
  IO_BANK0_GPIO1_CTRL_FUNCSEL_i2c0_scl = 3,     /*!< i2c0_scl : i2c0_scl                                                       */
  IO_BANK0_GPIO1_CTRL_FUNCSEL_pwm_b_0  = 4,     /*!< pwm_b_0 : pwm_b_0                                                         */
  IO_BANK0_GPIO1_CTRL_FUNCSEL_sio_1    = 5,     /*!< sio_1 : sio_1                                                             */
  IO_BANK0_GPIO1_CTRL_FUNCSEL_pio0_1   = 6,     /*!< pio0_1 : pio0_1                                                           */
  IO_BANK0_GPIO1_CTRL_FUNCSEL_pio1_1   = 7,     /*!< pio1_1 : pio1_1                                                           */
  IO_BANK0_GPIO1_CTRL_FUNCSEL_usb_muxing_vbus_detect = 9,/*!< usb_muxing_vbus_detect : usb_muxing_vbus_detect                  */
  IO_BANK0_GPIO1_CTRL_FUNCSEL_null     = 31,    /*!< null : null                                                               */
} IO_BANK0_GPIO1_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO2_STATUS  ====================================================== */
/* ======================================================  GPIO2_CTRL  ======================================================= */
/* =========================================  IO_BANK0 GPIO2_CTRL IRQOVER [28..29]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO2_CTRL_IRQOVER                                               */
  IO_BANK0_GPIO2_CTRL_IRQOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the interrupt                                       */
  IO_BANK0_GPIO2_CTRL_IRQOVER_INVERT   = 1,     /*!< INVERT : invert the interrupt                                             */
  IO_BANK0_GPIO2_CTRL_IRQOVER_LOW      = 2,     /*!< LOW : drive interrupt low                                                 */
  IO_BANK0_GPIO2_CTRL_IRQOVER_HIGH     = 3,     /*!< HIGH : drive interrupt high                                               */
} IO_BANK0_GPIO2_CTRL_IRQOVER_Enum;

/* ==========================================  IO_BANK0 GPIO2_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO2_CTRL_INOVER                                                */
  IO_BANK0_GPIO2_CTRL_INOVER_NORMAL    = 0,     /*!< NORMAL : don't invert the peri input                                      */
  IO_BANK0_GPIO2_CTRL_INOVER_INVERT    = 1,     /*!< INVERT : invert the peri input                                            */
  IO_BANK0_GPIO2_CTRL_INOVER_LOW       = 2,     /*!< LOW : drive peri input low                                                */
  IO_BANK0_GPIO2_CTRL_INOVER_HIGH      = 3,     /*!< HIGH : drive peri input high                                              */
} IO_BANK0_GPIO2_CTRL_INOVER_Enum;

/* ==========================================  IO_BANK0 GPIO2_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO2_CTRL_OEOVER                                                */
  IO_BANK0_GPIO2_CTRL_OEOVER_NORMAL    = 0,     /*!< NORMAL : drive output enable from peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO2_CTRL_OEOVER_INVERT    = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal
                                                     selected by funcsel                                                       */
  IO_BANK0_GPIO2_CTRL_OEOVER_DISABLE   = 2,     /*!< DISABLE : disable output                                                  */
  IO_BANK0_GPIO2_CTRL_OEOVER_ENABLE    = 3,     /*!< ENABLE : enable output                                                    */
} IO_BANK0_GPIO2_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO2_CTRL OUTOVER [8..9]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO2_CTRL_OUTOVER                                               */
  IO_BANK0_GPIO2_CTRL_OUTOVER_NORMAL   = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel          */
  IO_BANK0_GPIO2_CTRL_OUTOVER_INVERT   = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO2_CTRL_OUTOVER_LOW      = 2,     /*!< LOW : drive output low                                                    */
  IO_BANK0_GPIO2_CTRL_OUTOVER_HIGH     = 3,     /*!< HIGH : drive output high                                                  */
} IO_BANK0_GPIO2_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO2_CTRL FUNCSEL [0..4]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO2_CTRL_FUNCSEL                                               */
  IO_BANK0_GPIO2_CTRL_FUNCSEL_jtag_tdi = 0,     /*!< jtag_tdi : jtag_tdi                                                       */
  IO_BANK0_GPIO2_CTRL_FUNCSEL_spi0_sclk = 1,    /*!< spi0_sclk : spi0_sclk                                                     */
  IO_BANK0_GPIO2_CTRL_FUNCSEL_uart0_cts = 2,    /*!< uart0_cts : uart0_cts                                                     */
  IO_BANK0_GPIO2_CTRL_FUNCSEL_i2c1_sda = 3,     /*!< i2c1_sda : i2c1_sda                                                       */
  IO_BANK0_GPIO2_CTRL_FUNCSEL_pwm_a_1  = 4,     /*!< pwm_a_1 : pwm_a_1                                                         */
  IO_BANK0_GPIO2_CTRL_FUNCSEL_sio_2    = 5,     /*!< sio_2 : sio_2                                                             */
  IO_BANK0_GPIO2_CTRL_FUNCSEL_pio0_2   = 6,     /*!< pio0_2 : pio0_2                                                           */
  IO_BANK0_GPIO2_CTRL_FUNCSEL_pio1_2   = 7,     /*!< pio1_2 : pio1_2                                                           */
  IO_BANK0_GPIO2_CTRL_FUNCSEL_usb_muxing_vbus_en = 9,/*!< usb_muxing_vbus_en : usb_muxing_vbus_en                              */
  IO_BANK0_GPIO2_CTRL_FUNCSEL_null     = 31,    /*!< null : null                                                               */
} IO_BANK0_GPIO2_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO3_STATUS  ====================================================== */
/* ======================================================  GPIO3_CTRL  ======================================================= */
/* =========================================  IO_BANK0 GPIO3_CTRL IRQOVER [28..29]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO3_CTRL_IRQOVER                                               */
  IO_BANK0_GPIO3_CTRL_IRQOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the interrupt                                       */
  IO_BANK0_GPIO3_CTRL_IRQOVER_INVERT   = 1,     /*!< INVERT : invert the interrupt                                             */
  IO_BANK0_GPIO3_CTRL_IRQOVER_LOW      = 2,     /*!< LOW : drive interrupt low                                                 */
  IO_BANK0_GPIO3_CTRL_IRQOVER_HIGH     = 3,     /*!< HIGH : drive interrupt high                                               */
} IO_BANK0_GPIO3_CTRL_IRQOVER_Enum;

/* ==========================================  IO_BANK0 GPIO3_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO3_CTRL_INOVER                                                */
  IO_BANK0_GPIO3_CTRL_INOVER_NORMAL    = 0,     /*!< NORMAL : don't invert the peri input                                      */
  IO_BANK0_GPIO3_CTRL_INOVER_INVERT    = 1,     /*!< INVERT : invert the peri input                                            */
  IO_BANK0_GPIO3_CTRL_INOVER_LOW       = 2,     /*!< LOW : drive peri input low                                                */
  IO_BANK0_GPIO3_CTRL_INOVER_HIGH      = 3,     /*!< HIGH : drive peri input high                                              */
} IO_BANK0_GPIO3_CTRL_INOVER_Enum;

/* ==========================================  IO_BANK0 GPIO3_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO3_CTRL_OEOVER                                                */
  IO_BANK0_GPIO3_CTRL_OEOVER_NORMAL    = 0,     /*!< NORMAL : drive output enable from peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO3_CTRL_OEOVER_INVERT    = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal
                                                     selected by funcsel                                                       */
  IO_BANK0_GPIO3_CTRL_OEOVER_DISABLE   = 2,     /*!< DISABLE : disable output                                                  */
  IO_BANK0_GPIO3_CTRL_OEOVER_ENABLE    = 3,     /*!< ENABLE : enable output                                                    */
} IO_BANK0_GPIO3_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO3_CTRL OUTOVER [8..9]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO3_CTRL_OUTOVER                                               */
  IO_BANK0_GPIO3_CTRL_OUTOVER_NORMAL   = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel          */
  IO_BANK0_GPIO3_CTRL_OUTOVER_INVERT   = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO3_CTRL_OUTOVER_LOW      = 2,     /*!< LOW : drive output low                                                    */
  IO_BANK0_GPIO3_CTRL_OUTOVER_HIGH     = 3,     /*!< HIGH : drive output high                                                  */
} IO_BANK0_GPIO3_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO3_CTRL FUNCSEL [0..4]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO3_CTRL_FUNCSEL                                               */
  IO_BANK0_GPIO3_CTRL_FUNCSEL_jtag_tdo = 0,     /*!< jtag_tdo : jtag_tdo                                                       */
  IO_BANK0_GPIO3_CTRL_FUNCSEL_spi0_tx  = 1,     /*!< spi0_tx : spi0_tx                                                         */
  IO_BANK0_GPIO3_CTRL_FUNCSEL_uart0_rts = 2,    /*!< uart0_rts : uart0_rts                                                     */
  IO_BANK0_GPIO3_CTRL_FUNCSEL_i2c1_scl = 3,     /*!< i2c1_scl : i2c1_scl                                                       */
  IO_BANK0_GPIO3_CTRL_FUNCSEL_pwm_b_1  = 4,     /*!< pwm_b_1 : pwm_b_1                                                         */
  IO_BANK0_GPIO3_CTRL_FUNCSEL_sio_3    = 5,     /*!< sio_3 : sio_3                                                             */
  IO_BANK0_GPIO3_CTRL_FUNCSEL_pio0_3   = 6,     /*!< pio0_3 : pio0_3                                                           */
  IO_BANK0_GPIO3_CTRL_FUNCSEL_pio1_3   = 7,     /*!< pio1_3 : pio1_3                                                           */
  IO_BANK0_GPIO3_CTRL_FUNCSEL_usb_muxing_overcurr_detect = 9,/*!< usb_muxing_overcurr_detect : usb_muxing_overcurr_detect      */
  IO_BANK0_GPIO3_CTRL_FUNCSEL_null     = 31,    /*!< null : null                                                               */
} IO_BANK0_GPIO3_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO4_STATUS  ====================================================== */
/* ======================================================  GPIO4_CTRL  ======================================================= */
/* =========================================  IO_BANK0 GPIO4_CTRL IRQOVER [28..29]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO4_CTRL_IRQOVER                                               */
  IO_BANK0_GPIO4_CTRL_IRQOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the interrupt                                       */
  IO_BANK0_GPIO4_CTRL_IRQOVER_INVERT   = 1,     /*!< INVERT : invert the interrupt                                             */
  IO_BANK0_GPIO4_CTRL_IRQOVER_LOW      = 2,     /*!< LOW : drive interrupt low                                                 */
  IO_BANK0_GPIO4_CTRL_IRQOVER_HIGH     = 3,     /*!< HIGH : drive interrupt high                                               */
} IO_BANK0_GPIO4_CTRL_IRQOVER_Enum;

/* ==========================================  IO_BANK0 GPIO4_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO4_CTRL_INOVER                                                */
  IO_BANK0_GPIO4_CTRL_INOVER_NORMAL    = 0,     /*!< NORMAL : don't invert the peri input                                      */
  IO_BANK0_GPIO4_CTRL_INOVER_INVERT    = 1,     /*!< INVERT : invert the peri input                                            */
  IO_BANK0_GPIO4_CTRL_INOVER_LOW       = 2,     /*!< LOW : drive peri input low                                                */
  IO_BANK0_GPIO4_CTRL_INOVER_HIGH      = 3,     /*!< HIGH : drive peri input high                                              */
} IO_BANK0_GPIO4_CTRL_INOVER_Enum;

/* ==========================================  IO_BANK0 GPIO4_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO4_CTRL_OEOVER                                                */
  IO_BANK0_GPIO4_CTRL_OEOVER_NORMAL    = 0,     /*!< NORMAL : drive output enable from peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO4_CTRL_OEOVER_INVERT    = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal
                                                     selected by funcsel                                                       */
  IO_BANK0_GPIO4_CTRL_OEOVER_DISABLE   = 2,     /*!< DISABLE : disable output                                                  */
  IO_BANK0_GPIO4_CTRL_OEOVER_ENABLE    = 3,     /*!< ENABLE : enable output                                                    */
} IO_BANK0_GPIO4_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO4_CTRL OUTOVER [8..9]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO4_CTRL_OUTOVER                                               */
  IO_BANK0_GPIO4_CTRL_OUTOVER_NORMAL   = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel          */
  IO_BANK0_GPIO4_CTRL_OUTOVER_INVERT   = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO4_CTRL_OUTOVER_LOW      = 2,     /*!< LOW : drive output low                                                    */
  IO_BANK0_GPIO4_CTRL_OUTOVER_HIGH     = 3,     /*!< HIGH : drive output high                                                  */
} IO_BANK0_GPIO4_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO4_CTRL FUNCSEL [0..4]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO4_CTRL_FUNCSEL                                               */
  IO_BANK0_GPIO4_CTRL_FUNCSEL_spi0_rx  = 1,     /*!< spi0_rx : spi0_rx                                                         */
  IO_BANK0_GPIO4_CTRL_FUNCSEL_uart1_tx = 2,     /*!< uart1_tx : uart1_tx                                                       */
  IO_BANK0_GPIO4_CTRL_FUNCSEL_i2c0_sda = 3,     /*!< i2c0_sda : i2c0_sda                                                       */
  IO_BANK0_GPIO4_CTRL_FUNCSEL_pwm_a_2  = 4,     /*!< pwm_a_2 : pwm_a_2                                                         */
  IO_BANK0_GPIO4_CTRL_FUNCSEL_sio_4    = 5,     /*!< sio_4 : sio_4                                                             */
  IO_BANK0_GPIO4_CTRL_FUNCSEL_pio0_4   = 6,     /*!< pio0_4 : pio0_4                                                           */
  IO_BANK0_GPIO4_CTRL_FUNCSEL_pio1_4   = 7,     /*!< pio1_4 : pio1_4                                                           */
  IO_BANK0_GPIO4_CTRL_FUNCSEL_usb_muxing_vbus_detect = 9,/*!< usb_muxing_vbus_detect : usb_muxing_vbus_detect                  */
  IO_BANK0_GPIO4_CTRL_FUNCSEL_null     = 31,    /*!< null : null                                                               */
} IO_BANK0_GPIO4_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO5_STATUS  ====================================================== */
/* ======================================================  GPIO5_CTRL  ======================================================= */
/* =========================================  IO_BANK0 GPIO5_CTRL IRQOVER [28..29]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO5_CTRL_IRQOVER                                               */
  IO_BANK0_GPIO5_CTRL_IRQOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the interrupt                                       */
  IO_BANK0_GPIO5_CTRL_IRQOVER_INVERT   = 1,     /*!< INVERT : invert the interrupt                                             */
  IO_BANK0_GPIO5_CTRL_IRQOVER_LOW      = 2,     /*!< LOW : drive interrupt low                                                 */
  IO_BANK0_GPIO5_CTRL_IRQOVER_HIGH     = 3,     /*!< HIGH : drive interrupt high                                               */
} IO_BANK0_GPIO5_CTRL_IRQOVER_Enum;

/* ==========================================  IO_BANK0 GPIO5_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO5_CTRL_INOVER                                                */
  IO_BANK0_GPIO5_CTRL_INOVER_NORMAL    = 0,     /*!< NORMAL : don't invert the peri input                                      */
  IO_BANK0_GPIO5_CTRL_INOVER_INVERT    = 1,     /*!< INVERT : invert the peri input                                            */
  IO_BANK0_GPIO5_CTRL_INOVER_LOW       = 2,     /*!< LOW : drive peri input low                                                */
  IO_BANK0_GPIO5_CTRL_INOVER_HIGH      = 3,     /*!< HIGH : drive peri input high                                              */
} IO_BANK0_GPIO5_CTRL_INOVER_Enum;

/* ==========================================  IO_BANK0 GPIO5_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO5_CTRL_OEOVER                                                */
  IO_BANK0_GPIO5_CTRL_OEOVER_NORMAL    = 0,     /*!< NORMAL : drive output enable from peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO5_CTRL_OEOVER_INVERT    = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal
                                                     selected by funcsel                                                       */
  IO_BANK0_GPIO5_CTRL_OEOVER_DISABLE   = 2,     /*!< DISABLE : disable output                                                  */
  IO_BANK0_GPIO5_CTRL_OEOVER_ENABLE    = 3,     /*!< ENABLE : enable output                                                    */
} IO_BANK0_GPIO5_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO5_CTRL OUTOVER [8..9]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO5_CTRL_OUTOVER                                               */
  IO_BANK0_GPIO5_CTRL_OUTOVER_NORMAL   = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel          */
  IO_BANK0_GPIO5_CTRL_OUTOVER_INVERT   = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO5_CTRL_OUTOVER_LOW      = 2,     /*!< LOW : drive output low                                                    */
  IO_BANK0_GPIO5_CTRL_OUTOVER_HIGH     = 3,     /*!< HIGH : drive output high                                                  */
} IO_BANK0_GPIO5_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO5_CTRL FUNCSEL [0..4]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO5_CTRL_FUNCSEL                                               */
  IO_BANK0_GPIO5_CTRL_FUNCSEL_spi0_ss_n = 1,    /*!< spi0_ss_n : spi0_ss_n                                                     */
  IO_BANK0_GPIO5_CTRL_FUNCSEL_uart1_rx = 2,     /*!< uart1_rx : uart1_rx                                                       */
  IO_BANK0_GPIO5_CTRL_FUNCSEL_i2c0_scl = 3,     /*!< i2c0_scl : i2c0_scl                                                       */
  IO_BANK0_GPIO5_CTRL_FUNCSEL_pwm_b_2  = 4,     /*!< pwm_b_2 : pwm_b_2                                                         */
  IO_BANK0_GPIO5_CTRL_FUNCSEL_sio_5    = 5,     /*!< sio_5 : sio_5                                                             */
  IO_BANK0_GPIO5_CTRL_FUNCSEL_pio0_5   = 6,     /*!< pio0_5 : pio0_5                                                           */
  IO_BANK0_GPIO5_CTRL_FUNCSEL_pio1_5   = 7,     /*!< pio1_5 : pio1_5                                                           */
  IO_BANK0_GPIO5_CTRL_FUNCSEL_usb_muxing_vbus_en = 9,/*!< usb_muxing_vbus_en : usb_muxing_vbus_en                              */
  IO_BANK0_GPIO5_CTRL_FUNCSEL_null     = 31,    /*!< null : null                                                               */
} IO_BANK0_GPIO5_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO6_STATUS  ====================================================== */
/* ======================================================  GPIO6_CTRL  ======================================================= */
/* =========================================  IO_BANK0 GPIO6_CTRL IRQOVER [28..29]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO6_CTRL_IRQOVER                                               */
  IO_BANK0_GPIO6_CTRL_IRQOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the interrupt                                       */
  IO_BANK0_GPIO6_CTRL_IRQOVER_INVERT   = 1,     /*!< INVERT : invert the interrupt                                             */
  IO_BANK0_GPIO6_CTRL_IRQOVER_LOW      = 2,     /*!< LOW : drive interrupt low                                                 */
  IO_BANK0_GPIO6_CTRL_IRQOVER_HIGH     = 3,     /*!< HIGH : drive interrupt high                                               */
} IO_BANK0_GPIO6_CTRL_IRQOVER_Enum;

/* ==========================================  IO_BANK0 GPIO6_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO6_CTRL_INOVER                                                */
  IO_BANK0_GPIO6_CTRL_INOVER_NORMAL    = 0,     /*!< NORMAL : don't invert the peri input                                      */
  IO_BANK0_GPIO6_CTRL_INOVER_INVERT    = 1,     /*!< INVERT : invert the peri input                                            */
  IO_BANK0_GPIO6_CTRL_INOVER_LOW       = 2,     /*!< LOW : drive peri input low                                                */
  IO_BANK0_GPIO6_CTRL_INOVER_HIGH      = 3,     /*!< HIGH : drive peri input high                                              */
} IO_BANK0_GPIO6_CTRL_INOVER_Enum;

/* ==========================================  IO_BANK0 GPIO6_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO6_CTRL_OEOVER                                                */
  IO_BANK0_GPIO6_CTRL_OEOVER_NORMAL    = 0,     /*!< NORMAL : drive output enable from peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO6_CTRL_OEOVER_INVERT    = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal
                                                     selected by funcsel                                                       */
  IO_BANK0_GPIO6_CTRL_OEOVER_DISABLE   = 2,     /*!< DISABLE : disable output                                                  */
  IO_BANK0_GPIO6_CTRL_OEOVER_ENABLE    = 3,     /*!< ENABLE : enable output                                                    */
} IO_BANK0_GPIO6_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO6_CTRL OUTOVER [8..9]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO6_CTRL_OUTOVER                                               */
  IO_BANK0_GPIO6_CTRL_OUTOVER_NORMAL   = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel          */
  IO_BANK0_GPIO6_CTRL_OUTOVER_INVERT   = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO6_CTRL_OUTOVER_LOW      = 2,     /*!< LOW : drive output low                                                    */
  IO_BANK0_GPIO6_CTRL_OUTOVER_HIGH     = 3,     /*!< HIGH : drive output high                                                  */
} IO_BANK0_GPIO6_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO6_CTRL FUNCSEL [0..4]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO6_CTRL_FUNCSEL                                               */
  IO_BANK0_GPIO6_CTRL_FUNCSEL_spi0_sclk = 1,    /*!< spi0_sclk : spi0_sclk                                                     */
  IO_BANK0_GPIO6_CTRL_FUNCSEL_uart1_cts = 2,    /*!< uart1_cts : uart1_cts                                                     */
  IO_BANK0_GPIO6_CTRL_FUNCSEL_i2c1_sda = 3,     /*!< i2c1_sda : i2c1_sda                                                       */
  IO_BANK0_GPIO6_CTRL_FUNCSEL_pwm_a_3  = 4,     /*!< pwm_a_3 : pwm_a_3                                                         */
  IO_BANK0_GPIO6_CTRL_FUNCSEL_sio_6    = 5,     /*!< sio_6 : sio_6                                                             */
  IO_BANK0_GPIO6_CTRL_FUNCSEL_pio0_6   = 6,     /*!< pio0_6 : pio0_6                                                           */
  IO_BANK0_GPIO6_CTRL_FUNCSEL_pio1_6   = 7,     /*!< pio1_6 : pio1_6                                                           */
  IO_BANK0_GPIO6_CTRL_FUNCSEL_usb_muxing_extphy_softcon = 8,/*!< usb_muxing_extphy_softcon : usb_muxing_extphy_softcon         */
  IO_BANK0_GPIO6_CTRL_FUNCSEL_usb_muxing_overcurr_detect = 9,/*!< usb_muxing_overcurr_detect : usb_muxing_overcurr_detect      */
  IO_BANK0_GPIO6_CTRL_FUNCSEL_null     = 31,    /*!< null : null                                                               */
} IO_BANK0_GPIO6_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO7_STATUS  ====================================================== */
/* ======================================================  GPIO7_CTRL  ======================================================= */
/* =========================================  IO_BANK0 GPIO7_CTRL IRQOVER [28..29]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO7_CTRL_IRQOVER                                               */
  IO_BANK0_GPIO7_CTRL_IRQOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the interrupt                                       */
  IO_BANK0_GPIO7_CTRL_IRQOVER_INVERT   = 1,     /*!< INVERT : invert the interrupt                                             */
  IO_BANK0_GPIO7_CTRL_IRQOVER_LOW      = 2,     /*!< LOW : drive interrupt low                                                 */
  IO_BANK0_GPIO7_CTRL_IRQOVER_HIGH     = 3,     /*!< HIGH : drive interrupt high                                               */
} IO_BANK0_GPIO7_CTRL_IRQOVER_Enum;

/* ==========================================  IO_BANK0 GPIO7_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO7_CTRL_INOVER                                                */
  IO_BANK0_GPIO7_CTRL_INOVER_NORMAL    = 0,     /*!< NORMAL : don't invert the peri input                                      */
  IO_BANK0_GPIO7_CTRL_INOVER_INVERT    = 1,     /*!< INVERT : invert the peri input                                            */
  IO_BANK0_GPIO7_CTRL_INOVER_LOW       = 2,     /*!< LOW : drive peri input low                                                */
  IO_BANK0_GPIO7_CTRL_INOVER_HIGH      = 3,     /*!< HIGH : drive peri input high                                              */
} IO_BANK0_GPIO7_CTRL_INOVER_Enum;

/* ==========================================  IO_BANK0 GPIO7_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO7_CTRL_OEOVER                                                */
  IO_BANK0_GPIO7_CTRL_OEOVER_NORMAL    = 0,     /*!< NORMAL : drive output enable from peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO7_CTRL_OEOVER_INVERT    = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal
                                                     selected by funcsel                                                       */
  IO_BANK0_GPIO7_CTRL_OEOVER_DISABLE   = 2,     /*!< DISABLE : disable output                                                  */
  IO_BANK0_GPIO7_CTRL_OEOVER_ENABLE    = 3,     /*!< ENABLE : enable output                                                    */
} IO_BANK0_GPIO7_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO7_CTRL OUTOVER [8..9]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO7_CTRL_OUTOVER                                               */
  IO_BANK0_GPIO7_CTRL_OUTOVER_NORMAL   = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel          */
  IO_BANK0_GPIO7_CTRL_OUTOVER_INVERT   = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO7_CTRL_OUTOVER_LOW      = 2,     /*!< LOW : drive output low                                                    */
  IO_BANK0_GPIO7_CTRL_OUTOVER_HIGH     = 3,     /*!< HIGH : drive output high                                                  */
} IO_BANK0_GPIO7_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO7_CTRL FUNCSEL [0..4]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO7_CTRL_FUNCSEL                                               */
  IO_BANK0_GPIO7_CTRL_FUNCSEL_spi0_tx  = 1,     /*!< spi0_tx : spi0_tx                                                         */
  IO_BANK0_GPIO7_CTRL_FUNCSEL_uart1_rts = 2,    /*!< uart1_rts : uart1_rts                                                     */
  IO_BANK0_GPIO7_CTRL_FUNCSEL_i2c1_scl = 3,     /*!< i2c1_scl : i2c1_scl                                                       */
  IO_BANK0_GPIO7_CTRL_FUNCSEL_pwm_b_3  = 4,     /*!< pwm_b_3 : pwm_b_3                                                         */
  IO_BANK0_GPIO7_CTRL_FUNCSEL_sio_7    = 5,     /*!< sio_7 : sio_7                                                             */
  IO_BANK0_GPIO7_CTRL_FUNCSEL_pio0_7   = 6,     /*!< pio0_7 : pio0_7                                                           */
  IO_BANK0_GPIO7_CTRL_FUNCSEL_pio1_7   = 7,     /*!< pio1_7 : pio1_7                                                           */
  IO_BANK0_GPIO7_CTRL_FUNCSEL_usb_muxing_extphy_oe_n = 8,/*!< usb_muxing_extphy_oe_n : usb_muxing_extphy_oe_n                  */
  IO_BANK0_GPIO7_CTRL_FUNCSEL_usb_muxing_vbus_detect = 9,/*!< usb_muxing_vbus_detect : usb_muxing_vbus_detect                  */
  IO_BANK0_GPIO7_CTRL_FUNCSEL_null     = 31,    /*!< null : null                                                               */
} IO_BANK0_GPIO7_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO8_STATUS  ====================================================== */
/* ======================================================  GPIO8_CTRL  ======================================================= */
/* =========================================  IO_BANK0 GPIO8_CTRL IRQOVER [28..29]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO8_CTRL_IRQOVER                                               */
  IO_BANK0_GPIO8_CTRL_IRQOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the interrupt                                       */
  IO_BANK0_GPIO8_CTRL_IRQOVER_INVERT   = 1,     /*!< INVERT : invert the interrupt                                             */
  IO_BANK0_GPIO8_CTRL_IRQOVER_LOW      = 2,     /*!< LOW : drive interrupt low                                                 */
  IO_BANK0_GPIO8_CTRL_IRQOVER_HIGH     = 3,     /*!< HIGH : drive interrupt high                                               */
} IO_BANK0_GPIO8_CTRL_IRQOVER_Enum;

/* ==========================================  IO_BANK0 GPIO8_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO8_CTRL_INOVER                                                */
  IO_BANK0_GPIO8_CTRL_INOVER_NORMAL    = 0,     /*!< NORMAL : don't invert the peri input                                      */
  IO_BANK0_GPIO8_CTRL_INOVER_INVERT    = 1,     /*!< INVERT : invert the peri input                                            */
  IO_BANK0_GPIO8_CTRL_INOVER_LOW       = 2,     /*!< LOW : drive peri input low                                                */
  IO_BANK0_GPIO8_CTRL_INOVER_HIGH      = 3,     /*!< HIGH : drive peri input high                                              */
} IO_BANK0_GPIO8_CTRL_INOVER_Enum;

/* ==========================================  IO_BANK0 GPIO8_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO8_CTRL_OEOVER                                                */
  IO_BANK0_GPIO8_CTRL_OEOVER_NORMAL    = 0,     /*!< NORMAL : drive output enable from peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO8_CTRL_OEOVER_INVERT    = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal
                                                     selected by funcsel                                                       */
  IO_BANK0_GPIO8_CTRL_OEOVER_DISABLE   = 2,     /*!< DISABLE : disable output                                                  */
  IO_BANK0_GPIO8_CTRL_OEOVER_ENABLE    = 3,     /*!< ENABLE : enable output                                                    */
} IO_BANK0_GPIO8_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO8_CTRL OUTOVER [8..9]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO8_CTRL_OUTOVER                                               */
  IO_BANK0_GPIO8_CTRL_OUTOVER_NORMAL   = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel          */
  IO_BANK0_GPIO8_CTRL_OUTOVER_INVERT   = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO8_CTRL_OUTOVER_LOW      = 2,     /*!< LOW : drive output low                                                    */
  IO_BANK0_GPIO8_CTRL_OUTOVER_HIGH     = 3,     /*!< HIGH : drive output high                                                  */
} IO_BANK0_GPIO8_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO8_CTRL FUNCSEL [0..4]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO8_CTRL_FUNCSEL                                               */
  IO_BANK0_GPIO8_CTRL_FUNCSEL_spi1_rx  = 1,     /*!< spi1_rx : spi1_rx                                                         */
  IO_BANK0_GPIO8_CTRL_FUNCSEL_uart1_tx = 2,     /*!< uart1_tx : uart1_tx                                                       */
  IO_BANK0_GPIO8_CTRL_FUNCSEL_i2c0_sda = 3,     /*!< i2c0_sda : i2c0_sda                                                       */
  IO_BANK0_GPIO8_CTRL_FUNCSEL_pwm_a_4  = 4,     /*!< pwm_a_4 : pwm_a_4                                                         */
  IO_BANK0_GPIO8_CTRL_FUNCSEL_sio_8    = 5,     /*!< sio_8 : sio_8                                                             */
  IO_BANK0_GPIO8_CTRL_FUNCSEL_pio0_8   = 6,     /*!< pio0_8 : pio0_8                                                           */
  IO_BANK0_GPIO8_CTRL_FUNCSEL_pio1_8   = 7,     /*!< pio1_8 : pio1_8                                                           */
  IO_BANK0_GPIO8_CTRL_FUNCSEL_usb_muxing_extphy_rcv = 8,/*!< usb_muxing_extphy_rcv : usb_muxing_extphy_rcv                     */
  IO_BANK0_GPIO8_CTRL_FUNCSEL_usb_muxing_vbus_en = 9,/*!< usb_muxing_vbus_en : usb_muxing_vbus_en                              */
  IO_BANK0_GPIO8_CTRL_FUNCSEL_null     = 31,    /*!< null : null                                                               */
} IO_BANK0_GPIO8_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO9_STATUS  ====================================================== */
/* ======================================================  GPIO9_CTRL  ======================================================= */
/* =========================================  IO_BANK0 GPIO9_CTRL IRQOVER [28..29]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO9_CTRL_IRQOVER                                               */
  IO_BANK0_GPIO9_CTRL_IRQOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the interrupt                                       */
  IO_BANK0_GPIO9_CTRL_IRQOVER_INVERT   = 1,     /*!< INVERT : invert the interrupt                                             */
  IO_BANK0_GPIO9_CTRL_IRQOVER_LOW      = 2,     /*!< LOW : drive interrupt low                                                 */
  IO_BANK0_GPIO9_CTRL_IRQOVER_HIGH     = 3,     /*!< HIGH : drive interrupt high                                               */
} IO_BANK0_GPIO9_CTRL_IRQOVER_Enum;

/* ==========================================  IO_BANK0 GPIO9_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO9_CTRL_INOVER                                                */
  IO_BANK0_GPIO9_CTRL_INOVER_NORMAL    = 0,     /*!< NORMAL : don't invert the peri input                                      */
  IO_BANK0_GPIO9_CTRL_INOVER_INVERT    = 1,     /*!< INVERT : invert the peri input                                            */
  IO_BANK0_GPIO9_CTRL_INOVER_LOW       = 2,     /*!< LOW : drive peri input low                                                */
  IO_BANK0_GPIO9_CTRL_INOVER_HIGH      = 3,     /*!< HIGH : drive peri input high                                              */
} IO_BANK0_GPIO9_CTRL_INOVER_Enum;

/* ==========================================  IO_BANK0 GPIO9_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO9_CTRL_OEOVER                                                */
  IO_BANK0_GPIO9_CTRL_OEOVER_NORMAL    = 0,     /*!< NORMAL : drive output enable from peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO9_CTRL_OEOVER_INVERT    = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal
                                                     selected by funcsel                                                       */
  IO_BANK0_GPIO9_CTRL_OEOVER_DISABLE   = 2,     /*!< DISABLE : disable output                                                  */
  IO_BANK0_GPIO9_CTRL_OEOVER_ENABLE    = 3,     /*!< ENABLE : enable output                                                    */
} IO_BANK0_GPIO9_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO9_CTRL OUTOVER [8..9]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO9_CTRL_OUTOVER                                               */
  IO_BANK0_GPIO9_CTRL_OUTOVER_NORMAL   = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel          */
  IO_BANK0_GPIO9_CTRL_OUTOVER_INVERT   = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO9_CTRL_OUTOVER_LOW      = 2,     /*!< LOW : drive output low                                                    */
  IO_BANK0_GPIO9_CTRL_OUTOVER_HIGH     = 3,     /*!< HIGH : drive output high                                                  */
} IO_BANK0_GPIO9_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO9_CTRL FUNCSEL [0..4]  =========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO9_CTRL_FUNCSEL                                               */
  IO_BANK0_GPIO9_CTRL_FUNCSEL_spi1_ss_n = 1,    /*!< spi1_ss_n : spi1_ss_n                                                     */
  IO_BANK0_GPIO9_CTRL_FUNCSEL_uart1_rx = 2,     /*!< uart1_rx : uart1_rx                                                       */
  IO_BANK0_GPIO9_CTRL_FUNCSEL_i2c0_scl = 3,     /*!< i2c0_scl : i2c0_scl                                                       */
  IO_BANK0_GPIO9_CTRL_FUNCSEL_pwm_b_4  = 4,     /*!< pwm_b_4 : pwm_b_4                                                         */
  IO_BANK0_GPIO9_CTRL_FUNCSEL_sio_9    = 5,     /*!< sio_9 : sio_9                                                             */
  IO_BANK0_GPIO9_CTRL_FUNCSEL_pio0_9   = 6,     /*!< pio0_9 : pio0_9                                                           */
  IO_BANK0_GPIO9_CTRL_FUNCSEL_pio1_9   = 7,     /*!< pio1_9 : pio1_9                                                           */
  IO_BANK0_GPIO9_CTRL_FUNCSEL_usb_muxing_extphy_vp = 8,/*!< usb_muxing_extphy_vp : usb_muxing_extphy_vp                        */
  IO_BANK0_GPIO9_CTRL_FUNCSEL_usb_muxing_overcurr_detect = 9,/*!< usb_muxing_overcurr_detect : usb_muxing_overcurr_detect      */
  IO_BANK0_GPIO9_CTRL_FUNCSEL_null     = 31,    /*!< null : null                                                               */
} IO_BANK0_GPIO9_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO10_STATUS  ===================================================== */
/* ======================================================  GPIO10_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO10_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO10_CTRL_IRQOVER                                              */
  IO_BANK0_GPIO10_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt                                       */
  IO_BANK0_GPIO10_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt                                             */
  IO_BANK0_GPIO10_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low                                                 */
  IO_BANK0_GPIO10_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high                                               */
} IO_BANK0_GPIO10_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO10_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO10_CTRL_INOVER                                               */
  IO_BANK0_GPIO10_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input                                      */
  IO_BANK0_GPIO10_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input                                            */
  IO_BANK0_GPIO10_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low                                                */
  IO_BANK0_GPIO10_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high                                              */
} IO_BANK0_GPIO10_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO10_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO10_CTRL_OEOVER                                               */
  IO_BANK0_GPIO10_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO10_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal
                                                     selected by funcsel                                                       */
  IO_BANK0_GPIO10_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output                                                  */
  IO_BANK0_GPIO10_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output                                                    */
} IO_BANK0_GPIO10_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO10_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO10_CTRL_OUTOVER                                              */
  IO_BANK0_GPIO10_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel          */
  IO_BANK0_GPIO10_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO10_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low                                                    */
  IO_BANK0_GPIO10_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high                                                  */
} IO_BANK0_GPIO10_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO10_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO10_CTRL_FUNCSEL                                              */
  IO_BANK0_GPIO10_CTRL_FUNCSEL_spi1_sclk = 1,   /*!< spi1_sclk : spi1_sclk                                                     */
  IO_BANK0_GPIO10_CTRL_FUNCSEL_uart1_cts = 2,   /*!< uart1_cts : uart1_cts                                                     */
  IO_BANK0_GPIO10_CTRL_FUNCSEL_i2c1_sda = 3,    /*!< i2c1_sda : i2c1_sda                                                       */
  IO_BANK0_GPIO10_CTRL_FUNCSEL_pwm_a_5 = 4,     /*!< pwm_a_5 : pwm_a_5                                                         */
  IO_BANK0_GPIO10_CTRL_FUNCSEL_sio_10  = 5,     /*!< sio_10 : sio_10                                                           */
  IO_BANK0_GPIO10_CTRL_FUNCSEL_pio0_10 = 6,     /*!< pio0_10 : pio0_10                                                         */
  IO_BANK0_GPIO10_CTRL_FUNCSEL_pio1_10 = 7,     /*!< pio1_10 : pio1_10                                                         */
  IO_BANK0_GPIO10_CTRL_FUNCSEL_usb_muxing_extphy_vm = 8,/*!< usb_muxing_extphy_vm : usb_muxing_extphy_vm                       */
  IO_BANK0_GPIO10_CTRL_FUNCSEL_usb_muxing_vbus_detect = 9,/*!< usb_muxing_vbus_detect : usb_muxing_vbus_detect                 */
  IO_BANK0_GPIO10_CTRL_FUNCSEL_null    = 31,    /*!< null : null                                                               */
} IO_BANK0_GPIO10_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO11_STATUS  ===================================================== */
/* ======================================================  GPIO11_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO11_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO11_CTRL_IRQOVER                                              */
  IO_BANK0_GPIO11_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt                                       */
  IO_BANK0_GPIO11_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt                                             */
  IO_BANK0_GPIO11_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low                                                 */
  IO_BANK0_GPIO11_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high                                               */
} IO_BANK0_GPIO11_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO11_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO11_CTRL_INOVER                                               */
  IO_BANK0_GPIO11_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input                                      */
  IO_BANK0_GPIO11_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input                                            */
  IO_BANK0_GPIO11_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low                                                */
  IO_BANK0_GPIO11_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high                                              */
} IO_BANK0_GPIO11_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO11_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO11_CTRL_OEOVER                                               */
  IO_BANK0_GPIO11_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO11_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal
                                                     selected by funcsel                                                       */
  IO_BANK0_GPIO11_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output                                                  */
  IO_BANK0_GPIO11_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output                                                    */
} IO_BANK0_GPIO11_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO11_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO11_CTRL_OUTOVER                                              */
  IO_BANK0_GPIO11_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel          */
  IO_BANK0_GPIO11_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO11_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low                                                    */
  IO_BANK0_GPIO11_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high                                                  */
} IO_BANK0_GPIO11_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO11_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO11_CTRL_FUNCSEL                                              */
  IO_BANK0_GPIO11_CTRL_FUNCSEL_spi1_tx = 1,     /*!< spi1_tx : spi1_tx                                                         */
  IO_BANK0_GPIO11_CTRL_FUNCSEL_uart1_rts = 2,   /*!< uart1_rts : uart1_rts                                                     */
  IO_BANK0_GPIO11_CTRL_FUNCSEL_i2c1_scl = 3,    /*!< i2c1_scl : i2c1_scl                                                       */
  IO_BANK0_GPIO11_CTRL_FUNCSEL_pwm_b_5 = 4,     /*!< pwm_b_5 : pwm_b_5                                                         */
  IO_BANK0_GPIO11_CTRL_FUNCSEL_sio_11  = 5,     /*!< sio_11 : sio_11                                                           */
  IO_BANK0_GPIO11_CTRL_FUNCSEL_pio0_11 = 6,     /*!< pio0_11 : pio0_11                                                         */
  IO_BANK0_GPIO11_CTRL_FUNCSEL_pio1_11 = 7,     /*!< pio1_11 : pio1_11                                                         */
  IO_BANK0_GPIO11_CTRL_FUNCSEL_usb_muxing_extphy_suspnd = 8,/*!< usb_muxing_extphy_suspnd : usb_muxing_extphy_suspnd           */
  IO_BANK0_GPIO11_CTRL_FUNCSEL_usb_muxing_vbus_en = 9,/*!< usb_muxing_vbus_en : usb_muxing_vbus_en                             */
  IO_BANK0_GPIO11_CTRL_FUNCSEL_null    = 31,    /*!< null : null                                                               */
} IO_BANK0_GPIO11_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO12_STATUS  ===================================================== */
/* ======================================================  GPIO12_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO12_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO12_CTRL_IRQOVER                                              */
  IO_BANK0_GPIO12_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt                                       */
  IO_BANK0_GPIO12_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt                                             */
  IO_BANK0_GPIO12_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low                                                 */
  IO_BANK0_GPIO12_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high                                               */
} IO_BANK0_GPIO12_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO12_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO12_CTRL_INOVER                                               */
  IO_BANK0_GPIO12_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input                                      */
  IO_BANK0_GPIO12_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input                                            */
  IO_BANK0_GPIO12_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low                                                */
  IO_BANK0_GPIO12_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high                                              */
} IO_BANK0_GPIO12_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO12_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO12_CTRL_OEOVER                                               */
  IO_BANK0_GPIO12_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO12_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal
                                                     selected by funcsel                                                       */
  IO_BANK0_GPIO12_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output                                                  */
  IO_BANK0_GPIO12_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output                                                    */
} IO_BANK0_GPIO12_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO12_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO12_CTRL_OUTOVER                                              */
  IO_BANK0_GPIO12_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel          */
  IO_BANK0_GPIO12_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO12_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low                                                    */
  IO_BANK0_GPIO12_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high                                                  */
} IO_BANK0_GPIO12_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO12_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO12_CTRL_FUNCSEL                                              */
  IO_BANK0_GPIO12_CTRL_FUNCSEL_spi1_rx = 1,     /*!< spi1_rx : spi1_rx                                                         */
  IO_BANK0_GPIO12_CTRL_FUNCSEL_uart0_tx = 2,    /*!< uart0_tx : uart0_tx                                                       */
  IO_BANK0_GPIO12_CTRL_FUNCSEL_i2c0_sda = 3,    /*!< i2c0_sda : i2c0_sda                                                       */
  IO_BANK0_GPIO12_CTRL_FUNCSEL_pwm_a_6 = 4,     /*!< pwm_a_6 : pwm_a_6                                                         */
  IO_BANK0_GPIO12_CTRL_FUNCSEL_sio_12  = 5,     /*!< sio_12 : sio_12                                                           */
  IO_BANK0_GPIO12_CTRL_FUNCSEL_pio0_12 = 6,     /*!< pio0_12 : pio0_12                                                         */
  IO_BANK0_GPIO12_CTRL_FUNCSEL_pio1_12 = 7,     /*!< pio1_12 : pio1_12                                                         */
  IO_BANK0_GPIO12_CTRL_FUNCSEL_usb_muxing_extphy_speed = 8,/*!< usb_muxing_extphy_speed : usb_muxing_extphy_speed              */
  IO_BANK0_GPIO12_CTRL_FUNCSEL_usb_muxing_overcurr_detect = 9,/*!< usb_muxing_overcurr_detect : usb_muxing_overcurr_detect     */
  IO_BANK0_GPIO12_CTRL_FUNCSEL_null    = 31,    /*!< null : null                                                               */
} IO_BANK0_GPIO12_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO13_STATUS  ===================================================== */
/* ======================================================  GPIO13_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO13_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO13_CTRL_IRQOVER                                              */
  IO_BANK0_GPIO13_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt                                       */
  IO_BANK0_GPIO13_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt                                             */
  IO_BANK0_GPIO13_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low                                                 */
  IO_BANK0_GPIO13_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high                                               */
} IO_BANK0_GPIO13_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO13_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO13_CTRL_INOVER                                               */
  IO_BANK0_GPIO13_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input                                      */
  IO_BANK0_GPIO13_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input                                            */
  IO_BANK0_GPIO13_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low                                                */
  IO_BANK0_GPIO13_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high                                              */
} IO_BANK0_GPIO13_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO13_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO13_CTRL_OEOVER                                               */
  IO_BANK0_GPIO13_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO13_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal
                                                     selected by funcsel                                                       */
  IO_BANK0_GPIO13_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output                                                  */
  IO_BANK0_GPIO13_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output                                                    */
} IO_BANK0_GPIO13_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO13_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO13_CTRL_OUTOVER                                              */
  IO_BANK0_GPIO13_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel          */
  IO_BANK0_GPIO13_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO13_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low                                                    */
  IO_BANK0_GPIO13_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high                                                  */
} IO_BANK0_GPIO13_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO13_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO13_CTRL_FUNCSEL                                              */
  IO_BANK0_GPIO13_CTRL_FUNCSEL_spi1_ss_n = 1,   /*!< spi1_ss_n : spi1_ss_n                                                     */
  IO_BANK0_GPIO13_CTRL_FUNCSEL_uart0_rx = 2,    /*!< uart0_rx : uart0_rx                                                       */
  IO_BANK0_GPIO13_CTRL_FUNCSEL_i2c0_scl = 3,    /*!< i2c0_scl : i2c0_scl                                                       */
  IO_BANK0_GPIO13_CTRL_FUNCSEL_pwm_b_6 = 4,     /*!< pwm_b_6 : pwm_b_6                                                         */
  IO_BANK0_GPIO13_CTRL_FUNCSEL_sio_13  = 5,     /*!< sio_13 : sio_13                                                           */
  IO_BANK0_GPIO13_CTRL_FUNCSEL_pio0_13 = 6,     /*!< pio0_13 : pio0_13                                                         */
  IO_BANK0_GPIO13_CTRL_FUNCSEL_pio1_13 = 7,     /*!< pio1_13 : pio1_13                                                         */
  IO_BANK0_GPIO13_CTRL_FUNCSEL_usb_muxing_extphy_vpo = 8,/*!< usb_muxing_extphy_vpo : usb_muxing_extphy_vpo                    */
  IO_BANK0_GPIO13_CTRL_FUNCSEL_usb_muxing_vbus_detect = 9,/*!< usb_muxing_vbus_detect : usb_muxing_vbus_detect                 */
  IO_BANK0_GPIO13_CTRL_FUNCSEL_null    = 31,    /*!< null : null                                                               */
} IO_BANK0_GPIO13_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO14_STATUS  ===================================================== */
/* ======================================================  GPIO14_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO14_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO14_CTRL_IRQOVER                                              */
  IO_BANK0_GPIO14_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt                                       */
  IO_BANK0_GPIO14_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt                                             */
  IO_BANK0_GPIO14_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low                                                 */
  IO_BANK0_GPIO14_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high                                               */
} IO_BANK0_GPIO14_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO14_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO14_CTRL_INOVER                                               */
  IO_BANK0_GPIO14_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input                                      */
  IO_BANK0_GPIO14_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input                                            */
  IO_BANK0_GPIO14_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low                                                */
  IO_BANK0_GPIO14_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high                                              */
} IO_BANK0_GPIO14_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO14_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO14_CTRL_OEOVER                                               */
  IO_BANK0_GPIO14_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO14_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal
                                                     selected by funcsel                                                       */
  IO_BANK0_GPIO14_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output                                                  */
  IO_BANK0_GPIO14_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output                                                    */
} IO_BANK0_GPIO14_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO14_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO14_CTRL_OUTOVER                                              */
  IO_BANK0_GPIO14_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel          */
  IO_BANK0_GPIO14_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO14_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low                                                    */
  IO_BANK0_GPIO14_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high                                                  */
} IO_BANK0_GPIO14_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO14_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO14_CTRL_FUNCSEL                                              */
  IO_BANK0_GPIO14_CTRL_FUNCSEL_spi1_sclk = 1,   /*!< spi1_sclk : spi1_sclk                                                     */
  IO_BANK0_GPIO14_CTRL_FUNCSEL_uart0_cts = 2,   /*!< uart0_cts : uart0_cts                                                     */
  IO_BANK0_GPIO14_CTRL_FUNCSEL_i2c1_sda = 3,    /*!< i2c1_sda : i2c1_sda                                                       */
  IO_BANK0_GPIO14_CTRL_FUNCSEL_pwm_a_7 = 4,     /*!< pwm_a_7 : pwm_a_7                                                         */
  IO_BANK0_GPIO14_CTRL_FUNCSEL_sio_14  = 5,     /*!< sio_14 : sio_14                                                           */
  IO_BANK0_GPIO14_CTRL_FUNCSEL_pio0_14 = 6,     /*!< pio0_14 : pio0_14                                                         */
  IO_BANK0_GPIO14_CTRL_FUNCSEL_pio1_14 = 7,     /*!< pio1_14 : pio1_14                                                         */
  IO_BANK0_GPIO14_CTRL_FUNCSEL_usb_muxing_extphy_vmo = 8,/*!< usb_muxing_extphy_vmo : usb_muxing_extphy_vmo                    */
  IO_BANK0_GPIO14_CTRL_FUNCSEL_usb_muxing_vbus_en = 9,/*!< usb_muxing_vbus_en : usb_muxing_vbus_en                             */
  IO_BANK0_GPIO14_CTRL_FUNCSEL_null    = 31,    /*!< null : null                                                               */
} IO_BANK0_GPIO14_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO15_STATUS  ===================================================== */
/* ======================================================  GPIO15_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO15_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO15_CTRL_IRQOVER                                              */
  IO_BANK0_GPIO15_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt                                       */
  IO_BANK0_GPIO15_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt                                             */
  IO_BANK0_GPIO15_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low                                                 */
  IO_BANK0_GPIO15_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high                                               */
} IO_BANK0_GPIO15_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO15_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO15_CTRL_INOVER                                               */
  IO_BANK0_GPIO15_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input                                      */
  IO_BANK0_GPIO15_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input                                            */
  IO_BANK0_GPIO15_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low                                                */
  IO_BANK0_GPIO15_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high                                              */
} IO_BANK0_GPIO15_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO15_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO15_CTRL_OEOVER                                               */
  IO_BANK0_GPIO15_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO15_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal
                                                     selected by funcsel                                                       */
  IO_BANK0_GPIO15_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output                                                  */
  IO_BANK0_GPIO15_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output                                                    */
} IO_BANK0_GPIO15_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO15_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO15_CTRL_OUTOVER                                              */
  IO_BANK0_GPIO15_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel          */
  IO_BANK0_GPIO15_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO15_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low                                                    */
  IO_BANK0_GPIO15_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high                                                  */
} IO_BANK0_GPIO15_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO15_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO15_CTRL_FUNCSEL                                              */
  IO_BANK0_GPIO15_CTRL_FUNCSEL_spi1_tx = 1,     /*!< spi1_tx : spi1_tx                                                         */
  IO_BANK0_GPIO15_CTRL_FUNCSEL_uart0_rts = 2,   /*!< uart0_rts : uart0_rts                                                     */
  IO_BANK0_GPIO15_CTRL_FUNCSEL_i2c1_scl = 3,    /*!< i2c1_scl : i2c1_scl                                                       */
  IO_BANK0_GPIO15_CTRL_FUNCSEL_pwm_b_7 = 4,     /*!< pwm_b_7 : pwm_b_7                                                         */
  IO_BANK0_GPIO15_CTRL_FUNCSEL_sio_15  = 5,     /*!< sio_15 : sio_15                                                           */
  IO_BANK0_GPIO15_CTRL_FUNCSEL_pio0_15 = 6,     /*!< pio0_15 : pio0_15                                                         */
  IO_BANK0_GPIO15_CTRL_FUNCSEL_pio1_15 = 7,     /*!< pio1_15 : pio1_15                                                         */
  IO_BANK0_GPIO15_CTRL_FUNCSEL_usb_muxing_digital_dp = 8,/*!< usb_muxing_digital_dp : usb_muxing_digital_dp                    */
  IO_BANK0_GPIO15_CTRL_FUNCSEL_usb_muxing_overcurr_detect = 9,/*!< usb_muxing_overcurr_detect : usb_muxing_overcurr_detect     */
  IO_BANK0_GPIO15_CTRL_FUNCSEL_null    = 31,    /*!< null : null                                                               */
} IO_BANK0_GPIO15_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO16_STATUS  ===================================================== */
/* ======================================================  GPIO16_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO16_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO16_CTRL_IRQOVER                                              */
  IO_BANK0_GPIO16_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt                                       */
  IO_BANK0_GPIO16_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt                                             */
  IO_BANK0_GPIO16_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low                                                 */
  IO_BANK0_GPIO16_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high                                               */
} IO_BANK0_GPIO16_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO16_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO16_CTRL_INOVER                                               */
  IO_BANK0_GPIO16_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input                                      */
  IO_BANK0_GPIO16_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input                                            */
  IO_BANK0_GPIO16_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low                                                */
  IO_BANK0_GPIO16_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high                                              */
} IO_BANK0_GPIO16_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO16_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO16_CTRL_OEOVER                                               */
  IO_BANK0_GPIO16_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO16_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal
                                                     selected by funcsel                                                       */
  IO_BANK0_GPIO16_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output                                                  */
  IO_BANK0_GPIO16_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output                                                    */
} IO_BANK0_GPIO16_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO16_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO16_CTRL_OUTOVER                                              */
  IO_BANK0_GPIO16_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel          */
  IO_BANK0_GPIO16_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO16_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low                                                    */
  IO_BANK0_GPIO16_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high                                                  */
} IO_BANK0_GPIO16_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO16_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO16_CTRL_FUNCSEL                                              */
  IO_BANK0_GPIO16_CTRL_FUNCSEL_spi0_rx = 1,     /*!< spi0_rx : spi0_rx                                                         */
  IO_BANK0_GPIO16_CTRL_FUNCSEL_uart0_tx = 2,    /*!< uart0_tx : uart0_tx                                                       */
  IO_BANK0_GPIO16_CTRL_FUNCSEL_i2c0_sda = 3,    /*!< i2c0_sda : i2c0_sda                                                       */
  IO_BANK0_GPIO16_CTRL_FUNCSEL_pwm_a_0 = 4,     /*!< pwm_a_0 : pwm_a_0                                                         */
  IO_BANK0_GPIO16_CTRL_FUNCSEL_sio_16  = 5,     /*!< sio_16 : sio_16                                                           */
  IO_BANK0_GPIO16_CTRL_FUNCSEL_pio0_16 = 6,     /*!< pio0_16 : pio0_16                                                         */
  IO_BANK0_GPIO16_CTRL_FUNCSEL_pio1_16 = 7,     /*!< pio1_16 : pio1_16                                                         */
  IO_BANK0_GPIO16_CTRL_FUNCSEL_usb_muxing_digital_dm = 8,/*!< usb_muxing_digital_dm : usb_muxing_digital_dm                    */
  IO_BANK0_GPIO16_CTRL_FUNCSEL_usb_muxing_vbus_detect = 9,/*!< usb_muxing_vbus_detect : usb_muxing_vbus_detect                 */
  IO_BANK0_GPIO16_CTRL_FUNCSEL_null    = 31,    /*!< null : null                                                               */
} IO_BANK0_GPIO16_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO17_STATUS  ===================================================== */
/* ======================================================  GPIO17_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO17_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO17_CTRL_IRQOVER                                              */
  IO_BANK0_GPIO17_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt                                       */
  IO_BANK0_GPIO17_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt                                             */
  IO_BANK0_GPIO17_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low                                                 */
  IO_BANK0_GPIO17_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high                                               */
} IO_BANK0_GPIO17_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO17_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO17_CTRL_INOVER                                               */
  IO_BANK0_GPIO17_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input                                      */
  IO_BANK0_GPIO17_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input                                            */
  IO_BANK0_GPIO17_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low                                                */
  IO_BANK0_GPIO17_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high                                              */
} IO_BANK0_GPIO17_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO17_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO17_CTRL_OEOVER                                               */
  IO_BANK0_GPIO17_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO17_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal
                                                     selected by funcsel                                                       */
  IO_BANK0_GPIO17_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output                                                  */
  IO_BANK0_GPIO17_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output                                                    */
} IO_BANK0_GPIO17_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO17_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO17_CTRL_OUTOVER                                              */
  IO_BANK0_GPIO17_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel          */
  IO_BANK0_GPIO17_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO17_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low                                                    */
  IO_BANK0_GPIO17_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high                                                  */
} IO_BANK0_GPIO17_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO17_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO17_CTRL_FUNCSEL                                              */
  IO_BANK0_GPIO17_CTRL_FUNCSEL_spi0_ss_n = 1,   /*!< spi0_ss_n : spi0_ss_n                                                     */
  IO_BANK0_GPIO17_CTRL_FUNCSEL_uart0_rx = 2,    /*!< uart0_rx : uart0_rx                                                       */
  IO_BANK0_GPIO17_CTRL_FUNCSEL_i2c0_scl = 3,    /*!< i2c0_scl : i2c0_scl                                                       */
  IO_BANK0_GPIO17_CTRL_FUNCSEL_pwm_b_0 = 4,     /*!< pwm_b_0 : pwm_b_0                                                         */
  IO_BANK0_GPIO17_CTRL_FUNCSEL_sio_17  = 5,     /*!< sio_17 : sio_17                                                           */
  IO_BANK0_GPIO17_CTRL_FUNCSEL_pio0_17 = 6,     /*!< pio0_17 : pio0_17                                                         */
  IO_BANK0_GPIO17_CTRL_FUNCSEL_pio1_17 = 7,     /*!< pio1_17 : pio1_17                                                         */
  IO_BANK0_GPIO17_CTRL_FUNCSEL_usb_muxing_vbus_en = 9,/*!< usb_muxing_vbus_en : usb_muxing_vbus_en                             */
  IO_BANK0_GPIO17_CTRL_FUNCSEL_null    = 31,    /*!< null : null                                                               */
} IO_BANK0_GPIO17_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO18_STATUS  ===================================================== */
/* ======================================================  GPIO18_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO18_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO18_CTRL_IRQOVER                                              */
  IO_BANK0_GPIO18_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt                                       */
  IO_BANK0_GPIO18_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt                                             */
  IO_BANK0_GPIO18_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low                                                 */
  IO_BANK0_GPIO18_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high                                               */
} IO_BANK0_GPIO18_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO18_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO18_CTRL_INOVER                                               */
  IO_BANK0_GPIO18_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input                                      */
  IO_BANK0_GPIO18_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input                                            */
  IO_BANK0_GPIO18_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low                                                */
  IO_BANK0_GPIO18_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high                                              */
} IO_BANK0_GPIO18_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO18_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO18_CTRL_OEOVER                                               */
  IO_BANK0_GPIO18_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO18_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal
                                                     selected by funcsel                                                       */
  IO_BANK0_GPIO18_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output                                                  */
  IO_BANK0_GPIO18_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output                                                    */
} IO_BANK0_GPIO18_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO18_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO18_CTRL_OUTOVER                                              */
  IO_BANK0_GPIO18_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel          */
  IO_BANK0_GPIO18_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO18_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low                                                    */
  IO_BANK0_GPIO18_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high                                                  */
} IO_BANK0_GPIO18_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO18_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO18_CTRL_FUNCSEL                                              */
  IO_BANK0_GPIO18_CTRL_FUNCSEL_spi0_sclk = 1,   /*!< spi0_sclk : spi0_sclk                                                     */
  IO_BANK0_GPIO18_CTRL_FUNCSEL_uart0_cts = 2,   /*!< uart0_cts : uart0_cts                                                     */
  IO_BANK0_GPIO18_CTRL_FUNCSEL_i2c1_sda = 3,    /*!< i2c1_sda : i2c1_sda                                                       */
  IO_BANK0_GPIO18_CTRL_FUNCSEL_pwm_a_1 = 4,     /*!< pwm_a_1 : pwm_a_1                                                         */
  IO_BANK0_GPIO18_CTRL_FUNCSEL_sio_18  = 5,     /*!< sio_18 : sio_18                                                           */
  IO_BANK0_GPIO18_CTRL_FUNCSEL_pio0_18 = 6,     /*!< pio0_18 : pio0_18                                                         */
  IO_BANK0_GPIO18_CTRL_FUNCSEL_pio1_18 = 7,     /*!< pio1_18 : pio1_18                                                         */
  IO_BANK0_GPIO18_CTRL_FUNCSEL_usb_muxing_overcurr_detect = 9,/*!< usb_muxing_overcurr_detect : usb_muxing_overcurr_detect     */
  IO_BANK0_GPIO18_CTRL_FUNCSEL_null    = 31,    /*!< null : null                                                               */
} IO_BANK0_GPIO18_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO19_STATUS  ===================================================== */
/* ======================================================  GPIO19_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO19_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO19_CTRL_IRQOVER                                              */
  IO_BANK0_GPIO19_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt                                       */
  IO_BANK0_GPIO19_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt                                             */
  IO_BANK0_GPIO19_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low                                                 */
  IO_BANK0_GPIO19_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high                                               */
} IO_BANK0_GPIO19_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO19_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO19_CTRL_INOVER                                               */
  IO_BANK0_GPIO19_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input                                      */
  IO_BANK0_GPIO19_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input                                            */
  IO_BANK0_GPIO19_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low                                                */
  IO_BANK0_GPIO19_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high                                              */
} IO_BANK0_GPIO19_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO19_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO19_CTRL_OEOVER                                               */
  IO_BANK0_GPIO19_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO19_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal
                                                     selected by funcsel                                                       */
  IO_BANK0_GPIO19_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output                                                  */
  IO_BANK0_GPIO19_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output                                                    */
} IO_BANK0_GPIO19_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO19_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO19_CTRL_OUTOVER                                              */
  IO_BANK0_GPIO19_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel          */
  IO_BANK0_GPIO19_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO19_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low                                                    */
  IO_BANK0_GPIO19_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high                                                  */
} IO_BANK0_GPIO19_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO19_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO19_CTRL_FUNCSEL                                              */
  IO_BANK0_GPIO19_CTRL_FUNCSEL_spi0_tx = 1,     /*!< spi0_tx : spi0_tx                                                         */
  IO_BANK0_GPIO19_CTRL_FUNCSEL_uart0_rts = 2,   /*!< uart0_rts : uart0_rts                                                     */
  IO_BANK0_GPIO19_CTRL_FUNCSEL_i2c1_scl = 3,    /*!< i2c1_scl : i2c1_scl                                                       */
  IO_BANK0_GPIO19_CTRL_FUNCSEL_pwm_b_1 = 4,     /*!< pwm_b_1 : pwm_b_1                                                         */
  IO_BANK0_GPIO19_CTRL_FUNCSEL_sio_19  = 5,     /*!< sio_19 : sio_19                                                           */
  IO_BANK0_GPIO19_CTRL_FUNCSEL_pio0_19 = 6,     /*!< pio0_19 : pio0_19                                                         */
  IO_BANK0_GPIO19_CTRL_FUNCSEL_pio1_19 = 7,     /*!< pio1_19 : pio1_19                                                         */
  IO_BANK0_GPIO19_CTRL_FUNCSEL_usb_muxing_vbus_detect = 9,/*!< usb_muxing_vbus_detect : usb_muxing_vbus_detect                 */
  IO_BANK0_GPIO19_CTRL_FUNCSEL_null    = 31,    /*!< null : null                                                               */
} IO_BANK0_GPIO19_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO20_STATUS  ===================================================== */
/* ======================================================  GPIO20_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO20_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO20_CTRL_IRQOVER                                              */
  IO_BANK0_GPIO20_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt                                       */
  IO_BANK0_GPIO20_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt                                             */
  IO_BANK0_GPIO20_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low                                                 */
  IO_BANK0_GPIO20_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high                                               */
} IO_BANK0_GPIO20_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO20_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO20_CTRL_INOVER                                               */
  IO_BANK0_GPIO20_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input                                      */
  IO_BANK0_GPIO20_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input                                            */
  IO_BANK0_GPIO20_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low                                                */
  IO_BANK0_GPIO20_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high                                              */
} IO_BANK0_GPIO20_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO20_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO20_CTRL_OEOVER                                               */
  IO_BANK0_GPIO20_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO20_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal
                                                     selected by funcsel                                                       */
  IO_BANK0_GPIO20_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output                                                  */
  IO_BANK0_GPIO20_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output                                                    */
} IO_BANK0_GPIO20_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO20_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO20_CTRL_OUTOVER                                              */
  IO_BANK0_GPIO20_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel          */
  IO_BANK0_GPIO20_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO20_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low                                                    */
  IO_BANK0_GPIO20_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high                                                  */
} IO_BANK0_GPIO20_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO20_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO20_CTRL_FUNCSEL                                              */
  IO_BANK0_GPIO20_CTRL_FUNCSEL_spi0_rx = 1,     /*!< spi0_rx : spi0_rx                                                         */
  IO_BANK0_GPIO20_CTRL_FUNCSEL_uart1_tx = 2,    /*!< uart1_tx : uart1_tx                                                       */
  IO_BANK0_GPIO20_CTRL_FUNCSEL_i2c0_sda = 3,    /*!< i2c0_sda : i2c0_sda                                                       */
  IO_BANK0_GPIO20_CTRL_FUNCSEL_pwm_a_2 = 4,     /*!< pwm_a_2 : pwm_a_2                                                         */
  IO_BANK0_GPIO20_CTRL_FUNCSEL_sio_20  = 5,     /*!< sio_20 : sio_20                                                           */
  IO_BANK0_GPIO20_CTRL_FUNCSEL_pio0_20 = 6,     /*!< pio0_20 : pio0_20                                                         */
  IO_BANK0_GPIO20_CTRL_FUNCSEL_pio1_20 = 7,     /*!< pio1_20 : pio1_20                                                         */
  IO_BANK0_GPIO20_CTRL_FUNCSEL_clocks_gpin_0 = 8,/*!< clocks_gpin_0 : clocks_gpin_0                                            */
  IO_BANK0_GPIO20_CTRL_FUNCSEL_usb_muxing_vbus_en = 9,/*!< usb_muxing_vbus_en : usb_muxing_vbus_en                             */
  IO_BANK0_GPIO20_CTRL_FUNCSEL_null    = 31,    /*!< null : null                                                               */
} IO_BANK0_GPIO20_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO21_STATUS  ===================================================== */
/* ======================================================  GPIO21_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO21_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO21_CTRL_IRQOVER                                              */
  IO_BANK0_GPIO21_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt                                       */
  IO_BANK0_GPIO21_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt                                             */
  IO_BANK0_GPIO21_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low                                                 */
  IO_BANK0_GPIO21_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high                                               */
} IO_BANK0_GPIO21_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO21_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO21_CTRL_INOVER                                               */
  IO_BANK0_GPIO21_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input                                      */
  IO_BANK0_GPIO21_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input                                            */
  IO_BANK0_GPIO21_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low                                                */
  IO_BANK0_GPIO21_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high                                              */
} IO_BANK0_GPIO21_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO21_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO21_CTRL_OEOVER                                               */
  IO_BANK0_GPIO21_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO21_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal
                                                     selected by funcsel                                                       */
  IO_BANK0_GPIO21_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output                                                  */
  IO_BANK0_GPIO21_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output                                                    */
} IO_BANK0_GPIO21_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO21_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO21_CTRL_OUTOVER                                              */
  IO_BANK0_GPIO21_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel          */
  IO_BANK0_GPIO21_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO21_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low                                                    */
  IO_BANK0_GPIO21_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high                                                  */
} IO_BANK0_GPIO21_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO21_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO21_CTRL_FUNCSEL                                              */
  IO_BANK0_GPIO21_CTRL_FUNCSEL_spi0_ss_n = 1,   /*!< spi0_ss_n : spi0_ss_n                                                     */
  IO_BANK0_GPIO21_CTRL_FUNCSEL_uart1_rx = 2,    /*!< uart1_rx : uart1_rx                                                       */
  IO_BANK0_GPIO21_CTRL_FUNCSEL_i2c0_scl = 3,    /*!< i2c0_scl : i2c0_scl                                                       */
  IO_BANK0_GPIO21_CTRL_FUNCSEL_pwm_b_2 = 4,     /*!< pwm_b_2 : pwm_b_2                                                         */
  IO_BANK0_GPIO21_CTRL_FUNCSEL_sio_21  = 5,     /*!< sio_21 : sio_21                                                           */
  IO_BANK0_GPIO21_CTRL_FUNCSEL_pio0_21 = 6,     /*!< pio0_21 : pio0_21                                                         */
  IO_BANK0_GPIO21_CTRL_FUNCSEL_pio1_21 = 7,     /*!< pio1_21 : pio1_21                                                         */
  IO_BANK0_GPIO21_CTRL_FUNCSEL_clocks_gpout_0 = 8,/*!< clocks_gpout_0 : clocks_gpout_0                                         */
  IO_BANK0_GPIO21_CTRL_FUNCSEL_usb_muxing_overcurr_detect = 9,/*!< usb_muxing_overcurr_detect : usb_muxing_overcurr_detect     */
  IO_BANK0_GPIO21_CTRL_FUNCSEL_null    = 31,    /*!< null : null                                                               */
} IO_BANK0_GPIO21_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO22_STATUS  ===================================================== */
/* ======================================================  GPIO22_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO22_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO22_CTRL_IRQOVER                                              */
  IO_BANK0_GPIO22_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt                                       */
  IO_BANK0_GPIO22_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt                                             */
  IO_BANK0_GPIO22_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low                                                 */
  IO_BANK0_GPIO22_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high                                               */
} IO_BANK0_GPIO22_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO22_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO22_CTRL_INOVER                                               */
  IO_BANK0_GPIO22_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input                                      */
  IO_BANK0_GPIO22_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input                                            */
  IO_BANK0_GPIO22_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low                                                */
  IO_BANK0_GPIO22_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high                                              */
} IO_BANK0_GPIO22_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO22_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO22_CTRL_OEOVER                                               */
  IO_BANK0_GPIO22_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO22_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal
                                                     selected by funcsel                                                       */
  IO_BANK0_GPIO22_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output                                                  */
  IO_BANK0_GPIO22_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output                                                    */
} IO_BANK0_GPIO22_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO22_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO22_CTRL_OUTOVER                                              */
  IO_BANK0_GPIO22_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel          */
  IO_BANK0_GPIO22_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO22_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low                                                    */
  IO_BANK0_GPIO22_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high                                                  */
} IO_BANK0_GPIO22_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO22_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO22_CTRL_FUNCSEL                                              */
  IO_BANK0_GPIO22_CTRL_FUNCSEL_spi0_sclk = 1,   /*!< spi0_sclk : spi0_sclk                                                     */
  IO_BANK0_GPIO22_CTRL_FUNCSEL_uart1_cts = 2,   /*!< uart1_cts : uart1_cts                                                     */
  IO_BANK0_GPIO22_CTRL_FUNCSEL_i2c1_sda = 3,    /*!< i2c1_sda : i2c1_sda                                                       */
  IO_BANK0_GPIO22_CTRL_FUNCSEL_pwm_a_3 = 4,     /*!< pwm_a_3 : pwm_a_3                                                         */
  IO_BANK0_GPIO22_CTRL_FUNCSEL_sio_22  = 5,     /*!< sio_22 : sio_22                                                           */
  IO_BANK0_GPIO22_CTRL_FUNCSEL_pio0_22 = 6,     /*!< pio0_22 : pio0_22                                                         */
  IO_BANK0_GPIO22_CTRL_FUNCSEL_pio1_22 = 7,     /*!< pio1_22 : pio1_22                                                         */
  IO_BANK0_GPIO22_CTRL_FUNCSEL_clocks_gpin_1 = 8,/*!< clocks_gpin_1 : clocks_gpin_1                                            */
  IO_BANK0_GPIO22_CTRL_FUNCSEL_usb_muxing_vbus_detect = 9,/*!< usb_muxing_vbus_detect : usb_muxing_vbus_detect                 */
  IO_BANK0_GPIO22_CTRL_FUNCSEL_null    = 31,    /*!< null : null                                                               */
} IO_BANK0_GPIO22_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO23_STATUS  ===================================================== */
/* ======================================================  GPIO23_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO23_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO23_CTRL_IRQOVER                                              */
  IO_BANK0_GPIO23_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt                                       */
  IO_BANK0_GPIO23_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt                                             */
  IO_BANK0_GPIO23_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low                                                 */
  IO_BANK0_GPIO23_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high                                               */
} IO_BANK0_GPIO23_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO23_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO23_CTRL_INOVER                                               */
  IO_BANK0_GPIO23_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input                                      */
  IO_BANK0_GPIO23_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input                                            */
  IO_BANK0_GPIO23_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low                                                */
  IO_BANK0_GPIO23_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high                                              */
} IO_BANK0_GPIO23_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO23_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO23_CTRL_OEOVER                                               */
  IO_BANK0_GPIO23_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO23_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal
                                                     selected by funcsel                                                       */
  IO_BANK0_GPIO23_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output                                                  */
  IO_BANK0_GPIO23_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output                                                    */
} IO_BANK0_GPIO23_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO23_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO23_CTRL_OUTOVER                                              */
  IO_BANK0_GPIO23_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel          */
  IO_BANK0_GPIO23_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO23_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low                                                    */
  IO_BANK0_GPIO23_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high                                                  */
} IO_BANK0_GPIO23_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO23_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO23_CTRL_FUNCSEL                                              */
  IO_BANK0_GPIO23_CTRL_FUNCSEL_spi0_tx = 1,     /*!< spi0_tx : spi0_tx                                                         */
  IO_BANK0_GPIO23_CTRL_FUNCSEL_uart1_rts = 2,   /*!< uart1_rts : uart1_rts                                                     */
  IO_BANK0_GPIO23_CTRL_FUNCSEL_i2c1_scl = 3,    /*!< i2c1_scl : i2c1_scl                                                       */
  IO_BANK0_GPIO23_CTRL_FUNCSEL_pwm_b_3 = 4,     /*!< pwm_b_3 : pwm_b_3                                                         */
  IO_BANK0_GPIO23_CTRL_FUNCSEL_sio_23  = 5,     /*!< sio_23 : sio_23                                                           */
  IO_BANK0_GPIO23_CTRL_FUNCSEL_pio0_23 = 6,     /*!< pio0_23 : pio0_23                                                         */
  IO_BANK0_GPIO23_CTRL_FUNCSEL_pio1_23 = 7,     /*!< pio1_23 : pio1_23                                                         */
  IO_BANK0_GPIO23_CTRL_FUNCSEL_clocks_gpout_1 = 8,/*!< clocks_gpout_1 : clocks_gpout_1                                         */
  IO_BANK0_GPIO23_CTRL_FUNCSEL_usb_muxing_vbus_en = 9,/*!< usb_muxing_vbus_en : usb_muxing_vbus_en                             */
  IO_BANK0_GPIO23_CTRL_FUNCSEL_null    = 31,    /*!< null : null                                                               */
} IO_BANK0_GPIO23_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO24_STATUS  ===================================================== */
/* ======================================================  GPIO24_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO24_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO24_CTRL_IRQOVER                                              */
  IO_BANK0_GPIO24_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt                                       */
  IO_BANK0_GPIO24_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt                                             */
  IO_BANK0_GPIO24_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low                                                 */
  IO_BANK0_GPIO24_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high                                               */
} IO_BANK0_GPIO24_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO24_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO24_CTRL_INOVER                                               */
  IO_BANK0_GPIO24_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input                                      */
  IO_BANK0_GPIO24_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input                                            */
  IO_BANK0_GPIO24_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low                                                */
  IO_BANK0_GPIO24_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high                                              */
} IO_BANK0_GPIO24_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO24_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO24_CTRL_OEOVER                                               */
  IO_BANK0_GPIO24_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO24_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal
                                                     selected by funcsel                                                       */
  IO_BANK0_GPIO24_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output                                                  */
  IO_BANK0_GPIO24_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output                                                    */
} IO_BANK0_GPIO24_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO24_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO24_CTRL_OUTOVER                                              */
  IO_BANK0_GPIO24_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel          */
  IO_BANK0_GPIO24_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO24_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low                                                    */
  IO_BANK0_GPIO24_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high                                                  */
} IO_BANK0_GPIO24_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO24_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO24_CTRL_FUNCSEL                                              */
  IO_BANK0_GPIO24_CTRL_FUNCSEL_spi1_rx = 1,     /*!< spi1_rx : spi1_rx                                                         */
  IO_BANK0_GPIO24_CTRL_FUNCSEL_uart1_tx = 2,    /*!< uart1_tx : uart1_tx                                                       */
  IO_BANK0_GPIO24_CTRL_FUNCSEL_i2c0_sda = 3,    /*!< i2c0_sda : i2c0_sda                                                       */
  IO_BANK0_GPIO24_CTRL_FUNCSEL_pwm_a_4 = 4,     /*!< pwm_a_4 : pwm_a_4                                                         */
  IO_BANK0_GPIO24_CTRL_FUNCSEL_sio_24  = 5,     /*!< sio_24 : sio_24                                                           */
  IO_BANK0_GPIO24_CTRL_FUNCSEL_pio0_24 = 6,     /*!< pio0_24 : pio0_24                                                         */
  IO_BANK0_GPIO24_CTRL_FUNCSEL_pio1_24 = 7,     /*!< pio1_24 : pio1_24                                                         */
  IO_BANK0_GPIO24_CTRL_FUNCSEL_clocks_gpout_2 = 8,/*!< clocks_gpout_2 : clocks_gpout_2                                         */
  IO_BANK0_GPIO24_CTRL_FUNCSEL_usb_muxing_overcurr_detect = 9,/*!< usb_muxing_overcurr_detect : usb_muxing_overcurr_detect     */
  IO_BANK0_GPIO24_CTRL_FUNCSEL_null    = 31,    /*!< null : null                                                               */
} IO_BANK0_GPIO24_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO25_STATUS  ===================================================== */
/* ======================================================  GPIO25_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO25_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO25_CTRL_IRQOVER                                              */
  IO_BANK0_GPIO25_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt                                       */
  IO_BANK0_GPIO25_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt                                             */
  IO_BANK0_GPIO25_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low                                                 */
  IO_BANK0_GPIO25_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high                                               */
} IO_BANK0_GPIO25_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO25_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO25_CTRL_INOVER                                               */
  IO_BANK0_GPIO25_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input                                      */
  IO_BANK0_GPIO25_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input                                            */
  IO_BANK0_GPIO25_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low                                                */
  IO_BANK0_GPIO25_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high                                              */
} IO_BANK0_GPIO25_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO25_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO25_CTRL_OEOVER                                               */
  IO_BANK0_GPIO25_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO25_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal
                                                     selected by funcsel                                                       */
  IO_BANK0_GPIO25_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output                                                  */
  IO_BANK0_GPIO25_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output                                                    */
} IO_BANK0_GPIO25_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO25_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO25_CTRL_OUTOVER                                              */
  IO_BANK0_GPIO25_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel          */
  IO_BANK0_GPIO25_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO25_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low                                                    */
  IO_BANK0_GPIO25_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high                                                  */
} IO_BANK0_GPIO25_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO25_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO25_CTRL_FUNCSEL                                              */
  IO_BANK0_GPIO25_CTRL_FUNCSEL_spi1_ss_n = 1,   /*!< spi1_ss_n : spi1_ss_n                                                     */
  IO_BANK0_GPIO25_CTRL_FUNCSEL_uart1_rx = 2,    /*!< uart1_rx : uart1_rx                                                       */
  IO_BANK0_GPIO25_CTRL_FUNCSEL_i2c0_scl = 3,    /*!< i2c0_scl : i2c0_scl                                                       */
  IO_BANK0_GPIO25_CTRL_FUNCSEL_pwm_b_4 = 4,     /*!< pwm_b_4 : pwm_b_4                                                         */
  IO_BANK0_GPIO25_CTRL_FUNCSEL_sio_25  = 5,     /*!< sio_25 : sio_25                                                           */
  IO_BANK0_GPIO25_CTRL_FUNCSEL_pio0_25 = 6,     /*!< pio0_25 : pio0_25                                                         */
  IO_BANK0_GPIO25_CTRL_FUNCSEL_pio1_25 = 7,     /*!< pio1_25 : pio1_25                                                         */
  IO_BANK0_GPIO25_CTRL_FUNCSEL_clocks_gpout_3 = 8,/*!< clocks_gpout_3 : clocks_gpout_3                                         */
  IO_BANK0_GPIO25_CTRL_FUNCSEL_usb_muxing_vbus_detect = 9,/*!< usb_muxing_vbus_detect : usb_muxing_vbus_detect                 */
  IO_BANK0_GPIO25_CTRL_FUNCSEL_null    = 31,    /*!< null : null                                                               */
} IO_BANK0_GPIO25_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO26_STATUS  ===================================================== */
/* ======================================================  GPIO26_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO26_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO26_CTRL_IRQOVER                                              */
  IO_BANK0_GPIO26_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt                                       */
  IO_BANK0_GPIO26_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt                                             */
  IO_BANK0_GPIO26_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low                                                 */
  IO_BANK0_GPIO26_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high                                               */
} IO_BANK0_GPIO26_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO26_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO26_CTRL_INOVER                                               */
  IO_BANK0_GPIO26_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input                                      */
  IO_BANK0_GPIO26_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input                                            */
  IO_BANK0_GPIO26_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low                                                */
  IO_BANK0_GPIO26_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high                                              */
} IO_BANK0_GPIO26_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO26_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO26_CTRL_OEOVER                                               */
  IO_BANK0_GPIO26_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO26_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal
                                                     selected by funcsel                                                       */
  IO_BANK0_GPIO26_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output                                                  */
  IO_BANK0_GPIO26_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output                                                    */
} IO_BANK0_GPIO26_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO26_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO26_CTRL_OUTOVER                                              */
  IO_BANK0_GPIO26_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel          */
  IO_BANK0_GPIO26_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO26_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low                                                    */
  IO_BANK0_GPIO26_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high                                                  */
} IO_BANK0_GPIO26_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO26_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO26_CTRL_FUNCSEL                                              */
  IO_BANK0_GPIO26_CTRL_FUNCSEL_spi1_sclk = 1,   /*!< spi1_sclk : spi1_sclk                                                     */
  IO_BANK0_GPIO26_CTRL_FUNCSEL_uart1_cts = 2,   /*!< uart1_cts : uart1_cts                                                     */
  IO_BANK0_GPIO26_CTRL_FUNCSEL_i2c1_sda = 3,    /*!< i2c1_sda : i2c1_sda                                                       */
  IO_BANK0_GPIO26_CTRL_FUNCSEL_pwm_a_5 = 4,     /*!< pwm_a_5 : pwm_a_5                                                         */
  IO_BANK0_GPIO26_CTRL_FUNCSEL_sio_26  = 5,     /*!< sio_26 : sio_26                                                           */
  IO_BANK0_GPIO26_CTRL_FUNCSEL_pio0_26 = 6,     /*!< pio0_26 : pio0_26                                                         */
  IO_BANK0_GPIO26_CTRL_FUNCSEL_pio1_26 = 7,     /*!< pio1_26 : pio1_26                                                         */
  IO_BANK0_GPIO26_CTRL_FUNCSEL_usb_muxing_vbus_en = 9,/*!< usb_muxing_vbus_en : usb_muxing_vbus_en                             */
  IO_BANK0_GPIO26_CTRL_FUNCSEL_null    = 31,    /*!< null : null                                                               */
} IO_BANK0_GPIO26_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO27_STATUS  ===================================================== */
/* ======================================================  GPIO27_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO27_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO27_CTRL_IRQOVER                                              */
  IO_BANK0_GPIO27_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt                                       */
  IO_BANK0_GPIO27_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt                                             */
  IO_BANK0_GPIO27_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low                                                 */
  IO_BANK0_GPIO27_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high                                               */
} IO_BANK0_GPIO27_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO27_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO27_CTRL_INOVER                                               */
  IO_BANK0_GPIO27_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input                                      */
  IO_BANK0_GPIO27_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input                                            */
  IO_BANK0_GPIO27_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low                                                */
  IO_BANK0_GPIO27_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high                                              */
} IO_BANK0_GPIO27_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO27_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO27_CTRL_OEOVER                                               */
  IO_BANK0_GPIO27_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO27_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal
                                                     selected by funcsel                                                       */
  IO_BANK0_GPIO27_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output                                                  */
  IO_BANK0_GPIO27_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output                                                    */
} IO_BANK0_GPIO27_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO27_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO27_CTRL_OUTOVER                                              */
  IO_BANK0_GPIO27_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel          */
  IO_BANK0_GPIO27_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO27_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low                                                    */
  IO_BANK0_GPIO27_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high                                                  */
} IO_BANK0_GPIO27_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO27_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO27_CTRL_FUNCSEL                                              */
  IO_BANK0_GPIO27_CTRL_FUNCSEL_spi1_tx = 1,     /*!< spi1_tx : spi1_tx                                                         */
  IO_BANK0_GPIO27_CTRL_FUNCSEL_uart1_rts = 2,   /*!< uart1_rts : uart1_rts                                                     */
  IO_BANK0_GPIO27_CTRL_FUNCSEL_i2c1_scl = 3,    /*!< i2c1_scl : i2c1_scl                                                       */
  IO_BANK0_GPIO27_CTRL_FUNCSEL_pwm_b_5 = 4,     /*!< pwm_b_5 : pwm_b_5                                                         */
  IO_BANK0_GPIO27_CTRL_FUNCSEL_sio_27  = 5,     /*!< sio_27 : sio_27                                                           */
  IO_BANK0_GPIO27_CTRL_FUNCSEL_pio0_27 = 6,     /*!< pio0_27 : pio0_27                                                         */
  IO_BANK0_GPIO27_CTRL_FUNCSEL_pio1_27 = 7,     /*!< pio1_27 : pio1_27                                                         */
  IO_BANK0_GPIO27_CTRL_FUNCSEL_usb_muxing_overcurr_detect = 9,/*!< usb_muxing_overcurr_detect : usb_muxing_overcurr_detect     */
  IO_BANK0_GPIO27_CTRL_FUNCSEL_null    = 31,    /*!< null : null                                                               */
} IO_BANK0_GPIO27_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO28_STATUS  ===================================================== */
/* ======================================================  GPIO28_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO28_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO28_CTRL_IRQOVER                                              */
  IO_BANK0_GPIO28_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt                                       */
  IO_BANK0_GPIO28_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt                                             */
  IO_BANK0_GPIO28_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low                                                 */
  IO_BANK0_GPIO28_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high                                               */
} IO_BANK0_GPIO28_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO28_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO28_CTRL_INOVER                                               */
  IO_BANK0_GPIO28_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input                                      */
  IO_BANK0_GPIO28_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input                                            */
  IO_BANK0_GPIO28_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low                                                */
  IO_BANK0_GPIO28_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high                                              */
} IO_BANK0_GPIO28_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO28_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO28_CTRL_OEOVER                                               */
  IO_BANK0_GPIO28_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO28_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal
                                                     selected by funcsel                                                       */
  IO_BANK0_GPIO28_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output                                                  */
  IO_BANK0_GPIO28_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output                                                    */
} IO_BANK0_GPIO28_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO28_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO28_CTRL_OUTOVER                                              */
  IO_BANK0_GPIO28_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel          */
  IO_BANK0_GPIO28_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO28_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low                                                    */
  IO_BANK0_GPIO28_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high                                                  */
} IO_BANK0_GPIO28_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO28_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO28_CTRL_FUNCSEL                                              */
  IO_BANK0_GPIO28_CTRL_FUNCSEL_spi1_rx = 1,     /*!< spi1_rx : spi1_rx                                                         */
  IO_BANK0_GPIO28_CTRL_FUNCSEL_uart0_tx = 2,    /*!< uart0_tx : uart0_tx                                                       */
  IO_BANK0_GPIO28_CTRL_FUNCSEL_i2c0_sda = 3,    /*!< i2c0_sda : i2c0_sda                                                       */
  IO_BANK0_GPIO28_CTRL_FUNCSEL_pwm_a_6 = 4,     /*!< pwm_a_6 : pwm_a_6                                                         */
  IO_BANK0_GPIO28_CTRL_FUNCSEL_sio_28  = 5,     /*!< sio_28 : sio_28                                                           */
  IO_BANK0_GPIO28_CTRL_FUNCSEL_pio0_28 = 6,     /*!< pio0_28 : pio0_28                                                         */
  IO_BANK0_GPIO28_CTRL_FUNCSEL_pio1_28 = 7,     /*!< pio1_28 : pio1_28                                                         */
  IO_BANK0_GPIO28_CTRL_FUNCSEL_usb_muxing_vbus_detect = 9,/*!< usb_muxing_vbus_detect : usb_muxing_vbus_detect                 */
  IO_BANK0_GPIO28_CTRL_FUNCSEL_null    = 31,    /*!< null : null                                                               */
} IO_BANK0_GPIO28_CTRL_FUNCSEL_Enum;

/* =====================================================  GPIO29_STATUS  ===================================================== */
/* ======================================================  GPIO29_CTRL  ====================================================== */
/* =========================================  IO_BANK0 GPIO29_CTRL IRQOVER [28..29]  ========================================= */
typedef enum {                                  /*!< IO_BANK0_GPIO29_CTRL_IRQOVER                                              */
  IO_BANK0_GPIO29_CTRL_IRQOVER_NORMAL  = 0,     /*!< NORMAL : don't invert the interrupt                                       */
  IO_BANK0_GPIO29_CTRL_IRQOVER_INVERT  = 1,     /*!< INVERT : invert the interrupt                                             */
  IO_BANK0_GPIO29_CTRL_IRQOVER_LOW     = 2,     /*!< LOW : drive interrupt low                                                 */
  IO_BANK0_GPIO29_CTRL_IRQOVER_HIGH    = 3,     /*!< HIGH : drive interrupt high                                               */
} IO_BANK0_GPIO29_CTRL_IRQOVER_Enum;

/* =========================================  IO_BANK0 GPIO29_CTRL INOVER [16..17]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO29_CTRL_INOVER                                               */
  IO_BANK0_GPIO29_CTRL_INOVER_NORMAL   = 0,     /*!< NORMAL : don't invert the peri input                                      */
  IO_BANK0_GPIO29_CTRL_INOVER_INVERT   = 1,     /*!< INVERT : invert the peri input                                            */
  IO_BANK0_GPIO29_CTRL_INOVER_LOW      = 2,     /*!< LOW : drive peri input low                                                */
  IO_BANK0_GPIO29_CTRL_INOVER_HIGH     = 3,     /*!< HIGH : drive peri input high                                              */
} IO_BANK0_GPIO29_CTRL_INOVER_Enum;

/* =========================================  IO_BANK0 GPIO29_CTRL OEOVER [12..13]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO29_CTRL_OEOVER                                               */
  IO_BANK0_GPIO29_CTRL_OEOVER_NORMAL   = 0,     /*!< NORMAL : drive output enable from peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO29_CTRL_OEOVER_INVERT   = 1,     /*!< INVERT : drive output enable from inverse of peripheral signal
                                                     selected by funcsel                                                       */
  IO_BANK0_GPIO29_CTRL_OEOVER_DISABLE  = 2,     /*!< DISABLE : disable output                                                  */
  IO_BANK0_GPIO29_CTRL_OEOVER_ENABLE   = 3,     /*!< ENABLE : enable output                                                    */
} IO_BANK0_GPIO29_CTRL_OEOVER_Enum;

/* ==========================================  IO_BANK0 GPIO29_CTRL OUTOVER [8..9]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO29_CTRL_OUTOVER                                              */
  IO_BANK0_GPIO29_CTRL_OUTOVER_NORMAL  = 0,     /*!< NORMAL : drive output from peripheral signal selected by funcsel          */
  IO_BANK0_GPIO29_CTRL_OUTOVER_INVERT  = 1,     /*!< INVERT : drive output from inverse of peripheral signal selected
                                                     by funcsel                                                                */
  IO_BANK0_GPIO29_CTRL_OUTOVER_LOW     = 2,     /*!< LOW : drive output low                                                    */
  IO_BANK0_GPIO29_CTRL_OUTOVER_HIGH    = 3,     /*!< HIGH : drive output high                                                  */
} IO_BANK0_GPIO29_CTRL_OUTOVER_Enum;

/* ==========================================  IO_BANK0 GPIO29_CTRL FUNCSEL [0..4]  ========================================== */
typedef enum {                                  /*!< IO_BANK0_GPIO29_CTRL_FUNCSEL                                              */
  IO_BANK0_GPIO29_CTRL_FUNCSEL_spi1_ss_n = 1,   /*!< spi1_ss_n : spi1_ss_n                                                     */
  IO_BANK0_GPIO29_CTRL_FUNCSEL_uart0_rx = 2,    /*!< uart0_rx : uart0_rx                                                       */
  IO_BANK0_GPIO29_CTRL_FUNCSEL_i2c0_scl = 3,    /*!< i2c0_scl : i2c0_scl                                                       */
  IO_BANK0_GPIO29_CTRL_FUNCSEL_pwm_b_6 = 4,     /*!< pwm_b_6 : pwm_b_6                                                         */
  IO_BANK0_GPIO29_CTRL_FUNCSEL_sio_29  = 5,     /*!< sio_29 : sio_29                                                           */
  IO_BANK0_GPIO29_CTRL_FUNCSEL_pio0_29 = 6,     /*!< pio0_29 : pio0_29                                                         */
  IO_BANK0_GPIO29_CTRL_FUNCSEL_pio1_29 = 7,     /*!< pio1_29 : pio1_29                                                         */
  IO_BANK0_GPIO29_CTRL_FUNCSEL_usb_muxing_vbus_en = 9,/*!< usb_muxing_vbus_en : usb_muxing_vbus_en                             */
  IO_BANK0_GPIO29_CTRL_FUNCSEL_null    = 31,    /*!< null : null                                                               */
} IO_BANK0_GPIO29_CTRL_FUNCSEL_Enum;

/* =========================================================  INTR0  ========================================================= */
/* =========================================================  INTR1  ========================================================= */
/* =========================================================  INTR2  ========================================================= */
/* =========================================================  INTR3  ========================================================= */
/* ======================================================  PROC0_INTE0  ====================================================== */
/* ======================================================  PROC0_INTE1  ====================================================== */
/* ======================================================  PROC0_INTE2  ====================================================== */
/* ======================================================  PROC0_INTE3  ====================================================== */
/* ======================================================  PROC0_INTF0  ====================================================== */
/* ======================================================  PROC0_INTF1  ====================================================== */
/* ======================================================  PROC0_INTF2  ====================================================== */
/* ======================================================  PROC0_INTF3  ====================================================== */
/* ======================================================  PROC0_INTS0  ====================================================== */
/* ======================================================  PROC0_INTS1  ====================================================== */
/* ======================================================  PROC0_INTS2  ====================================================== */
/* ======================================================  PROC0_INTS3  ====================================================== */
/* ======================================================  PROC1_INTE0  ====================================================== */
/* ======================================================  PROC1_INTE1  ====================================================== */
/* ======================================================  PROC1_INTE2  ====================================================== */
/* ======================================================  PROC1_INTE3  ====================================================== */
/* ======================================================  PROC1_INTF0  ====================================================== */
/* ======================================================  PROC1_INTF1  ====================================================== */
/* ======================================================  PROC1_INTF2  ====================================================== */
/* ======================================================  PROC1_INTF3  ====================================================== */
/* ======================================================  PROC1_INTS0  ====================================================== */
/* ======================================================  PROC1_INTS1  ====================================================== */
/* ======================================================  PROC1_INTS2  ====================================================== */
/* ======================================================  PROC1_INTS3  ====================================================== */
/* ==================================================  DORMANT_WAKE_INTE0  =================================================== */
/* ==================================================  DORMANT_WAKE_INTE1  =================================================== */
/* ==================================================  DORMANT_WAKE_INTE2  =================================================== */
/* ==================================================  DORMANT_WAKE_INTE3  =================================================== */
/* ==================================================  DORMANT_WAKE_INTF0  =================================================== */
/* ==================================================  DORMANT_WAKE_INTF1  =================================================== */
/* ==================================================  DORMANT_WAKE_INTF2  =================================================== */
/* ==================================================  DORMANT_WAKE_INTF3  =================================================== */
/* ==================================================  DORMANT_WAKE_INTS0  =================================================== */
/* ==================================================  DORMANT_WAKE_INTS1  =================================================== */
/* ==================================================  DORMANT_WAKE_INTS2  =================================================== */
/* ==================================================  DORMANT_WAKE_INTS3  =================================================== */


/* =========================================================================================================================== */
/* ================                                          IO_QSPI                                          ================ */
/* =========================================================================================================================== */

/* =================================================  GPIO_QSPI_SCLK_STATUS  ================================================= */
/* ==================================================  GPIO_QSPI_SCLK_CTRL  ================================================== */
/* =====================================  IO_QSPI GPIO_QSPI_SCLK_CTRL IRQOVER [28..29]  ====================================== */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SCLK_CTRL_IRQOVER                                       */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_IRQOVER_NORMAL = 0,/*!< NORMAL : don't invert the interrupt                                      */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_IRQOVER_INVERT = 1,/*!< INVERT : invert the interrupt                                            */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_IRQOVER_LOW = 2,  /*!< LOW : drive interrupt low                                                 */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_IRQOVER_HIGH = 3, /*!< HIGH : drive interrupt high                                               */
} IO_QSPI_GPIO_QSPI_SCLK_CTRL_IRQOVER_Enum;

/* ======================================  IO_QSPI GPIO_QSPI_SCLK_CTRL INOVER [16..17]  ====================================== */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SCLK_CTRL_INOVER                                        */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_INOVER_NORMAL = 0,/*!< NORMAL : don't invert the peri input                                      */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_INOVER_INVERT = 1,/*!< INVERT : invert the peri input                                            */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_INOVER_LOW = 2,   /*!< LOW : drive peri input low                                                */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_INOVER_HIGH = 3,  /*!< HIGH : drive peri input high                                              */
} IO_QSPI_GPIO_QSPI_SCLK_CTRL_INOVER_Enum;

/* ======================================  IO_QSPI GPIO_QSPI_SCLK_CTRL OEOVER [12..13]  ====================================== */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SCLK_CTRL_OEOVER                                        */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_OEOVER_NORMAL = 0,/*!< NORMAL : drive output enable from peripheral signal selected
                                                     by funcsel                                                                */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_OEOVER_INVERT = 1,/*!< INVERT : drive output enable from inverse of peripheral signal
                                                     selected by funcsel                                                       */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_OEOVER_DISABLE = 2,/*!< DISABLE : disable output                                                 */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_OEOVER_ENABLE = 3,/*!< ENABLE : enable output                                                    */
} IO_QSPI_GPIO_QSPI_SCLK_CTRL_OEOVER_Enum;

/* ======================================  IO_QSPI GPIO_QSPI_SCLK_CTRL OUTOVER [8..9]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SCLK_CTRL_OUTOVER                                       */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_OUTOVER_NORMAL = 0,/*!< NORMAL : drive output from peripheral signal selected by funcsel         */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_OUTOVER_INVERT = 1,/*!< INVERT : drive output from inverse of peripheral signal selected
                                                     by funcsel                                                                */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_OUTOVER_LOW = 2,  /*!< LOW : drive output low                                                    */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_OUTOVER_HIGH = 3, /*!< HIGH : drive output high                                                  */
} IO_QSPI_GPIO_QSPI_SCLK_CTRL_OUTOVER_Enum;

/* ======================================  IO_QSPI GPIO_QSPI_SCLK_CTRL FUNCSEL [0..4]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SCLK_CTRL_FUNCSEL                                       */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_FUNCSEL_xip_sclk = 0,/*!< xip_sclk : xip_sclk                                                    */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_FUNCSEL_sio_30 = 5,/*!< sio_30 : sio_30                                                          */
  IO_QSPI_GPIO_QSPI_SCLK_CTRL_FUNCSEL_null = 31,/*!< null : null                                                               */
} IO_QSPI_GPIO_QSPI_SCLK_CTRL_FUNCSEL_Enum;

/* ==================================================  GPIO_QSPI_SS_STATUS  ================================================== */
/* ===================================================  GPIO_QSPI_SS_CTRL  =================================================== */
/* ======================================  IO_QSPI GPIO_QSPI_SS_CTRL IRQOVER [28..29]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SS_CTRL_IRQOVER                                         */
  IO_QSPI_GPIO_QSPI_SS_CTRL_IRQOVER_NORMAL = 0, /*!< NORMAL : don't invert the interrupt                                       */
  IO_QSPI_GPIO_QSPI_SS_CTRL_IRQOVER_INVERT = 1, /*!< INVERT : invert the interrupt                                             */
  IO_QSPI_GPIO_QSPI_SS_CTRL_IRQOVER_LOW = 2,    /*!< LOW : drive interrupt low                                                 */
  IO_QSPI_GPIO_QSPI_SS_CTRL_IRQOVER_HIGH = 3,   /*!< HIGH : drive interrupt high                                               */
} IO_QSPI_GPIO_QSPI_SS_CTRL_IRQOVER_Enum;

/* =======================================  IO_QSPI GPIO_QSPI_SS_CTRL INOVER [16..17]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SS_CTRL_INOVER                                          */
  IO_QSPI_GPIO_QSPI_SS_CTRL_INOVER_NORMAL = 0,  /*!< NORMAL : don't invert the peri input                                      */
  IO_QSPI_GPIO_QSPI_SS_CTRL_INOVER_INVERT = 1,  /*!< INVERT : invert the peri input                                            */
  IO_QSPI_GPIO_QSPI_SS_CTRL_INOVER_LOW = 2,     /*!< LOW : drive peri input low                                                */
  IO_QSPI_GPIO_QSPI_SS_CTRL_INOVER_HIGH = 3,    /*!< HIGH : drive peri input high                                              */
} IO_QSPI_GPIO_QSPI_SS_CTRL_INOVER_Enum;

/* =======================================  IO_QSPI GPIO_QSPI_SS_CTRL OEOVER [12..13]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SS_CTRL_OEOVER                                          */
  IO_QSPI_GPIO_QSPI_SS_CTRL_OEOVER_NORMAL = 0,  /*!< NORMAL : drive output enable from peripheral signal selected
                                                     by funcsel                                                                */
  IO_QSPI_GPIO_QSPI_SS_CTRL_OEOVER_INVERT = 1,  /*!< INVERT : drive output enable from inverse of peripheral signal
                                                     selected by funcsel                                                       */
  IO_QSPI_GPIO_QSPI_SS_CTRL_OEOVER_DISABLE = 2, /*!< DISABLE : disable output                                                  */
  IO_QSPI_GPIO_QSPI_SS_CTRL_OEOVER_ENABLE = 3,  /*!< ENABLE : enable output                                                    */
} IO_QSPI_GPIO_QSPI_SS_CTRL_OEOVER_Enum;

/* =======================================  IO_QSPI GPIO_QSPI_SS_CTRL OUTOVER [8..9]  ======================================== */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SS_CTRL_OUTOVER                                         */
  IO_QSPI_GPIO_QSPI_SS_CTRL_OUTOVER_NORMAL = 0, /*!< NORMAL : drive output from peripheral signal selected by funcsel          */
  IO_QSPI_GPIO_QSPI_SS_CTRL_OUTOVER_INVERT = 1, /*!< INVERT : drive output from inverse of peripheral signal selected
                                                     by funcsel                                                                */
  IO_QSPI_GPIO_QSPI_SS_CTRL_OUTOVER_LOW = 2,    /*!< LOW : drive output low                                                    */
  IO_QSPI_GPIO_QSPI_SS_CTRL_OUTOVER_HIGH = 3,   /*!< HIGH : drive output high                                                  */
} IO_QSPI_GPIO_QSPI_SS_CTRL_OUTOVER_Enum;

/* =======================================  IO_QSPI GPIO_QSPI_SS_CTRL FUNCSEL [0..4]  ======================================== */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SS_CTRL_FUNCSEL                                         */
  IO_QSPI_GPIO_QSPI_SS_CTRL_FUNCSEL_xip_ss_n = 0,/*!< xip_ss_n : xip_ss_n                                                      */
  IO_QSPI_GPIO_QSPI_SS_CTRL_FUNCSEL_sio_31 = 5, /*!< sio_31 : sio_31                                                           */
  IO_QSPI_GPIO_QSPI_SS_CTRL_FUNCSEL_null = 31,  /*!< null : null                                                               */
} IO_QSPI_GPIO_QSPI_SS_CTRL_FUNCSEL_Enum;

/* =================================================  GPIO_QSPI_SD0_STATUS  ================================================== */
/* ==================================================  GPIO_QSPI_SD0_CTRL  =================================================== */
/* ======================================  IO_QSPI GPIO_QSPI_SD0_CTRL IRQOVER [28..29]  ====================================== */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD0_CTRL_IRQOVER                                        */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_IRQOVER_NORMAL = 0,/*!< NORMAL : don't invert the interrupt                                       */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_IRQOVER_INVERT = 1,/*!< INVERT : invert the interrupt                                             */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_IRQOVER_LOW = 2,   /*!< LOW : drive interrupt low                                                 */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_IRQOVER_HIGH = 3,  /*!< HIGH : drive interrupt high                                               */
} IO_QSPI_GPIO_QSPI_SD0_CTRL_IRQOVER_Enum;

/* ======================================  IO_QSPI GPIO_QSPI_SD0_CTRL INOVER [16..17]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD0_CTRL_INOVER                                         */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_INOVER_NORMAL = 0, /*!< NORMAL : don't invert the peri input                                      */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_INOVER_INVERT = 1, /*!< INVERT : invert the peri input                                            */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_INOVER_LOW = 2,    /*!< LOW : drive peri input low                                                */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_INOVER_HIGH = 3,   /*!< HIGH : drive peri input high                                              */
} IO_QSPI_GPIO_QSPI_SD0_CTRL_INOVER_Enum;

/* ======================================  IO_QSPI GPIO_QSPI_SD0_CTRL OEOVER [12..13]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD0_CTRL_OEOVER                                         */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_OEOVER_NORMAL = 0, /*!< NORMAL : drive output enable from peripheral signal selected
                                                     by funcsel                                                                */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_OEOVER_INVERT = 1, /*!< INVERT : drive output enable from inverse of peripheral signal
                                                     selected by funcsel                                                       */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_OEOVER_DISABLE = 2,/*!< DISABLE : disable output                                                  */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_OEOVER_ENABLE = 3, /*!< ENABLE : enable output                                                    */
} IO_QSPI_GPIO_QSPI_SD0_CTRL_OEOVER_Enum;

/* =======================================  IO_QSPI GPIO_QSPI_SD0_CTRL OUTOVER [8..9]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD0_CTRL_OUTOVER                                        */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_OUTOVER_NORMAL = 0,/*!< NORMAL : drive output from peripheral signal selected by funcsel          */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_OUTOVER_INVERT = 1,/*!< INVERT : drive output from inverse of peripheral signal selected
                                                     by funcsel                                                                */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_OUTOVER_LOW = 2,   /*!< LOW : drive output low                                                    */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_OUTOVER_HIGH = 3,  /*!< HIGH : drive output high                                                  */
} IO_QSPI_GPIO_QSPI_SD0_CTRL_OUTOVER_Enum;

/* =======================================  IO_QSPI GPIO_QSPI_SD0_CTRL FUNCSEL [0..4]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD0_CTRL_FUNCSEL                                        */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_FUNCSEL_xip_sd0 = 0,/*!< xip_sd0 : xip_sd0                                                        */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_FUNCSEL_sio_32 = 5,/*!< sio_32 : sio_32                                                           */
  IO_QSPI_GPIO_QSPI_SD0_CTRL_FUNCSEL_null = 31, /*!< null : null                                                               */
} IO_QSPI_GPIO_QSPI_SD0_CTRL_FUNCSEL_Enum;

/* =================================================  GPIO_QSPI_SD1_STATUS  ================================================== */
/* ==================================================  GPIO_QSPI_SD1_CTRL  =================================================== */
/* ======================================  IO_QSPI GPIO_QSPI_SD1_CTRL IRQOVER [28..29]  ====================================== */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD1_CTRL_IRQOVER                                        */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_IRQOVER_NORMAL = 0,/*!< NORMAL : don't invert the interrupt                                       */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_IRQOVER_INVERT = 1,/*!< INVERT : invert the interrupt                                             */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_IRQOVER_LOW = 2,   /*!< LOW : drive interrupt low                                                 */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_IRQOVER_HIGH = 3,  /*!< HIGH : drive interrupt high                                               */
} IO_QSPI_GPIO_QSPI_SD1_CTRL_IRQOVER_Enum;

/* ======================================  IO_QSPI GPIO_QSPI_SD1_CTRL INOVER [16..17]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD1_CTRL_INOVER                                         */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_INOVER_NORMAL = 0, /*!< NORMAL : don't invert the peri input                                      */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_INOVER_INVERT = 1, /*!< INVERT : invert the peri input                                            */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_INOVER_LOW = 2,    /*!< LOW : drive peri input low                                                */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_INOVER_HIGH = 3,   /*!< HIGH : drive peri input high                                              */
} IO_QSPI_GPIO_QSPI_SD1_CTRL_INOVER_Enum;

/* ======================================  IO_QSPI GPIO_QSPI_SD1_CTRL OEOVER [12..13]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD1_CTRL_OEOVER                                         */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_OEOVER_NORMAL = 0, /*!< NORMAL : drive output enable from peripheral signal selected
                                                     by funcsel                                                                */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_OEOVER_INVERT = 1, /*!< INVERT : drive output enable from inverse of peripheral signal
                                                     selected by funcsel                                                       */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_OEOVER_DISABLE = 2,/*!< DISABLE : disable output                                                  */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_OEOVER_ENABLE = 3, /*!< ENABLE : enable output                                                    */
} IO_QSPI_GPIO_QSPI_SD1_CTRL_OEOVER_Enum;

/* =======================================  IO_QSPI GPIO_QSPI_SD1_CTRL OUTOVER [8..9]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD1_CTRL_OUTOVER                                        */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_OUTOVER_NORMAL = 0,/*!< NORMAL : drive output from peripheral signal selected by funcsel          */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_OUTOVER_INVERT = 1,/*!< INVERT : drive output from inverse of peripheral signal selected
                                                     by funcsel                                                                */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_OUTOVER_LOW = 2,   /*!< LOW : drive output low                                                    */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_OUTOVER_HIGH = 3,  /*!< HIGH : drive output high                                                  */
} IO_QSPI_GPIO_QSPI_SD1_CTRL_OUTOVER_Enum;

/* =======================================  IO_QSPI GPIO_QSPI_SD1_CTRL FUNCSEL [0..4]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD1_CTRL_FUNCSEL                                        */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_FUNCSEL_xip_sd1 = 0,/*!< xip_sd1 : xip_sd1                                                        */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_FUNCSEL_sio_33 = 5,/*!< sio_33 : sio_33                                                           */
  IO_QSPI_GPIO_QSPI_SD1_CTRL_FUNCSEL_null = 31, /*!< null : null                                                               */
} IO_QSPI_GPIO_QSPI_SD1_CTRL_FUNCSEL_Enum;

/* =================================================  GPIO_QSPI_SD2_STATUS  ================================================== */
/* ==================================================  GPIO_QSPI_SD2_CTRL  =================================================== */
/* ======================================  IO_QSPI GPIO_QSPI_SD2_CTRL IRQOVER [28..29]  ====================================== */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD2_CTRL_IRQOVER                                        */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_IRQOVER_NORMAL = 0,/*!< NORMAL : don't invert the interrupt                                       */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_IRQOVER_INVERT = 1,/*!< INVERT : invert the interrupt                                             */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_IRQOVER_LOW = 2,   /*!< LOW : drive interrupt low                                                 */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_IRQOVER_HIGH = 3,  /*!< HIGH : drive interrupt high                                               */
} IO_QSPI_GPIO_QSPI_SD2_CTRL_IRQOVER_Enum;

/* ======================================  IO_QSPI GPIO_QSPI_SD2_CTRL INOVER [16..17]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD2_CTRL_INOVER                                         */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_INOVER_NORMAL = 0, /*!< NORMAL : don't invert the peri input                                      */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_INOVER_INVERT = 1, /*!< INVERT : invert the peri input                                            */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_INOVER_LOW = 2,    /*!< LOW : drive peri input low                                                */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_INOVER_HIGH = 3,   /*!< HIGH : drive peri input high                                              */
} IO_QSPI_GPIO_QSPI_SD2_CTRL_INOVER_Enum;

/* ======================================  IO_QSPI GPIO_QSPI_SD2_CTRL OEOVER [12..13]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD2_CTRL_OEOVER                                         */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_OEOVER_NORMAL = 0, /*!< NORMAL : drive output enable from peripheral signal selected
                                                     by funcsel                                                                */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_OEOVER_INVERT = 1, /*!< INVERT : drive output enable from inverse of peripheral signal
                                                     selected by funcsel                                                       */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_OEOVER_DISABLE = 2,/*!< DISABLE : disable output                                                  */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_OEOVER_ENABLE = 3, /*!< ENABLE : enable output                                                    */
} IO_QSPI_GPIO_QSPI_SD2_CTRL_OEOVER_Enum;

/* =======================================  IO_QSPI GPIO_QSPI_SD2_CTRL OUTOVER [8..9]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD2_CTRL_OUTOVER                                        */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_OUTOVER_NORMAL = 0,/*!< NORMAL : drive output from peripheral signal selected by funcsel          */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_OUTOVER_INVERT = 1,/*!< INVERT : drive output from inverse of peripheral signal selected
                                                     by funcsel                                                                */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_OUTOVER_LOW = 2,   /*!< LOW : drive output low                                                    */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_OUTOVER_HIGH = 3,  /*!< HIGH : drive output high                                                  */
} IO_QSPI_GPIO_QSPI_SD2_CTRL_OUTOVER_Enum;

/* =======================================  IO_QSPI GPIO_QSPI_SD2_CTRL FUNCSEL [0..4]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD2_CTRL_FUNCSEL                                        */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_FUNCSEL_xip_sd2 = 0,/*!< xip_sd2 : xip_sd2                                                        */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_FUNCSEL_sio_34 = 5,/*!< sio_34 : sio_34                                                           */
  IO_QSPI_GPIO_QSPI_SD2_CTRL_FUNCSEL_null = 31, /*!< null : null                                                               */
} IO_QSPI_GPIO_QSPI_SD2_CTRL_FUNCSEL_Enum;

/* =================================================  GPIO_QSPI_SD3_STATUS  ================================================== */
/* ==================================================  GPIO_QSPI_SD3_CTRL  =================================================== */
/* ======================================  IO_QSPI GPIO_QSPI_SD3_CTRL IRQOVER [28..29]  ====================================== */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD3_CTRL_IRQOVER                                        */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_IRQOVER_NORMAL = 0,/*!< NORMAL : don't invert the interrupt                                       */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_IRQOVER_INVERT = 1,/*!< INVERT : invert the interrupt                                             */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_IRQOVER_LOW = 2,   /*!< LOW : drive interrupt low                                                 */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_IRQOVER_HIGH = 3,  /*!< HIGH : drive interrupt high                                               */
} IO_QSPI_GPIO_QSPI_SD3_CTRL_IRQOVER_Enum;

/* ======================================  IO_QSPI GPIO_QSPI_SD3_CTRL INOVER [16..17]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD3_CTRL_INOVER                                         */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_INOVER_NORMAL = 0, /*!< NORMAL : don't invert the peri input                                      */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_INOVER_INVERT = 1, /*!< INVERT : invert the peri input                                            */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_INOVER_LOW = 2,    /*!< LOW : drive peri input low                                                */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_INOVER_HIGH = 3,   /*!< HIGH : drive peri input high                                              */
} IO_QSPI_GPIO_QSPI_SD3_CTRL_INOVER_Enum;

/* ======================================  IO_QSPI GPIO_QSPI_SD3_CTRL OEOVER [12..13]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD3_CTRL_OEOVER                                         */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_OEOVER_NORMAL = 0, /*!< NORMAL : drive output enable from peripheral signal selected
                                                     by funcsel                                                                */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_OEOVER_INVERT = 1, /*!< INVERT : drive output enable from inverse of peripheral signal
                                                     selected by funcsel                                                       */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_OEOVER_DISABLE = 2,/*!< DISABLE : disable output                                                  */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_OEOVER_ENABLE = 3, /*!< ENABLE : enable output                                                    */
} IO_QSPI_GPIO_QSPI_SD3_CTRL_OEOVER_Enum;

/* =======================================  IO_QSPI GPIO_QSPI_SD3_CTRL OUTOVER [8..9]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD3_CTRL_OUTOVER                                        */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_OUTOVER_NORMAL = 0,/*!< NORMAL : drive output from peripheral signal selected by funcsel          */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_OUTOVER_INVERT = 1,/*!< INVERT : drive output from inverse of peripheral signal selected
                                                     by funcsel                                                                */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_OUTOVER_LOW = 2,   /*!< LOW : drive output low                                                    */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_OUTOVER_HIGH = 3,  /*!< HIGH : drive output high                                                  */
} IO_QSPI_GPIO_QSPI_SD3_CTRL_OUTOVER_Enum;

/* =======================================  IO_QSPI GPIO_QSPI_SD3_CTRL FUNCSEL [0..4]  ======================================= */
typedef enum {                                  /*!< IO_QSPI_GPIO_QSPI_SD3_CTRL_FUNCSEL                                        */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_FUNCSEL_xip_sd3 = 0,/*!< xip_sd3 : xip_sd3                                                        */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_FUNCSEL_sio_35 = 5,/*!< sio_35 : sio_35                                                           */
  IO_QSPI_GPIO_QSPI_SD3_CTRL_FUNCSEL_null = 31, /*!< null : null                                                               */
} IO_QSPI_GPIO_QSPI_SD3_CTRL_FUNCSEL_Enum;

/* =========================================================  INTR  ========================================================== */
/* ======================================================  PROC0_INTE  ======================================================= */
/* ======================================================  PROC0_INTF  ======================================================= */
/* ======================================================  PROC0_INTS  ======================================================= */
/* ======================================================  PROC1_INTE  ======================================================= */
/* ======================================================  PROC1_INTF  ======================================================= */
/* ======================================================  PROC1_INTS  ======================================================= */
/* ===================================================  DORMANT_WAKE_INTE  =================================================== */
/* ===================================================  DORMANT_WAKE_INTF  =================================================== */
/* ===================================================  DORMANT_WAKE_INTS  =================================================== */


/* =========================================================================================================================== */
/* ================                                        PADS_BANK0                                         ================ */
/* =========================================================================================================================== */

/* ====================================================  VOLTAGE_SELECT  ===================================================== */
/* ====================================  PADS_BANK0 VOLTAGE_SELECT VOLTAGE_SELECT [0..0]  ==================================== */
typedef enum {                                  /*!< PADS_BANK0_VOLTAGE_SELECT_VOLTAGE_SELECT                                  */
  PADS_BANK0_VOLTAGE_SELECT_VOLTAGE_SELECT_3v3 = 0,/*!< 3v3 : Set voltage to 3.3V (DVDD >= 2V5)                                */
  PADS_BANK0_VOLTAGE_SELECT_VOLTAGE_SELECT_1v8 = 1,/*!< 1v8 : Set voltage to 1.8V (DVDD <= 1V8)                                */
} PADS_BANK0_VOLTAGE_SELECT_VOLTAGE_SELECT_Enum;

/* =========================================================  GPIO0  ========================================================= */
/* =============================================  PADS_BANK0 GPIO0 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO0_DRIVE                                                    */
  PADS_BANK0_GPIO0_DRIVE_2mA           = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_BANK0_GPIO0_DRIVE_4mA           = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_BANK0_GPIO0_DRIVE_8mA           = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_BANK0_GPIO0_DRIVE_12mA          = 3,     /*!< 12mA : 12mA                                                               */
} PADS_BANK0_GPIO0_DRIVE_Enum;

/* =========================================================  GPIO1  ========================================================= */
/* =============================================  PADS_BANK0 GPIO1 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO1_DRIVE                                                    */
  PADS_BANK0_GPIO1_DRIVE_2mA           = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_BANK0_GPIO1_DRIVE_4mA           = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_BANK0_GPIO1_DRIVE_8mA           = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_BANK0_GPIO1_DRIVE_12mA          = 3,     /*!< 12mA : 12mA                                                               */
} PADS_BANK0_GPIO1_DRIVE_Enum;

/* =========================================================  GPIO2  ========================================================= */
/* =============================================  PADS_BANK0 GPIO2 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO2_DRIVE                                                    */
  PADS_BANK0_GPIO2_DRIVE_2mA           = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_BANK0_GPIO2_DRIVE_4mA           = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_BANK0_GPIO2_DRIVE_8mA           = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_BANK0_GPIO2_DRIVE_12mA          = 3,     /*!< 12mA : 12mA                                                               */
} PADS_BANK0_GPIO2_DRIVE_Enum;

/* =========================================================  GPIO3  ========================================================= */
/* =============================================  PADS_BANK0 GPIO3 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO3_DRIVE                                                    */
  PADS_BANK0_GPIO3_DRIVE_2mA           = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_BANK0_GPIO3_DRIVE_4mA           = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_BANK0_GPIO3_DRIVE_8mA           = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_BANK0_GPIO3_DRIVE_12mA          = 3,     /*!< 12mA : 12mA                                                               */
} PADS_BANK0_GPIO3_DRIVE_Enum;

/* =========================================================  GPIO4  ========================================================= */
/* =============================================  PADS_BANK0 GPIO4 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO4_DRIVE                                                    */
  PADS_BANK0_GPIO4_DRIVE_2mA           = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_BANK0_GPIO4_DRIVE_4mA           = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_BANK0_GPIO4_DRIVE_8mA           = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_BANK0_GPIO4_DRIVE_12mA          = 3,     /*!< 12mA : 12mA                                                               */
} PADS_BANK0_GPIO4_DRIVE_Enum;

/* =========================================================  GPIO5  ========================================================= */
/* =============================================  PADS_BANK0 GPIO5 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO5_DRIVE                                                    */
  PADS_BANK0_GPIO5_DRIVE_2mA           = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_BANK0_GPIO5_DRIVE_4mA           = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_BANK0_GPIO5_DRIVE_8mA           = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_BANK0_GPIO5_DRIVE_12mA          = 3,     /*!< 12mA : 12mA                                                               */
} PADS_BANK0_GPIO5_DRIVE_Enum;

/* =========================================================  GPIO6  ========================================================= */
/* =============================================  PADS_BANK0 GPIO6 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO6_DRIVE                                                    */
  PADS_BANK0_GPIO6_DRIVE_2mA           = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_BANK0_GPIO6_DRIVE_4mA           = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_BANK0_GPIO6_DRIVE_8mA           = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_BANK0_GPIO6_DRIVE_12mA          = 3,     /*!< 12mA : 12mA                                                               */
} PADS_BANK0_GPIO6_DRIVE_Enum;

/* =========================================================  GPIO7  ========================================================= */
/* =============================================  PADS_BANK0 GPIO7 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO7_DRIVE                                                    */
  PADS_BANK0_GPIO7_DRIVE_2mA           = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_BANK0_GPIO7_DRIVE_4mA           = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_BANK0_GPIO7_DRIVE_8mA           = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_BANK0_GPIO7_DRIVE_12mA          = 3,     /*!< 12mA : 12mA                                                               */
} PADS_BANK0_GPIO7_DRIVE_Enum;

/* =========================================================  GPIO8  ========================================================= */
/* =============================================  PADS_BANK0 GPIO8 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO8_DRIVE                                                    */
  PADS_BANK0_GPIO8_DRIVE_2mA           = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_BANK0_GPIO8_DRIVE_4mA           = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_BANK0_GPIO8_DRIVE_8mA           = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_BANK0_GPIO8_DRIVE_12mA          = 3,     /*!< 12mA : 12mA                                                               */
} PADS_BANK0_GPIO8_DRIVE_Enum;

/* =========================================================  GPIO9  ========================================================= */
/* =============================================  PADS_BANK0 GPIO9 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO9_DRIVE                                                    */
  PADS_BANK0_GPIO9_DRIVE_2mA           = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_BANK0_GPIO9_DRIVE_4mA           = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_BANK0_GPIO9_DRIVE_8mA           = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_BANK0_GPIO9_DRIVE_12mA          = 3,     /*!< 12mA : 12mA                                                               */
} PADS_BANK0_GPIO9_DRIVE_Enum;

/* ========================================================  GPIO10  ========================================================= */
/* ============================================  PADS_BANK0 GPIO10 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO10_DRIVE                                                   */
  PADS_BANK0_GPIO10_DRIVE_2mA          = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_BANK0_GPIO10_DRIVE_4mA          = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_BANK0_GPIO10_DRIVE_8mA          = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_BANK0_GPIO10_DRIVE_12mA         = 3,     /*!< 12mA : 12mA                                                               */
} PADS_BANK0_GPIO10_DRIVE_Enum;

/* ========================================================  GPIO11  ========================================================= */
/* ============================================  PADS_BANK0 GPIO11 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO11_DRIVE                                                   */
  PADS_BANK0_GPIO11_DRIVE_2mA          = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_BANK0_GPIO11_DRIVE_4mA          = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_BANK0_GPIO11_DRIVE_8mA          = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_BANK0_GPIO11_DRIVE_12mA         = 3,     /*!< 12mA : 12mA                                                               */
} PADS_BANK0_GPIO11_DRIVE_Enum;

/* ========================================================  GPIO12  ========================================================= */
/* ============================================  PADS_BANK0 GPIO12 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO12_DRIVE                                                   */
  PADS_BANK0_GPIO12_DRIVE_2mA          = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_BANK0_GPIO12_DRIVE_4mA          = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_BANK0_GPIO12_DRIVE_8mA          = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_BANK0_GPIO12_DRIVE_12mA         = 3,     /*!< 12mA : 12mA                                                               */
} PADS_BANK0_GPIO12_DRIVE_Enum;

/* ========================================================  GPIO13  ========================================================= */
/* ============================================  PADS_BANK0 GPIO13 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO13_DRIVE                                                   */
  PADS_BANK0_GPIO13_DRIVE_2mA          = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_BANK0_GPIO13_DRIVE_4mA          = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_BANK0_GPIO13_DRIVE_8mA          = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_BANK0_GPIO13_DRIVE_12mA         = 3,     /*!< 12mA : 12mA                                                               */
} PADS_BANK0_GPIO13_DRIVE_Enum;

/* ========================================================  GPIO14  ========================================================= */
/* ============================================  PADS_BANK0 GPIO14 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO14_DRIVE                                                   */
  PADS_BANK0_GPIO14_DRIVE_2mA          = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_BANK0_GPIO14_DRIVE_4mA          = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_BANK0_GPIO14_DRIVE_8mA          = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_BANK0_GPIO14_DRIVE_12mA         = 3,     /*!< 12mA : 12mA                                                               */
} PADS_BANK0_GPIO14_DRIVE_Enum;

/* ========================================================  GPIO15  ========================================================= */
/* ============================================  PADS_BANK0 GPIO15 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO15_DRIVE                                                   */
  PADS_BANK0_GPIO15_DRIVE_2mA          = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_BANK0_GPIO15_DRIVE_4mA          = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_BANK0_GPIO15_DRIVE_8mA          = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_BANK0_GPIO15_DRIVE_12mA         = 3,     /*!< 12mA : 12mA                                                               */
} PADS_BANK0_GPIO15_DRIVE_Enum;

/* ========================================================  GPIO16  ========================================================= */
/* ============================================  PADS_BANK0 GPIO16 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO16_DRIVE                                                   */
  PADS_BANK0_GPIO16_DRIVE_2mA          = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_BANK0_GPIO16_DRIVE_4mA          = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_BANK0_GPIO16_DRIVE_8mA          = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_BANK0_GPIO16_DRIVE_12mA         = 3,     /*!< 12mA : 12mA                                                               */
} PADS_BANK0_GPIO16_DRIVE_Enum;

/* ========================================================  GPIO17  ========================================================= */
/* ============================================  PADS_BANK0 GPIO17 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO17_DRIVE                                                   */
  PADS_BANK0_GPIO17_DRIVE_2mA          = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_BANK0_GPIO17_DRIVE_4mA          = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_BANK0_GPIO17_DRIVE_8mA          = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_BANK0_GPIO17_DRIVE_12mA         = 3,     /*!< 12mA : 12mA                                                               */
} PADS_BANK0_GPIO17_DRIVE_Enum;

/* ========================================================  GPIO18  ========================================================= */
/* ============================================  PADS_BANK0 GPIO18 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO18_DRIVE                                                   */
  PADS_BANK0_GPIO18_DRIVE_2mA          = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_BANK0_GPIO18_DRIVE_4mA          = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_BANK0_GPIO18_DRIVE_8mA          = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_BANK0_GPIO18_DRIVE_12mA         = 3,     /*!< 12mA : 12mA                                                               */
} PADS_BANK0_GPIO18_DRIVE_Enum;

/* ========================================================  GPIO19  ========================================================= */
/* ============================================  PADS_BANK0 GPIO19 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO19_DRIVE                                                   */
  PADS_BANK0_GPIO19_DRIVE_2mA          = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_BANK0_GPIO19_DRIVE_4mA          = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_BANK0_GPIO19_DRIVE_8mA          = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_BANK0_GPIO19_DRIVE_12mA         = 3,     /*!< 12mA : 12mA                                                               */
} PADS_BANK0_GPIO19_DRIVE_Enum;

/* ========================================================  GPIO20  ========================================================= */
/* ============================================  PADS_BANK0 GPIO20 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO20_DRIVE                                                   */
  PADS_BANK0_GPIO20_DRIVE_2mA          = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_BANK0_GPIO20_DRIVE_4mA          = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_BANK0_GPIO20_DRIVE_8mA          = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_BANK0_GPIO20_DRIVE_12mA         = 3,     /*!< 12mA : 12mA                                                               */
} PADS_BANK0_GPIO20_DRIVE_Enum;

/* ========================================================  GPIO21  ========================================================= */
/* ============================================  PADS_BANK0 GPIO21 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO21_DRIVE                                                   */
  PADS_BANK0_GPIO21_DRIVE_2mA          = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_BANK0_GPIO21_DRIVE_4mA          = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_BANK0_GPIO21_DRIVE_8mA          = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_BANK0_GPIO21_DRIVE_12mA         = 3,     /*!< 12mA : 12mA                                                               */
} PADS_BANK0_GPIO21_DRIVE_Enum;

/* ========================================================  GPIO22  ========================================================= */
/* ============================================  PADS_BANK0 GPIO22 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO22_DRIVE                                                   */
  PADS_BANK0_GPIO22_DRIVE_2mA          = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_BANK0_GPIO22_DRIVE_4mA          = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_BANK0_GPIO22_DRIVE_8mA          = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_BANK0_GPIO22_DRIVE_12mA         = 3,     /*!< 12mA : 12mA                                                               */
} PADS_BANK0_GPIO22_DRIVE_Enum;

/* ========================================================  GPIO23  ========================================================= */
/* ============================================  PADS_BANK0 GPIO23 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO23_DRIVE                                                   */
  PADS_BANK0_GPIO23_DRIVE_2mA          = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_BANK0_GPIO23_DRIVE_4mA          = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_BANK0_GPIO23_DRIVE_8mA          = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_BANK0_GPIO23_DRIVE_12mA         = 3,     /*!< 12mA : 12mA                                                               */
} PADS_BANK0_GPIO23_DRIVE_Enum;

/* ========================================================  GPIO24  ========================================================= */
/* ============================================  PADS_BANK0 GPIO24 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO24_DRIVE                                                   */
  PADS_BANK0_GPIO24_DRIVE_2mA          = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_BANK0_GPIO24_DRIVE_4mA          = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_BANK0_GPIO24_DRIVE_8mA          = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_BANK0_GPIO24_DRIVE_12mA         = 3,     /*!< 12mA : 12mA                                                               */
} PADS_BANK0_GPIO24_DRIVE_Enum;

/* ========================================================  GPIO25  ========================================================= */
/* ============================================  PADS_BANK0 GPIO25 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO25_DRIVE                                                   */
  PADS_BANK0_GPIO25_DRIVE_2mA          = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_BANK0_GPIO25_DRIVE_4mA          = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_BANK0_GPIO25_DRIVE_8mA          = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_BANK0_GPIO25_DRIVE_12mA         = 3,     /*!< 12mA : 12mA                                                               */
} PADS_BANK0_GPIO25_DRIVE_Enum;

/* ========================================================  GPIO26  ========================================================= */
/* ============================================  PADS_BANK0 GPIO26 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO26_DRIVE                                                   */
  PADS_BANK0_GPIO26_DRIVE_2mA          = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_BANK0_GPIO26_DRIVE_4mA          = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_BANK0_GPIO26_DRIVE_8mA          = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_BANK0_GPIO26_DRIVE_12mA         = 3,     /*!< 12mA : 12mA                                                               */
} PADS_BANK0_GPIO26_DRIVE_Enum;

/* ========================================================  GPIO27  ========================================================= */
/* ============================================  PADS_BANK0 GPIO27 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO27_DRIVE                                                   */
  PADS_BANK0_GPIO27_DRIVE_2mA          = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_BANK0_GPIO27_DRIVE_4mA          = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_BANK0_GPIO27_DRIVE_8mA          = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_BANK0_GPIO27_DRIVE_12mA         = 3,     /*!< 12mA : 12mA                                                               */
} PADS_BANK0_GPIO27_DRIVE_Enum;

/* ========================================================  GPIO28  ========================================================= */
/* ============================================  PADS_BANK0 GPIO28 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO28_DRIVE                                                   */
  PADS_BANK0_GPIO28_DRIVE_2mA          = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_BANK0_GPIO28_DRIVE_4mA          = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_BANK0_GPIO28_DRIVE_8mA          = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_BANK0_GPIO28_DRIVE_12mA         = 3,     /*!< 12mA : 12mA                                                               */
} PADS_BANK0_GPIO28_DRIVE_Enum;

/* ========================================================  GPIO29  ========================================================= */
/* ============================================  PADS_BANK0 GPIO29 DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_GPIO29_DRIVE                                                   */
  PADS_BANK0_GPIO29_DRIVE_2mA          = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_BANK0_GPIO29_DRIVE_4mA          = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_BANK0_GPIO29_DRIVE_8mA          = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_BANK0_GPIO29_DRIVE_12mA         = 3,     /*!< 12mA : 12mA                                                               */
} PADS_BANK0_GPIO29_DRIVE_Enum;

/* =========================================================  SWCLK  ========================================================= */
/* =============================================  PADS_BANK0 SWCLK DRIVE [4..5]  ============================================= */
typedef enum {                                  /*!< PADS_BANK0_SWCLK_DRIVE                                                    */
  PADS_BANK0_SWCLK_DRIVE_2mA           = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_BANK0_SWCLK_DRIVE_4mA           = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_BANK0_SWCLK_DRIVE_8mA           = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_BANK0_SWCLK_DRIVE_12mA          = 3,     /*!< 12mA : 12mA                                                               */
} PADS_BANK0_SWCLK_DRIVE_Enum;

/* ==========================================================  SWD  ========================================================== */
/* ==============================================  PADS_BANK0 SWD DRIVE [4..5]  ============================================== */
typedef enum {                                  /*!< PADS_BANK0_SWD_DRIVE                                                      */
  PADS_BANK0_SWD_DRIVE_2mA             = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_BANK0_SWD_DRIVE_4mA             = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_BANK0_SWD_DRIVE_8mA             = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_BANK0_SWD_DRIVE_12mA            = 3,     /*!< 12mA : 12mA                                                               */
} PADS_BANK0_SWD_DRIVE_Enum;



/* =========================================================================================================================== */
/* ================                                         PADS_QSPI                                         ================ */
/* =========================================================================================================================== */

/* ====================================================  VOLTAGE_SELECT  ===================================================== */
/* ====================================  PADS_QSPI VOLTAGE_SELECT VOLTAGE_SELECT [0..0]  ===================================== */
typedef enum {                                  /*!< PADS_QSPI_VOLTAGE_SELECT_VOLTAGE_SELECT                                   */
  PADS_QSPI_VOLTAGE_SELECT_VOLTAGE_SELECT_3v3 = 0,/*!< 3v3 : Set voltage to 3.3V (DVDD >= 2V5)                                 */
  PADS_QSPI_VOLTAGE_SELECT_VOLTAGE_SELECT_1v8 = 1,/*!< 1v8 : Set voltage to 1.8V (DVDD <= 1V8)                                 */
} PADS_QSPI_VOLTAGE_SELECT_VOLTAGE_SELECT_Enum;

/* ====================================================  GPIO_QSPI_SCLK  ===================================================== */
/* =========================================  PADS_QSPI GPIO_QSPI_SCLK DRIVE [4..5]  ========================================= */
typedef enum {                                  /*!< PADS_QSPI_GPIO_QSPI_SCLK_DRIVE                                            */
  PADS_QSPI_GPIO_QSPI_SCLK_DRIVE_2mA   = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_QSPI_GPIO_QSPI_SCLK_DRIVE_4mA   = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_QSPI_GPIO_QSPI_SCLK_DRIVE_8mA   = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_QSPI_GPIO_QSPI_SCLK_DRIVE_12mA  = 3,     /*!< 12mA : 12mA                                                               */
} PADS_QSPI_GPIO_QSPI_SCLK_DRIVE_Enum;

/* =====================================================  GPIO_QSPI_SD0  ===================================================== */
/* =========================================  PADS_QSPI GPIO_QSPI_SD0 DRIVE [4..5]  ========================================== */
typedef enum {                                  /*!< PADS_QSPI_GPIO_QSPI_SD0_DRIVE                                             */
  PADS_QSPI_GPIO_QSPI_SD0_DRIVE_2mA    = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_QSPI_GPIO_QSPI_SD0_DRIVE_4mA    = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_QSPI_GPIO_QSPI_SD0_DRIVE_8mA    = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_QSPI_GPIO_QSPI_SD0_DRIVE_12mA   = 3,     /*!< 12mA : 12mA                                                               */
} PADS_QSPI_GPIO_QSPI_SD0_DRIVE_Enum;

/* =====================================================  GPIO_QSPI_SD1  ===================================================== */
/* =========================================  PADS_QSPI GPIO_QSPI_SD1 DRIVE [4..5]  ========================================== */
typedef enum {                                  /*!< PADS_QSPI_GPIO_QSPI_SD1_DRIVE                                             */
  PADS_QSPI_GPIO_QSPI_SD1_DRIVE_2mA    = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_QSPI_GPIO_QSPI_SD1_DRIVE_4mA    = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_QSPI_GPIO_QSPI_SD1_DRIVE_8mA    = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_QSPI_GPIO_QSPI_SD1_DRIVE_12mA   = 3,     /*!< 12mA : 12mA                                                               */
} PADS_QSPI_GPIO_QSPI_SD1_DRIVE_Enum;

/* =====================================================  GPIO_QSPI_SD2  ===================================================== */
/* =========================================  PADS_QSPI GPIO_QSPI_SD2 DRIVE [4..5]  ========================================== */
typedef enum {                                  /*!< PADS_QSPI_GPIO_QSPI_SD2_DRIVE                                             */
  PADS_QSPI_GPIO_QSPI_SD2_DRIVE_2mA    = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_QSPI_GPIO_QSPI_SD2_DRIVE_4mA    = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_QSPI_GPIO_QSPI_SD2_DRIVE_8mA    = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_QSPI_GPIO_QSPI_SD2_DRIVE_12mA   = 3,     /*!< 12mA : 12mA                                                               */
} PADS_QSPI_GPIO_QSPI_SD2_DRIVE_Enum;

/* =====================================================  GPIO_QSPI_SD3  ===================================================== */
/* =========================================  PADS_QSPI GPIO_QSPI_SD3 DRIVE [4..5]  ========================================== */
typedef enum {                                  /*!< PADS_QSPI_GPIO_QSPI_SD3_DRIVE                                             */
  PADS_QSPI_GPIO_QSPI_SD3_DRIVE_2mA    = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_QSPI_GPIO_QSPI_SD3_DRIVE_4mA    = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_QSPI_GPIO_QSPI_SD3_DRIVE_8mA    = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_QSPI_GPIO_QSPI_SD3_DRIVE_12mA   = 3,     /*!< 12mA : 12mA                                                               */
} PADS_QSPI_GPIO_QSPI_SD3_DRIVE_Enum;

/* =====================================================  GPIO_QSPI_SS  ====================================================== */
/* ==========================================  PADS_QSPI GPIO_QSPI_SS DRIVE [4..5]  ========================================== */
typedef enum {                                  /*!< PADS_QSPI_GPIO_QSPI_SS_DRIVE                                              */
  PADS_QSPI_GPIO_QSPI_SS_DRIVE_2mA     = 0,     /*!< 2mA : 2mA                                                                 */
  PADS_QSPI_GPIO_QSPI_SS_DRIVE_4mA     = 1,     /*!< 4mA : 4mA                                                                 */
  PADS_QSPI_GPIO_QSPI_SS_DRIVE_8mA     = 2,     /*!< 8mA : 8mA                                                                 */
  PADS_QSPI_GPIO_QSPI_SS_DRIVE_12mA    = 3,     /*!< 12mA : 12mA                                                               */
} PADS_QSPI_GPIO_QSPI_SS_DRIVE_Enum;



/* =========================================================================================================================== */
/* ================                                           XOSC                                            ================ */
/* =========================================================================================================================== */

/* =========================================================  CTRL  ========================================================== */
/* ===============================================  XOSC CTRL ENABLE [12..23]  =============================================== */
typedef enum {                                  /*!< XOSC_CTRL_ENABLE                                                          */
  XOSC_CTRL_ENABLE_DISABLE             = 3358,  /*!< DISABLE : DISABLE                                                         */
  XOSC_CTRL_ENABLE_ENABLE              = 4011,  /*!< ENABLE : ENABLE                                                           */
} XOSC_CTRL_ENABLE_Enum;

/* =============================================  XOSC CTRL FREQ_RANGE [0..11]  ============================================== */
typedef enum {                                  /*!< XOSC_CTRL_FREQ_RANGE                                                      */
  XOSC_CTRL_FREQ_RANGE_1_15MHZ         = 2720,  /*!< 1_15MHZ : 1_15MHZ                                                         */
  XOSC_CTRL_FREQ_RANGE_RESERVED_1      = 2721,  /*!< RESERVED_1 : RESERVED_1                                                   */
  XOSC_CTRL_FREQ_RANGE_RESERVED_2      = 2722,  /*!< RESERVED_2 : RESERVED_2                                                   */
  XOSC_CTRL_FREQ_RANGE_RESERVED_3      = 2723,  /*!< RESERVED_3 : RESERVED_3                                                   */
} XOSC_CTRL_FREQ_RANGE_Enum;

/* ========================================================  STATUS  ========================================================= */
/* =============================================  XOSC STATUS FREQ_RANGE [0..1]  ============================================= */
typedef enum {                                  /*!< XOSC_STATUS_FREQ_RANGE                                                    */
  XOSC_STATUS_FREQ_RANGE_1_15MHZ       = 0,     /*!< 1_15MHZ : 1_15MHZ                                                         */
  XOSC_STATUS_FREQ_RANGE_RESERVED_1    = 1,     /*!< RESERVED_1 : RESERVED_1                                                   */
  XOSC_STATUS_FREQ_RANGE_RESERVED_2    = 2,     /*!< RESERVED_2 : RESERVED_2                                                   */
  XOSC_STATUS_FREQ_RANGE_RESERVED_3    = 3,     /*!< RESERVED_3 : RESERVED_3                                                   */
} XOSC_STATUS_FREQ_RANGE_Enum;

/* ========================================================  DORMANT  ======================================================== */
/* ========================================================  STARTUP  ======================================================== */
/* =========================================================  COUNT  ========================================================= */


/* =========================================================================================================================== */
/* ================                                          PLL_SYS                                          ================ */
/* =========================================================================================================================== */

/* ==========================================================  CS  =========================================================== */
/* ==========================================================  PWR  ========================================================== */
/* =======================================================  FBDIV_INT  ======================================================= */
/* =========================================================  PRIM  ========================================================== */


/* =========================================================================================================================== */
/* ================                                          BUSCTRL                                          ================ */
/* =========================================================================================================================== */

/* =====================================================  BUS_PRIORITY  ====================================================== */
/* ===================================================  BUS_PRIORITY_ACK  ==================================================== */
/* =======================================================  PERFCTR0  ======================================================== */
/* =======================================================  PERFSEL0  ======================================================== */
/* =======================================================  PERFCTR1  ======================================================== */
/* =======================================================  PERFSEL1  ======================================================== */
/* =======================================================  PERFCTR2  ======================================================== */
/* =======================================================  PERFSEL2  ======================================================== */
/* =======================================================  PERFCTR3  ======================================================== */
/* =======================================================  PERFSEL3  ======================================================== */


/* =========================================================================================================================== */
/* ================                                           UART0                                           ================ */
/* =========================================================================================================================== */

/* ========================================================  UARTDR  ========================================================= */
/* ========================================================  UARTRSR  ======================================================== */
/* ========================================================  UARTFR  ========================================================= */
/* =======================================================  UARTILPR  ======================================================== */
/* =======================================================  UARTIBRD  ======================================================== */
/* =======================================================  UARTFBRD  ======================================================== */
/* =======================================================  UARTLCR_H  ======================================================= */
/* ========================================================  UARTCR  ========================================================= */
/* =======================================================  UARTIFLS  ======================================================== */
/* =======================================================  UARTIMSC  ======================================================== */
/* ========================================================  UARTRIS  ======================================================== */
/* ========================================================  UARTMIS  ======================================================== */
/* ========================================================  UARTICR  ======================================================== */
/* =======================================================  UARTDMACR  ======================================================= */
/* =====================================================  UARTPERIPHID0  ===================================================== */
/* =====================================================  UARTPERIPHID1  ===================================================== */
/* =====================================================  UARTPERIPHID2  ===================================================== */
/* =====================================================  UARTPERIPHID3  ===================================================== */
/* =====================================================  UARTPCELLID0  ====================================================== */
/* =====================================================  UARTPCELLID1  ====================================================== */
/* =====================================================  UARTPCELLID2  ====================================================== */
/* =====================================================  UARTPCELLID3  ====================================================== */


/* =========================================================================================================================== */
/* ================                                           SPI0                                            ================ */
/* =========================================================================================================================== */

/* ========================================================  SSPCR0  ========================================================= */
/* ========================================================  SSPCR1  ========================================================= */
/* =========================================================  SSPDR  ========================================================= */
/* =========================================================  SSPSR  ========================================================= */
/* ========================================================  SSPCPSR  ======================================================== */
/* ========================================================  SSPIMSC  ======================================================== */
/* ========================================================  SSPRIS  ========================================================= */
/* ========================================================  SSPMIS  ========================================================= */
/* ========================================================  SSPICR  ========================================================= */
/* =======================================================  SSPDMACR  ======================================================== */
/* =====================================================  SSPPERIPHID0  ====================================================== */
/* =====================================================  SSPPERIPHID1  ====================================================== */
/* =====================================================  SSPPERIPHID2  ====================================================== */
/* =====================================================  SSPPERIPHID3  ====================================================== */
/* ======================================================  SSPPCELLID0  ====================================================== */
/* ======================================================  SSPPCELLID1  ====================================================== */
/* ======================================================  SSPPCELLID2  ====================================================== */
/* ======================================================  SSPPCELLID3  ====================================================== */


/* =========================================================================================================================== */
/* ================                                           I2C0                                            ================ */
/* =========================================================================================================================== */

/* ========================================================  IC_CON  ========================================================= */
/* =======================================  I2C0 IC_CON RX_FIFO_FULL_HLD_CTRL [9..9]  ======================================== */
typedef enum {                                  /*!< I2C0_IC_CON_RX_FIFO_FULL_HLD_CTRL                                         */
  I2C0_IC_CON_RX_FIFO_FULL_HLD_CTRL_DISABLED = 0,/*!< DISABLED : Overflow when RX_FIFO is full                                 */
  I2C0_IC_CON_RX_FIFO_FULL_HLD_CTRL_ENABLED = 1,/*!< ENABLED : Hold bus when RX_FIFO is full                                   */
} I2C0_IC_CON_RX_FIFO_FULL_HLD_CTRL_Enum;

/* ===========================================  I2C0 IC_CON TX_EMPTY_CTRL [8..8]  ============================================ */
typedef enum {                                  /*!< I2C0_IC_CON_TX_EMPTY_CTRL                                                 */
  I2C0_IC_CON_TX_EMPTY_CTRL_DISABLED   = 0,     /*!< DISABLED : Default behaviour of TX_EMPTY interrupt                        */
  I2C0_IC_CON_TX_EMPTY_CTRL_ENABLED    = 1,     /*!< ENABLED : Controlled generation of TX_EMPTY interrupt                     */
} I2C0_IC_CON_TX_EMPTY_CTRL_Enum;

/* ========================================  I2C0 IC_CON STOP_DET_IFADDRESSED [7..7]  ======================================== */
typedef enum {                                  /*!< I2C0_IC_CON_STOP_DET_IFADDRESSED                                          */
  I2C0_IC_CON_STOP_DET_IFADDRESSED_DISABLED = 0,/*!< DISABLED : slave issues STOP_DET intr always                              */
  I2C0_IC_CON_STOP_DET_IFADDRESSED_ENABLED = 1, /*!< ENABLED : slave issues STOP_DET intr only if addressed                    */
} I2C0_IC_CON_STOP_DET_IFADDRESSED_Enum;

/* ==========================================  I2C0 IC_CON IC_SLAVE_DISABLE [6..6]  ========================================== */
typedef enum {                                  /*!< I2C0_IC_CON_IC_SLAVE_DISABLE                                              */
  I2C0_IC_CON_IC_SLAVE_DISABLE_SLAVE_ENABLED = 0,/*!< SLAVE_ENABLED : Slave mode is enabled                                    */
  I2C0_IC_CON_IC_SLAVE_DISABLE_SLAVE_DISABLED = 1,/*!< SLAVE_DISABLED : Slave mode is disabled                                 */
} I2C0_IC_CON_IC_SLAVE_DISABLE_Enum;

/* ===========================================  I2C0 IC_CON IC_RESTART_EN [5..5]  ============================================ */
typedef enum {                                  /*!< I2C0_IC_CON_IC_RESTART_EN                                                 */
  I2C0_IC_CON_IC_RESTART_EN_DISABLED   = 0,     /*!< DISABLED : Master restart disabled                                        */
  I2C0_IC_CON_IC_RESTART_EN_ENABLED    = 1,     /*!< ENABLED : Master restart enabled                                          */
} I2C0_IC_CON_IC_RESTART_EN_Enum;

/* ========================================  I2C0 IC_CON IC_10BITADDR_MASTER [4..4]  ========================================= */
typedef enum {                                  /*!< I2C0_IC_CON_IC_10BITADDR_MASTER                                           */
  I2C0_IC_CON_IC_10BITADDR_MASTER_ADDR_7BITS = 0,/*!< ADDR_7BITS : Master 7Bit addressing mode                                 */
  I2C0_IC_CON_IC_10BITADDR_MASTER_ADDR_10BITS = 1,/*!< ADDR_10BITS : Master 10Bit addressing mode                              */
} I2C0_IC_CON_IC_10BITADDR_MASTER_Enum;

/* =========================================  I2C0 IC_CON IC_10BITADDR_SLAVE [3..3]  ========================================= */
typedef enum {                                  /*!< I2C0_IC_CON_IC_10BITADDR_SLAVE                                            */
  I2C0_IC_CON_IC_10BITADDR_SLAVE_ADDR_7BITS = 0,/*!< ADDR_7BITS : Slave 7Bit addressing                                        */
  I2C0_IC_CON_IC_10BITADDR_SLAVE_ADDR_10BITS = 1,/*!< ADDR_10BITS : Slave 10Bit addressing                                     */
} I2C0_IC_CON_IC_10BITADDR_SLAVE_Enum;

/* ===============================================  I2C0 IC_CON SPEED [1..2]  ================================================ */
typedef enum {                                  /*!< I2C0_IC_CON_SPEED                                                         */
  I2C0_IC_CON_SPEED_STANDARD           = 1,     /*!< STANDARD : Standard Speed mode of operation                               */
  I2C0_IC_CON_SPEED_FAST               = 2,     /*!< FAST : Fast or Fast Plus mode of operation                                */
  I2C0_IC_CON_SPEED_HIGH               = 3,     /*!< HIGH : High Speed mode of operation                                       */
} I2C0_IC_CON_SPEED_Enum;

/* ============================================  I2C0 IC_CON MASTER_MODE [0..0]  ============================================= */
typedef enum {                                  /*!< I2C0_IC_CON_MASTER_MODE                                                   */
  I2C0_IC_CON_MASTER_MODE_DISABLED     = 0,     /*!< DISABLED : Master mode is disabled                                        */
  I2C0_IC_CON_MASTER_MODE_ENABLED      = 1,     /*!< ENABLED : Master mode is enabled                                          */
} I2C0_IC_CON_MASTER_MODE_Enum;

/* ========================================================  IC_TAR  ========================================================= */
/* =============================================  I2C0 IC_TAR SPECIAL [11..11]  ============================================== */
typedef enum {                                  /*!< I2C0_IC_TAR_SPECIAL                                                       */
  I2C0_IC_TAR_SPECIAL_DISABLED         = 0,     /*!< DISABLED : Disables programming of GENERAL_CALL or START_BYTE
                                                     transmission                                                              */
  I2C0_IC_TAR_SPECIAL_ENABLED          = 1,     /*!< ENABLED : Enables programming of GENERAL_CALL or START_BYTE
                                                     transmission                                                              */
} I2C0_IC_TAR_SPECIAL_Enum;

/* ===========================================  I2C0 IC_TAR GC_OR_START [10..10]  ============================================ */
typedef enum {                                  /*!< I2C0_IC_TAR_GC_OR_START                                                   */
  I2C0_IC_TAR_GC_OR_START_GENERAL_CALL = 0,     /*!< GENERAL_CALL : GENERAL_CALL byte transmission                             */
  I2C0_IC_TAR_GC_OR_START_START_BYTE   = 1,     /*!< START_BYTE : START byte transmission                                      */
} I2C0_IC_TAR_GC_OR_START_Enum;

/* ========================================================  IC_SAR  ========================================================= */
/* ======================================================  IC_DATA_CMD  ====================================================== */
/* =======================================  I2C0 IC_DATA_CMD FIRST_DATA_BYTE [11..11]  ======================================= */
typedef enum {                                  /*!< I2C0_IC_DATA_CMD_FIRST_DATA_BYTE                                          */
  I2C0_IC_DATA_CMD_FIRST_DATA_BYTE_INACTIVE = 0,/*!< INACTIVE : Sequential data byte received                                  */
  I2C0_IC_DATA_CMD_FIRST_DATA_BYTE_ACTIVE = 1,  /*!< ACTIVE : Non sequential data byte received                                */
} I2C0_IC_DATA_CMD_FIRST_DATA_BYTE_Enum;

/* ===========================================  I2C0 IC_DATA_CMD RESTART [10..10]  =========================================== */
typedef enum {                                  /*!< I2C0_IC_DATA_CMD_RESTART                                                  */
  I2C0_IC_DATA_CMD_RESTART_DISABLE     = 0,     /*!< DISABLE : Don't Issue RESTART before this command                         */
  I2C0_IC_DATA_CMD_RESTART_ENABLE      = 1,     /*!< ENABLE : Issue RESTART before this command                                */
} I2C0_IC_DATA_CMD_RESTART_Enum;

/* =============================================  I2C0 IC_DATA_CMD STOP [9..9]  ============================================== */
typedef enum {                                  /*!< I2C0_IC_DATA_CMD_STOP                                                     */
  I2C0_IC_DATA_CMD_STOP_DISABLE        = 0,     /*!< DISABLE : Don't Issue STOP after this command                             */
  I2C0_IC_DATA_CMD_STOP_ENABLE         = 1,     /*!< ENABLE : Issue STOP after this command                                    */
} I2C0_IC_DATA_CMD_STOP_Enum;

/* ==============================================  I2C0 IC_DATA_CMD CMD [8..8]  ============================================== */
typedef enum {                                  /*!< I2C0_IC_DATA_CMD_CMD                                                      */
  I2C0_IC_DATA_CMD_CMD_WRITE           = 0,     /*!< WRITE : Master Write Command                                              */
  I2C0_IC_DATA_CMD_CMD_READ            = 1,     /*!< READ : Master Read Command                                                */
} I2C0_IC_DATA_CMD_CMD_Enum;

/* ====================================================  IC_SS_SCL_HCNT  ===================================================== */
/* ====================================================  IC_SS_SCL_LCNT  ===================================================== */
/* ====================================================  IC_FS_SCL_HCNT  ===================================================== */
/* ====================================================  IC_FS_SCL_LCNT  ===================================================== */
/* =====================================================  IC_INTR_STAT  ====================================================== */
/* ======================================  I2C0 IC_INTR_STAT R_MASTER_ON_HOLD [13..13]  ====================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_STAT_R_MASTER_ON_HOLD                                        */
  I2C0_IC_INTR_STAT_R_MASTER_ON_HOLD_INACTIVE = 0,/*!< INACTIVE : R_MASTER_ON_HOLD interrupt is inactive                       */
  I2C0_IC_INTR_STAT_R_MASTER_ON_HOLD_ACTIVE = 1,/*!< ACTIVE : R_MASTER_ON_HOLD interrupt is active                             */
} I2C0_IC_INTR_STAT_R_MASTER_ON_HOLD_Enum;

/* =======================================  I2C0 IC_INTR_STAT R_RESTART_DET [12..12]  ======================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_STAT_R_RESTART_DET                                           */
  I2C0_IC_INTR_STAT_R_RESTART_DET_INACTIVE = 0, /*!< INACTIVE : R_RESTART_DET interrupt is inactive                            */
  I2C0_IC_INTR_STAT_R_RESTART_DET_ACTIVE = 1,   /*!< ACTIVE : R_RESTART_DET interrupt is active                                */
} I2C0_IC_INTR_STAT_R_RESTART_DET_Enum;

/* =========================================  I2C0 IC_INTR_STAT R_GEN_CALL [11..11]  ========================================= */
typedef enum {                                  /*!< I2C0_IC_INTR_STAT_R_GEN_CALL                                              */
  I2C0_IC_INTR_STAT_R_GEN_CALL_INACTIVE = 0,    /*!< INACTIVE : R_GEN_CALL interrupt is inactive                               */
  I2C0_IC_INTR_STAT_R_GEN_CALL_ACTIVE  = 1,     /*!< ACTIVE : R_GEN_CALL interrupt is active                                   */
} I2C0_IC_INTR_STAT_R_GEN_CALL_Enum;

/* ========================================  I2C0 IC_INTR_STAT R_START_DET [10..10]  ========================================= */
typedef enum {                                  /*!< I2C0_IC_INTR_STAT_R_START_DET                                             */
  I2C0_IC_INTR_STAT_R_START_DET_INACTIVE = 0,   /*!< INACTIVE : R_START_DET interrupt is inactive                              */
  I2C0_IC_INTR_STAT_R_START_DET_ACTIVE = 1,     /*!< ACTIVE : R_START_DET interrupt is active                                  */
} I2C0_IC_INTR_STAT_R_START_DET_Enum;

/* ==========================================  I2C0 IC_INTR_STAT R_STOP_DET [9..9]  ========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_STAT_R_STOP_DET                                              */
  I2C0_IC_INTR_STAT_R_STOP_DET_INACTIVE = 0,    /*!< INACTIVE : R_STOP_DET interrupt is inactive                               */
  I2C0_IC_INTR_STAT_R_STOP_DET_ACTIVE  = 1,     /*!< ACTIVE : R_STOP_DET interrupt is active                                   */
} I2C0_IC_INTR_STAT_R_STOP_DET_Enum;

/* ==========================================  I2C0 IC_INTR_STAT R_ACTIVITY [8..8]  ========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_STAT_R_ACTIVITY                                              */
  I2C0_IC_INTR_STAT_R_ACTIVITY_INACTIVE = 0,    /*!< INACTIVE : R_ACTIVITY interrupt is inactive                               */
  I2C0_IC_INTR_STAT_R_ACTIVITY_ACTIVE  = 1,     /*!< ACTIVE : R_ACTIVITY interrupt is active                                   */
} I2C0_IC_INTR_STAT_R_ACTIVITY_Enum;

/* ==========================================  I2C0 IC_INTR_STAT R_RX_DONE [7..7]  =========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_STAT_R_RX_DONE                                               */
  I2C0_IC_INTR_STAT_R_RX_DONE_INACTIVE = 0,     /*!< INACTIVE : R_RX_DONE interrupt is inactive                                */
  I2C0_IC_INTR_STAT_R_RX_DONE_ACTIVE   = 1,     /*!< ACTIVE : R_RX_DONE interrupt is active                                    */
} I2C0_IC_INTR_STAT_R_RX_DONE_Enum;

/* ==========================================  I2C0 IC_INTR_STAT R_TX_ABRT [6..6]  =========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_STAT_R_TX_ABRT                                               */
  I2C0_IC_INTR_STAT_R_TX_ABRT_INACTIVE = 0,     /*!< INACTIVE : R_TX_ABRT interrupt is inactive                                */
  I2C0_IC_INTR_STAT_R_TX_ABRT_ACTIVE   = 1,     /*!< ACTIVE : R_TX_ABRT interrupt is active                                    */
} I2C0_IC_INTR_STAT_R_TX_ABRT_Enum;

/* ===========================================  I2C0 IC_INTR_STAT R_RD_REQ [5..5]  =========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_STAT_R_RD_REQ                                                */
  I2C0_IC_INTR_STAT_R_RD_REQ_INACTIVE  = 0,     /*!< INACTIVE : R_RD_REQ interrupt is inactive                                 */
  I2C0_IC_INTR_STAT_R_RD_REQ_ACTIVE    = 1,     /*!< ACTIVE : R_RD_REQ interrupt is active                                     */
} I2C0_IC_INTR_STAT_R_RD_REQ_Enum;

/* ==========================================  I2C0 IC_INTR_STAT R_TX_EMPTY [4..4]  ========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_STAT_R_TX_EMPTY                                              */
  I2C0_IC_INTR_STAT_R_TX_EMPTY_INACTIVE = 0,    /*!< INACTIVE : R_TX_EMPTY interrupt is inactive                               */
  I2C0_IC_INTR_STAT_R_TX_EMPTY_ACTIVE  = 1,     /*!< ACTIVE : R_TX_EMPTY interrupt is active                                   */
} I2C0_IC_INTR_STAT_R_TX_EMPTY_Enum;

/* ==========================================  I2C0 IC_INTR_STAT R_TX_OVER [3..3]  =========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_STAT_R_TX_OVER                                               */
  I2C0_IC_INTR_STAT_R_TX_OVER_INACTIVE = 0,     /*!< INACTIVE : R_TX_OVER interrupt is inactive                                */
  I2C0_IC_INTR_STAT_R_TX_OVER_ACTIVE   = 1,     /*!< ACTIVE : R_TX_OVER interrupt is active                                    */
} I2C0_IC_INTR_STAT_R_TX_OVER_Enum;

/* ==========================================  I2C0 IC_INTR_STAT R_RX_FULL [2..2]  =========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_STAT_R_RX_FULL                                               */
  I2C0_IC_INTR_STAT_R_RX_FULL_INACTIVE = 0,     /*!< INACTIVE : R_RX_FULL interrupt is inactive                                */
  I2C0_IC_INTR_STAT_R_RX_FULL_ACTIVE   = 1,     /*!< ACTIVE : R_RX_FULL interrupt is active                                    */
} I2C0_IC_INTR_STAT_R_RX_FULL_Enum;

/* ==========================================  I2C0 IC_INTR_STAT R_RX_OVER [1..1]  =========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_STAT_R_RX_OVER                                               */
  I2C0_IC_INTR_STAT_R_RX_OVER_INACTIVE = 0,     /*!< INACTIVE : R_RX_OVER interrupt is inactive                                */
  I2C0_IC_INTR_STAT_R_RX_OVER_ACTIVE   = 1,     /*!< ACTIVE : R_RX_OVER interrupt is active                                    */
} I2C0_IC_INTR_STAT_R_RX_OVER_Enum;

/* ==========================================  I2C0 IC_INTR_STAT R_RX_UNDER [0..0]  ========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_STAT_R_RX_UNDER                                              */
  I2C0_IC_INTR_STAT_R_RX_UNDER_INACTIVE = 0,    /*!< INACTIVE : RX_UNDER interrupt is inactive                                 */
  I2C0_IC_INTR_STAT_R_RX_UNDER_ACTIVE  = 1,     /*!< ACTIVE : RX_UNDER interrupt is active                                     */
} I2C0_IC_INTR_STAT_R_RX_UNDER_Enum;

/* =====================================================  IC_INTR_MASK  ====================================================== */
/* =================================  I2C0 IC_INTR_MASK M_MASTER_ON_HOLD_READ_ONLY [13..13]  ================================= */
typedef enum {                                  /*!< I2C0_IC_INTR_MASK_M_MASTER_ON_HOLD_READ_ONLY                              */
  I2C0_IC_INTR_MASK_M_MASTER_ON_HOLD_READ_ONLY_ENABLED = 0,/*!< ENABLED : MASTER_ON_HOLD interrupt is masked                   */
  I2C0_IC_INTR_MASK_M_MASTER_ON_HOLD_READ_ONLY_DISABLED = 1,/*!< DISABLED : MASTER_ON_HOLD interrupt is unmasked               */
} I2C0_IC_INTR_MASK_M_MASTER_ON_HOLD_READ_ONLY_Enum;

/* =======================================  I2C0 IC_INTR_MASK M_RESTART_DET [12..12]  ======================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_MASK_M_RESTART_DET                                           */
  I2C0_IC_INTR_MASK_M_RESTART_DET_ENABLED = 0,  /*!< ENABLED : RESTART_DET interrupt is masked                                 */
  I2C0_IC_INTR_MASK_M_RESTART_DET_DISABLED = 1, /*!< DISABLED : RESTART_DET interrupt is unmasked                              */
} I2C0_IC_INTR_MASK_M_RESTART_DET_Enum;

/* =========================================  I2C0 IC_INTR_MASK M_GEN_CALL [11..11]  ========================================= */
typedef enum {                                  /*!< I2C0_IC_INTR_MASK_M_GEN_CALL                                              */
  I2C0_IC_INTR_MASK_M_GEN_CALL_ENABLED = 0,     /*!< ENABLED : GEN_CALL interrupt is masked                                    */
  I2C0_IC_INTR_MASK_M_GEN_CALL_DISABLED = 1,    /*!< DISABLED : GEN_CALL interrupt is unmasked                                 */
} I2C0_IC_INTR_MASK_M_GEN_CALL_Enum;

/* ========================================  I2C0 IC_INTR_MASK M_START_DET [10..10]  ========================================= */
typedef enum {                                  /*!< I2C0_IC_INTR_MASK_M_START_DET                                             */
  I2C0_IC_INTR_MASK_M_START_DET_ENABLED = 0,    /*!< ENABLED : START_DET interrupt is masked                                   */
  I2C0_IC_INTR_MASK_M_START_DET_DISABLED = 1,   /*!< DISABLED : START_DET interrupt is unmasked                                */
} I2C0_IC_INTR_MASK_M_START_DET_Enum;

/* ==========================================  I2C0 IC_INTR_MASK M_STOP_DET [9..9]  ========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_MASK_M_STOP_DET                                              */
  I2C0_IC_INTR_MASK_M_STOP_DET_ENABLED = 0,     /*!< ENABLED : STOP_DET interrupt is masked                                    */
  I2C0_IC_INTR_MASK_M_STOP_DET_DISABLED = 1,    /*!< DISABLED : STOP_DET interrupt is unmasked                                 */
} I2C0_IC_INTR_MASK_M_STOP_DET_Enum;

/* ==========================================  I2C0 IC_INTR_MASK M_ACTIVITY [8..8]  ========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_MASK_M_ACTIVITY                                              */
  I2C0_IC_INTR_MASK_M_ACTIVITY_ENABLED = 0,     /*!< ENABLED : ACTIVITY interrupt is masked                                    */
  I2C0_IC_INTR_MASK_M_ACTIVITY_DISABLED = 1,    /*!< DISABLED : ACTIVITY interrupt is unmasked                                 */
} I2C0_IC_INTR_MASK_M_ACTIVITY_Enum;

/* ==========================================  I2C0 IC_INTR_MASK M_RX_DONE [7..7]  =========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_MASK_M_RX_DONE                                               */
  I2C0_IC_INTR_MASK_M_RX_DONE_ENABLED  = 0,     /*!< ENABLED : RX_DONE interrupt is masked                                     */
  I2C0_IC_INTR_MASK_M_RX_DONE_DISABLED = 1,     /*!< DISABLED : RX_DONE interrupt is unmasked                                  */
} I2C0_IC_INTR_MASK_M_RX_DONE_Enum;

/* ==========================================  I2C0 IC_INTR_MASK M_TX_ABRT [6..6]  =========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_MASK_M_TX_ABRT                                               */
  I2C0_IC_INTR_MASK_M_TX_ABRT_ENABLED  = 0,     /*!< ENABLED : TX_ABORT interrupt is masked                                    */
  I2C0_IC_INTR_MASK_M_TX_ABRT_DISABLED = 1,     /*!< DISABLED : TX_ABORT interrupt is unmasked                                 */
} I2C0_IC_INTR_MASK_M_TX_ABRT_Enum;

/* ===========================================  I2C0 IC_INTR_MASK M_RD_REQ [5..5]  =========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_MASK_M_RD_REQ                                                */
  I2C0_IC_INTR_MASK_M_RD_REQ_ENABLED   = 0,     /*!< ENABLED : RD_REQ interrupt is masked                                      */
  I2C0_IC_INTR_MASK_M_RD_REQ_DISABLED  = 1,     /*!< DISABLED : RD_REQ interrupt is unmasked                                   */
} I2C0_IC_INTR_MASK_M_RD_REQ_Enum;

/* ==========================================  I2C0 IC_INTR_MASK M_TX_EMPTY [4..4]  ========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_MASK_M_TX_EMPTY                                              */
  I2C0_IC_INTR_MASK_M_TX_EMPTY_ENABLED = 0,     /*!< ENABLED : TX_EMPTY interrupt is masked                                    */
  I2C0_IC_INTR_MASK_M_TX_EMPTY_DISABLED = 1,    /*!< DISABLED : TX_EMPTY interrupt is unmasked                                 */
} I2C0_IC_INTR_MASK_M_TX_EMPTY_Enum;

/* ==========================================  I2C0 IC_INTR_MASK M_TX_OVER [3..3]  =========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_MASK_M_TX_OVER                                               */
  I2C0_IC_INTR_MASK_M_TX_OVER_ENABLED  = 0,     /*!< ENABLED : TX_OVER interrupt is masked                                     */
  I2C0_IC_INTR_MASK_M_TX_OVER_DISABLED = 1,     /*!< DISABLED : TX_OVER interrupt is unmasked                                  */
} I2C0_IC_INTR_MASK_M_TX_OVER_Enum;

/* ==========================================  I2C0 IC_INTR_MASK M_RX_FULL [2..2]  =========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_MASK_M_RX_FULL                                               */
  I2C0_IC_INTR_MASK_M_RX_FULL_ENABLED  = 0,     /*!< ENABLED : RX_FULL interrupt is masked                                     */
  I2C0_IC_INTR_MASK_M_RX_FULL_DISABLED = 1,     /*!< DISABLED : RX_FULL interrupt is unmasked                                  */
} I2C0_IC_INTR_MASK_M_RX_FULL_Enum;

/* ==========================================  I2C0 IC_INTR_MASK M_RX_OVER [1..1]  =========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_MASK_M_RX_OVER                                               */
  I2C0_IC_INTR_MASK_M_RX_OVER_ENABLED  = 0,     /*!< ENABLED : RX_OVER interrupt is masked                                     */
  I2C0_IC_INTR_MASK_M_RX_OVER_DISABLED = 1,     /*!< DISABLED : RX_OVER interrupt is unmasked                                  */
} I2C0_IC_INTR_MASK_M_RX_OVER_Enum;

/* ==========================================  I2C0 IC_INTR_MASK M_RX_UNDER [0..0]  ========================================== */
typedef enum {                                  /*!< I2C0_IC_INTR_MASK_M_RX_UNDER                                              */
  I2C0_IC_INTR_MASK_M_RX_UNDER_ENABLED = 0,     /*!< ENABLED : RX_UNDER interrupt is masked                                    */
  I2C0_IC_INTR_MASK_M_RX_UNDER_DISABLED = 1,    /*!< DISABLED : RX_UNDER interrupt is unmasked                                 */
} I2C0_IC_INTR_MASK_M_RX_UNDER_Enum;

/* ===================================================  IC_RAW_INTR_STAT  ==================================================== */
/* =====================================  I2C0 IC_RAW_INTR_STAT MASTER_ON_HOLD [13..13]  ===================================== */
typedef enum {                                  /*!< I2C0_IC_RAW_INTR_STAT_MASTER_ON_HOLD                                      */
  I2C0_IC_RAW_INTR_STAT_MASTER_ON_HOLD_INACTIVE = 0,/*!< INACTIVE : MASTER_ON_HOLD interrupt is inactive                       */
  I2C0_IC_RAW_INTR_STAT_MASTER_ON_HOLD_ACTIVE = 1,/*!< ACTIVE : MASTER_ON_HOLD interrupt is active                             */
} I2C0_IC_RAW_INTR_STAT_MASTER_ON_HOLD_Enum;

/* ======================================  I2C0 IC_RAW_INTR_STAT RESTART_DET [12..12]  ======================================= */
typedef enum {                                  /*!< I2C0_IC_RAW_INTR_STAT_RESTART_DET                                         */
  I2C0_IC_RAW_INTR_STAT_RESTART_DET_INACTIVE = 0,/*!< INACTIVE : RESTART_DET interrupt is inactive                             */
  I2C0_IC_RAW_INTR_STAT_RESTART_DET_ACTIVE = 1, /*!< ACTIVE : RESTART_DET interrupt is active                                  */
} I2C0_IC_RAW_INTR_STAT_RESTART_DET_Enum;

/* ========================================  I2C0 IC_RAW_INTR_STAT GEN_CALL [11..11]  ======================================== */
typedef enum {                                  /*!< I2C0_IC_RAW_INTR_STAT_GEN_CALL                                            */
  I2C0_IC_RAW_INTR_STAT_GEN_CALL_INACTIVE = 0,  /*!< INACTIVE : GEN_CALL interrupt is inactive                                 */
  I2C0_IC_RAW_INTR_STAT_GEN_CALL_ACTIVE = 1,    /*!< ACTIVE : GEN_CALL interrupt is active                                     */
} I2C0_IC_RAW_INTR_STAT_GEN_CALL_Enum;

/* =======================================  I2C0 IC_RAW_INTR_STAT START_DET [10..10]  ======================================== */
typedef enum {                                  /*!< I2C0_IC_RAW_INTR_STAT_START_DET                                           */
  I2C0_IC_RAW_INTR_STAT_START_DET_INACTIVE = 0, /*!< INACTIVE : START_DET interrupt is inactive                                */
  I2C0_IC_RAW_INTR_STAT_START_DET_ACTIVE = 1,   /*!< ACTIVE : START_DET interrupt is active                                    */
} I2C0_IC_RAW_INTR_STAT_START_DET_Enum;

/* =========================================  I2C0 IC_RAW_INTR_STAT STOP_DET [9..9]  ========================================= */
typedef enum {                                  /*!< I2C0_IC_RAW_INTR_STAT_STOP_DET                                            */
  I2C0_IC_RAW_INTR_STAT_STOP_DET_INACTIVE = 0,  /*!< INACTIVE : STOP_DET interrupt is inactive                                 */
  I2C0_IC_RAW_INTR_STAT_STOP_DET_ACTIVE = 1,    /*!< ACTIVE : STOP_DET interrupt is active                                     */
} I2C0_IC_RAW_INTR_STAT_STOP_DET_Enum;

/* =========================================  I2C0 IC_RAW_INTR_STAT ACTIVITY [8..8]  ========================================= */
typedef enum {                                  /*!< I2C0_IC_RAW_INTR_STAT_ACTIVITY                                            */
  I2C0_IC_RAW_INTR_STAT_ACTIVITY_INACTIVE = 0,  /*!< INACTIVE : RAW_INTR_ACTIVITY interrupt is inactive                        */
  I2C0_IC_RAW_INTR_STAT_ACTIVITY_ACTIVE = 1,    /*!< ACTIVE : RAW_INTR_ACTIVITY interrupt is active                            */
} I2C0_IC_RAW_INTR_STAT_ACTIVITY_Enum;

/* =========================================  I2C0 IC_RAW_INTR_STAT RX_DONE [7..7]  ========================================== */
typedef enum {                                  /*!< I2C0_IC_RAW_INTR_STAT_RX_DONE                                             */
  I2C0_IC_RAW_INTR_STAT_RX_DONE_INACTIVE = 0,   /*!< INACTIVE : RX_DONE interrupt is inactive                                  */
  I2C0_IC_RAW_INTR_STAT_RX_DONE_ACTIVE = 1,     /*!< ACTIVE : RX_DONE interrupt is active                                      */
} I2C0_IC_RAW_INTR_STAT_RX_DONE_Enum;

/* =========================================  I2C0 IC_RAW_INTR_STAT TX_ABRT [6..6]  ========================================== */
typedef enum {                                  /*!< I2C0_IC_RAW_INTR_STAT_TX_ABRT                                             */
  I2C0_IC_RAW_INTR_STAT_TX_ABRT_INACTIVE = 0,   /*!< INACTIVE : TX_ABRT interrupt is inactive                                  */
  I2C0_IC_RAW_INTR_STAT_TX_ABRT_ACTIVE = 1,     /*!< ACTIVE : TX_ABRT interrupt is active                                      */
} I2C0_IC_RAW_INTR_STAT_TX_ABRT_Enum;

/* ==========================================  I2C0 IC_RAW_INTR_STAT RD_REQ [5..5]  ========================================== */
typedef enum {                                  /*!< I2C0_IC_RAW_INTR_STAT_RD_REQ                                              */
  I2C0_IC_RAW_INTR_STAT_RD_REQ_INACTIVE = 0,    /*!< INACTIVE : RD_REQ interrupt is inactive                                   */
  I2C0_IC_RAW_INTR_STAT_RD_REQ_ACTIVE  = 1,     /*!< ACTIVE : RD_REQ interrupt is active                                       */
} I2C0_IC_RAW_INTR_STAT_RD_REQ_Enum;

/* =========================================  I2C0 IC_RAW_INTR_STAT TX_EMPTY [4..4]  ========================================= */
typedef enum {                                  /*!< I2C0_IC_RAW_INTR_STAT_TX_EMPTY                                            */
  I2C0_IC_RAW_INTR_STAT_TX_EMPTY_INACTIVE = 0,  /*!< INACTIVE : TX_EMPTY interrupt is inactive                                 */
  I2C0_IC_RAW_INTR_STAT_TX_EMPTY_ACTIVE = 1,    /*!< ACTIVE : TX_EMPTY interrupt is active                                     */
} I2C0_IC_RAW_INTR_STAT_TX_EMPTY_Enum;

/* =========================================  I2C0 IC_RAW_INTR_STAT TX_OVER [3..3]  ========================================== */
typedef enum {                                  /*!< I2C0_IC_RAW_INTR_STAT_TX_OVER                                             */
  I2C0_IC_RAW_INTR_STAT_TX_OVER_INACTIVE = 0,   /*!< INACTIVE : TX_OVER interrupt is inactive                                  */
  I2C0_IC_RAW_INTR_STAT_TX_OVER_ACTIVE = 1,     /*!< ACTIVE : TX_OVER interrupt is active                                      */
} I2C0_IC_RAW_INTR_STAT_TX_OVER_Enum;

/* =========================================  I2C0 IC_RAW_INTR_STAT RX_FULL [2..2]  ========================================== */
typedef enum {                                  /*!< I2C0_IC_RAW_INTR_STAT_RX_FULL                                             */
  I2C0_IC_RAW_INTR_STAT_RX_FULL_INACTIVE = 0,   /*!< INACTIVE : RX_FULL interrupt is inactive                                  */
  I2C0_IC_RAW_INTR_STAT_RX_FULL_ACTIVE = 1,     /*!< ACTIVE : RX_FULL interrupt is active                                      */
} I2C0_IC_RAW_INTR_STAT_RX_FULL_Enum;

/* =========================================  I2C0 IC_RAW_INTR_STAT RX_OVER [1..1]  ========================================== */
typedef enum {                                  /*!< I2C0_IC_RAW_INTR_STAT_RX_OVER                                             */
  I2C0_IC_RAW_INTR_STAT_RX_OVER_INACTIVE = 0,   /*!< INACTIVE : RX_OVER interrupt is inactive                                  */
  I2C0_IC_RAW_INTR_STAT_RX_OVER_ACTIVE = 1,     /*!< ACTIVE : RX_OVER interrupt is active                                      */
} I2C0_IC_RAW_INTR_STAT_RX_OVER_Enum;

/* =========================================  I2C0 IC_RAW_INTR_STAT RX_UNDER [0..0]  ========================================= */
typedef enum {                                  /*!< I2C0_IC_RAW_INTR_STAT_RX_UNDER                                            */
  I2C0_IC_RAW_INTR_STAT_RX_UNDER_INACTIVE = 0,  /*!< INACTIVE : RX_UNDER interrupt is inactive                                 */
  I2C0_IC_RAW_INTR_STAT_RX_UNDER_ACTIVE = 1,    /*!< ACTIVE : RX_UNDER interrupt is active                                     */
} I2C0_IC_RAW_INTR_STAT_RX_UNDER_Enum;

/* =======================================================  IC_RX_TL  ======================================================== */
/* =======================================================  IC_TX_TL  ======================================================== */
/* ======================================================  IC_CLR_INTR  ====================================================== */
/* ====================================================  IC_CLR_RX_UNDER  ==================================================== */
/* ====================================================  IC_CLR_RX_OVER  ===================================================== */
/* ====================================================  IC_CLR_TX_OVER  ===================================================== */
/* =====================================================  IC_CLR_RD_REQ  ===================================================== */
/* ====================================================  IC_CLR_TX_ABRT  ===================================================== */
/* ====================================================  IC_CLR_RX_DONE  ===================================================== */
/* ====================================================  IC_CLR_ACTIVITY  ==================================================== */
/* ====================================================  IC_CLR_STOP_DET  ==================================================== */
/* ===================================================  IC_CLR_START_DET  ==================================================== */
/* ====================================================  IC_CLR_GEN_CALL  ==================================================== */
/* =======================================================  IC_ENABLE  ======================================================= */
/* ==========================================  I2C0 IC_ENABLE TX_CMD_BLOCK [2..2]  =========================================== */
typedef enum {                                  /*!< I2C0_IC_ENABLE_TX_CMD_BLOCK                                               */
  I2C0_IC_ENABLE_TX_CMD_BLOCK_NOT_BLOCKED = 0,  /*!< NOT_BLOCKED : Tx Command execution not blocked                            */
  I2C0_IC_ENABLE_TX_CMD_BLOCK_BLOCKED  = 1,     /*!< BLOCKED : Tx Command execution blocked                                    */
} I2C0_IC_ENABLE_TX_CMD_BLOCK_Enum;

/* ==============================================  I2C0 IC_ENABLE ABORT [1..1]  ============================================== */
typedef enum {                                  /*!< I2C0_IC_ENABLE_ABORT                                                      */
  I2C0_IC_ENABLE_ABORT_DISABLE         = 0,     /*!< DISABLE : ABORT operation not in progress                                 */
  I2C0_IC_ENABLE_ABORT_ENABLED         = 1,     /*!< ENABLED : ABORT operation in progress                                     */
} I2C0_IC_ENABLE_ABORT_Enum;

/* =============================================  I2C0 IC_ENABLE ENABLE [0..0]  ============================================== */
typedef enum {                                  /*!< I2C0_IC_ENABLE_ENABLE                                                     */
  I2C0_IC_ENABLE_ENABLE_DISABLED       = 0,     /*!< DISABLED : I2C is disabled                                                */
  I2C0_IC_ENABLE_ENABLE_ENABLED        = 1,     /*!< ENABLED : I2C is enabled                                                  */
} I2C0_IC_ENABLE_ENABLE_Enum;

/* =======================================================  IC_STATUS  ======================================================= */
/* ==========================================  I2C0 IC_STATUS SLV_ACTIVITY [6..6]  =========================================== */
typedef enum {                                  /*!< I2C0_IC_STATUS_SLV_ACTIVITY                                               */
  I2C0_IC_STATUS_SLV_ACTIVITY_IDLE     = 0,     /*!< IDLE : Slave is idle                                                      */
  I2C0_IC_STATUS_SLV_ACTIVITY_ACTIVE   = 1,     /*!< ACTIVE : Slave not idle                                                   */
} I2C0_IC_STATUS_SLV_ACTIVITY_Enum;

/* ==========================================  I2C0 IC_STATUS MST_ACTIVITY [5..5]  =========================================== */
typedef enum {                                  /*!< I2C0_IC_STATUS_MST_ACTIVITY                                               */
  I2C0_IC_STATUS_MST_ACTIVITY_IDLE     = 0,     /*!< IDLE : Master is idle                                                     */
  I2C0_IC_STATUS_MST_ACTIVITY_ACTIVE   = 1,     /*!< ACTIVE : Master not idle                                                  */
} I2C0_IC_STATUS_MST_ACTIVITY_Enum;

/* ===============================================  I2C0 IC_STATUS RFF [4..4]  =============================================== */
typedef enum {                                  /*!< I2C0_IC_STATUS_RFF                                                        */
  I2C0_IC_STATUS_RFF_NOT_FULL          = 0,     /*!< NOT_FULL : Rx FIFO not full                                               */
  I2C0_IC_STATUS_RFF_FULL              = 1,     /*!< FULL : Rx FIFO is full                                                    */
} I2C0_IC_STATUS_RFF_Enum;

/* ==============================================  I2C0 IC_STATUS RFNE [3..3]  =============================================== */
typedef enum {                                  /*!< I2C0_IC_STATUS_RFNE                                                       */
  I2C0_IC_STATUS_RFNE_EMPTY            = 0,     /*!< EMPTY : Rx FIFO is empty                                                  */
  I2C0_IC_STATUS_RFNE_NOT_EMPTY        = 1,     /*!< NOT_EMPTY : Rx FIFO not empty                                             */
} I2C0_IC_STATUS_RFNE_Enum;

/* ===============================================  I2C0 IC_STATUS TFE [2..2]  =============================================== */
typedef enum {                                  /*!< I2C0_IC_STATUS_TFE                                                        */
  I2C0_IC_STATUS_TFE_NON_EMPTY         = 0,     /*!< NON_EMPTY : Tx FIFO not empty                                             */
  I2C0_IC_STATUS_TFE_EMPTY             = 1,     /*!< EMPTY : Tx FIFO is empty                                                  */
} I2C0_IC_STATUS_TFE_Enum;

/* ==============================================  I2C0 IC_STATUS TFNF [1..1]  =============================================== */
typedef enum {                                  /*!< I2C0_IC_STATUS_TFNF                                                       */
  I2C0_IC_STATUS_TFNF_FULL             = 0,     /*!< FULL : Tx FIFO is full                                                    */
  I2C0_IC_STATUS_TFNF_NOT_FULL         = 1,     /*!< NOT_FULL : Tx FIFO not full                                               */
} I2C0_IC_STATUS_TFNF_Enum;

/* ============================================  I2C0 IC_STATUS ACTIVITY [0..0]  ============================================= */
typedef enum {                                  /*!< I2C0_IC_STATUS_ACTIVITY                                                   */
  I2C0_IC_STATUS_ACTIVITY_INACTIVE     = 0,     /*!< INACTIVE : I2C is idle                                                    */
  I2C0_IC_STATUS_ACTIVITY_ACTIVE       = 1,     /*!< ACTIVE : I2C is active                                                    */
} I2C0_IC_STATUS_ACTIVITY_Enum;

/* =======================================================  IC_TXFLR  ======================================================== */
/* =======================================================  IC_RXFLR  ======================================================== */
/* ======================================================  IC_SDA_HOLD  ====================================================== */
/* ===================================================  IC_TX_ABRT_SOURCE  =================================================== */
/* ====================================  I2C0 IC_TX_ABRT_SOURCE ABRT_USER_ABRT [16..16]  ===================================== */
typedef enum {                                  /*!< I2C0_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT                                     */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT_ABRT_USER_ABRT_VOID = 0,/*!< ABRT_USER_ABRT_VOID : Transfer abort detected by master- scenario
                                                     not present                                                               */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT_ABRT_USER_ABRT_GENERATED = 1,/*!< ABRT_USER_ABRT_GENERATED : Transfer abort detected by master */
} I2C0_IC_TX_ABRT_SOURCE_ABRT_USER_ABRT_Enum;

/* ====================================  I2C0 IC_TX_ABRT_SOURCE ABRT_SLVRD_INTX [15..15]  ==================================== */
typedef enum {                                  /*!< I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX                                    */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX_ABRT_SLVRD_INTX_VOID = 0,/*!< ABRT_SLVRD_INTX_VOID : Slave trying to transmit to remote master
                                                     in read mode- scenario not present                                        */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX_ABRT_SLVRD_INTX_GENERATED = 1,/*!< ABRT_SLVRD_INTX_GENERATED : Slave trying to transmit to remote
                                                     master in read mode                                                       */
} I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVRD_INTX_Enum;

/* ===================================  I2C0 IC_TX_ABRT_SOURCE ABRT_SLV_ARBLOST [14..14]  ==================================== */
typedef enum {                                  /*!< I2C0_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST                                   */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST_ABRT_SLV_ARBLOST_VOID = 0,/*!< ABRT_SLV_ARBLOST_VOID : Slave lost arbitration to remote master-
                                                     scenario not present                                                      */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST_ABRT_SLV_ARBLOST_GENERATED = 1,/*!< ABRT_SLV_ARBLOST_GENERATED : Slave lost arbitration to remote
                                                     master                                                                    */
} I2C0_IC_TX_ABRT_SOURCE_ABRT_SLV_ARBLOST_Enum;

/* =================================  I2C0 IC_TX_ABRT_SOURCE ABRT_SLVFLUSH_TXFIFO [13..13]  ================================== */
typedef enum {                                  /*!< I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO                               */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO_ABRT_SLVFLUSH_TXFIFO_VOID = 0,/*!< ABRT_SLVFLUSH_TXFIFO_VOID : Slave flushes existing data in TX-FIFO
                                                     upon getting read command- scenario not present                           */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO_ABRT_SLVFLUSH_TXFIFO_GENERATED = 1,/*!< ABRT_SLVFLUSH_TXFIFO_GENERATED : Slave flushes existing data
                                                     in TX-FIFO upon getting read command                                      */
} I2C0_IC_TX_ABRT_SOURCE_ABRT_SLVFLUSH_TXFIFO_Enum;

/* =======================================  I2C0 IC_TX_ABRT_SOURCE ARB_LOST [12..12]  ======================================== */
typedef enum {                                  /*!< I2C0_IC_TX_ABRT_SOURCE_ARB_LOST                                           */
  I2C0_IC_TX_ABRT_SOURCE_ARB_LOST_ABRT_LOST_VOID = 0,/*!< ABRT_LOST_VOID : Master or Slave-Transmitter lost arbitration-
                                                     scenario not present                                                      */
  I2C0_IC_TX_ABRT_SOURCE_ARB_LOST_ABRT_LOST_GENERATED = 1,/*!< ABRT_LOST_GENERATED : Master or Slave-Transmitter lost arbitration */
} I2C0_IC_TX_ABRT_SOURCE_ARB_LOST_Enum;

/* ====================================  I2C0 IC_TX_ABRT_SOURCE ABRT_MASTER_DIS [11..11]  ==================================== */
typedef enum {                                  /*!< I2C0_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS                                    */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS_ABRT_MASTER_DIS_VOID = 0,/*!< ABRT_MASTER_DIS_VOID : User initiating master operation when
                                                     MASTER disabled- scenario not present                                     */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS_ABRT_MASTER_DIS_GENERATED = 1,/*!< ABRT_MASTER_DIS_GENERATED : User initiating master operation
                                                     when MASTER disabled                                                      */
} I2C0_IC_TX_ABRT_SOURCE_ABRT_MASTER_DIS_Enum;

/* ==================================  I2C0 IC_TX_ABRT_SOURCE ABRT_10B_RD_NORSTRT [10..10]  ================================== */
typedef enum {                                  /*!< I2C0_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT                                */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT_ABRT_10B_RD_VOID = 0,/*!< ABRT_10B_RD_VOID : Master not trying to read in 10Bit addressing
                                                     mode when RESTART disabled                                                */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT_ABRT_10B_RD_GENERATED = 1,/*!< ABRT_10B_RD_GENERATED : Master trying to read in 10Bit addressing
                                                     mode when RESTART disabled                                                */
} I2C0_IC_TX_ABRT_SOURCE_ABRT_10B_RD_NORSTRT_Enum;

/* ===================================  I2C0 IC_TX_ABRT_SOURCE ABRT_SBYTE_NORSTRT [9..9]  ==================================== */
typedef enum {                                  /*!< I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT                                 */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT_ABRT_SBYTE_NORSTRT_VOID = 0,/*!< ABRT_SBYTE_NORSTRT_VOID : User trying to send START byte when
                                                     RESTART disabled- scenario not present                                    */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT_ABRT_SBYTE_NORSTRT_GENERATED = 1,/*!< ABRT_SBYTE_NORSTRT_GENERATED : User trying to send START byte
                                                     when RESTART disabled                                                     */
} I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_NORSTRT_Enum;

/* =====================================  I2C0 IC_TX_ABRT_SOURCE ABRT_HS_NORSTRT [8..8]  ===================================== */
typedef enum {                                  /*!< I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT                                    */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT_ABRT_HS_NORSTRT_VOID = 0,/*!< ABRT_HS_NORSTRT_VOID : User trying to switch Master to HS mode
                                                     when RESTART disabled- scenario not present                               */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT_ABRT_HS_NORSTRT_GENERATED = 1,/*!< ABRT_HS_NORSTRT_GENERATED : User trying to switch Master to
                                                     HS mode when RESTART disabled                                             */
} I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_NORSTRT_Enum;

/* ====================================  I2C0 IC_TX_ABRT_SOURCE ABRT_SBYTE_ACKDET [7..7]  ==================================== */
typedef enum {                                  /*!< I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET                                  */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET_ABRT_SBYTE_ACKDET_VOID = 0,/*!< ABRT_SBYTE_ACKDET_VOID : ACK detected for START byte- scenario
                                                     not present                                                               */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET_ABRT_SBYTE_ACKDET_GENERATED = 1,/*!< ABRT_SBYTE_ACKDET_GENERATED : ACK detected for START byte */
} I2C0_IC_TX_ABRT_SOURCE_ABRT_SBYTE_ACKDET_Enum;

/* =====================================  I2C0 IC_TX_ABRT_SOURCE ABRT_HS_ACKDET [6..6]  ====================================== */
typedef enum {                                  /*!< I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET                                     */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET_ABRT_HS_ACK_VOID = 0,/*!< ABRT_HS_ACK_VOID : HS Master code ACKed in HS Mode- scenario
                                                     not present                                                               */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET_ABRT_HS_ACK_GENERATED = 1,/*!< ABRT_HS_ACK_GENERATED : HS Master code ACKed in HS Mode */
} I2C0_IC_TX_ABRT_SOURCE_ABRT_HS_ACKDET_Enum;

/* =====================================  I2C0 IC_TX_ABRT_SOURCE ABRT_GCALL_READ [5..5]  ===================================== */
typedef enum {                                  /*!< I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ                                    */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ_ABRT_GCALL_READ_VOID = 0,/*!< ABRT_GCALL_READ_VOID : GCALL is followed by read from bus-scenario
                                                     not present                                                               */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ_ABRT_GCALL_READ_GENERATED = 1,/*!< ABRT_GCALL_READ_GENERATED : GCALL is followed by read from bus */
} I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_READ_Enum;

/* ====================================  I2C0 IC_TX_ABRT_SOURCE ABRT_GCALL_NOACK [4..4]  ===================================== */
typedef enum {                                  /*!< I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK                                   */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK_ABRT_GCALL_NOACK_VOID = 0,/*!< ABRT_GCALL_NOACK_VOID : GCALL not ACKed by any slave-scenario
                                                     not present                                                               */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK_ABRT_GCALL_NOACK_GENERATED = 1,/*!< ABRT_GCALL_NOACK_GENERATED : GCALL not ACKed by any slave */
} I2C0_IC_TX_ABRT_SOURCE_ABRT_GCALL_NOACK_Enum;

/* ====================================  I2C0 IC_TX_ABRT_SOURCE ABRT_TXDATA_NOACK [3..3]  ==================================== */
typedef enum {                                  /*!< I2C0_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK                                  */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK_ABRT_TXDATA_NOACK_VOID = 0,/*!< ABRT_TXDATA_NOACK_VOID : Transmitted data non-ACKed by addressed
                                                     slave-scenario not present                                                */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK_ABRT_TXDATA_NOACK_GENERATED = 1,/*!< ABRT_TXDATA_NOACK_GENERATED : Transmitted data not ACKed by
                                                     addressed slave                                                           */
} I2C0_IC_TX_ABRT_SOURCE_ABRT_TXDATA_NOACK_Enum;

/* ===================================  I2C0 IC_TX_ABRT_SOURCE ABRT_10ADDR2_NOACK [2..2]  ==================================== */
typedef enum {                                  /*!< I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK                                 */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK_INACTIVE = 0,/*!< INACTIVE : This abort is not generated                           */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK_ACTIVE = 1,/*!< ACTIVE : Byte 2 of 10Bit Address not ACKed by any slave            */
} I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR2_NOACK_Enum;

/* ===================================  I2C0 IC_TX_ABRT_SOURCE ABRT_10ADDR1_NOACK [1..1]  ==================================== */
typedef enum {                                  /*!< I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK                                 */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK_INACTIVE = 0,/*!< INACTIVE : This abort is not generated                           */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK_ACTIVE = 1,/*!< ACTIVE : Byte 1 of 10Bit Address not ACKed by any slave            */
} I2C0_IC_TX_ABRT_SOURCE_ABRT_10ADDR1_NOACK_Enum;

/* ===================================  I2C0 IC_TX_ABRT_SOURCE ABRT_7B_ADDR_NOACK [0..0]  ==================================== */
typedef enum {                                  /*!< I2C0_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK                                 */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK_INACTIVE = 0,/*!< INACTIVE : This abort is not generated                           */
  I2C0_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK_ACTIVE = 1,/*!< ACTIVE : This abort is generated because of NOACK for 7-bit
                                                     address                                                                   */
} I2C0_IC_TX_ABRT_SOURCE_ABRT_7B_ADDR_NOACK_Enum;

/* =================================================  IC_SLV_DATA_NACK_ONLY  ================================================= */
/* ========================================  I2C0 IC_SLV_DATA_NACK_ONLY NACK [0..0]  ========================================= */
typedef enum {                                  /*!< I2C0_IC_SLV_DATA_NACK_ONLY_NACK                                           */
  I2C0_IC_SLV_DATA_NACK_ONLY_NACK_DISABLED = 0, /*!< DISABLED : Slave receiver generates NACK normally                         */
  I2C0_IC_SLV_DATA_NACK_ONLY_NACK_ENABLED = 1,  /*!< ENABLED : Slave receiver generates NACK upon data reception
                                                     only                                                                      */
} I2C0_IC_SLV_DATA_NACK_ONLY_NACK_Enum;

/* =======================================================  IC_DMA_CR  ======================================================= */
/* ==============================================  I2C0 IC_DMA_CR TDMAE [1..1]  ============================================== */
typedef enum {                                  /*!< I2C0_IC_DMA_CR_TDMAE                                                      */
  I2C0_IC_DMA_CR_TDMAE_DISABLED        = 0,     /*!< DISABLED : transmit FIFO DMA channel disabled                             */
  I2C0_IC_DMA_CR_TDMAE_ENABLED         = 1,     /*!< ENABLED : Transmit FIFO DMA channel enabled                               */
} I2C0_IC_DMA_CR_TDMAE_Enum;

/* ==============================================  I2C0 IC_DMA_CR RDMAE [0..0]  ============================================== */
typedef enum {                                  /*!< I2C0_IC_DMA_CR_RDMAE                                                      */
  I2C0_IC_DMA_CR_RDMAE_DISABLED        = 0,     /*!< DISABLED : Receive FIFO DMA channel disabled                              */
  I2C0_IC_DMA_CR_RDMAE_ENABLED         = 1,     /*!< ENABLED : Receive FIFO DMA channel enabled                                */
} I2C0_IC_DMA_CR_RDMAE_Enum;

/* ======================================================  IC_DMA_TDLR  ====================================================== */
/* ======================================================  IC_DMA_RDLR  ====================================================== */
/* =====================================================  IC_SDA_SETUP  ====================================================== */
/* ==================================================  IC_ACK_GENERAL_CALL  ================================================== */
/* =====================================  I2C0 IC_ACK_GENERAL_CALL ACK_GEN_CALL [0..0]  ====================================== */
typedef enum {                                  /*!< I2C0_IC_ACK_GENERAL_CALL_ACK_GEN_CALL                                     */
  I2C0_IC_ACK_GENERAL_CALL_ACK_GEN_CALL_DISABLED = 0,/*!< DISABLED : Generate NACK for a General Call                          */
  I2C0_IC_ACK_GENERAL_CALL_ACK_GEN_CALL_ENABLED = 1,/*!< ENABLED : Generate ACK for a General Call                             */
} I2C0_IC_ACK_GENERAL_CALL_ACK_GEN_CALL_Enum;

/* ===================================================  IC_ENABLE_STATUS  ==================================================== */
/* =====================================  I2C0 IC_ENABLE_STATUS SLV_RX_DATA_LOST [2..2]  ===================================== */
typedef enum {                                  /*!< I2C0_IC_ENABLE_STATUS_SLV_RX_DATA_LOST                                    */
  I2C0_IC_ENABLE_STATUS_SLV_RX_DATA_LOST_INACTIVE = 0,/*!< INACTIVE : Slave RX Data is not lost                                */
  I2C0_IC_ENABLE_STATUS_SLV_RX_DATA_LOST_ACTIVE = 1,/*!< ACTIVE : Slave RX Data is lost                                        */
} I2C0_IC_ENABLE_STATUS_SLV_RX_DATA_LOST_Enum;

/* =================================  I2C0 IC_ENABLE_STATUS SLV_DISABLED_WHILE_BUSY [1..1]  ================================== */
typedef enum {                                  /*!< I2C0_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY                             */
  I2C0_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY_INACTIVE = 0,/*!< INACTIVE : Slave is disabled when it is idle                 */
  I2C0_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY_ACTIVE = 1,/*!< ACTIVE : Slave is disabled when it is active                   */
} I2C0_IC_ENABLE_STATUS_SLV_DISABLED_WHILE_BUSY_Enum;

/* ==========================================  I2C0 IC_ENABLE_STATUS IC_EN [0..0]  =========================================== */
typedef enum {                                  /*!< I2C0_IC_ENABLE_STATUS_IC_EN                                               */
  I2C0_IC_ENABLE_STATUS_IC_EN_DISABLED = 0,     /*!< DISABLED : I2C disabled                                                   */
  I2C0_IC_ENABLE_STATUS_IC_EN_ENABLED  = 1,     /*!< ENABLED : I2C enabled                                                     */
} I2C0_IC_ENABLE_STATUS_IC_EN_Enum;

/* =====================================================  IC_FS_SPKLEN  ====================================================== */
/* ==================================================  IC_CLR_RESTART_DET  =================================================== */
/* ====================================================  IC_COMP_PARAM_1  ==================================================== */
/* ====================================================  IC_COMP_VERSION  ==================================================== */
/* =====================================================  IC_COMP_TYPE  ====================================================== */


/* =========================================================================================================================== */
/* ================                                            ADC                                            ================ */
/* =========================================================================================================================== */

/* ==========================================================  CS  =========================================================== */
/* ========================================================  RESULT  ========================================================= */
/* ==========================================================  FCS  ========================================================== */
/* =========================================================  FIFO  ========================================================== */
/* ==========================================================  DIV  ========================================================== */
/* =========================================================  INTR  ========================================================== */
/* =========================================================  INTE  ========================================================== */
/* =========================================================  INTF  ========================================================== */
/* =========================================================  INTS  ========================================================== */


/* =========================================================================================================================== */
/* ================                                            PWM                                            ================ */
/* =========================================================================================================================== */

/* ========================================================  CH0_CSR  ======================================================== */
/* ==============================================  PWM CH0_CSR DIVMODE [4..5]  =============================================== */
typedef enum {                                  /*!< PWM_CH0_CSR_DIVMODE                                                       */
  PWM_CH0_CSR_DIVMODE_div              = 0,     /*!< div : Free-running counting at rate dictated by fractional divider        */
  PWM_CH0_CSR_DIVMODE_level            = 1,     /*!< level : Fractional divider operation is gated by the PWM B pin.           */
  PWM_CH0_CSR_DIVMODE_rise             = 2,     /*!< rise : Counter advances with each rising edge of the PWM B pin.           */
  PWM_CH0_CSR_DIVMODE_fall             = 3,     /*!< fall : Counter advances with each falling edge of the PWM B
                                                     pin.                                                                      */
} PWM_CH0_CSR_DIVMODE_Enum;

/* ========================================================  CH0_DIV  ======================================================== */
/* ========================================================  CH0_CTR  ======================================================== */
/* ========================================================  CH0_CC  ========================================================= */
/* ========================================================  CH0_TOP  ======================================================== */
/* ========================================================  CH1_CSR  ======================================================== */
/* ==============================================  PWM CH1_CSR DIVMODE [4..5]  =============================================== */
typedef enum {                                  /*!< PWM_CH1_CSR_DIVMODE                                                       */
  PWM_CH1_CSR_DIVMODE_div              = 0,     /*!< div : Free-running counting at rate dictated by fractional divider        */
  PWM_CH1_CSR_DIVMODE_level            = 1,     /*!< level : Fractional divider operation is gated by the PWM B pin.           */
  PWM_CH1_CSR_DIVMODE_rise             = 2,     /*!< rise : Counter advances with each rising edge of the PWM B pin.           */
  PWM_CH1_CSR_DIVMODE_fall             = 3,     /*!< fall : Counter advances with each falling edge of the PWM B
                                                     pin.                                                                      */
} PWM_CH1_CSR_DIVMODE_Enum;

/* ========================================================  CH1_DIV  ======================================================== */
/* ========================================================  CH1_CTR  ======================================================== */
/* ========================================================  CH1_CC  ========================================================= */
/* ========================================================  CH1_TOP  ======================================================== */
/* ========================================================  CH2_CSR  ======================================================== */
/* ==============================================  PWM CH2_CSR DIVMODE [4..5]  =============================================== */
typedef enum {                                  /*!< PWM_CH2_CSR_DIVMODE                                                       */
  PWM_CH2_CSR_DIVMODE_div              = 0,     /*!< div : Free-running counting at rate dictated by fractional divider        */
  PWM_CH2_CSR_DIVMODE_level            = 1,     /*!< level : Fractional divider operation is gated by the PWM B pin.           */
  PWM_CH2_CSR_DIVMODE_rise             = 2,     /*!< rise : Counter advances with each rising edge of the PWM B pin.           */
  PWM_CH2_CSR_DIVMODE_fall             = 3,     /*!< fall : Counter advances with each falling edge of the PWM B
                                                     pin.                                                                      */
} PWM_CH2_CSR_DIVMODE_Enum;

/* ========================================================  CH2_DIV  ======================================================== */
/* ========================================================  CH2_CTR  ======================================================== */
/* ========================================================  CH2_CC  ========================================================= */
/* ========================================================  CH2_TOP  ======================================================== */
/* ========================================================  CH3_CSR  ======================================================== */
/* ==============================================  PWM CH3_CSR DIVMODE [4..5]  =============================================== */
typedef enum {                                  /*!< PWM_CH3_CSR_DIVMODE                                                       */
  PWM_CH3_CSR_DIVMODE_div              = 0,     /*!< div : Free-running counting at rate dictated by fractional divider        */
  PWM_CH3_CSR_DIVMODE_level            = 1,     /*!< level : Fractional divider operation is gated by the PWM B pin.           */
  PWM_CH3_CSR_DIVMODE_rise             = 2,     /*!< rise : Counter advances with each rising edge of the PWM B pin.           */
  PWM_CH3_CSR_DIVMODE_fall             = 3,     /*!< fall : Counter advances with each falling edge of the PWM B
                                                     pin.                                                                      */
} PWM_CH3_CSR_DIVMODE_Enum;

/* ========================================================  CH3_DIV  ======================================================== */
/* ========================================================  CH3_CTR  ======================================================== */
/* ========================================================  CH3_CC  ========================================================= */
/* ========================================================  CH3_TOP  ======================================================== */
/* ========================================================  CH4_CSR  ======================================================== */
/* ==============================================  PWM CH4_CSR DIVMODE [4..5]  =============================================== */
typedef enum {                                  /*!< PWM_CH4_CSR_DIVMODE                                                       */
  PWM_CH4_CSR_DIVMODE_div              = 0,     /*!< div : Free-running counting at rate dictated by fractional divider        */
  PWM_CH4_CSR_DIVMODE_level            = 1,     /*!< level : Fractional divider operation is gated by the PWM B pin.           */
  PWM_CH4_CSR_DIVMODE_rise             = 2,     /*!< rise : Counter advances with each rising edge of the PWM B pin.           */
  PWM_CH4_CSR_DIVMODE_fall             = 3,     /*!< fall : Counter advances with each falling edge of the PWM B
                                                     pin.                                                                      */
} PWM_CH4_CSR_DIVMODE_Enum;

/* ========================================================  CH4_DIV  ======================================================== */
/* ========================================================  CH4_CTR  ======================================================== */
/* ========================================================  CH4_CC  ========================================================= */
/* ========================================================  CH4_TOP  ======================================================== */
/* ========================================================  CH5_CSR  ======================================================== */
/* ==============================================  PWM CH5_CSR DIVMODE [4..5]  =============================================== */
typedef enum {                                  /*!< PWM_CH5_CSR_DIVMODE                                                       */
  PWM_CH5_CSR_DIVMODE_div              = 0,     /*!< div : Free-running counting at rate dictated by fractional divider        */
  PWM_CH5_CSR_DIVMODE_level            = 1,     /*!< level : Fractional divider operation is gated by the PWM B pin.           */
  PWM_CH5_CSR_DIVMODE_rise             = 2,     /*!< rise : Counter advances with each rising edge of the PWM B pin.           */
  PWM_CH5_CSR_DIVMODE_fall             = 3,     /*!< fall : Counter advances with each falling edge of the PWM B
                                                     pin.                                                                      */
} PWM_CH5_CSR_DIVMODE_Enum;

/* ========================================================  CH5_DIV  ======================================================== */
/* ========================================================  CH5_CTR  ======================================================== */
/* ========================================================  CH5_CC  ========================================================= */
/* ========================================================  CH5_TOP  ======================================================== */
/* ========================================================  CH6_CSR  ======================================================== */
/* ==============================================  PWM CH6_CSR DIVMODE [4..5]  =============================================== */
typedef enum {                                  /*!< PWM_CH6_CSR_DIVMODE                                                       */
  PWM_CH6_CSR_DIVMODE_div              = 0,     /*!< div : Free-running counting at rate dictated by fractional divider        */
  PWM_CH6_CSR_DIVMODE_level            = 1,     /*!< level : Fractional divider operation is gated by the PWM B pin.           */
  PWM_CH6_CSR_DIVMODE_rise             = 2,     /*!< rise : Counter advances with each rising edge of the PWM B pin.           */
  PWM_CH6_CSR_DIVMODE_fall             = 3,     /*!< fall : Counter advances with each falling edge of the PWM B
                                                     pin.                                                                      */
} PWM_CH6_CSR_DIVMODE_Enum;

/* ========================================================  CH6_DIV  ======================================================== */
/* ========================================================  CH6_CTR  ======================================================== */
/* ========================================================  CH6_CC  ========================================================= */
/* ========================================================  CH6_TOP  ======================================================== */
/* ========================================================  CH7_CSR  ======================================================== */
/* ==============================================  PWM CH7_CSR DIVMODE [4..5]  =============================================== */
typedef enum {                                  /*!< PWM_CH7_CSR_DIVMODE                                                       */
  PWM_CH7_CSR_DIVMODE_div              = 0,     /*!< div : Free-running counting at rate dictated by fractional divider        */
  PWM_CH7_CSR_DIVMODE_level            = 1,     /*!< level : Fractional divider operation is gated by the PWM B pin.           */
  PWM_CH7_CSR_DIVMODE_rise             = 2,     /*!< rise : Counter advances with each rising edge of the PWM B pin.           */
  PWM_CH7_CSR_DIVMODE_fall             = 3,     /*!< fall : Counter advances with each falling edge of the PWM B
                                                     pin.                                                                      */
} PWM_CH7_CSR_DIVMODE_Enum;

/* ========================================================  CH7_DIV  ======================================================== */
/* ========================================================  CH7_CTR  ======================================================== */
/* ========================================================  CH7_CC  ========================================================= */
/* ========================================================  CH7_TOP  ======================================================== */
/* ==========================================================  EN  =========================================================== */
/* =========================================================  INTR  ========================================================== */
/* =========================================================  INTE  ========================================================== */
/* =========================================================  INTF  ========================================================== */
/* =========================================================  INTS  ========================================================== */


/* =========================================================================================================================== */
/* ================                                           TIMER                                           ================ */
/* =========================================================================================================================== */

/* ========================================================  TIMEHW  ========================================================= */
/* ========================================================  TIMELW  ========================================================= */
/* ========================================================  TIMEHR  ========================================================= */
/* ========================================================  TIMELR  ========================================================= */
/* ========================================================  ALARM0  ========================================================= */
/* ========================================================  ALARM1  ========================================================= */
/* ========================================================  ALARM2  ========================================================= */
/* ========================================================  ALARM3  ========================================================= */
/* =========================================================  ARMED  ========================================================= */
/* =======================================================  TIMERAWH  ======================================================== */
/* =======================================================  TIMERAWL  ======================================================== */
/* =======================================================  DBGPAUSE  ======================================================== */
/* =========================================================  PAUSE  ========================================================= */
/* =========================================================  INTR  ========================================================== */
/* =========================================================  INTE  ========================================================== */
/* =========================================================  INTF  ========================================================== */
/* =========================================================  INTS  ========================================================== */


/* =========================================================================================================================== */
/* ================                                         WATCHDOG                                          ================ */
/* =========================================================================================================================== */

/* =========================================================  CTRL  ========================================================== */
/* =========================================================  LOAD  ========================================================== */
/* ========================================================  REASON  ========================================================= */
/* =======================================================  SCRATCH0  ======================================================== */
/* =======================================================  SCRATCH1  ======================================================== */
/* =======================================================  SCRATCH2  ======================================================== */
/* =======================================================  SCRATCH3  ======================================================== */
/* =======================================================  SCRATCH4  ======================================================== */
/* =======================================================  SCRATCH5  ======================================================== */
/* =======================================================  SCRATCH6  ======================================================== */
/* =======================================================  SCRATCH7  ======================================================== */
/* =========================================================  TICK  ========================================================== */


/* =========================================================================================================================== */
/* ================                                            RTC                                            ================ */
/* =========================================================================================================================== */

/* =======================================================  CLKDIV_M1  ======================================================= */
/* ========================================================  SETUP_0  ======================================================== */
/* ========================================================  SETUP_1  ======================================================== */
/* =========================================================  CTRL  ========================================================== */
/* ======================================================  IRQ_SETUP_0  ====================================================== */
/* ======================================================  IRQ_SETUP_1  ====================================================== */
/* =========================================================  RTC_1  ========================================================= */
/* =========================================================  RTC_0  ========================================================= */
/* =========================================================  INTR  ========================================================== */
/* =========================================================  INTE  ========================================================== */
/* =========================================================  INTF  ========================================================== */
/* =========================================================  INTS  ========================================================== */


/* =========================================================================================================================== */
/* ================                                           ROSC                                            ================ */
/* =========================================================================================================================== */

/* =========================================================  CTRL  ========================================================== */
/* ===============================================  ROSC CTRL ENABLE [12..23]  =============================================== */
typedef enum {                                  /*!< ROSC_CTRL_ENABLE                                                          */
  ROSC_CTRL_ENABLE_DISABLE             = 3358,  /*!< DISABLE : DISABLE                                                         */
  ROSC_CTRL_ENABLE_ENABLE              = 4011,  /*!< ENABLE : ENABLE                                                           */
} ROSC_CTRL_ENABLE_Enum;

/* =============================================  ROSC CTRL FREQ_RANGE [0..11]  ============================================== */
typedef enum {                                  /*!< ROSC_CTRL_FREQ_RANGE                                                      */
  ROSC_CTRL_FREQ_RANGE_LOW             = 4004,  /*!< LOW : LOW                                                                 */
  ROSC_CTRL_FREQ_RANGE_MEDIUM          = 4005,  /*!< MEDIUM : MEDIUM                                                           */
  ROSC_CTRL_FREQ_RANGE_HIGH            = 4007,  /*!< HIGH : HIGH                                                               */
  ROSC_CTRL_FREQ_RANGE_TOOHIGH         = 4006,  /*!< TOOHIGH : TOOHIGH                                                         */
} ROSC_CTRL_FREQ_RANGE_Enum;

/* =========================================================  FREQA  ========================================================= */
/* ==============================================  ROSC FREQA PASSWD [16..31]  =============================================== */
typedef enum {                                  /*!< ROSC_FREQA_PASSWD                                                         */
  ROSC_FREQA_PASSWD_PASS               = 38550, /*!< PASS : PASS                                                               */
} ROSC_FREQA_PASSWD_Enum;

/* =========================================================  FREQB  ========================================================= */
/* ==============================================  ROSC FREQB PASSWD [16..31]  =============================================== */
typedef enum {                                  /*!< ROSC_FREQB_PASSWD                                                         */
  ROSC_FREQB_PASSWD_PASS               = 38550, /*!< PASS : PASS                                                               */
} ROSC_FREQB_PASSWD_Enum;

/* ========================================================  DORMANT  ======================================================== */
/* ==========================================================  DIV  ========================================================== */
/* =================================================  ROSC DIV DIV [0..11]  ================================================== */
typedef enum {                                  /*!< ROSC_DIV_DIV                                                              */
  ROSC_DIV_DIV_PASS                    = 2720,  /*!< PASS : PASS                                                               */
} ROSC_DIV_DIV_Enum;

/* =========================================================  PHASE  ========================================================= */
/* ========================================================  STATUS  ========================================================= */
/* =======================================================  RANDOMBIT  ======================================================= */
/* =========================================================  COUNT  ========================================================= */


/* =========================================================================================================================== */
/* ================                                    VREG_AND_CHIP_RESET                                    ================ */
/* =========================================================================================================================== */

/* =========================================================  VREG  ========================================================== */
/* ==========================================================  BOD  ========================================================== */
/* ======================================================  CHIP_RESET  ======================================================= */


/* =========================================================================================================================== */
/* ================                                           TBMAN                                           ================ */
/* =========================================================================================================================== */

/* =======================================================  PLATFORM  ======================================================== */


/* =========================================================================================================================== */
/* ================                                            DMA                                            ================ */
/* =========================================================================================================================== */

/* =====================================================  CH0_READ_ADDR  ===================================================== */
/* ====================================================  CH0_WRITE_ADDR  ===================================================== */
/* ====================================================  CH0_TRANS_COUNT  ==================================================== */
/* =====================================================  CH0_CTRL_TRIG  ===================================================== */
/* ==========================================  DMA CH0_CTRL_TRIG TREQ_SEL [15..20]  ========================================== */
typedef enum {                                  /*!< DMA_CH0_CTRL_TRIG_TREQ_SEL                                                */
  DMA_CH0_CTRL_TRIG_TREQ_SEL_TIMER0    = 59,    /*!< TIMER0 : Select Timer 0 as TREQ                                           */
  DMA_CH0_CTRL_TRIG_TREQ_SEL_TIMER1    = 60,    /*!< TIMER1 : Select Timer 1 as TREQ                                           */
  DMA_CH0_CTRL_TRIG_TREQ_SEL_TIMER2    = 61,    /*!< TIMER2 : Select Timer 2 as TREQ (Optional)                                */
  DMA_CH0_CTRL_TRIG_TREQ_SEL_TIMER3    = 62,    /*!< TIMER3 : Select Timer 3 as TREQ (Optional)                                */
  DMA_CH0_CTRL_TRIG_TREQ_SEL_PERMANENT = 63,    /*!< PERMANENT : Permanent request, for unpaced transfers.                     */
} DMA_CH0_CTRL_TRIG_TREQ_SEL_Enum;

/* ==========================================  DMA CH0_CTRL_TRIG RING_SIZE [6..9]  =========================================== */
typedef enum {                                  /*!< DMA_CH0_CTRL_TRIG_RING_SIZE                                               */
  DMA_CH0_CTRL_TRIG_RING_SIZE_RING_NONE = 0,    /*!< RING_NONE : RING_NONE                                                     */
} DMA_CH0_CTRL_TRIG_RING_SIZE_Enum;

/* ==========================================  DMA CH0_CTRL_TRIG DATA_SIZE [2..3]  =========================================== */
typedef enum {                                  /*!< DMA_CH0_CTRL_TRIG_DATA_SIZE                                               */
  DMA_CH0_CTRL_TRIG_DATA_SIZE_SIZE_BYTE = 0,    /*!< SIZE_BYTE : SIZE_BYTE                                                     */
  DMA_CH0_CTRL_TRIG_DATA_SIZE_SIZE_HALFWORD = 1,/*!< SIZE_HALFWORD : SIZE_HALFWORD                                             */
  DMA_CH0_CTRL_TRIG_DATA_SIZE_SIZE_WORD = 2,    /*!< SIZE_WORD : SIZE_WORD                                                     */
} DMA_CH0_CTRL_TRIG_DATA_SIZE_Enum;

/* =====================================================  CH0_AL1_CTRL  ====================================================== */
/* ===================================================  CH0_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH0_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH0_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH0_AL2_CTRL  ====================================================== */
/* ==================================================  CH0_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH0_AL2_READ_ADDR  =================================================== */
/* ================================================  CH0_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH0_AL3_CTRL  ====================================================== */
/* ==================================================  CH0_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH0_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH0_AL3_READ_ADDR_TRIG  ================================================= */
/* =====================================================  CH1_READ_ADDR  ===================================================== */
/* ====================================================  CH1_WRITE_ADDR  ===================================================== */
/* ====================================================  CH1_TRANS_COUNT  ==================================================== */
/* =====================================================  CH1_CTRL_TRIG  ===================================================== */
/* ==========================================  DMA CH1_CTRL_TRIG TREQ_SEL [15..20]  ========================================== */
typedef enum {                                  /*!< DMA_CH1_CTRL_TRIG_TREQ_SEL                                                */
  DMA_CH1_CTRL_TRIG_TREQ_SEL_TIMER0    = 59,    /*!< TIMER0 : Select Timer 0 as TREQ                                           */
  DMA_CH1_CTRL_TRIG_TREQ_SEL_TIMER1    = 60,    /*!< TIMER1 : Select Timer 1 as TREQ                                           */
  DMA_CH1_CTRL_TRIG_TREQ_SEL_TIMER2    = 61,    /*!< TIMER2 : Select Timer 2 as TREQ (Optional)                                */
  DMA_CH1_CTRL_TRIG_TREQ_SEL_TIMER3    = 62,    /*!< TIMER3 : Select Timer 3 as TREQ (Optional)                                */
  DMA_CH1_CTRL_TRIG_TREQ_SEL_PERMANENT = 63,    /*!< PERMANENT : Permanent request, for unpaced transfers.                     */
} DMA_CH1_CTRL_TRIG_TREQ_SEL_Enum;

/* ==========================================  DMA CH1_CTRL_TRIG RING_SIZE [6..9]  =========================================== */
typedef enum {                                  /*!< DMA_CH1_CTRL_TRIG_RING_SIZE                                               */
  DMA_CH1_CTRL_TRIG_RING_SIZE_RING_NONE = 0,    /*!< RING_NONE : RING_NONE                                                     */
} DMA_CH1_CTRL_TRIG_RING_SIZE_Enum;

/* ==========================================  DMA CH1_CTRL_TRIG DATA_SIZE [2..3]  =========================================== */
typedef enum {                                  /*!< DMA_CH1_CTRL_TRIG_DATA_SIZE                                               */
  DMA_CH1_CTRL_TRIG_DATA_SIZE_SIZE_BYTE = 0,    /*!< SIZE_BYTE : SIZE_BYTE                                                     */
  DMA_CH1_CTRL_TRIG_DATA_SIZE_SIZE_HALFWORD = 1,/*!< SIZE_HALFWORD : SIZE_HALFWORD                                             */
  DMA_CH1_CTRL_TRIG_DATA_SIZE_SIZE_WORD = 2,    /*!< SIZE_WORD : SIZE_WORD                                                     */
} DMA_CH1_CTRL_TRIG_DATA_SIZE_Enum;

/* =====================================================  CH1_AL1_CTRL  ====================================================== */
/* ===================================================  CH1_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH1_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH1_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH1_AL2_CTRL  ====================================================== */
/* ==================================================  CH1_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH1_AL2_READ_ADDR  =================================================== */
/* ================================================  CH1_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH1_AL3_CTRL  ====================================================== */
/* ==================================================  CH1_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH1_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH1_AL3_READ_ADDR_TRIG  ================================================= */
/* =====================================================  CH2_READ_ADDR  ===================================================== */
/* ====================================================  CH2_WRITE_ADDR  ===================================================== */
/* ====================================================  CH2_TRANS_COUNT  ==================================================== */
/* =====================================================  CH2_CTRL_TRIG  ===================================================== */
/* ==========================================  DMA CH2_CTRL_TRIG TREQ_SEL [15..20]  ========================================== */
typedef enum {                                  /*!< DMA_CH2_CTRL_TRIG_TREQ_SEL                                                */
  DMA_CH2_CTRL_TRIG_TREQ_SEL_TIMER0    = 59,    /*!< TIMER0 : Select Timer 0 as TREQ                                           */
  DMA_CH2_CTRL_TRIG_TREQ_SEL_TIMER1    = 60,    /*!< TIMER1 : Select Timer 1 as TREQ                                           */
  DMA_CH2_CTRL_TRIG_TREQ_SEL_TIMER2    = 61,    /*!< TIMER2 : Select Timer 2 as TREQ (Optional)                                */
  DMA_CH2_CTRL_TRIG_TREQ_SEL_TIMER3    = 62,    /*!< TIMER3 : Select Timer 3 as TREQ (Optional)                                */
  DMA_CH2_CTRL_TRIG_TREQ_SEL_PERMANENT = 63,    /*!< PERMANENT : Permanent request, for unpaced transfers.                     */
} DMA_CH2_CTRL_TRIG_TREQ_SEL_Enum;

/* ==========================================  DMA CH2_CTRL_TRIG RING_SIZE [6..9]  =========================================== */
typedef enum {                                  /*!< DMA_CH2_CTRL_TRIG_RING_SIZE                                               */
  DMA_CH2_CTRL_TRIG_RING_SIZE_RING_NONE = 0,    /*!< RING_NONE : RING_NONE                                                     */
} DMA_CH2_CTRL_TRIG_RING_SIZE_Enum;

/* ==========================================  DMA CH2_CTRL_TRIG DATA_SIZE [2..3]  =========================================== */
typedef enum {                                  /*!< DMA_CH2_CTRL_TRIG_DATA_SIZE                                               */
  DMA_CH2_CTRL_TRIG_DATA_SIZE_SIZE_BYTE = 0,    /*!< SIZE_BYTE : SIZE_BYTE                                                     */
  DMA_CH2_CTRL_TRIG_DATA_SIZE_SIZE_HALFWORD = 1,/*!< SIZE_HALFWORD : SIZE_HALFWORD                                             */
  DMA_CH2_CTRL_TRIG_DATA_SIZE_SIZE_WORD = 2,    /*!< SIZE_WORD : SIZE_WORD                                                     */
} DMA_CH2_CTRL_TRIG_DATA_SIZE_Enum;

/* =====================================================  CH2_AL1_CTRL  ====================================================== */
/* ===================================================  CH2_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH2_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH2_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH2_AL2_CTRL  ====================================================== */
/* ==================================================  CH2_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH2_AL2_READ_ADDR  =================================================== */
/* ================================================  CH2_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH2_AL3_CTRL  ====================================================== */
/* ==================================================  CH2_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH2_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH2_AL3_READ_ADDR_TRIG  ================================================= */
/* =====================================================  CH3_READ_ADDR  ===================================================== */
/* ====================================================  CH3_WRITE_ADDR  ===================================================== */
/* ====================================================  CH3_TRANS_COUNT  ==================================================== */
/* =====================================================  CH3_CTRL_TRIG  ===================================================== */
/* ==========================================  DMA CH3_CTRL_TRIG TREQ_SEL [15..20]  ========================================== */
typedef enum {                                  /*!< DMA_CH3_CTRL_TRIG_TREQ_SEL                                                */
  DMA_CH3_CTRL_TRIG_TREQ_SEL_TIMER0    = 59,    /*!< TIMER0 : Select Timer 0 as TREQ                                           */
  DMA_CH3_CTRL_TRIG_TREQ_SEL_TIMER1    = 60,    /*!< TIMER1 : Select Timer 1 as TREQ                                           */
  DMA_CH3_CTRL_TRIG_TREQ_SEL_TIMER2    = 61,    /*!< TIMER2 : Select Timer 2 as TREQ (Optional)                                */
  DMA_CH3_CTRL_TRIG_TREQ_SEL_TIMER3    = 62,    /*!< TIMER3 : Select Timer 3 as TREQ (Optional)                                */
  DMA_CH3_CTRL_TRIG_TREQ_SEL_PERMANENT = 63,    /*!< PERMANENT : Permanent request, for unpaced transfers.                     */
} DMA_CH3_CTRL_TRIG_TREQ_SEL_Enum;

/* ==========================================  DMA CH3_CTRL_TRIG RING_SIZE [6..9]  =========================================== */
typedef enum {                                  /*!< DMA_CH3_CTRL_TRIG_RING_SIZE                                               */
  DMA_CH3_CTRL_TRIG_RING_SIZE_RING_NONE = 0,    /*!< RING_NONE : RING_NONE                                                     */
} DMA_CH3_CTRL_TRIG_RING_SIZE_Enum;

/* ==========================================  DMA CH3_CTRL_TRIG DATA_SIZE [2..3]  =========================================== */
typedef enum {                                  /*!< DMA_CH3_CTRL_TRIG_DATA_SIZE                                               */
  DMA_CH3_CTRL_TRIG_DATA_SIZE_SIZE_BYTE = 0,    /*!< SIZE_BYTE : SIZE_BYTE                                                     */
  DMA_CH3_CTRL_TRIG_DATA_SIZE_SIZE_HALFWORD = 1,/*!< SIZE_HALFWORD : SIZE_HALFWORD                                             */
  DMA_CH3_CTRL_TRIG_DATA_SIZE_SIZE_WORD = 2,    /*!< SIZE_WORD : SIZE_WORD                                                     */
} DMA_CH3_CTRL_TRIG_DATA_SIZE_Enum;

/* =====================================================  CH3_AL1_CTRL  ====================================================== */
/* ===================================================  CH3_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH3_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH3_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH3_AL2_CTRL  ====================================================== */
/* ==================================================  CH3_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH3_AL2_READ_ADDR  =================================================== */
/* ================================================  CH3_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH3_AL3_CTRL  ====================================================== */
/* ==================================================  CH3_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH3_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH3_AL3_READ_ADDR_TRIG  ================================================= */
/* =====================================================  CH4_READ_ADDR  ===================================================== */
/* ====================================================  CH4_WRITE_ADDR  ===================================================== */
/* ====================================================  CH4_TRANS_COUNT  ==================================================== */
/* =====================================================  CH4_CTRL_TRIG  ===================================================== */
/* ==========================================  DMA CH4_CTRL_TRIG TREQ_SEL [15..20]  ========================================== */
typedef enum {                                  /*!< DMA_CH4_CTRL_TRIG_TREQ_SEL                                                */
  DMA_CH4_CTRL_TRIG_TREQ_SEL_TIMER0    = 59,    /*!< TIMER0 : Select Timer 0 as TREQ                                           */
  DMA_CH4_CTRL_TRIG_TREQ_SEL_TIMER1    = 60,    /*!< TIMER1 : Select Timer 1 as TREQ                                           */
  DMA_CH4_CTRL_TRIG_TREQ_SEL_TIMER2    = 61,    /*!< TIMER2 : Select Timer 2 as TREQ (Optional)                                */
  DMA_CH4_CTRL_TRIG_TREQ_SEL_TIMER3    = 62,    /*!< TIMER3 : Select Timer 3 as TREQ (Optional)                                */
  DMA_CH4_CTRL_TRIG_TREQ_SEL_PERMANENT = 63,    /*!< PERMANENT : Permanent request, for unpaced transfers.                     */
} DMA_CH4_CTRL_TRIG_TREQ_SEL_Enum;

/* ==========================================  DMA CH4_CTRL_TRIG RING_SIZE [6..9]  =========================================== */
typedef enum {                                  /*!< DMA_CH4_CTRL_TRIG_RING_SIZE                                               */
  DMA_CH4_CTRL_TRIG_RING_SIZE_RING_NONE = 0,    /*!< RING_NONE : RING_NONE                                                     */
} DMA_CH4_CTRL_TRIG_RING_SIZE_Enum;

/* ==========================================  DMA CH4_CTRL_TRIG DATA_SIZE [2..3]  =========================================== */
typedef enum {                                  /*!< DMA_CH4_CTRL_TRIG_DATA_SIZE                                               */
  DMA_CH4_CTRL_TRIG_DATA_SIZE_SIZE_BYTE = 0,    /*!< SIZE_BYTE : SIZE_BYTE                                                     */
  DMA_CH4_CTRL_TRIG_DATA_SIZE_SIZE_HALFWORD = 1,/*!< SIZE_HALFWORD : SIZE_HALFWORD                                             */
  DMA_CH4_CTRL_TRIG_DATA_SIZE_SIZE_WORD = 2,    /*!< SIZE_WORD : SIZE_WORD                                                     */
} DMA_CH4_CTRL_TRIG_DATA_SIZE_Enum;

/* =====================================================  CH4_AL1_CTRL  ====================================================== */
/* ===================================================  CH4_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH4_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH4_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH4_AL2_CTRL  ====================================================== */
/* ==================================================  CH4_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH4_AL2_READ_ADDR  =================================================== */
/* ================================================  CH4_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH4_AL3_CTRL  ====================================================== */
/* ==================================================  CH4_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH4_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH4_AL3_READ_ADDR_TRIG  ================================================= */
/* =====================================================  CH5_READ_ADDR  ===================================================== */
/* ====================================================  CH5_WRITE_ADDR  ===================================================== */
/* ====================================================  CH5_TRANS_COUNT  ==================================================== */
/* =====================================================  CH5_CTRL_TRIG  ===================================================== */
/* ==========================================  DMA CH5_CTRL_TRIG TREQ_SEL [15..20]  ========================================== */
typedef enum {                                  /*!< DMA_CH5_CTRL_TRIG_TREQ_SEL                                                */
  DMA_CH5_CTRL_TRIG_TREQ_SEL_TIMER0    = 59,    /*!< TIMER0 : Select Timer 0 as TREQ                                           */
  DMA_CH5_CTRL_TRIG_TREQ_SEL_TIMER1    = 60,    /*!< TIMER1 : Select Timer 1 as TREQ                                           */
  DMA_CH5_CTRL_TRIG_TREQ_SEL_TIMER2    = 61,    /*!< TIMER2 : Select Timer 2 as TREQ (Optional)                                */
  DMA_CH5_CTRL_TRIG_TREQ_SEL_TIMER3    = 62,    /*!< TIMER3 : Select Timer 3 as TREQ (Optional)                                */
  DMA_CH5_CTRL_TRIG_TREQ_SEL_PERMANENT = 63,    /*!< PERMANENT : Permanent request, for unpaced transfers.                     */
} DMA_CH5_CTRL_TRIG_TREQ_SEL_Enum;

/* ==========================================  DMA CH5_CTRL_TRIG RING_SIZE [6..9]  =========================================== */
typedef enum {                                  /*!< DMA_CH5_CTRL_TRIG_RING_SIZE                                               */
  DMA_CH5_CTRL_TRIG_RING_SIZE_RING_NONE = 0,    /*!< RING_NONE : RING_NONE                                                     */
} DMA_CH5_CTRL_TRIG_RING_SIZE_Enum;

/* ==========================================  DMA CH5_CTRL_TRIG DATA_SIZE [2..3]  =========================================== */
typedef enum {                                  /*!< DMA_CH5_CTRL_TRIG_DATA_SIZE                                               */
  DMA_CH5_CTRL_TRIG_DATA_SIZE_SIZE_BYTE = 0,    /*!< SIZE_BYTE : SIZE_BYTE                                                     */
  DMA_CH5_CTRL_TRIG_DATA_SIZE_SIZE_HALFWORD = 1,/*!< SIZE_HALFWORD : SIZE_HALFWORD                                             */
  DMA_CH5_CTRL_TRIG_DATA_SIZE_SIZE_WORD = 2,    /*!< SIZE_WORD : SIZE_WORD                                                     */
} DMA_CH5_CTRL_TRIG_DATA_SIZE_Enum;

/* =====================================================  CH5_AL1_CTRL  ====================================================== */
/* ===================================================  CH5_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH5_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH5_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH5_AL2_CTRL  ====================================================== */
/* ==================================================  CH5_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH5_AL2_READ_ADDR  =================================================== */
/* ================================================  CH5_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH5_AL3_CTRL  ====================================================== */
/* ==================================================  CH5_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH5_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH5_AL3_READ_ADDR_TRIG  ================================================= */
/* =====================================================  CH6_READ_ADDR  ===================================================== */
/* ====================================================  CH6_WRITE_ADDR  ===================================================== */
/* ====================================================  CH6_TRANS_COUNT  ==================================================== */
/* =====================================================  CH6_CTRL_TRIG  ===================================================== */
/* ==========================================  DMA CH6_CTRL_TRIG TREQ_SEL [15..20]  ========================================== */
typedef enum {                                  /*!< DMA_CH6_CTRL_TRIG_TREQ_SEL                                                */
  DMA_CH6_CTRL_TRIG_TREQ_SEL_TIMER0    = 59,    /*!< TIMER0 : Select Timer 0 as TREQ                                           */
  DMA_CH6_CTRL_TRIG_TREQ_SEL_TIMER1    = 60,    /*!< TIMER1 : Select Timer 1 as TREQ                                           */
  DMA_CH6_CTRL_TRIG_TREQ_SEL_TIMER2    = 61,    /*!< TIMER2 : Select Timer 2 as TREQ (Optional)                                */
  DMA_CH6_CTRL_TRIG_TREQ_SEL_TIMER3    = 62,    /*!< TIMER3 : Select Timer 3 as TREQ (Optional)                                */
  DMA_CH6_CTRL_TRIG_TREQ_SEL_PERMANENT = 63,    /*!< PERMANENT : Permanent request, for unpaced transfers.                     */
} DMA_CH6_CTRL_TRIG_TREQ_SEL_Enum;

/* ==========================================  DMA CH6_CTRL_TRIG RING_SIZE [6..9]  =========================================== */
typedef enum {                                  /*!< DMA_CH6_CTRL_TRIG_RING_SIZE                                               */
  DMA_CH6_CTRL_TRIG_RING_SIZE_RING_NONE = 0,    /*!< RING_NONE : RING_NONE                                                     */
} DMA_CH6_CTRL_TRIG_RING_SIZE_Enum;

/* ==========================================  DMA CH6_CTRL_TRIG DATA_SIZE [2..3]  =========================================== */
typedef enum {                                  /*!< DMA_CH6_CTRL_TRIG_DATA_SIZE                                               */
  DMA_CH6_CTRL_TRIG_DATA_SIZE_SIZE_BYTE = 0,    /*!< SIZE_BYTE : SIZE_BYTE                                                     */
  DMA_CH6_CTRL_TRIG_DATA_SIZE_SIZE_HALFWORD = 1,/*!< SIZE_HALFWORD : SIZE_HALFWORD                                             */
  DMA_CH6_CTRL_TRIG_DATA_SIZE_SIZE_WORD = 2,    /*!< SIZE_WORD : SIZE_WORD                                                     */
} DMA_CH6_CTRL_TRIG_DATA_SIZE_Enum;

/* =====================================================  CH6_AL1_CTRL  ====================================================== */
/* ===================================================  CH6_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH6_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH6_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH6_AL2_CTRL  ====================================================== */
/* ==================================================  CH6_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH6_AL2_READ_ADDR  =================================================== */
/* ================================================  CH6_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH6_AL3_CTRL  ====================================================== */
/* ==================================================  CH6_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH6_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH6_AL3_READ_ADDR_TRIG  ================================================= */
/* =====================================================  CH7_READ_ADDR  ===================================================== */
/* ====================================================  CH7_WRITE_ADDR  ===================================================== */
/* ====================================================  CH7_TRANS_COUNT  ==================================================== */
/* =====================================================  CH7_CTRL_TRIG  ===================================================== */
/* ==========================================  DMA CH7_CTRL_TRIG TREQ_SEL [15..20]  ========================================== */
typedef enum {                                  /*!< DMA_CH7_CTRL_TRIG_TREQ_SEL                                                */
  DMA_CH7_CTRL_TRIG_TREQ_SEL_TIMER0    = 59,    /*!< TIMER0 : Select Timer 0 as TREQ                                           */
  DMA_CH7_CTRL_TRIG_TREQ_SEL_TIMER1    = 60,    /*!< TIMER1 : Select Timer 1 as TREQ                                           */
  DMA_CH7_CTRL_TRIG_TREQ_SEL_TIMER2    = 61,    /*!< TIMER2 : Select Timer 2 as TREQ (Optional)                                */
  DMA_CH7_CTRL_TRIG_TREQ_SEL_TIMER3    = 62,    /*!< TIMER3 : Select Timer 3 as TREQ (Optional)                                */
  DMA_CH7_CTRL_TRIG_TREQ_SEL_PERMANENT = 63,    /*!< PERMANENT : Permanent request, for unpaced transfers.                     */
} DMA_CH7_CTRL_TRIG_TREQ_SEL_Enum;

/* ==========================================  DMA CH7_CTRL_TRIG RING_SIZE [6..9]  =========================================== */
typedef enum {                                  /*!< DMA_CH7_CTRL_TRIG_RING_SIZE                                               */
  DMA_CH7_CTRL_TRIG_RING_SIZE_RING_NONE = 0,    /*!< RING_NONE : RING_NONE                                                     */
} DMA_CH7_CTRL_TRIG_RING_SIZE_Enum;

/* ==========================================  DMA CH7_CTRL_TRIG DATA_SIZE [2..3]  =========================================== */
typedef enum {                                  /*!< DMA_CH7_CTRL_TRIG_DATA_SIZE                                               */
  DMA_CH7_CTRL_TRIG_DATA_SIZE_SIZE_BYTE = 0,    /*!< SIZE_BYTE : SIZE_BYTE                                                     */
  DMA_CH7_CTRL_TRIG_DATA_SIZE_SIZE_HALFWORD = 1,/*!< SIZE_HALFWORD : SIZE_HALFWORD                                             */
  DMA_CH7_CTRL_TRIG_DATA_SIZE_SIZE_WORD = 2,    /*!< SIZE_WORD : SIZE_WORD                                                     */
} DMA_CH7_CTRL_TRIG_DATA_SIZE_Enum;

/* =====================================================  CH7_AL1_CTRL  ====================================================== */
/* ===================================================  CH7_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH7_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH7_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH7_AL2_CTRL  ====================================================== */
/* ==================================================  CH7_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH7_AL2_READ_ADDR  =================================================== */
/* ================================================  CH7_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH7_AL3_CTRL  ====================================================== */
/* ==================================================  CH7_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH7_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH7_AL3_READ_ADDR_TRIG  ================================================= */
/* =====================================================  CH8_READ_ADDR  ===================================================== */
/* ====================================================  CH8_WRITE_ADDR  ===================================================== */
/* ====================================================  CH8_TRANS_COUNT  ==================================================== */
/* =====================================================  CH8_CTRL_TRIG  ===================================================== */
/* ==========================================  DMA CH8_CTRL_TRIG TREQ_SEL [15..20]  ========================================== */
typedef enum {                                  /*!< DMA_CH8_CTRL_TRIG_TREQ_SEL                                                */
  DMA_CH8_CTRL_TRIG_TREQ_SEL_TIMER0    = 59,    /*!< TIMER0 : Select Timer 0 as TREQ                                           */
  DMA_CH8_CTRL_TRIG_TREQ_SEL_TIMER1    = 60,    /*!< TIMER1 : Select Timer 1 as TREQ                                           */
  DMA_CH8_CTRL_TRIG_TREQ_SEL_TIMER2    = 61,    /*!< TIMER2 : Select Timer 2 as TREQ (Optional)                                */
  DMA_CH8_CTRL_TRIG_TREQ_SEL_TIMER3    = 62,    /*!< TIMER3 : Select Timer 3 as TREQ (Optional)                                */
  DMA_CH8_CTRL_TRIG_TREQ_SEL_PERMANENT = 63,    /*!< PERMANENT : Permanent request, for unpaced transfers.                     */
} DMA_CH8_CTRL_TRIG_TREQ_SEL_Enum;

/* ==========================================  DMA CH8_CTRL_TRIG RING_SIZE [6..9]  =========================================== */
typedef enum {                                  /*!< DMA_CH8_CTRL_TRIG_RING_SIZE                                               */
  DMA_CH8_CTRL_TRIG_RING_SIZE_RING_NONE = 0,    /*!< RING_NONE : RING_NONE                                                     */
} DMA_CH8_CTRL_TRIG_RING_SIZE_Enum;

/* ==========================================  DMA CH8_CTRL_TRIG DATA_SIZE [2..3]  =========================================== */
typedef enum {                                  /*!< DMA_CH8_CTRL_TRIG_DATA_SIZE                                               */
  DMA_CH8_CTRL_TRIG_DATA_SIZE_SIZE_BYTE = 0,    /*!< SIZE_BYTE : SIZE_BYTE                                                     */
  DMA_CH8_CTRL_TRIG_DATA_SIZE_SIZE_HALFWORD = 1,/*!< SIZE_HALFWORD : SIZE_HALFWORD                                             */
  DMA_CH8_CTRL_TRIG_DATA_SIZE_SIZE_WORD = 2,    /*!< SIZE_WORD : SIZE_WORD                                                     */
} DMA_CH8_CTRL_TRIG_DATA_SIZE_Enum;

/* =====================================================  CH8_AL1_CTRL  ====================================================== */
/* ===================================================  CH8_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH8_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH8_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH8_AL2_CTRL  ====================================================== */
/* ==================================================  CH8_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH8_AL2_READ_ADDR  =================================================== */
/* ================================================  CH8_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH8_AL3_CTRL  ====================================================== */
/* ==================================================  CH8_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH8_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH8_AL3_READ_ADDR_TRIG  ================================================= */
/* =====================================================  CH9_READ_ADDR  ===================================================== */
/* ====================================================  CH9_WRITE_ADDR  ===================================================== */
/* ====================================================  CH9_TRANS_COUNT  ==================================================== */
/* =====================================================  CH9_CTRL_TRIG  ===================================================== */
/* ==========================================  DMA CH9_CTRL_TRIG TREQ_SEL [15..20]  ========================================== */
typedef enum {                                  /*!< DMA_CH9_CTRL_TRIG_TREQ_SEL                                                */
  DMA_CH9_CTRL_TRIG_TREQ_SEL_TIMER0    = 59,    /*!< TIMER0 : Select Timer 0 as TREQ                                           */
  DMA_CH9_CTRL_TRIG_TREQ_SEL_TIMER1    = 60,    /*!< TIMER1 : Select Timer 1 as TREQ                                           */
  DMA_CH9_CTRL_TRIG_TREQ_SEL_TIMER2    = 61,    /*!< TIMER2 : Select Timer 2 as TREQ (Optional)                                */
  DMA_CH9_CTRL_TRIG_TREQ_SEL_TIMER3    = 62,    /*!< TIMER3 : Select Timer 3 as TREQ (Optional)                                */
  DMA_CH9_CTRL_TRIG_TREQ_SEL_PERMANENT = 63,    /*!< PERMANENT : Permanent request, for unpaced transfers.                     */
} DMA_CH9_CTRL_TRIG_TREQ_SEL_Enum;

/* ==========================================  DMA CH9_CTRL_TRIG RING_SIZE [6..9]  =========================================== */
typedef enum {                                  /*!< DMA_CH9_CTRL_TRIG_RING_SIZE                                               */
  DMA_CH9_CTRL_TRIG_RING_SIZE_RING_NONE = 0,    /*!< RING_NONE : RING_NONE                                                     */
} DMA_CH9_CTRL_TRIG_RING_SIZE_Enum;

/* ==========================================  DMA CH9_CTRL_TRIG DATA_SIZE [2..3]  =========================================== */
typedef enum {                                  /*!< DMA_CH9_CTRL_TRIG_DATA_SIZE                                               */
  DMA_CH9_CTRL_TRIG_DATA_SIZE_SIZE_BYTE = 0,    /*!< SIZE_BYTE : SIZE_BYTE                                                     */
  DMA_CH9_CTRL_TRIG_DATA_SIZE_SIZE_HALFWORD = 1,/*!< SIZE_HALFWORD : SIZE_HALFWORD                                             */
  DMA_CH9_CTRL_TRIG_DATA_SIZE_SIZE_WORD = 2,    /*!< SIZE_WORD : SIZE_WORD                                                     */
} DMA_CH9_CTRL_TRIG_DATA_SIZE_Enum;

/* =====================================================  CH9_AL1_CTRL  ====================================================== */
/* ===================================================  CH9_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH9_AL1_WRITE_ADDR  =================================================== */
/* ===============================================  CH9_AL1_TRANS_COUNT_TRIG  ================================================ */
/* =====================================================  CH9_AL2_CTRL  ====================================================== */
/* ==================================================  CH9_AL2_TRANS_COUNT  ================================================== */
/* ===================================================  CH9_AL2_READ_ADDR  =================================================== */
/* ================================================  CH9_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH9_AL3_CTRL  ====================================================== */
/* ==================================================  CH9_AL3_WRITE_ADDR  =================================================== */
/* ==================================================  CH9_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH9_AL3_READ_ADDR_TRIG  ================================================= */
/* ====================================================  CH10_READ_ADDR  ===================================================== */
/* ====================================================  CH10_WRITE_ADDR  ==================================================== */
/* ===================================================  CH10_TRANS_COUNT  ==================================================== */
/* ====================================================  CH10_CTRL_TRIG  ===================================================== */
/* =========================================  DMA CH10_CTRL_TRIG TREQ_SEL [15..20]  ========================================== */
typedef enum {                                  /*!< DMA_CH10_CTRL_TRIG_TREQ_SEL                                               */
  DMA_CH10_CTRL_TRIG_TREQ_SEL_TIMER0   = 59,    /*!< TIMER0 : Select Timer 0 as TREQ                                           */
  DMA_CH10_CTRL_TRIG_TREQ_SEL_TIMER1   = 60,    /*!< TIMER1 : Select Timer 1 as TREQ                                           */
  DMA_CH10_CTRL_TRIG_TREQ_SEL_TIMER2   = 61,    /*!< TIMER2 : Select Timer 2 as TREQ (Optional)                                */
  DMA_CH10_CTRL_TRIG_TREQ_SEL_TIMER3   = 62,    /*!< TIMER3 : Select Timer 3 as TREQ (Optional)                                */
  DMA_CH10_CTRL_TRIG_TREQ_SEL_PERMANENT = 63,   /*!< PERMANENT : Permanent request, for unpaced transfers.                     */
} DMA_CH10_CTRL_TRIG_TREQ_SEL_Enum;

/* ==========================================  DMA CH10_CTRL_TRIG RING_SIZE [6..9]  ========================================== */
typedef enum {                                  /*!< DMA_CH10_CTRL_TRIG_RING_SIZE                                              */
  DMA_CH10_CTRL_TRIG_RING_SIZE_RING_NONE = 0,   /*!< RING_NONE : RING_NONE                                                     */
} DMA_CH10_CTRL_TRIG_RING_SIZE_Enum;

/* ==========================================  DMA CH10_CTRL_TRIG DATA_SIZE [2..3]  ========================================== */
typedef enum {                                  /*!< DMA_CH10_CTRL_TRIG_DATA_SIZE                                              */
  DMA_CH10_CTRL_TRIG_DATA_SIZE_SIZE_BYTE = 0,   /*!< SIZE_BYTE : SIZE_BYTE                                                     */
  DMA_CH10_CTRL_TRIG_DATA_SIZE_SIZE_HALFWORD = 1,/*!< SIZE_HALFWORD : SIZE_HALFWORD                                            */
  DMA_CH10_CTRL_TRIG_DATA_SIZE_SIZE_WORD = 2,   /*!< SIZE_WORD : SIZE_WORD                                                     */
} DMA_CH10_CTRL_TRIG_DATA_SIZE_Enum;

/* =====================================================  CH10_AL1_CTRL  ===================================================== */
/* ==================================================  CH10_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH10_AL1_WRITE_ADDR  ================================================== */
/* ===============================================  CH10_AL1_TRANS_COUNT_TRIG  =============================================== */
/* =====================================================  CH10_AL2_CTRL  ===================================================== */
/* =================================================  CH10_AL2_TRANS_COUNT  ================================================== */
/* ==================================================  CH10_AL2_READ_ADDR  =================================================== */
/* ===============================================  CH10_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH10_AL3_CTRL  ===================================================== */
/* ==================================================  CH10_AL3_WRITE_ADDR  ================================================== */
/* =================================================  CH10_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH10_AL3_READ_ADDR_TRIG  ================================================ */
/* ====================================================  CH11_READ_ADDR  ===================================================== */
/* ====================================================  CH11_WRITE_ADDR  ==================================================== */
/* ===================================================  CH11_TRANS_COUNT  ==================================================== */
/* ====================================================  CH11_CTRL_TRIG  ===================================================== */
/* =========================================  DMA CH11_CTRL_TRIG TREQ_SEL [15..20]  ========================================== */
typedef enum {                                  /*!< DMA_CH11_CTRL_TRIG_TREQ_SEL                                               */
  DMA_CH11_CTRL_TRIG_TREQ_SEL_TIMER0   = 59,    /*!< TIMER0 : Select Timer 0 as TREQ                                           */
  DMA_CH11_CTRL_TRIG_TREQ_SEL_TIMER1   = 60,    /*!< TIMER1 : Select Timer 1 as TREQ                                           */
  DMA_CH11_CTRL_TRIG_TREQ_SEL_TIMER2   = 61,    /*!< TIMER2 : Select Timer 2 as TREQ (Optional)                                */
  DMA_CH11_CTRL_TRIG_TREQ_SEL_TIMER3   = 62,    /*!< TIMER3 : Select Timer 3 as TREQ (Optional)                                */
  DMA_CH11_CTRL_TRIG_TREQ_SEL_PERMANENT = 63,   /*!< PERMANENT : Permanent request, for unpaced transfers.                     */
} DMA_CH11_CTRL_TRIG_TREQ_SEL_Enum;

/* ==========================================  DMA CH11_CTRL_TRIG RING_SIZE [6..9]  ========================================== */
typedef enum {                                  /*!< DMA_CH11_CTRL_TRIG_RING_SIZE                                              */
  DMA_CH11_CTRL_TRIG_RING_SIZE_RING_NONE = 0,   /*!< RING_NONE : RING_NONE                                                     */
} DMA_CH11_CTRL_TRIG_RING_SIZE_Enum;

/* ==========================================  DMA CH11_CTRL_TRIG DATA_SIZE [2..3]  ========================================== */
typedef enum {                                  /*!< DMA_CH11_CTRL_TRIG_DATA_SIZE                                              */
  DMA_CH11_CTRL_TRIG_DATA_SIZE_SIZE_BYTE = 0,   /*!< SIZE_BYTE : SIZE_BYTE                                                     */
  DMA_CH11_CTRL_TRIG_DATA_SIZE_SIZE_HALFWORD = 1,/*!< SIZE_HALFWORD : SIZE_HALFWORD                                            */
  DMA_CH11_CTRL_TRIG_DATA_SIZE_SIZE_WORD = 2,   /*!< SIZE_WORD : SIZE_WORD                                                     */
} DMA_CH11_CTRL_TRIG_DATA_SIZE_Enum;

/* =====================================================  CH11_AL1_CTRL  ===================================================== */
/* ==================================================  CH11_AL1_READ_ADDR  =================================================== */
/* ==================================================  CH11_AL1_WRITE_ADDR  ================================================== */
/* ===============================================  CH11_AL1_TRANS_COUNT_TRIG  =============================================== */
/* =====================================================  CH11_AL2_CTRL  ===================================================== */
/* =================================================  CH11_AL2_TRANS_COUNT  ================================================== */
/* ==================================================  CH11_AL2_READ_ADDR  =================================================== */
/* ===============================================  CH11_AL2_WRITE_ADDR_TRIG  ================================================ */
/* =====================================================  CH11_AL3_CTRL  ===================================================== */
/* ==================================================  CH11_AL3_WRITE_ADDR  ================================================== */
/* =================================================  CH11_AL3_TRANS_COUNT  ================================================== */
/* ================================================  CH11_AL3_READ_ADDR_TRIG  ================================================ */
/* =========================================================  INTR  ========================================================== */
/* =========================================================  INTE0  ========================================================= */
/* =========================================================  INTF0  ========================================================= */
/* =========================================================  INTS0  ========================================================= */
/* =========================================================  INTE1  ========================================================= */
/* =========================================================  INTF1  ========================================================= */
/* =========================================================  INTS1  ========================================================= */
/* ========================================================  TIMER0  ========================================================= */
/* ========================================================  TIMER1  ========================================================= */
/* ==================================================  MULTI_CHAN_TRIGGER  =================================================== */
/* ======================================================  SNIFF_CTRL  ======================================================= */
/* ==============================================  DMA SNIFF_CTRL CALC [5..8]  =============================================== */
typedef enum {                                  /*!< DMA_SNIFF_CTRL_CALC                                                       */
  DMA_SNIFF_CTRL_CALC_CRC32            = 0,     /*!< CRC32 : Calculate a CRC-32 (IEEE802.3 polynomial)                         */
  DMA_SNIFF_CTRL_CALC_CRC32R           = 1,     /*!< CRC32R : Calculate a CRC-32 (IEEE802.3 polynomial) with bit
                                                     reversed data                                                             */
  DMA_SNIFF_CTRL_CALC_CRC16            = 2,     /*!< CRC16 : Calculate a CRC-16-CCITT                                          */
  DMA_SNIFF_CTRL_CALC_CRC16R           = 3,     /*!< CRC16R : Calculate a CRC-16-CCITT with bit reversed data                  */
  DMA_SNIFF_CTRL_CALC_EVEN             = 14,    /*!< EVEN : XOR reduction over all data. == 1 if the total 1 population
                                                     count is odd.                                                             */
  DMA_SNIFF_CTRL_CALC_SUM              = 15,    /*!< SUM : Calculate a simple 32-bit checksum (addition with a 32
                                                     bit accumulator)                                                          */
} DMA_SNIFF_CTRL_CALC_Enum;

/* ======================================================  SNIFF_DATA  ======================================================= */
/* ======================================================  FIFO_LEVELS  ====================================================== */
/* ======================================================  CHAN_ABORT  ======================================================= */
/* ======================================================  N_CHANNELS  ======================================================= */
/* ====================================================  CH0_DBG_CTDREQ  ===================================================== */
/* ======================================================  CH0_DBG_TCR  ====================================================== */
/* ====================================================  CH1_DBG_CTDREQ  ===================================================== */
/* ======================================================  CH1_DBG_TCR  ====================================================== */
/* ====================================================  CH2_DBG_CTDREQ  ===================================================== */
/* ======================================================  CH2_DBG_TCR  ====================================================== */
/* ====================================================  CH3_DBG_CTDREQ  ===================================================== */
/* ======================================================  CH3_DBG_TCR  ====================================================== */
/* ====================================================  CH4_DBG_CTDREQ  ===================================================== */
/* ======================================================  CH4_DBG_TCR  ====================================================== */
/* ====================================================  CH5_DBG_CTDREQ  ===================================================== */
/* ======================================================  CH5_DBG_TCR  ====================================================== */
/* ====================================================  CH6_DBG_CTDREQ  ===================================================== */
/* ======================================================  CH6_DBG_TCR  ====================================================== */
/* ====================================================  CH7_DBG_CTDREQ  ===================================================== */
/* ======================================================  CH7_DBG_TCR  ====================================================== */
/* ====================================================  CH8_DBG_CTDREQ  ===================================================== */
/* ======================================================  CH8_DBG_TCR  ====================================================== */
/* ====================================================  CH9_DBG_CTDREQ  ===================================================== */
/* ======================================================  CH9_DBG_TCR  ====================================================== */
/* ====================================================  CH10_DBG_CTDREQ  ==================================================== */
/* =====================================================  CH10_DBG_TCR  ====================================================== */
/* ====================================================  CH11_DBG_CTDREQ  ==================================================== */
/* =====================================================  CH11_DBG_TCR  ====================================================== */


/* =========================================================================================================================== */
/* ================                                       USBCTRL_REGS                                        ================ */
/* =========================================================================================================================== */

/* =======================================================  ADDR_ENDP  ======================================================= */
/* ======================================================  ADDR_ENDP1  ======================================================= */
/* ======================================================  ADDR_ENDP2  ======================================================= */
/* ======================================================  ADDR_ENDP3  ======================================================= */
/* ======================================================  ADDR_ENDP4  ======================================================= */
/* ======================================================  ADDR_ENDP5  ======================================================= */
/* ======================================================  ADDR_ENDP6  ======================================================= */
/* ======================================================  ADDR_ENDP7  ======================================================= */
/* ======================================================  ADDR_ENDP8  ======================================================= */
/* ======================================================  ADDR_ENDP9  ======================================================= */
/* ======================================================  ADDR_ENDP10  ====================================================== */
/* ======================================================  ADDR_ENDP11  ====================================================== */
/* ======================================================  ADDR_ENDP12  ====================================================== */
/* ======================================================  ADDR_ENDP13  ====================================================== */
/* ======================================================  ADDR_ENDP14  ====================================================== */
/* ======================================================  ADDR_ENDP15  ====================================================== */
/* =======================================================  MAIN_CTRL  ======================================================= */
/* ========================================================  SOF_WR  ========================================================= */
/* ========================================================  SOF_RD  ========================================================= */
/* =======================================================  SIE_CTRL  ======================================================== */
/* ======================================================  SIE_STATUS  ======================================================= */
/* ======================================================  INT_EP_CTRL  ====================================================== */
/* ======================================================  BUFF_STATUS  ====================================================== */
/* ================================================  BUFF_CPU_SHOULD_HANDLE  ================================================= */
/* =======================================================  EP_ABORT  ======================================================== */
/* =====================================================  EP_ABORT_DONE  ===================================================== */
/* =====================================================  EP_STALL_ARM  ====================================================== */
/* =======================================================  NAK_POLL  ======================================================== */
/* ==================================================  EP_STATUS_STALL_NAK  ================================================== */
/* ======================================================  USB_MUXING  ======================================================= */
/* ========================================================  USB_PWR  ======================================================== */
/* =====================================================  USBPHY_DIRECT  ===================================================== */
/* ================================================  USBPHY_DIRECT_OVERRIDE  ================================================= */
/* ======================================================  USBPHY_TRIM  ====================================================== */
/* =========================================================  INTR  ========================================================== */
/* =========================================================  INTE  ========================================================== */
/* =========================================================  INTF  ========================================================== */
/* =========================================================  INTS  ========================================================== */


/* =========================================================================================================================== */
/* ================                                           PIO0                                            ================ */
/* =========================================================================================================================== */

/* =========================================================  CTRL  ========================================================== */
/* =========================================================  FSTAT  ========================================================= */
/* ========================================================  FDEBUG  ========================================================= */
/* ========================================================  FLEVEL  ========================================================= */
/* =========================================================  TXF0  ========================================================== */
/* =========================================================  TXF1  ========================================================== */
/* =========================================================  TXF2  ========================================================== */
/* =========================================================  TXF3  ========================================================== */
/* =========================================================  RXF0  ========================================================== */
/* =========================================================  RXF1  ========================================================== */
/* =========================================================  RXF2  ========================================================== */
/* =========================================================  RXF3  ========================================================== */
/* ==========================================================  IRQ  ========================================================== */
/* =======================================================  IRQ_FORCE  ======================================================= */
/* ===================================================  INPUT_SYNC_BYPASS  =================================================== */
/* ======================================================  DBG_PADOUT  ======================================================= */
/* =======================================================  DBG_PADOE  ======================================================= */
/* ======================================================  DBG_CFGINFO  ====================================================== */
/* ======================================================  INSTR_MEM0  ======================================================= */
/* ======================================================  INSTR_MEM1  ======================================================= */
/* ======================================================  INSTR_MEM2  ======================================================= */
/* ======================================================  INSTR_MEM3  ======================================================= */
/* ======================================================  INSTR_MEM4  ======================================================= */
/* ======================================================  INSTR_MEM5  ======================================================= */
/* ======================================================  INSTR_MEM6  ======================================================= */
/* ======================================================  INSTR_MEM7  ======================================================= */
/* ======================================================  INSTR_MEM8  ======================================================= */
/* ======================================================  INSTR_MEM9  ======================================================= */
/* ======================================================  INSTR_MEM10  ====================================================== */
/* ======================================================  INSTR_MEM11  ====================================================== */
/* ======================================================  INSTR_MEM12  ====================================================== */
/* ======================================================  INSTR_MEM13  ====================================================== */
/* ======================================================  INSTR_MEM14  ====================================================== */
/* ======================================================  INSTR_MEM15  ====================================================== */
/* ======================================================  INSTR_MEM16  ====================================================== */
/* ======================================================  INSTR_MEM17  ====================================================== */
/* ======================================================  INSTR_MEM18  ====================================================== */
/* ======================================================  INSTR_MEM19  ====================================================== */
/* ======================================================  INSTR_MEM20  ====================================================== */
/* ======================================================  INSTR_MEM21  ====================================================== */
/* ======================================================  INSTR_MEM22  ====================================================== */
/* ======================================================  INSTR_MEM23  ====================================================== */
/* ======================================================  INSTR_MEM24  ====================================================== */
/* ======================================================  INSTR_MEM25  ====================================================== */
/* ======================================================  INSTR_MEM26  ====================================================== */
/* ======================================================  INSTR_MEM27  ====================================================== */
/* ======================================================  INSTR_MEM28  ====================================================== */
/* ======================================================  INSTR_MEM29  ====================================================== */
/* ======================================================  INSTR_MEM30  ====================================================== */
/* ======================================================  INSTR_MEM31  ====================================================== */
/* ======================================================  SM0_CLKDIV  ======================================================= */
/* =====================================================  SM0_EXECCTRL  ====================================================== */
/* ==========================================  PIO0 SM0_EXECCTRL STATUS_SEL [4..4]  ========================================== */
typedef enum {                                  /*!< PIO0_SM0_EXECCTRL_STATUS_SEL                                              */
  PIO0_SM0_EXECCTRL_STATUS_SEL_TXLEVEL = 0,     /*!< TXLEVEL : All-ones if TX FIFO level < N, otherwise all-zeroes             */
  PIO0_SM0_EXECCTRL_STATUS_SEL_RXLEVEL = 1,     /*!< RXLEVEL : All-ones if RX FIFO level < N, otherwise all-zeroes             */
} PIO0_SM0_EXECCTRL_STATUS_SEL_Enum;

/* =====================================================  SM0_SHIFTCTRL  ===================================================== */
/* =======================================================  SM0_ADDR  ======================================================== */
/* =======================================================  SM0_INSTR  ======================================================= */
/* ======================================================  SM0_PINCTRL  ====================================================== */
/* ======================================================  SM1_CLKDIV  ======================================================= */
/* =====================================================  SM1_EXECCTRL  ====================================================== */
/* ==========================================  PIO0 SM1_EXECCTRL STATUS_SEL [4..4]  ========================================== */
typedef enum {                                  /*!< PIO0_SM1_EXECCTRL_STATUS_SEL                                              */
  PIO0_SM1_EXECCTRL_STATUS_SEL_TXLEVEL = 0,     /*!< TXLEVEL : All-ones if TX FIFO level < N, otherwise all-zeroes             */
  PIO0_SM1_EXECCTRL_STATUS_SEL_RXLEVEL = 1,     /*!< RXLEVEL : All-ones if RX FIFO level < N, otherwise all-zeroes             */
} PIO0_SM1_EXECCTRL_STATUS_SEL_Enum;

/* =====================================================  SM1_SHIFTCTRL  ===================================================== */
/* =======================================================  SM1_ADDR  ======================================================== */
/* =======================================================  SM1_INSTR  ======================================================= */
/* ======================================================  SM1_PINCTRL  ====================================================== */
/* ======================================================  SM2_CLKDIV  ======================================================= */
/* =====================================================  SM2_EXECCTRL  ====================================================== */
/* ==========================================  PIO0 SM2_EXECCTRL STATUS_SEL [4..4]  ========================================== */
typedef enum {                                  /*!< PIO0_SM2_EXECCTRL_STATUS_SEL                                              */
  PIO0_SM2_EXECCTRL_STATUS_SEL_TXLEVEL = 0,     /*!< TXLEVEL : All-ones if TX FIFO level < N, otherwise all-zeroes             */
  PIO0_SM2_EXECCTRL_STATUS_SEL_RXLEVEL = 1,     /*!< RXLEVEL : All-ones if RX FIFO level < N, otherwise all-zeroes             */
} PIO0_SM2_EXECCTRL_STATUS_SEL_Enum;

/* =====================================================  SM2_SHIFTCTRL  ===================================================== */
/* =======================================================  SM2_ADDR  ======================================================== */
/* =======================================================  SM2_INSTR  ======================================================= */
/* ======================================================  SM2_PINCTRL  ====================================================== */
/* ======================================================  SM3_CLKDIV  ======================================================= */
/* =====================================================  SM3_EXECCTRL  ====================================================== */
/* ==========================================  PIO0 SM3_EXECCTRL STATUS_SEL [4..4]  ========================================== */
typedef enum {                                  /*!< PIO0_SM3_EXECCTRL_STATUS_SEL                                              */
  PIO0_SM3_EXECCTRL_STATUS_SEL_TXLEVEL = 0,     /*!< TXLEVEL : All-ones if TX FIFO level < N, otherwise all-zeroes             */
  PIO0_SM3_EXECCTRL_STATUS_SEL_RXLEVEL = 1,     /*!< RXLEVEL : All-ones if RX FIFO level < N, otherwise all-zeroes             */
} PIO0_SM3_EXECCTRL_STATUS_SEL_Enum;

/* =====================================================  SM3_SHIFTCTRL  ===================================================== */
/* =======================================================  SM3_ADDR  ======================================================== */
/* =======================================================  SM3_INSTR  ======================================================= */
/* ======================================================  SM3_PINCTRL  ====================================================== */
/* =========================================================  INTR  ========================================================== */
/* =======================================================  IRQ0_INTE  ======================================================= */
/* =======================================================  IRQ0_INTF  ======================================================= */
/* =======================================================  IRQ0_INTS  ======================================================= */
/* =======================================================  IRQ1_INTE  ======================================================= */
/* =======================================================  IRQ1_INTF  ======================================================= */
/* =======================================================  IRQ1_INTS  ======================================================= */


/* =========================================================================================================================== */
/* ================                                            SIO                                            ================ */
/* =========================================================================================================================== */

/* =========================================================  CPUID  ========================================================= */
/* ========================================================  GPIO_IN  ======================================================== */
/* ======================================================  GPIO_HI_IN  ======================================================= */
/* =======================================================  GPIO_OUT  ======================================================== */
/* =====================================================  GPIO_OUT_SET  ====================================================== */
/* =====================================================  GPIO_OUT_CLR  ====================================================== */
/* =====================================================  GPIO_OUT_XOR  ====================================================== */
/* ========================================================  GPIO_OE  ======================================================== */
/* ======================================================  GPIO_OE_SET  ====================================================== */
/* ======================================================  GPIO_OE_CLR  ====================================================== */
/* ======================================================  GPIO_OE_XOR  ====================================================== */
/* ======================================================  GPIO_HI_OUT  ====================================================== */
/* ====================================================  GPIO_HI_OUT_SET  ==================================================== */
/* ====================================================  GPIO_HI_OUT_CLR  ==================================================== */
/* ====================================================  GPIO_HI_OUT_XOR  ==================================================== */
/* ======================================================  GPIO_HI_OE  ======================================================= */
/* ====================================================  GPIO_HI_OE_SET  ===================================================== */
/* ====================================================  GPIO_HI_OE_CLR  ===================================================== */
/* ====================================================  GPIO_HI_OE_XOR  ===================================================== */
/* ========================================================  FIFO_ST  ======================================================== */
/* ========================================================  FIFO_WR  ======================================================== */
/* ========================================================  FIFO_RD  ======================================================== */
/* ======================================================  SPINLOCK_ST  ====================================================== */
/* =====================================================  DIV_UDIVIDEND  ===================================================== */
/* =====================================================  DIV_UDIVISOR  ====================================================== */
/* =====================================================  DIV_SDIVIDEND  ===================================================== */
/* =====================================================  DIV_SDIVISOR  ====================================================== */
/* =====================================================  DIV_QUOTIENT  ====================================================== */
/* =====================================================  DIV_REMAINDER  ===================================================== */
/* ========================================================  DIV_CSR  ======================================================== */
/* ====================================================  INTERP0_ACCUM0  ===================================================== */
/* ====================================================  INTERP0_ACCUM1  ===================================================== */
/* =====================================================  INTERP0_BASE0  ===================================================== */
/* =====================================================  INTERP0_BASE1  ===================================================== */
/* =====================================================  INTERP0_BASE2  ===================================================== */
/* ===================================================  INTERP0_POP_LANE0  =================================================== */
/* ===================================================  INTERP0_POP_LANE1  =================================================== */
/* ===================================================  INTERP0_POP_FULL  ==================================================== */
/* ==================================================  INTERP0_PEEK_LANE0  =================================================== */
/* ==================================================  INTERP0_PEEK_LANE1  =================================================== */
/* ===================================================  INTERP0_PEEK_FULL  =================================================== */
/* ==================================================  INTERP0_CTRL_LANE0  =================================================== */
/* ==================================================  INTERP0_CTRL_LANE1  =================================================== */
/* ==================================================  INTERP0_ACCUM0_ADD  =================================================== */
/* ==================================================  INTERP0_ACCUM1_ADD  =================================================== */
/* ==================================================  INTERP0_BASE_1AND0  =================================================== */
/* ====================================================  INTERP1_ACCUM0  ===================================================== */
/* ====================================================  INTERP1_ACCUM1  ===================================================== */
/* =====================================================  INTERP1_BASE0  ===================================================== */
/* =====================================================  INTERP1_BASE1  ===================================================== */
/* =====================================================  INTERP1_BASE2  ===================================================== */
/* ===================================================  INTERP1_POP_LANE0  =================================================== */
/* ===================================================  INTERP1_POP_LANE1  =================================================== */
/* ===================================================  INTERP1_POP_FULL  ==================================================== */
/* ==================================================  INTERP1_PEEK_LANE0  =================================================== */
/* ==================================================  INTERP1_PEEK_LANE1  =================================================== */
/* ===================================================  INTERP1_PEEK_FULL  =================================================== */
/* ==================================================  INTERP1_CTRL_LANE0  =================================================== */
/* ==================================================  INTERP1_CTRL_LANE1  =================================================== */
/* ==================================================  INTERP1_ACCUM0_ADD  =================================================== */
/* ==================================================  INTERP1_ACCUM1_ADD  =================================================== */
/* ==================================================  INTERP1_BASE_1AND0  =================================================== */
/* =======================================================  SPINLOCK0  ======================================================= */
/* =======================================================  SPINLOCK1  ======================================================= */
/* =======================================================  SPINLOCK2  ======================================================= */
/* =======================================================  SPINLOCK3  ======================================================= */
/* =======================================================  SPINLOCK4  ======================================================= */
/* =======================================================  SPINLOCK5  ======================================================= */
/* =======================================================  SPINLOCK6  ======================================================= */
/* =======================================================  SPINLOCK7  ======================================================= */
/* =======================================================  SPINLOCK8  ======================================================= */
/* =======================================================  SPINLOCK9  ======================================================= */
/* ======================================================  SPINLOCK10  ======================================================= */
/* ======================================================  SPINLOCK11  ======================================================= */
/* ======================================================  SPINLOCK12  ======================================================= */
/* ======================================================  SPINLOCK13  ======================================================= */
/* ======================================================  SPINLOCK14  ======================================================= */
/* ======================================================  SPINLOCK15  ======================================================= */
/* ======================================================  SPINLOCK16  ======================================================= */
/* ======================================================  SPINLOCK17  ======================================================= */
/* ======================================================  SPINLOCK18  ======================================================= */
/* ======================================================  SPINLOCK19  ======================================================= */
/* ======================================================  SPINLOCK20  ======================================================= */
/* ======================================================  SPINLOCK21  ======================================================= */
/* ======================================================  SPINLOCK22  ======================================================= */
/* ======================================================  SPINLOCK23  ======================================================= */
/* ======================================================  SPINLOCK24  ======================================================= */
/* ======================================================  SPINLOCK25  ======================================================= */
/* ======================================================  SPINLOCK26  ======================================================= */
/* ======================================================  SPINLOCK27  ======================================================= */
/* ======================================================  SPINLOCK28  ======================================================= */
/* ======================================================  SPINLOCK29  ======================================================= */
/* ======================================================  SPINLOCK30  ======================================================= */
/* ======================================================  SPINLOCK31  ======================================================= */


/* =========================================================================================================================== */
/* ================                                            PPB                                            ================ */
/* =========================================================================================================================== */

/* =======================================================  SYST_CSR  ======================================================== */
/* =======================================================  SYST_RVR  ======================================================== */
/* =======================================================  SYST_CVR  ======================================================== */
/* ======================================================  SYST_CALIB  ======================================================= */
/* =======================================================  NVIC_ISER  ======================================================= */
/* =======================================================  NVIC_ICER  ======================================================= */
/* =======================================================  NVIC_ISPR  ======================================================= */
/* =======================================================  NVIC_ICPR  ======================================================= */
/* =======================================================  NVIC_IPR0  ======================================================= */
/* =======================================================  NVIC_IPR1  ======================================================= */
/* =======================================================  NVIC_IPR2  ======================================================= */
/* =======================================================  NVIC_IPR3  ======================================================= */
/* =======================================================  NVIC_IPR4  ======================================================= */
/* =======================================================  NVIC_IPR5  ======================================================= */
/* =======================================================  NVIC_IPR6  ======================================================= */
/* =======================================================  NVIC_IPR7  ======================================================= */
/* =========================================================  CPUID  ========================================================= */
/* =========================================================  ICSR  ========================================================== */
/* =========================================================  VTOR  ========================================================== */
/* =========================================================  AIRCR  ========================================================= */
/* ==========================================================  SCR  ========================================================== */
/* ==========================================================  CCR  ========================================================== */
/* =========================================================  SHPR2  ========================================================= */
/* =========================================================  SHPR3  ========================================================= */
/* =========================================================  SHCSR  ========================================================= */
/* =======================================================  MPU_TYPE  ======================================================== */
/* =======================================================  MPU_CTRL  ======================================================== */
/* ========================================================  MPU_RNR  ======================================================== */
/* =======================================================  MPU_RBAR  ======================================================== */
/* =======================================================  MPU_RASR  ======================================================== */

/** @} */ /* End of group EnumValue_peripherals */


#ifdef __cplusplus
}
#endif

#endif /* RP2040_H */


/** @} */ /* End of group RP2040 */

/** @} */ /* End of group Raspberry Pi */
