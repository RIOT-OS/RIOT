NATIVEINCLUDES += -I$(RIOTCPU)/native/include/

ifneq (,$(filter periph_can,$(USEMODULE)))
  ifeq (,$(filter libsocketcan,$(USEPKG)))
    # link system libsocketcan if not using the provided package
    LINKFLAGS += -lsocketcan
  endif
endif

ifneq (,$(filter can,$(USEMODULE)))
  # In case of native, we rely on the real CAN implementation to handle
  # the nitty-gritty details such as loop delay.
  CFLAGS += -DCONFIG_FDCAN_DEVICE_TRANSCEIVER_LOOP_DELAY=0
endif

ifneq (,$(filter periph_timer,$(USEMODULE)))
  # using timer_settime requires -lrt
  LINKFLAGS += -lrt
endif

TOOLCHAINS_SUPPORTED = gnu llvm afl

# Platform triple as used by Rust
ifeq ($(OS) $(OS_ARCH),Linux x86_64)
  ifneq (,$(filter arch_32bit,$(FEATURES_USED)))
    RUST_TARGET = i686-unknown-linux-gnu
  else
    RUST_TARGET = x86_64-unknown-linux-gnu
  endif
endif

include $(RIOTMAKE)/arch/native.inc.mk

USE_LIBUCONTEXT := $(shell pkg-config libucontext 2> /dev/null && echo 1 || echo 0)

ifeq ($(USE_LIBUCONTEXT),1)
  CFLAGS += $(pkg-config libucontext --cflags) -DUSE_LIBUCONTEXT=1
  LINKFLAGS += $(shell pkg-config libucontext --libs)
endif

ifeq (x86_64,$(OS_ARCH))
  # Disable use of FPU/SSE registers if FPU is not used. This prevents radom
  # stack corruptions and floating point exceptions to not occur during
  # context switching.
	ifeq (,$(filter float_math,$(FEATURES_USED)))
		# FPU/SSE registers are not reliably saved and restored in glibc's ucontext
		# implementation (see https://github.com/RIOT-OS/RIOT/issues/495) and not at
		# all in libucontext's (but there at least this is documented). So we force
		# the compiler to only use registers known to be properly backed up and
		# restored during context switching
		CFLAGS += -mgeneral-regs-only

		# Since we disabled the use of non-general registers (such as FPU registers),
		# we need to use a soft FPU
		CFLAGS += -msoft-float
		LINKFLAGS += -msoft-float
	endif
endif
